#! /usr/bin/elw python

# LWIDIA_COPYRIGHT_BEGIN
#
# Copyright 2011, 2015-2017,2019-2020 by LWPU Corporation.  All rights reserved.  All
# information contained herein is proprietary and confidential to LWPU
# Corporation.  Any use, reproduction, or disclosure without the written
# permission of LWPU Corporation is prohibited.
#
# LWIDIA_COPYRIGHT_END

import optparse
import sys
import re
import random
from datetime import timedelta, datetime
import time
import hashlib
import struct

# Header string for the version file
g_VersionHeader = """//
// This file is automatically generated by Makefile.
//                                                  
#include \"core/include/version.h\"
"""  
      
# C++ types to use for variables
g_IntType            = 'unsigned int'
g_StringType         = 'char *'
g_BoolType           = 'bool'
g_64BitType          = 'unsigned long long'
g_FieldDiagModeType  = 'FieldDiagMode'

# Expiration of the bypass in days
g_BypassExpirationDays = 30

#------------------------------------------------------------------------------
# \brief Get the tuple associated with a value containing 
#        (typestr, bSymbol, valstr)
# 
# \param val  : Value to get the tuple for
# 
# \return (typestr, bSymbol, valstr) tuple
def GetValueTuple (typeStr, symbol, val):
    if typeStr == 's':
        varType = g_StringType
    elif typeStr == 'u':
        varType = g_IntType
    elif typeStr == 'b':
        varType = g_BoolType
    elif typeStr == 'u64':
        varType = g_64BitType
    elif typeStr == 'fielddiag':
        varType = g_FieldDiagModeType
        if val == '':
            val = 'none'
    elif typeStr == '':
        try:
            intVal = int(val)
            varType = g_IntType
        except ValueError:
            if val != 'true' and val != 'false' and val != '':
                varType = g_StringType
            else:
                varType = g_BoolType
                if val == '':
                    val = 'false'
    else:
        raise Exception('Invalid type string : %s' % typeStr)

    return (varType, symbol, val)

#------------------------------------------------------------------------------
# \brief Parse a command line var,val[,type,sym] into a 2 entry tuple for 
#        colwersion into a dictionary entry
# 
# \param arg  : Command line arg string to parse
# 
# \return (var, (typestr, bSymbol, valstr)) tuple
def ParseVar (arg):
    opt = re.split(',',arg)
    if len(opt) == 2:
        typeStr = ''
        symbol = False
    elif len(opt) == 3:
        typeStr = opt[2]
        symbol = False
    elif len(opt) == 4:
        typeStr = opt[2]
        if opt[3] == 'y':
            symbol = True
        else:
            symbol = False
    else:
        raise Exception('Invalid argument : %s' % arg)

    return (opt[0], GetValueTuple(typeStr, symbol, opt[1]))

#------------------------------------------------------------------------------
# \brief Compute a hash value of a string.
#
# \param str : String for which to compute the hash.
#
# \return integer hash value
def ComputeHash (str):
    m = hashlib.md5()
    m.update(str.encode('utf-8'))
    return int(m.hexdigest()[:8], 16)

#------------------------------------------------------------------------------
# \brief Compute a hash value based on the CL number and version string
# 
# \param cl  : Integer changelist number
# \param ver : Version string
# 
# \return hash value using the changelist number and version string
def ComputeBypassHashVal (cl, ver):
    return ComputeHash(str(cl) + ver)

#------------------------------------------------------------------------------
# \brief Compute a hash value based on the CL number and version string
# 
# \param bypassHash  : previously computed bypass hash
# \param ver         : Version string
# 
# \return hash value using the bypass hash number and version string
def ComputeInternalBypassHashVal (bypassHash, ver):
    hashVal = ComputeHash(str(bypassHash) + ver)
    if hashVal != bypassHash:
        return hashVal
    lwrRetry = 0
    while hashVal == bypassHash and lwrRetry < 32:
        hashVal = ComputeHash(str(bypassHash ^ (1 << lwrRetry)) + ver)
        if hashVal != bypassHash:
            return hashVal
        lwrRetry = lwrRetry+1
    return (hashVal ^ (1 << random.randint(0, 31))) & 0xffffffff

#------------------------------------------------------------------------------
# \brief Compute the expiration timestamp (i.e. time in seconds since the 
#        epoch) for the bypass
# 
# \return time since the epoch that the bypass expires
def GetExpirationTimestamp ():
    expireTime = datetime.now() + timedelta(g_BypassExpirationDays)
    return time.mktime(expireTime.timetuple())

#------------------------------------------------------------------------------
# \brief Write a variable to C++
# 
# \param f   : open file object to write the variable to
# \param var : variable name to write
# \param val : variable value tuple (typestr, bSymbol, valuestr)
def WriteCppVar (f, var, val):
    # if the value is a char* and is not a symbol, then the value needs to have
    # quotation marks placed around it
    if val[0] == 'char *' and val[1] == False:
        outputStr = 'const %s %s = ENCJSENT("%s");\n' % (val[0],var,val[2])
    elif val[0] == 'unsigned int':
        outputStr = 'const %s %s = 0x%08x;\n' % (val[0],var,int(val[2]) & 0xFFFFFFFF)
    elif val[0] == g_FieldDiagModeType:
        outputStr = 'const %s %s = %s::FDM_%s;\n' % (val[0], var, val[0], val[2].upper())
    else:
        if val[0] == 'char *':
            outputStr = 'const %s %s = ENCJSENT(%s);\n' % (val[0],var,val[2])
        else:
            outputStr = 'const %s %s = %s;\n' % (val[0],var,val[2])
    f.write(outputStr)

def main (argv=None):
    """Generate dynamic files used during MODS compilation and installation
    
When a version file is provided on the command line the appropriate version C++
file is generated using the variable,value pairs supplied on the command line.
At a minimum g_Changelist and g_Version must be present in order to correctly
generate the C++ file

When a bypass file is provided on the command line the bypass bin file is
generated variable,value pairs supplied on the command line.
g_Changelist and g_Version must be present in order to correctly
generate the JS file

Variable/value pairs are specified on the command line with an optional type
character and symbol flag.  If the type character is not specified then an
attempt is made to auto determine the type based on the contents between string,
unsigned integer, or boolean with ambiguous values defaulting to string and
empty values defaulting to boolean.

Written against the default python 2.5 in use on the farm, ick.
"""

    if argv is None:
        argv = sys.argv

    usage = ("usage: %prog [options] <var>,<val>[,<type>[,<symbol>]] " +
             "[<var1>,<val1>[,<type1>[,<symbol1>]] ...]\n" +
             "       var   = Valid C++ variable name\n" +
             "       val   = Value for the variable\n" +
             "       type  = type of the var (s = string, u = unsigned int, b = bool, u64 = unsigned 64 bit)\n" +
             "       sybol = value is a symbol (y = symbol, n = literal)\n")
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-v", "--versionfile", dest="versionfile", default="",
                      help="version cpp filename (default = '' - no generation)")
    parser.add_option("-b", "--bypassfile", dest="bypassfile", default="",
                      help="bypass bin filename (default = '' - no generation)")
    parser.add_option("--hashvar", dest="hashvarname", default="g_BypassHash",
                      help="bypass hash variable name (default = g_BypassHash)")
    parser.add_option("--inthashvar", dest="internalhashvarname", default="g_InternalBypassHash",
                      help="internal bypass hash variable name (default = g_InternalBypassHash)")
    parser.add_option("--expirevar", dest="expirevarname", default="",
                      help="bypass expiration variable name (default = '' - no generation)")
    (options, args) = parser.parse_args(argv)
    if len(args) < 2:
        parser.print_help()
        sys.exit(1)

    # Colwert the var,val command line options into a dictionary with the
    # variable names as the keys and (type string, value is symbol,
    # value) tuple as the values
    varDict = dict([ParseVar(x) for x in args[1:]])

    # Ensure that the variables used to callwlate the bypass hash exist
    if ('g_Changelist' not in varDict) or ('g_Version' not in varDict) :
        print('g_Changelist or g_Version is missing from variable list!!')
        sys.exit(1)

    # Add custom variables that do not fit the general rule.

    # The bypass hash variable name needs to be computed 
    hashInt = ComputeBypassHashVal(int(varDict['g_Changelist'][2]), 
                                   varDict['g_Version'][2])
    varDict[options.hashvarname] = GetValueTuple('u','n',str(hashInt))

    internalHashInt = ComputeInternalBypassHashVal(hashInt, 
                                                   varDict['g_Version'][2])
    varDict[options.internalhashvarname] = GetValueTuple('u','n',str(internalHashInt))

    expireTs = int(GetExpirationTimestamp() * 1000)
    if options.expirevarname != '':
        varDict[options.expirevarname] = ('u64','n',str(int(expireTs)))

    # Write out the version file
    if options.versionfile != "":
        f = open(options.versionfile, 'w+')
        f.write(g_VersionHeader)
        for (k,v) in varDict.items():
            WriteCppVar(f, k, v)
        f.close()

    # Write out the bypass/internal bypass file
    if options.bypassfile != "":
        bypassstr = struct.pack("I", ~hashInt & 0xffffffff)
        bypassstr += struct.pack("I", internalHashInt & 0xffffffff)
        bypassstr += struct.pack("q", ~expireTs)
        f = open(options.bypassfile, 'wb+')
        f.write(bypassstr)
        f.close()

        bypassstr = struct.pack("I", ~hashInt & 0xffffffff)
        bypassstr += struct.pack("I", ~internalHashInt & 0xffffffff)
        bypassstr += struct.pack("q", ~expireTs)

        extloc = options.bypassfile.rfind(".")
        if extloc == -1:
            intbypassfile = options.bypassfile + ".INTERNAL"
        else:
            intbypassfile = options.bypassfile[:extloc] + ".INTERNAL" + options.bypassfile[extloc:]
        f = open(intbypassfile, 'wb+')
        f.write(bypassstr)
        f.close()

if __name__ == "__main__":
    sys.exit(main())
