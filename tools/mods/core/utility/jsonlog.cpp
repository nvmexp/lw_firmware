/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2009-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#include "core/include/cmdline.h"
#include "core/include/jsonlog.h"
#include "core/include/filesink.h"
#include "core/include/utility.h"
#include "core/include/tasker.h"
#include "core/include/script.h"
#include "core/include/onetime.h"
#include "core/include/version.h"
#include <jsdate.h>  // JavaScript Date class C api
#include <jsobj.h> // JavaScript object class
#include <math.h>    // fmod
#include <string.h>

//------------------------------------------------------------------------------
//! JsonLogStream -- used by JsonItem, writes a "mods.jso" file.
//!
//! All the text formatting and I/O is handled here.
//------------------------------------------------------------------------------
namespace JsonLogStream
{
    //! Open a single-run json logfile.
    //! fname_template may be a full or relative path.
    //!
    //! If the file already exists, a unique name is generated by inserting a
    //! a 4-digit decimal number before the last '.' i.e. "mods0000.jso".
    //!
    //! Each number is tried in sequence up to 9999 before giving up.
    //! An existing json logfile is never overwritten.
    //!
    //! Upon opening the file, an initial line of "[\n" is written to begin
    //! the outer JSON data-array.
    //!
    //! If logType is USE_LIMITED, we will open up a limited json logfile instead.
    //! Key differences between this and the standard logfile, opened using the
    //! default USE_FULL, are that the limited logfile only contains a limited
    //! subset of the JSON logs logged to the standard logfile (determined using
    //! the category of the JsonItems logged to it and IsAllowedExternal()), and
    //! that it is never encrypted even when encryption is enabled (e.g. in 
    //! fieldiag mode).

    RC Open (string fname_template, JsonLogStream::LogType
             logType);

    //! Open a multi-run json logfile.
    //! fname_exact may be a full or relative path.
    //!
    //! If the file already exists, and Append is false, it will be erased.
    //!
    //! An empty file is started with two lines of "[\n" to begin the
    //! outer array of runs and the current run.
    //!
    //! If the file already exists, and Append is true, it will be checked
    //! for syntax errors and then extended.
    //!
    //! logType functions here as it does above for single-run
    //! JSON files.

    RC OpenMultiRun (string fname_exact, bool Append, JsonLogStream::LogType
                     logType);
    RC InnerOpenMultiRun (string fname_exact, bool Append, FileSink* filesink,
                          JsonLogStream::LogType logType);

    //! Close the json logfile, if any.
    //! Before closing the file, one or two final lines of "]\n" are written
    //! to close the outer JSON data-array(s).

    void Close();

    //! Print the JsonItem to the logfile and flush to disk.
    RC      PrintJsonItem (const JsonItem & jsi);

    //! Generate JSON string that describes this object
    //!
    //! Iterate through the items in jso and generate strings
    //! that describe them. If another object is found, relwrse
    //! and increase the indentLevel
    RC      StringifyJsObject(JSContext* cx, JSObject* jso,
                              string &outputString,
                              UINT32 indentLevel = 0);

    string  StringifyScalarVal (JSContext * cx, jsval v);
    void    Printf(FileSink * Filesink,
                   const char * Format, ...);

    void    InnerWriteFinalRc(string finalRc, bool comma);
    void    InnerWriteFinalRc(INT32 finalRc, bool comma);

    enum PutsDestination
    {
        StdoutAndFile,
        StdoutOnly
    };
    enum LineEnding
    {
        NoLineEnding,
        AppendLFToInline
    };
    enum BufStatus
    {
        MaxSize = 4096
    };
    void JsonOutput
    (
        const char * str,
        PutsDestination destination,
        LineEnding lineEnding,
        FileSink * pFilesink
    );

    static bool       d_IsOpen = false;
    static int        d_ItemsPrintedFull = 0;
    static int        d_ItemsPrintedLimited = 0;
    static FileSink * d_pFileSinkFull = nullptr;
    static FileSink * d_pFileSinkLimited = nullptr;
    static void*      d_pMutex = nullptr;
    static bool       d_IsMultiRun = false;
    static long       d_StartingFullFileOffset = 0;
    static long       d_StartingLimitedFileOffset = 0;

    static bool       d_JsonInline = false;  // to hold flag for sending JSON to serial
    static char *     d_Buf = nullptr;
    static long       d_BufSize = MaxSize;

    static LogType    d_LogType = JSONLOG_USE_FULL;

    bool GetInline();
    RC SetInline(bool val);
};

// JSON output utility function

#define JSON_HEADER "@JSON@"

JS_CLASS(JsonLog);

static SObject JsonLog_Object
(
   "JsonLog",
   JsonLogClass,
   0,
   0,
   "Output JSON log data."
);

//-----------------------------------------------------------------------------
static void C_JsonItem_finalize
(
    JSContext *cx,
    JSObject *obj
)
{
    MASSERT(cx != 0);
    MASSERT(obj != 0);

    JsonItem * pJsonItem = (JsonItem *)JS_GetPrivate(cx, obj);
    if (pJsonItem)
    {
        delete pJsonItem;
    }
};
//-----------------------------------------------------------------------------
static JSClass JsonItemClass =
{
    "JsonItem",
    JSCLASS_HAS_PRIVATE,
    JS_PropertyStub,
    JS_PropertyStub,
    JS_PropertyStub,
    JS_PropertyStub,
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ColwertStub,
    C_JsonItem_finalize
};

void JsonLogStream::JsonOutput
(
    const char * str,
    PutsDestination destination,
    LineEnding lineEnding,
    FileSink * pFilesink
)
{
    if(destination == StdoutAndFile)
    {
        if (pFilesink != nullptr)
        {
            pFilesink->Print(str, strlen(str));
        }
    }

    if(d_JsonInline)
    {
        // For the SLT pick&place robots, we are logging JSON intermingled with
        // the normal logging output on stdout.
        // Put the @JSON@ prefix at the beginning of each line of output so
        // that the json can later be separated out from the stdout capture.
        ::Printf(Tee::PriHigh, JSON_HEADER "%s", str);
        if(lineEnding == AppendLFToInline)
        {
            ::Printf(Tee::PriHigh, "\n");
        }
    }
}

//------------------------------------------------------------------------------
bool JsonLogStream::IsOpen()
{
    return d_IsOpen;
}

//------------------------------------------------------------------------------
bool JsonLogStream::IsAllowedExternally(JsonItem::JsonCategory logType)
{
    switch (logType)
    {
        case JsonItem::JSONLOG_PEXTOPOLOGY:
        case JsonItem::JSONLOG_PEXINFO:
        case JsonItem::JSONLOG_INFOROM:
        case JsonItem::JSONLOG_LWLINKTOPOLOGY:
        case JsonItem::JSONLOG_LWLINKINFO:
        case JsonItem::JSONLOG_GPUINFO:
        case JsonItem::JSONLOG_TESTENTRY:
        case JsonItem::JSONLOG_TESTEXIT:
        case JsonItem::JSONLOG_CARRIERFRU:
            return true;
        default:
            return false;
    }
}

//------------------------------------------------------------------------------
RC JsonLogStream::Open(string fname_template /*= "mods.jso"*/,
                       JsonLogStream::LogType logType =
                       JsonLogStream::JSONLOG_USE_FULL)
{
    d_LogType = logType;

    if ((d_pFileSinkFull && (logType == JsonLogStream::JSONLOG_USE_FULL))
       || (d_pFileSinkLimited && (logType == JsonLogStream::JSONLOG_USE_LIMITED)))
    {
    Close();
    }

    d_pMutex = Tasker::AllocMutex("JsonLogStream::d_pMutex",
                                  Tasker::mtxUnchecked);

    Tasker::MutexHolder mhold(d_pMutex);

    unique_ptr<FileSink> pFilesink = make_unique<FileSink>();

    string uniqueFname = Utility::CreateUniqueFilename(fname_template);

    RC rc;

    if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
    {
        d_pFileSinkLimited = pFilesink.release();
        rc = d_pFileSinkLimited->Open (uniqueFname, FileSink::Truncate, false);
    }
    else
    {
        d_pFileSinkFull = pFilesink.release();
        rc = d_pFileSinkFull->Open (uniqueFname, FileSink::Truncate);
    }

    if (OK != rc)
    {
        ::Printf(Tee::PriHigh, "Error: Unable to open JSON log: %s\n", uniqueFname.c_str());
        mhold.Release();
        Close();
    }
    else
    {
        ::Printf(Tee::PriNormal, "Opened JSON log: %s\n", uniqueFname.c_str());
        d_IsOpen = true;
        d_IsMultiRun = false;
        if (d_Buf == nullptr)
            d_Buf = new char[d_BufSize];

        JsonOutput("[\n", StdoutAndFile, NoLineEnding, 
                   (logType == JsonLogStream::JSONLOG_USE_LIMITED) ? d_pFileSinkLimited :
                   d_pFileSinkFull);

        if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
        {
            d_StartingLimitedFileOffset = 0;
        }
        else
        {
            d_StartingFullFileOffset = 0;
        }

        WriteInitialTimestamp(OneTimeInit::GetDOB(), 
                   (logType == JsonLogStream::JSONLOG_USE_LIMITED) ? d_pFileSinkLimited :
                   d_pFileSinkFull);

    }

    return rc;
}

//------------------------------------------------------------------------------
RC JsonLogStream::OpenMultiRun(string fname, bool Append,
                               JsonLogStream::LogType logType =
                               JsonLogStream::JSONLOG_USE_FULL)
{
    d_LogType = logType;

    if(d_JsonInline)
        return RC::ILWALID_FILE_FORMAT;

    if ((d_pFileSinkFull && (logType == JsonLogStream::JSONLOG_USE_FULL))
       || (d_pFileSinkLimited && (logType == JsonLogStream::JSONLOG_USE_LIMITED)))
    {
        Close();
    }

    d_pMutex = Tasker::AllocMutex("JsonLogStream::d_pMutex",
                                  Tasker::mtxUnchecked);
    Tasker::MutexHolder mhold(d_pMutex);

    RC rc;

    auto pFilesink = make_unique<FileSink>();

    CHECK_RC(InnerOpenMultiRun(fname, Append, pFilesink.get(), logType));
    pFilesink->Flush();

    if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
    {
        d_pFileSinkLimited = pFilesink.release();
    }
    else
    {
        d_pFileSinkFull = pFilesink.release();
    }

    WriteInitialTimestamp(OneTimeInit::GetDOB(),
                         (logType == JsonLogStream::JSONLOG_USE_LIMITED) ? d_pFileSinkLimited :
                          d_pFileSinkFull);

    mhold.Release();

    return rc;
}

//------------------------------------------------------------------------------
RC JsonLogStream::InnerOpenMultiRun(string fname, bool Append, FileSink* pFilesink,
                                    JsonLogStream::LogType logType =
                                    JsonLogStream::JSONLOG_USE_FULL)
{
    RC rc;

    if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
        rc = pFilesink->Open (fname,
                Append ? FileSink::Append : FileSink::Truncate, false);
    else
        rc = pFilesink->Open (fname,
                Append ? FileSink::Append : FileSink::Truncate);

    if (OK != rc)
    {
        ::Printf(Tee::PriHigh, "Error: Unable to open JSON log: \"%s\"\n",
                fname.c_str());
        return rc;
    }

    ::Printf(Tee::PriNormal, "Opened JSON log: %s\n", fname.c_str());
    d_IsOpen = true;
    d_IsMultiRun = true;
    if (d_Buf == nullptr)
        d_Buf = new char[d_BufSize];
    long fileSize;
    CHECK_RC(pFilesink->Tell(&fileSize));

    if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
    {
        d_StartingLimitedFileOffset = fileSize;
    }
    else
    {
        d_StartingFullFileOffset = fileSize;
    }


    // A multi-run mods json logfile should start and end with these strings:
    const char * prefix = "[\n[\n";
    const long   prefixLen = 4;
    const char * suffix = "]\n]\n";
    const long   suffixLen = 4;

    if (0 == fileSize)
    {
        // New file -- start the outer array-of-runs
        JsonOutput("[\n", StdoutAndFile, NoLineEnding, pFilesink);

        // Open next run  (begin first inner array: no leading comma).
        JsonOutput("[\n", StdoutAndFile, NoLineEnding, pFilesink);
    }
    else  if (fileSize < (prefixLen + suffixLen))
    {
        // Previous hang with too little data to save.

        // Delete old data by reopening with Truncate.
        pFilesink->Close();
        if (logType == JsonLogStream::JSONLOG_USE_LIMITED)
            rc = pFilesink->Open (fname, FileSink::Truncate, false);
        else
            rc = pFilesink->Open (fname, FileSink::Truncate);
        if (OK != rc)
        {
            ::Printf(Tee::PriHigh, "Error: Unable to open JSON log: \"%s\"\n",
                     fname.c_str());
            return rc;
        }

        // Start a new multi-run log, add a hang record, close the run.
        JsonOutput("[\n", StdoutAndFile, NoLineEnding, pFilesink);
        JsonOutput("[\n", StdoutAndFile, NoLineEnding, pFilesink);
        InnerWriteFinalRc(RC::TIMEOUT_ERROR, false);
        JsonOutput("]\n", StdoutAndFile, NoLineEnding, pFilesink);

        // Open next run (begin new inner array).
        JsonOutput(",[\n", StdoutAndFile, NoLineEnding, pFilesink);
    }
    else if (!pFilesink->IsEncrypted())
    {
        // Existing multi-run file, we must check it and fix/extend it.
        // This only works for unencrypted logs.

        vector<char>buf;
        long bytesRead;

        CHECK_RC(pFilesink->Seek(0, SEEK_SET));
        CHECK_RC(pFilesink->Read(&buf, prefixLen, &bytesRead));

        if (bytesRead != prefixLen)
        {
            ::Printf(Tee::PriHigh,
                     "Error : Unable to read %ld prefix bytes (got %ld)\n",
                     prefixLen, bytesRead);
            return RC::ILWALID_FILE_FORMAT;
        }

        if (0 != strncmp(prefix, &buf[0], prefixLen))
        {
            ::Printf(Tee::PriHigh,
                    "Error: \"%s\" is not a valid multi-run json logfile.\n",
                    fname.c_str());
            return RC::ILWALID_FILE_FORMAT;
        }

        // Seeking and reading from the end of a file is unreliable due to
        // the line ending on a particular platform.  For instance, on DOS
        // fseek will count \r characters as bytes (even when the file is
        // open in text mode), however when the data is read by fread, the
        // \r characters will be removed.  Thus if we seek -4 bytes from the
        // end of a file and then attempt to ready 4 bytes, we may or may
        // not be able to depending on whether one of the last 4 bytes is a
        // \r character. Use a loop here to ensure we read the last 4 non-\r
        // characters from the file
        long endOffset = -suffixLen;
        do
        {
            CHECK_RC(pFilesink->Seek(endOffset, SEEK_END));
            CHECK_RC(pFilesink->Read(&buf, suffixLen, &bytesRead));
            endOffset--;
        } while (bytesRead != suffixLen);

        if (0 == strncmp(suffix, &buf[0], suffixLen))
        {
            // We want to actually erase the last two non-\r characters in the
            // file so we need to use the same trick as above
            const long finalLineLen = 2;
            endOffset = -finalLineLen;
            do
            {
                // Erase the last line to "reopen" the outer array.
                CHECK_RC(pFilesink->Seek(endOffset, SEEK_END));
                CHECK_RC(pFilesink->Read(&buf, finalLineLen, &bytesRead));
                endOffset--;
            } while (bytesRead != finalLineLen);

            CHECK_RC(pFilesink->Seek(endOffset+1, SEEK_END));
        }
        else if (0 == strncmp(" }\n", &buf[1], 3))
        {
            // Hang log -- close previous run.
            CHECK_RC(pFilesink->Seek(0L, SEEK_END));
            WriteFinalRc(RC::TIMEOUT_ERROR);
            JsonOutput("]\n", StdoutAndFile, NoLineEnding, pFilesink);
        }

        // Open next run (begin new inner array).
        JsonOutput(",[\n", StdoutAndFile, NoLineEnding, pFilesink);
    }
    return rc;
}

//------------------------------------------------------------------------------
void JsonLogStream::Close()
{
    Tasker::MutexHolder mhold;

    if (Tasker::IsInitialized() && d_pMutex)
        mhold.Acquire(d_pMutex);

    if (d_IsOpen)
    {
        WriteFinalTimestamp(OneTimeInit::GetDOD(), OneTimeInit::GetAge(false));
        JsonOutput("]\n", StdoutAndFile, NoLineEnding, d_pFileSinkFull);  // Close array of objects for this run.
        JsonOutput("]\n", StdoutAndFile, NoLineEnding, d_pFileSinkLimited);
        if (d_IsMultiRun)
        {
            JsonOutput("]\n", StdoutAndFile, NoLineEnding, d_pFileSinkFull);  // close outer array
            JsonOutput("]\n", StdoutAndFile, NoLineEnding, d_pFileSinkLimited);
        }

        long fsize = 0;

        if (d_pFileSinkFull != nullptr)
        {
        d_pFileSinkFull->Tell(&fsize);
        ::Printf(Tee::PriLow, "Closing %s after %s %ld bytes to it.\n",
               d_pFileSinkFull->GetFileName().c_str(),
               d_StartingFullFileOffset ? "appending" : "writing",
               fsize - d_StartingFullFileOffset);

        d_pFileSinkFull->Close();
        }

        fsize = 0;

        if (d_pFileSinkLimited != nullptr)
        {
            d_pFileSinkLimited->Tell(&fsize);
            ::Printf(Tee::PriLow, "Closing %s after %s %ld bytes to it.\n",
                   d_pFileSinkLimited->GetFileName().c_str(),
                   d_StartingLimitedFileOffset ? "appending" : "writing",
                   fsize - d_StartingLimitedFileOffset);

            d_pFileSinkLimited->Close();
        }

        d_IsOpen = false;
        d_ItemsPrintedFull = 0;
        d_ItemsPrintedLimited = 0;
    }

    if (d_pFileSinkFull != nullptr)
    {
        delete d_pFileSinkFull;
        d_pFileSinkFull = nullptr;
    }

    if (d_pFileSinkLimited != nullptr)
    {
        delete d_pFileSinkLimited;
        d_pFileSinkLimited = nullptr;
    }

    if (d_Buf)
    {
        delete []d_Buf;
        d_Buf = nullptr;
        d_BufSize = MaxSize;
    }

    if (d_pMutex)
    {
        mhold.Release();

        Tasker::FreeMutex(d_pMutex);
        d_pMutex = nullptr;
    }
}

//------------------------------------------------------------------------------
RC JsonLogStream::PrintJsonItem(const JsonItem & jsi)
{
    if (!d_IsOpen)
    {
        // This is a no-op if the user didn't open a mods0000.jso file.
        return OK;
    }

    RC rc;

    string objectString;
    CHECK_RC(StringifyJsObject(jsi.GetCtx(), jsi.GetObj(), objectString));

    // Take the mutex before writing anything to the FileSink.

    Tasker::MutexHolder mhold(d_pMutex);

    if (JsonLogStream::IsAllowedExternally(jsi.GetCategory()))
    {
        JsonLogStream::Printf(d_pFileSinkLimited, "%c{ \"__tag__\" : \"%s\"\n",
                (d_ItemsPrintedLimited ? ',' : ' '),
                jsi.GetTag());
    
        JsonLogStream::Printf(d_pFileSinkLimited, objectString.c_str());
    
        JsonLogStream::Printf(d_pFileSinkLimited, "}\n");
    }

    JsonLogStream::Printf(d_pFileSinkFull, "%c{ \"__tag__\" : \"%s\"\n",
            (d_ItemsPrintedFull ? ',' : ' '),
            jsi.GetTag());

    JsonLogStream::Printf(d_pFileSinkFull, objectString.c_str());

    JsonLogStream::Printf(d_pFileSinkFull, "}\n");

    if (JsonLogStream::IsAllowedExternally(jsi.GetCategory()) && (d_pFileSinkLimited != nullptr))
    {
        d_pFileSinkLimited->Flush();
        d_ItemsPrintedLimited++;
    }
    if (d_pFileSinkFull != nullptr)
    {
        d_pFileSinkFull->Flush();
        d_ItemsPrintedFull++;
    }

    return OK;
}

//------------------------------------------------------------------------------
RC JsonLogStream::StringifyJsObject(JSContext * cx, JSObject* jso,
                                    string &outputString,
                                    UINT32 indentLevel /* = 0 */)
{
    // Get the property name/value pairs that we will print to the log.

    RC rc;
    JavaScriptPtr pJs;
    JSPropertiesEnumerator pe (cx, jso);
    JSIdArray * ida = pe.GetProperties();
    vector<string> names;
    vector<string> vals;

    string indent(indentLevel * 2, ' ');

    if (0 == ida)
        return RC::CANNOT_ENUMERATE_OBJECT;

    for (int i = 0; i < ida->length; i++)
    {
        jsval jsv;
        if (!JS_IdToValue(cx, ida->vector[i], &jsv))
            return RC::CANNOT_GET_ELEMENT;

        string propName;
        CHECK_RC(pJs->FromJsval(jsv, &propName));
        names.push_back (propName);

        if (!JS_GetProperty(cx, jso, propName.c_str(), &jsv))
            return RC::CANNOT_GET_ELEMENT;

        if (JSTYPE_OBJECT == JS_TypeOfValue(cx, jsv))
        {
            // We know how to print some kinds of JS Objects.

            JSObject * pObj = JSVAL_TO_OBJECT(jsv);

            if (JS_IsArrayObject(cx, pObj))
            {
                JsArray jsa;
                string s = "[";

                CHECK_RC(pJs->FromJsval(jsv, &jsa));

                for (size_t i = 0; i < jsa.size(); i++)
                {
                    JSObject* pArrItemObj;
                    if (OK == pJs->FromJsval(jsa[i], &pArrItemObj) &&
                        (JS_InstanceOf(cx, pArrItemObj, &js_ObjectClass, nullptr) ||
                         JS_InstanceOf(cx, pArrItemObj, &JsonItemClass, nullptr)))
                    {
                        string itemStr;
                        CHECK_RC(StringifyJsObject(cx, pArrItemObj, itemStr, indentLevel+1));
                        s += itemStr;
                    }
                    else
                    {
                        s += StringifyScalarVal(cx, jsa[i]);
                    }
                    if (i < jsa.size() - 1)
                        s += ",";
                }
                s += "]";
                vals.push_back(s);
            }
            else if (JS_InstanceOf(cx, pObj, &js_DateClass, nullptr))
            {
                // Date object containing a timestamp.
                // Colwert to an ISO 8601 datetime string.

                // Get local time:
                const int year  = js_DateGetYear(cx, pObj);
                const int month = js_DateGetMonth(cx, pObj) + 1;
                const int day   = js_DateGetDate(cx, pObj);
                const int hour  = js_DateGetHours(cx, pObj);
                const int mins  = js_DateGetMinutes(cx, pObj);
                const int secs  = js_DateGetSeconds(cx, pObj);
                const double mse = js_DateGetMsecSinceEpoch(cx, pObj);
                const int msecs = static_cast<int>(fmod(mse, 1000.0));

                // Get time-zone offset, no helper JSAPI call for this...
                jsval jsv;
                CHECK_RC(pJs->CallMethod(pObj, "getTimezoneOffset", JsArray(), &jsv));

                INT32 tzoffMinutes;
                CHECK_RC(pJs->FromJsval(jsv, &tzoffMinutes));
                const int tzhour = tzoffMinutes / 60;
                const int tzmin  = abs(tzoffMinutes - tzhour*60);

                vals.push_back(Utility::StrPrintf(
                        "\"%d-%02d-%02dT%02d:%02d:%02d.%03d%+02d:%02d\"",
                        year,month,day,
                        hour,mins,secs,msecs,
                        tzhour,tzmin));
            }
            else if (JS_InstanceOf(cx, pObj, &js_ObjectClass, nullptr) ||
                     JS_InstanceOf(cx, pObj, &JsonItemClass, nullptr))
            {
                string nestedString;
                CHECK_RC(StringifyJsObject(cx, pObj, nestedString,
                                           indentLevel + 1));
                vals.push_back(nestedString);
            }
            else
            {
                return RC::CANNOT_GET_ELEMENT;
            }
        }
        else
        {
            vals.push_back(StringifyScalarVal(cx, jsv));
        }
    }

    for (size_t i = 0; i < names.size(); i++)
    {
        // For a non-nested object (indentLevel == 0), we need a comma
        // because there's already the tag.
        // For nested objects, we need commas after the first key
        string separator("");
        if (indentLevel == 0 || i > 0)
        {
            separator = ",";
        }
        else
        {
            // add a space on nested objects to align keys (purely cosmetic)
            separator = " ";
        }
        // Generates the strings of the form '  ,"key" : value'
        // the vals[x].c_str() can exceed the 4K limit of StrPrintf() so just
        // append it manually.
        outputString += Utility::StrPrintf("%s  %s\"%s\" : ", indent.c_str(),
                                           separator.c_str(), names[i].c_str());
        outputString += vals[i].c_str();
        outputString += "\n";
    }

    // Opening and closing {} for nested objects
    if (indentLevel != 0)
    {
        string prevIndent((indentLevel - 1) * 2, ' ');
        outputString = "\n" + prevIndent + "  {\n" + outputString + prevIndent + "  }";
    }

    return OK;
}

//------------------------------------------------------------------------------
//! Quotes strings, pass-through num/bool, and coerce anything else to "null".
//!
string JsonLogStream::StringifyScalarVal(JSContext * cx, jsval v)
{
    string s;

    if (OK != JavaScriptPtr()->FromJsval(v, &s))
        return "";

    switch (JS_TypeOfValue(cx, v))
    {
        case JSTYPE_STRING:
            s = "\"" + Utility::StringReplace(s, "\"", "\\\"") + "\"";
            break;

        case JSTYPE_NUMBER:
        case JSTYPE_BOOLEAN:
            break;

        default:
            s = "null";
            break;
    }
    return s;
}

//------------------------------------------------------------------------------
void JsonLogStream::Printf(FileSink* pFilesink, const char * Format, ...)
{
    // Partial replication of Utility::StrPrintf to avoid alloc/copy/free
    // of string objects for each line of output.

    va_list Arguments;
    va_start(Arguments, Format);

    // XXX (FORMAT_FOR_64BITS) - workaround until MSVC71 is phased out
#if defined(_WIN32) && (_MSC_VER < 1500)
    const string &cleansed = Utility::CleanseFormatWAR(Format);
    Format = cleansed.c_str();
#endif

    int charactersWritten = 0;

    charactersWritten = vsnprintf(d_Buf, d_BufSize, Format, Arguments);
    va_end(Arguments);
    if (charactersWritten >= d_BufSize)
    {
        delete []d_Buf;
        d_Buf = new char[charactersWritten+1];
        d_BufSize = charactersWritten+1;
        va_start(Arguments, Format);
        charactersWritten = vsnprintf(d_Buf, d_BufSize, Format, Arguments);
        va_end(Arguments);
        d_Buf[charactersWritten] = '\0';
    }

    if (pFilesink != nullptr)
    {
        pFilesink->Print(d_Buf, charactersWritten);
    }

    if (!d_JsonInline)
    {
        // Rest of this code is just to print to stdout with @JSON@ prefixes
        // for the SLT pick&place robot.
        return;
    }

    int cpos = 0;
    int begin = 0;
    while (d_Buf[cpos] != '\0')
    {
        if (d_Buf[cpos] == '\n')
        {
            d_Buf[cpos] = '\0';
            JsonOutput(&d_Buf[begin],StdoutOnly, AppendLFToInline, pFilesink);
            begin = cpos+1;
        }
        cpos++;
    }
    // print the tail
    if (begin != cpos)
    {
        JsonOutput(&d_Buf[begin],StdoutOnly, NoLineEnding, pFilesink);
    }
}

//------------------------------------------------------------------------------
void JsonLogStream::WriteFinalRc(string finalRc)
{
    if (d_IsOpen)
    {
        InnerWriteFinalRc(finalRc, true);
        if (d_pFileSinkLimited != nullptr)
        {
            d_pFileSinkLimited->Flush();
        }
        if (d_pFileSinkFull != nullptr)
        {
            d_pFileSinkFull->Flush();
        }
    }
}

void JsonLogStream::InnerWriteFinalRc(string finalRc, bool comma)
{
    JsonLogStream::Printf (d_pFileSinkFull,
        "%c{ \"__tag__\" : \"final_rc\"\n"
        "  ,\"rc\" : \"%s\"\n"
        " }\n",
        (comma ? ',' : ' '),
        finalRc.c_str());
    JsonLogStream::Printf (d_pFileSinkLimited,
        "%c{ \"__tag__\" : \"final_rc\"\n"
        "  ,\"rc\" : \"%s\"\n"
        " }\n",
        (comma ? ',' : ' '),
        finalRc.c_str());
}

void JsonLogStream::WriteFinalRc(INT32 finalRc)
{
    if (d_IsOpen)
    {
        InnerWriteFinalRc(finalRc, true);
        if (d_pFileSinkLimited != nullptr)
        {
            d_pFileSinkLimited->Flush();
        }
        if (d_pFileSinkFull != nullptr)
        {
            d_pFileSinkFull->Flush();
        }
    }
}

void JsonLogStream::InnerWriteFinalRc(INT32 finalRc, bool comma)
{
    string finalRcStr = Utility::StrPrintf("%d", finalRc);
    InnerWriteFinalRc(finalRcStr, comma);
}

//------------------------------------------------------------------------------
void JsonLogStream::WriteInitialTimestamp
(
    const string & ts, // string containing the timestamp
    FileSink * pFilesink
)
{
    if (d_IsOpen)
    {
        int itemsPrinted;
        if (pFilesink == d_pFileSinkLimited)
        {
            itemsPrinted = d_ItemsPrintedLimited;
        }
        else
        {
            itemsPrinted = d_ItemsPrintedFull;
        }
       
        JsonLogStream::Printf(pFilesink,
            "%c{ \"__tag__\" : \"MODS_Start\"\n"
            "  ,\"timestamp\" : \"%s\"\n"
            " }\n",
            (itemsPrinted ? ',' : ' '),
            ts.c_str());
        pFilesink->Flush();
        if (pFilesink == d_pFileSinkLimited)
        {
            d_ItemsPrintedLimited++;
        }
        else
        {
            d_ItemsPrintedFull++;
        }
    }
}

//------------------------------------------------------------------------------
void JsonLogStream::WriteFinalTimestamp
(
    const string & ts // string containing the timestamp
    ,const string & rt // string containing the elapsed time in seconds
)
{
    if (d_IsOpen)
    {

        if (d_pFileSinkLimited != nullptr)
        {
            JsonLogStream::Printf(d_pFileSinkLimited,
                "%c{ \"__tag__\" : \"MODS_end\"\n"
                "  ,\"timestamp\" : \"%s\"\n"
                "  ,\"elapsedSeconds\" : %s\n"
                " }\n",
                (d_ItemsPrintedLimited ? ',' : ' '),ts.c_str(),rt.c_str());
            d_pFileSinkLimited->Flush();
            d_ItemsPrintedLimited++;
        }
        if (d_pFileSinkFull != nullptr)
        {
            JsonLogStream::Printf(d_pFileSinkFull,
                "%c{ \"__tag__\" : \"MODS_end\"\n"
                "  ,\"timestamp\" : \"%s\"\n"
                "  ,\"elapsedSeconds\" : %s\n"
                " }\n",
                (d_ItemsPrintedFull ? ',' : ' '),ts.c_str(),rt.c_str());
            d_pFileSinkFull->Flush();
            d_ItemsPrintedFull++;
        }
    }
}

//----------------------------------------------------------------------------

JS_STEST_LWSTOM(JsonLog, Open, 1, "Open a single-run JSON log file")
{
    MASSERT(pContext != 0);
    MASSERT(pArguments != 0);
    MASSERT(pReturlwalue != 0);

    STEST_HEADER(0, 2, "Usage: JsonLog.Open(filename_template, type="
                 "JsonConst.USE_FULL)\n");
    STEST_OPTIONAL_ARG(0, string, fname_template, "mods.jso");
    STEST_OPTIONAL_ARG(1, INT32, type, JsonLogStream::JSONLOG_USE_FULL);


    RETURN_RC(JsonLogStream::Open(fname_template,
                                  static_cast<JsonLogStream::LogType>(type)));
}

JS_STEST_LWSTOM(JsonLog, OpenMultiRun, 3, "Open a multi-run JSON log file")
{
    MASSERT(pContext != 0);
    MASSERT(pArguments != 0);
    MASSERT(pReturlwalue != 0);

    STEST_HEADER(2, 3, "Usage: JsonLog.OpenMultiRun(filename, doAppend,"
                 "type=JsonConst.USE_FULL)\n");
    STEST_ARG(0, string, fname);
    STEST_ARG(1, bool, append);
    STEST_OPTIONAL_ARG(2, INT32, type, JsonLogStream::JSONLOG_USE_FULL);

    RETURN_RC(JsonLogStream::OpenMultiRun(fname, append,
              static_cast<JsonLogStream::LogType>(type)));
}

JS_STEST_LWSTOM(JsonLog, Close, 0, "Close the JSON log file")
{
    MASSERT(pContext != 0);
    MASSERT(pArguments != 0);
    MASSERT(pReturlwalue != 0);

    JsonLogStream::Close();
    RETURN_RC(OK);
}

P_(JsonLog_Get_FileName)
{
   MASSERT(pContext != 0);
   MASSERT(pValue   != 0);

   if
   (
         (! JsonLogStream::d_IsOpen)
      || (OK != JavaScriptPtr()->ToJsval(JsonLogStream::d_pFileSinkFull->GetFileName(), pValue))
   )
   {
      JS_ReportError(pContext, "Failed to get JsonLog.FileName.");
      *pValue = JSVAL_NULL;
   }

   return JS_TRUE;
}
static SProperty JsonLog_FileName
(
   JsonLog_Object,
   "FileName",
   0,
   "",
   JsonLog_Get_FileName,
   0,
   JSPROP_READONLY,
   "JsonLog file name."
);

P_(JsonLog_Get_IsOpen)
{
   MASSERT(pContext != 0);
   MASSERT(pValue   != 0);

   *pValue = BOOLEAN_TO_JSVAL(JsonLogStream::d_IsOpen);

   return JS_TRUE;
}
static SProperty JsonLog_IsOpen
(
   JsonLog_Object,
   "IsOpen",
   0,
   "",
   JsonLog_Get_IsOpen,
   0,
   JSPROP_READONLY,
   "JsonLog is active."
);

bool JsonLogStream::GetInline()
{
    return JsonLogStream::d_JsonInline;
}

RC JsonLogStream::SetInline(bool val)
{
    JsonLogStream::d_JsonInline = val;
    return OK;
}

P_(JsonLog_Get_Inline)
{
   MASSERT(pContext != 0);
   MASSERT(pValue   != 0);

   bool Result = JsonLogStream::GetInline();

   if(OK != JavaScriptPtr()->ToJsval(Result, pValue))
   {
      JS_ReportError(pContext, "Failed to get JsonLogStream.Inline");
      *pValue = JSVAL_NULL;
      return JS_FALSE;
   }

   return JS_TRUE;
}
P_(JsonLog_Set_Inline)
{
   MASSERT(pContext != 0);
   MASSERT(pValue   != 0);

   bool Value;

   if (OK != JavaScriptPtr()->FromJsval(*pValue, &Value))
   {
      JS_ReportError(pContext, "Failed to set JsonLogStream . Inline");
      return JS_FALSE;
   }

   if(OK != JsonLogStream::SetInline(Value))
   {
      JS_ReportWarning(pContext, "Error Setting Inline");
      *pValue = JSVAL_NULL;
      return JS_TRUE;
   }

   return JS_TRUE;
}
static SProperty JsonLog_Inline
(
   JsonLog_Object,
   "Inline",
   0,
   false,
   JsonLog_Get_Inline,
   JsonLog_Set_Inline,
   0,
   "JsonLog inline in mods.log."
);

//------------------------------------------------------------------------------
// Class statics.

void * JsonItem::s_Mutex = nullptr;
int JsonItem::s_UniqueCounter = 0;

void JsonItem::FreeSharedResources()
{
    if (s_Mutex)
    {
        Tasker::FreeMutex(s_Mutex);
        s_Mutex = nullptr;
    }
    JsonLogStream::Close();
}

int JsonItem::GetUniqueInt()
{
    if (!s_Mutex)
    {
        s_Mutex = Tasker::AllocMutex("JsonItem::s_Mutex", Tasker::mtxUnchecked);
    }

    Tasker::MutexHolder mhold(s_Mutex);

    int i = s_UniqueCounter;
    ++s_UniqueCounter;
    return i;
}

//-----------------------------------------------------------------------------
static JSBool C_JsonItem_constructor
(
    JSContext *cx,
    JSObject *thisObj,
    uintN argc,
    jsval *argv,
    jsval *rval
)
{
    // Store C++ object in the JS object.
    JS_SetPrivate(cx, thisObj, new JsonItem(cx, nullptr, thisObj));
    return JS_TRUE;
}

//-----------------------------------------------------------------------------
static SObject JsonItem_Object
(
    "JsonItem",
    JsonItemClass,
    0,
    0,
    "JsonItem logging Object",
    C_JsonItem_constructor
);

//-----------------------------------------------------------------------------
// Construct a JsonItem (called from the JS constructor).
//
JsonItem::JsonItem
(
    JSContext * ctx,
    JSObject * nullObj,
    JSObject * pThisObj
)
 :  m_pCtx(ctx)
   ,m_pParent(nullObj)
   ,m_pObj(pThisObj)
   ,m_FreedByGC(true)
{
}

//-----------------------------------------------------------------------------
// Construct a JsonItem (called from C++)
//
JsonItem::JsonItem
(
    JSContext * ctx,
    JSObject * pParent,
    const char * propName
)
 :  m_pCtx(ctx)
   ,m_pParent(pParent)
   ,m_pObj(nullptr)
   ,m_FreedByGC(true)
{
    // Create a JS object as property of the pParent JS object.
    m_pObj = JS_DefineObject(
            m_pCtx,
            m_pParent,
            propName,       // "JsonEnter" or "JsonExit" normally.
            &JsonItemClass,
            nullptr,
            JSPROP_ENUMERATE);

    // Store the C++ object in the JS object.
    JS_SetPrivate(m_pCtx, m_pObj, this);
}

//-----------------------------------------------------------------------------
// Construct a JsonItem (called from C++)
//
JsonItem::JsonItem()
 :  m_pCtx(nullptr)
   ,m_pParent(nullptr)
   ,m_pObj(nullptr)
   ,m_FreedByGC(false)
{
    JavaScriptPtr pJavaScript;

    pJavaScript->GetContext(&m_pCtx);
    MASSERT(m_pCtx);

    // Create a JavaScript object to store properties
    m_pObj = JS_NewObject(m_pCtx, &JsonItemClass, nullptr, m_pParent);

    // Store the C++ object in the JS object.
    JS_SetPrivate(m_pCtx, m_pObj, this);

    // Root the JS object so that it will not be garbage-collected.
    JS_AddNamedRoot(m_pCtx, &m_pObj, __FUNCTION__);
}

//------------------------------------------------------------------------------
JsonItem::~JsonItem()
{
    JS_SetPrivate(m_pCtx, m_pObj, 0);

    if (!m_FreedByGC)
    {
        JS_RemoveRoot(m_pCtx, &m_pObj);
    }
}

//------------------------------------------------------------------------------
JS_STEST_LWSTOM(JsonItem, WriteToLogFile, 0, "Write record to .jso file")
{
    JsonItem *pJsonItem;
    if ((pJsonItem = JS_GET_PRIVATE(JsonItem, pContext, pObject,
                                          "JsonItem")) != 0)
    {
        RETURN_RC(pJsonItem->WriteToLogfile());
    }
    return JS_FALSE;
}

//------------------------------------------------------------------------------
JS_STEST_LWSTOM(JsonItem, SetTag, 1, "Set record tag")
{
    MASSERT(pArguments   !=0);
    MASSERT(pReturlwalue !=0);
    const char usage[] = "Usage: JsonItem.SetTag(string)\n";

    if (NumArguments != 1)
    {
        JS_ReportError(pContext, usage);
        return JS_FALSE;
    }

    JavaScriptPtr pJavaScript;
    string tagName;
    if (OK != pJavaScript->FromJsval(pArguments[0], &tagName))
    {
        JS_ReportError(pContext, usage);
        return JS_FALSE;
    }

    JsonItem *pJsonItem;
    if ((pJsonItem = JS_GET_PRIVATE(JsonItem, pContext, pObject,
            "JsonItem")) != 0)
    {
        pJsonItem->SetTag(tagName.c_str());
    }
    RETURN_RC(OK);
}

JS_STEST_LWSTOM(JsonItem, SetCategory, 1, "Set the JSON log's category")
{
    MASSERT(pContext != 0);
    MASSERT(pArguments != 0);
    MASSERT(pReturlwalue != 0);

    STEST_HEADER(0, 1, "Usage: JsonItem.SetCategory(category="
                 "JsonConst.DEFAULT)\n");
    STEST_OPTIONAL_ARG(0, INT32, category, JsonItem::JSONLOG_DEFAULT);

    JsonItem *pJsonItem;
    if ((pJsonItem = JS_GET_PRIVATE(JsonItem, pContext, pObject,
            "JsonItem")) != 0)
    {
        pJsonItem->SetCategory(static_cast<JsonItem::JsonCategory>(category));
        RETURN_RC(OK);
    }
    return JS_FALSE;
}

JS_STEST_LWSTOM(JsonItem,
                JsonLimitedSetAllowedField,
                1,
                "Set json limited allowed field")
{
    STEST_HEADER(1, 1, "Usage: JsonItem.JsonLimitedSetAllowedField(field)");
    STEST_PRIVATE(JsonItem, pJsonItem, "JsonItem");
    STEST_ARG(0, string, field);
    pJsonItem->JsonLimitedSetAllowedField(field);
    RETURN_RC(OK);
}

JS_SMETHOD_LWSTOM(JsonItem,
                  Stringify,
                  0,
                  "Colwert json to string")
{
    STEST_HEADER(0, 0, "Usage: JsonItem.Stringify()");
    STEST_PRIVATE(JsonItem, pJsonItem, "JsonItem");

    string str;
    if (OK != pJsonItem->Stringify(&str))
    {
        JS_ReportError(pContext, "Failed to Stringify JsonItem");
        return JS_FALSE;
    }
    if (OK != pJavaScript->ToJsval(str, pReturlwalue))
    {
        JS_ReportError(pContext, "Failed to colwert JsonItem string");
        return JS_FALSE;
    }
    return JS_TRUE;
}

//------------------------------------------------------------------------------
RC JsonItem::WriteToLogfile()
{
    // In limited json mode, check if only a few fields were requested
    // If so, remove other fields from the json object
    if (JsonLogStream::d_LogType == JsonLogStream::JSONLOG_USE_LIMITED &&
        !m_JsonLimitedAllowAllFields)
    {
        JsonLimitedRemoveUnallowedFields();
    }
    return JsonLogStream::PrintJsonItem (*this);
}

//------------------------------------------------------------------------------
RC JsonItem::Stringify(string* pStr)
{
    MASSERT(pStr);
    return JsonLogStream::StringifyJsObject(GetCtx(), GetObj(), *pStr);
}

//------------------------------------------------------------------------------
void JsonItem::SetTag(const char * tagname)
{
    m_Tag = tagname;
}

//------------------------------------------------------------------------------
void JsonItem::SetCategory(JsonItem::JsonCategory category)
{
    m_Category = category;
}

//------------------------------------------------------------------------------
void JsonItem::SetLwrDateTimeField(const char * name)
{
    // Add a Date property of the given name, holding the lwrren time.

    JSObject * pDateObj = JS_ConstructObject(
            m_pCtx,
            &js_DateClass,   // not exported in JS 1.4 library
            nullptr,
            m_pObj);

    SetField(name, OBJECT_TO_JSVAL(pDateObj), 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetUniqueIntField(const char * name)
{
    const int unique = GetUniqueInt();

    // We can avoid "boxing" the int if it fits in 30 bits.
    // This should always be true for the output of GetUniqueInt.
    MASSERT(INT_FITS_IN_JSVAL(unique));

    // Make visible read only to JS.
    SetField(name, INT_TO_JSVAL(unique), JSPROP_READONLY);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, bool v)
{
    SetField(name, BOOLEAN_TO_JSVAL(v), 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, UINT32 v)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(v, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, INT32 v)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(v, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, UINT64 v)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(v, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, INT64 v)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(v, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, double v)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(v, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, const char * p)
{
    JavaScriptPtr pJs;
    jsval jsv;
    string s = p;
    pJs->ToJsval(s, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, JsArray * p)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(p, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, jsval v, int flags)
{
    RemoveField(name);
    flags |= JSPROP_ENUMERATE;
    JS_DefineProperty(GetCtx(), GetObj(), name, v, nullptr, nullptr, flags);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, JSObject *p)
{
    JavaScriptPtr pJs;
    jsval jsv;
    pJs->ToJsval(p, &jsv);
    SetField(name, jsv, 0);
}

//------------------------------------------------------------------------------
void JsonItem::SetField(const char * name, JsonItem *p)
{
    SetField(name, p->GetObj());
}

//------------------------------------------------------------------------------
void JsonItem::RemoveField(const char * name)
{
    JS_DeleteProperty(GetCtx(), GetObj(), name);
}

//------------------------------------------------------------------------------
void JsonItem::RemoveAllFields()
{
    JS_ClearScope(GetCtx(), GetObj());
}

//------------------------------------------------------------------------------
void JsonItem::CopyAllFields(const JsonItem & jsi)
{
    JavaScriptPtr pJs;
    JSContext * cx = GetCtx();
    JSPropertiesEnumerator pe (cx, jsi.GetObj());
    JSIdArray * ida = pe.GetProperties();
    if (0 == ida)
    {
        MASSERT(!"can't enum properties");
        return;
    }

    for (int i = 0; i < ida->length; i++)
    {
        jsval jsv;
        if (!JS_IdToValue(cx, ida->vector[i], &jsv))
        {
            MASSERT(!"can't get propid");
            return;
        }

        string propName;
        if (OK != pJs->FromJsval(jsv, &propName))
        {
            MASSERT(!"can't get propname");
            return;
        }

        if (!JS_GetProperty(cx, jsi.GetObj(), propName.c_str(), &jsv))
        {
            MASSERT(!"can't get value");
            return;
        }

        SetField(propName.c_str(), jsv, 0);
    }
}

//------------------------------------------------------------------------------
void JsonItem::AddFailLoop(UINT32 loop)
{
    JsArray jsa;
    JavaScriptPtr pJs;

    if (OK == pJs->GetProperty(GetObj(), "fail_loops", &jsa))
    {
        if (jsa.size() >= 25)
        {
            // Don't store very many loops here, we really only care about
            // the first one in the common case, and the list can get huge
            // on a very broken gpu.
            return;
        }
        for (size_t i = 0; i < jsa.size(); i++)
        {
            UINT32 oldL;
            pJs->FromJsval(jsa[i], &oldL);
            if (oldL == loop)
            {
                // Loop is already present -- nothing to do.
                return;
            }
        }
    }
    jsval jsv;
    pJs->ToJsval(loop, &jsv);
    jsa.push_back(jsv);
    pJs->ToJsval(&jsa, &jsv);

    pJs->SetPropertyJsval(GetObj(), "fail_loops", jsv);
}

//------------------------------------------------------------------------------
void JsonItem::JsonLimitedSetAllowedField(string field)
{
    m_JsonLimitedAllowedFields.push_back(field);
}

//------------------------------------------------------------------------------
bool JsonItem::JsonLimitedIsAllowedField(string field)
{
    if (m_JsonLimitedAllowedFields.empty())
    {
        return m_JsonLimitedAllowAllFields;
    }
    return std::find(m_JsonLimitedAllowedFields.begin(),
                     m_JsonLimitedAllowedFields.end(), field) !=
                     m_JsonLimitedAllowedFields.end();
}

//------------------------------------------------------------------------------
void JsonItem::JsonLimitedRemoveUnallowedFields()
{
    JavaScriptPtr pJs;
    JSContext *cx = GetCtx();
    JSPropertiesEnumerator pe(cx, GetObj());
    JSIdArray *ida = pe.GetProperties();
    if (ida != nullptr)
    {
        for (int i = 0; i < ida->length; i++)
        {
            jsval jsv;
            if (JS_IdToValue(cx, ida->vector[i], &jsv))
            {
                string field;
                if (OK == pJs->FromJsval(jsv, &field))
                {
                    if (!JsonLimitedIsAllowedField(field))
                    {
                        RemoveField(field.c_str());
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//              JSON constants
//-----------------------------------------------------------------------------
JS_CLASS(JsonConst);
static SObject JsonConst_Object
(
   "JsonConst",
   JsonConstClass,
   0,
   0,
   "JSON logging constants."
);
PROP_CONST(JsonConst, DEFAULT, JsonItem::JSONLOG_DEFAULT);
PROP_CONST(JsonConst, LWLINKTOPOLOGY, JsonItem::JSONLOG_LWLINKTOPOLOGY);
PROP_CONST(JsonConst, LWLINKINFO, JsonItem::JSONLOG_LWLINKINFO);
PROP_CONST(JsonConst, PEXTOPOLOGY, JsonItem::JSONLOG_PEXTOPOLOGY);
PROP_CONST(JsonConst, PEXINFO, JsonItem::JSONLOG_PEXINFO);
PROP_CONST(JsonConst, USE_FULL, JsonLogStream::JSONLOG_USE_FULL);
PROP_CONST(JsonConst, USE_LIMITED, JsonLogStream::JSONLOG_USE_LIMITED);
PROP_CONST(JsonConst, GPUINFO, JsonItem::JSONLOG_GPUINFO);
PROP_CONST(JsonConst, CARRIERFRU, JsonItem::JSONLOG_CARRIERFRU);
