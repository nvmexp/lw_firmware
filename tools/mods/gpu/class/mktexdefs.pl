#!/usr/bin/elw perl

#
# Texture header/sampler #define generator.
#
# Parses include/$chip/texture_state_generated.spec to produce a set of 
# #defines similar to what you'd see in the software class headers.
#
$chip                  = shift; # chip name
$headertype            = shift; # Must be "tex"
$classNumber           = shift; # class number (5097 or 8397, etc.)

$OFS = "\r\n";                  # DOS-style files
%enums = ();                    # map of enum definitions
$group = undef;                 # current state group
$bit = 0;                       # current bit number

$prefix = "LW$classNumber";     # prefix for #defines
$chip =~ tr/[a-z]/[A-Z]/;
$filename = "$chip"."TEXDEFS";  # base filename

print << "EOF";
/*
* _LWRM_COPYRIGHT_BEGIN_
*
* Copyright 2001-2007 by LWPU Corporation.  All rights reserved.  All
* information contained herein is proprietary and confidential to LWPU
* Corporation.  Any use, reproduction, or disclosure without the written
* permission of LWPU Corporation is prohibited.
*
* _LWRM_COPYRIGHT_END_
*/

/* This file is autogenerated by mktexdefs.pl.  Do not edit. */

EOF

print "\n";
print "#ifndef __".$filename."_H__\n";
print "#define __".$filename."_H__\n";
print "\n";


for (<>) {

    s/\/\/.*$//;                # strip "//" comments
    @tokens = split;            # tokenize
    next if (@tokens == 0);     # skip empty lines
    next if m/^\#(if|define|endif)/; # skip preprocessor directives

    if ($tokens[0] eq "context") {

        # file header - ignore

    } elsif ($tokens[0] eq "enum_type") {

        # Enum root definition -- make this the "active" enum type.
        $enum_type = $tokens[1];
        $enums{$enum_type} = [];

    } elsif ($tokens[0] eq "enum") {

        # Enum value definition.  Push a name/value pair onto the list of
        # enums in the enum hash for the active enum type.  Capitalize the
        # name.
        $tokens[1] =~ tr/[a-z]/[A-Z]/;
        $enum = [ $tokens[1], $tokens[2] ];
        $listref = $enums{$enum_type};
        push @$listref, $enum;

    } elsif ($tokens[0] eq "group") {

        # Structure group definition.  Extract the base #define name for known
        # structure types.
        if ($tokens[1] eq "TextureHeaderState") {
            $group = "TEXHEAD";
            print "\n/*\n** Texture Header State\n */\n";
        } elsif ($tokens[1] eq "TextureSamplerState") {
            $group = "TEXSAMP";
            print "\n/*\n** Texture Sampler State\n */\n";
        } elsif ($tokens[1] eq "TextureHeaderStateVersion2") {
            $group = "TEXHEADV2_";
        } else {
            $group = "USELESSCRAP";
        }

        # Start at bit 0.
        $bit = 0;

    } elsif ($tokens[0] eq "down") {

        next if $group eq "USELESSCRAP";
        die "Missing group header" if !defined($group);

        # Blank line between DWORD definitions.
        print "\n" if ($bit % 32) == 0;

        # Skip over padding bits if the field is named "-".
        if ($tokens[2] eq "-") {
            $bit += $tokens[3];
            next;
        }

        # Generate a #define field name by inserting underscores before all
        # capital characters and then capitalizing the whole field.
        $tokens[2] =~ s/([A-Z])/_$1/g;
        $tokens[2] =~ s/^_//;   # skip an underscore if the first letter is
                                # capital
        $tokens[2] =~ tr/[a-z]/[A-Z]/;

        # Base define name is something like:
        #    LW5097_TEXHEAD0_FIELD_NAME
        # where the number is the DWORD number of the current field.
        $defname = $prefix . "_" . $group . int($bit/32) . "_" . $tokens[2];

        # Make sure each field is wholly contained within a dword.
        die "Field [$bit..$bit+$tokens[3]-1] straddles a dword."
          if int($bit/32) != int(($bit+$tokens[3]-1)/32);

        # Print the definition for the field bits within the word.
        printf("#define %-58s %d:%d\n", $defname, ($bit%32)+$tokens[3]-1,
               $bit%32);

        # If the field isn't "U", treat as an enumerated type.  Find the entry
        # in the hash, and sort it by enum values.  Then print each defined
        # enum value.  Don't print anything else for integer type fields.
        if ($tokens[1] ne "U") {

            $listref = $enums{$tokens[1]};
            die "Can't find $tokens[1] enum def." if !defined($listref);
            for (sort {$a->[1] <=> $b->[1]} @$listref) {
                $enumname = $defname . "_" . $_->[0];
                printf("#define %-58s 0x%08x\n", $enumname, $_->[1]);
            }
        }

        # Skip ahead by the field size.
        $bit += $tokens[3];
    } elsif ($tokens[0] eq "bitpack") {
        # eat this fermi spec token for now
    } elsif ($tokens[0] eq "packet") {
        # eat this fermi spec token for now
    } elsif ($tokens[0] eq "struct") {
        # eat this fermi spec token for now
    } else {

        # Anything else is an error.
        die "Unknown line:  $_";

    }
}

print "\n\n#endif /* #ifndef __".$filename."_H__ */\n";
