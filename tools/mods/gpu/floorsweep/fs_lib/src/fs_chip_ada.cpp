#include <iostream>
#include <sstream>

#include "fs_chip_ada.h"

namespace fslib {

//-----------------------------------------------------------------------------
// Include generated headers
//-----------------------------------------------------------------------------

#include "ad102_config.h"
#include "ad103_config.h"
#include "ad104_config.h"
#include "ad106_config.h"
#include "ad107_config.h"

//-----------------------------------------------------------------------------
// ADLit1Chip_t
//-----------------------------------------------------------------------------

/**
 * @brief Returns an instance of the GPC type used in ADLit1 chips
 * 
 * @return std::unique_ptr<GPC_t> A GPC with GFX configuration
 */
void ADLit1Chip_t::getGPCType(GPCHandle_t& handle) const {
    makeModule(handle, GPCWithGFX_t());
}

/**
 * @brief Returns an instance of the FBP type used in ADLit1 chips
 * 
 * @return std::unique_ptr<FBP_t> A FBP connected to DDR memory
 */
void ADLit1Chip_t::getFBPType(FBPHandle_t& handle) const {
    makeModule(handle, DDRFBP_t());
}

/**
 * @brief Litter ADLit1-specific floorsweeping configuration check
 *
 * ADLit1 is a litter of GDDR chips without uGPUs
 *  - PES/TPC pairings enforced via GPC class `GPCWithGFX_t`
 *  - Valid L2 slice configuration enforced in this function.
 * 
 * @param[in] fsmode The mode to use: PRODUCT, FUNC_VALID, IGNORE_FSLIB
 * @param[out] msg An error message describing why a configuration is invalid
 * @return true This floorsweeping configuration is valid for a generic ADLit1 chip
 * @return false This floorsweeping configuration is invalid for a generic ADLit1 chip
 */
bool ADLit1Chip_t::isValid(FSmode fsmode, std::string& msg) const {
    // GDDR chip with no uGPU rules
    // Enforce default compute/memory rules
    // Enforce PES/TPC pairings by using GPCWithGFX

    // In a DDR-based FBP in Ampere/Ada, the number of L2 slices in each LTC must be equal.
    int num_slices = -1;
    bool first_fbp = true;
    mask32_t next_l2_mask = 0xFFFFFFFF;
    for (uint32_t i = 0; i < FBPs.size(); i++) {
        const DDRFBP_t &FBP = static_cast<const DDRFBP_t&>(*FBPs[i]);
        if (FBP.getEnabled()) {
            if (first_fbp) {
                // Get L2 slice configuration for product mode
                next_l2_mask = FBP.getL2Mask();
            }
            int fbp_slices_per_ltc = -1;
            if (FBP.isValidSlice(fsmode, msg, next_l2_mask)) {
                fbp_slices_per_ltc = FBP.numSlicesPerLTC();
                if (first_fbp) {
                    num_slices = fbp_slices_per_ltc;
                    first_fbp = false;
                } else if (fbp_slices_per_ltc != num_slices) {
                        std::stringstream ss;
                        ss << "The number of L2 slices are not the same across FBPs! FBP " 
                        << i << " has " << fbp_slices_per_ltc << " slices per LTC, but other FBPs have " 
                        << num_slices << " per LTC!";
                        msg = ss.str();
                        return false;
                }
            } else {
                // msg generated by isValidSlice
                return false;
            }
        }
    }

    // Each GPC must have an equal number of ROPs in PRODUCT mode
    if (fsmode == FSmode::PRODUCT) {
        bool first_gpc = true;
        uint32_t num_rops = 0;
        for (uint32_t i = 0; i < GPCs.size(); i++) {
            const GPCWithGFX_t& GPC = dynamic_cast<const GPCWithGFX_t&>(*GPCs[i]);
            if (GPC.getEnabled()) {
                uint32_t rops = getNumEnabled(GPC.ROPs);
                if (first_gpc) {
                    num_rops = rops;
                    first_gpc = false;
                } else {
                    if (num_rops != rops) {
                        std::stringstream ss;
                        ss << "The number of ROPs are not the same across GPCs! GPC " 
                        << i << " has " << rops << " ROPs, but other GPCs have " 
                        << num_rops << " ROPs!";
                        msg = ss.str();
                        return false;                        
                    }
                }
            }
        }
    }
    


    return checkBalancedLTCValid(fsmode, msg) && FSChip_t::isValid(fsmode, msg);
}

/**
 * @brief Checks LTC/HalfFBPA configuration and determines if it is valid
 *
 * A generic ADLit1 chip allows balanced LTC mode for FUNC_VALID
 * 
 * @param[in] fsmode The mode to use: PRODUCT, FUNC_VALID, IGNORE_FSLIB
 * @param[out] msg An error message describing why a configuration is invalid
 * @return true This LTC/HalfFBPA configuration is valid for a generic ADLit1 chip
 * @return false This LTC/HalfFBPA configuration is invalid for a generic ADLit1 chip
 */
bool ADLit1Chip_t::checkBalancedLTCValid(FSmode fsmode, std::string& msg) const {
    bool half_fbpa_floorswept = false;
    bool all_ltcs_floorswept = true;
    for (uint32_t i = 0; i < FBPs.size(); i++) {
        const DDRFBP_t &FBP = static_cast<const DDRFBP_t&>(*FBPs[i]);
        if (FBP.getEnabled()) {
            // For non-balanced LTC mode, enabled half FBPAs should equal enabled LTCs
            // In balanced mode, no half FBPAs should be floorswept
            half_fbpa_floorswept |= (FBP.getNumEnabledHalfFBPAs() < FBP.HalfFBPAs.size());
            all_ltcs_floorswept &= (FBP.getNumEnabledLTCs() < FBP.LTCs.size());
            if (half_fbpa_floorswept && FBP.getNumEnabledHalfFBPAs() != FBP.getNumEnabledLTCs()) {
                // A FBPA has been floorswept in the system, so this isn't balanced.
                // An LTC has been floorswept in this FBP, so this configuration is invalid.
                std::stringstream ss;
                ss << "A FBPA has been floorswept in the system, so this isn't balanced. "
                << "An LTC has been floorswept in this FBP, so this configuration is invalid.";
                msg = ss.str();
                return false;
            }
        }
    }
    // If we haven't floorswept a Half FBPA, but all FBPs have an LTC floorswept, 
    // this is balanced LTC config
    if (!half_fbpa_floorswept && all_ltcs_floorswept) {
        std::stringstream ss;
        switch(fsmode) {
            case FSmode::PRODUCT:
                if (checkBalancedLTCAllowed()) {
                    return true;
                } else {
                    ss << "Balanced LTC mode is not PRODUCT valid for ADLit1 chips besides AD107!";
                    msg = ss.str();
                    return false;
                }
            case FSmode::FUNC_VALID:
                return true;
            case FSmode::IGNORE_FSLIB:
                return true;
            default:
                ss << "Invalid FSmode! Options are PRODUCT, FUNC_VALID, and IGNORE_FSLIB!";
                msg = ss.str();
                return false;
        }
    } else {
        return true;
    }
}

/**
 * @brief Checks if balanced LTC mode is allowed for PRODUCT mode for a chip
 *
 * Not allowed for ADLit1 besides AD107
 * 
 * @return true Balanced LTC mode is PRODUCT valid
 * @return false Balanced LTC mode is not PRODUCT valid
 */
bool ADLit1Chip_t::checkBalancedLTCAllowed() const {
    return false;
}

/**
 * @brief turn an invalid config into a valid config by further floorsweeping it
 * 
 */
void ADLit1Chip_t::funcDownBin() {
    DDRGPU_t::funcDownBin();
}

//-----------------------------------------------------------------------------
// AD10x Chips
//-----------------------------------------------------------------------------

/**
 * @brief AD103-specific floorsweeping configuration check
 * 
 * @param[in] fsmode The mode to use: PRODUCT, FUNC_VALID, IGNORE_FSLIB
 * @param[out] msg An error message describing why a configuration is invalid
 * @return true This floorsweeping configuration is valid for AD103
 * @return false This floorsweeping configuration is invalid for AD103
 */
bool AD103_t::isValid(FSmode fsmode, std::string& msg) const {
    // AD103 has 4 TPCs in GPC 3, and 2 PESs.  Make sure that TPC 4,5 and PES 2 are FS'd
    const GPCWithGFX_t& gpc3 = dynamic_cast<const GPCWithGFX_t&>(*GPCs[3]);
    if (gpc3.PESs[2]->getEnabled() || 
        gpc3.TPCs[4]->getEnabled() || 
        gpc3.TPCs[5]->getEnabled()) {
            std::stringstream ss;
            ss << "AD103 has 4 TPCs in GPC3.  TPCs 4 and 5, along with PES 2 must be disabled!";
            msg = ss.str();
            return false; 
    }
    return ADLit1Chip_t::isValid(fsmode, msg);
}

/**
 * @brief Checks if balanced LTC mode is allowed for PRODUCT mode for AD107
 *
 * Allowed for AD107
 * 
 * @return true Balanced LTC mode is PRODUCT valid
 * @return false Balanced LTC mode is not PRODUCT valid
 */
bool AD107_t::checkBalancedLTCAllowed() const {
    return true;
}

}  // namespace fslib



