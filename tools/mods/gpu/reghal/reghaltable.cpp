/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2017-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#include "reghaltable.h"
#include "lwmisc.h"
#ifdef MATS_STANDALONE
#include "fakemods.h"
#else
#include "core/include/massert.h"
#include "core/include/platform.h"
#include "core/include/utility.h"
#endif
#include "g_lwconfig.h"
#include "reghal_tables.h" // Generated RegHalTableInfo::g_CompressedRegHalTables
#include "core/include/zlib.h"
#include <set>
#include <unordered_map>

#define MODS_FIELD_RANGE(r) (((1?r)<<16) | (0?r))

#define PCIE_CAP_LIST         0x0034
#define PCIE_CAP_LIST_CAP_PTR    7:0

#define PCIE_CAP_HDR_CAP_ID      7:0
#define PCIE_CAP_HDR_NEXT_PTR   15:8

#define PCIE_EXT_HDR          0x0100
#define PCIE_EXT_HDR_CAP_ID     15:0
#define PCIE_EXT_HDR_NEXT_PTR  31:20

const RegHalTable::ArrayIndexes_t RegHalTable::NO_INDEXES = {};

map<Device::LwDeviceId, unique_ptr<RegHalTable::HalTable>> RegHalTable::s_HalTables;

// Declare a bunch of externs for the HAL tables generated by
// genreghalimpl.py
//
#ifdef DEBUG
namespace RegHalTableInfo
{
    extern const RawModsGpuRegAddressMap g_ModsGpuRegAddressMap[];
    extern const RawModsGpuRegFieldMap   g_ModsGpuRegFieldMap[];
    extern const RawModsGpuRegValueMap   g_ModsGpuRegValueMap[];
}
#endif

namespace RegHalTableInfo
{
    map<ModsGpuRegAddress, string> g_ModsGpuRegAddressToString;
    map<string, ModsGpuRegAddress> g_StringToModsGpuRegAddress;
    map<ModsGpuRegField, string>   g_ModsGpuRegFieldToString;
    map<string, ModsGpuRegField>   g_StringToModsGpuRegField;
    map<ModsGpuRegValue, string>   g_ModsGpuRegValueToString;
    map<string, ModsGpuRegValue>   g_StringToModsGpuRegValue;
}

namespace
{
    // Read little endian value
    template<typename T>
    void ReadLE(const UINT08* buf, T* pValue)
    {
        *pValue = 0;

        for (size_t i = 0; i < sizeof(T); i++)
        {
            *pValue |= static_cast<UINT32>(*(buf++)) << (i * 8);
        }
    }

    // See reghaldump.cpp for details how the RegHal tables are packed/encoded.
    enum TableHeaderLayout
    {
        // A unique RegHal table consists of:
        // - 4 bytes little endian chip id
        // - 4 bytes little endian compressed size of the RegHal table
        // - 4 bytes little endian decompressed size of the RegHal table
        // - 4 bytes little endian number of elements/entries in the RegHal table
        // - N bytes of compressed RegHal table
        uniqueTableChipId           = 0,
        uniqueTableCompressedSize   = 4,
        uniqueTableDecompressedSize = 8,
        uniqueTableNumberOfElements = 12,
        uniqueTableHeaderSize       = 16,

        // A duplicate RegHal table consists of:
        // - 4 bytes little endian chip id
        // - 4 bytes set to 0xFF to indicate remapping
        // - 4 bytes little endian target chip id with the actual table
        duplicateTableChipId        = 0,
        duplicateTableIdentifier    = 4, // NoTable
        duplicateTableTargetChipId  = 8,
        duplicateTableHeaderSize    = 12,
    };

    constexpr UINT32 NoTable = ~0U;

    // Read 4 bytes little endian from compressed RegHal tables
    UINT32 ReadCompressedLE(UINT32 pos)
    {
        MASSERT(pos + 4 <= sizeof(RegHalTableInfo::g_CompressedRegHalTables));

        UINT32 value;
        ReadLE(&RegHalTableInfo::g_CompressedRegHalTables[pos], &value);

        return value;
    }

    UINT32 FindRegHalInCompressedTables(UINT32 chipId)
    {
        UINT32 numRestarts = 0;
        UINT32 pos         = 0;

        while (pos + duplicateTableHeaderSize < sizeof(RegHalTableInfo::g_CompressedRegHalTables))
        {
            UINT32 lwrChipId = ReadCompressedLE(pos + uniqueTableChipId);
            UINT32 size      = ReadCompressedLE(pos + uniqueTableCompressedSize);

            MASSERT((size == NoTable) ||
                    (pos + size <= sizeof(RegHalTableInfo::g_CompressedRegHalTables)));

            if (chipId == lwrChipId)
            {
                if (size == NoTable)
                {
                    // Found a duplicate RegHal table, which is remapped to another chip,
                    // so reset the search.
                    chipId = ReadCompressedLE(pos + duplicateTableTargetChipId);
                    pos = 0;
                    MASSERT(numRestarts == 0); // Allow only one redirection
                    ++numRestarts;
                    continue;
                }

                return pos;
            }

            if (size == NoTable)
            {
                pos += duplicateTableHeaderSize;
            }
            else
            {
                pos += uniqueTableHeaderSize + size;
            }
        }
        MASSERT(pos == sizeof(RegHalTableInfo::g_CompressedRegHalTables));

        Printf(Tee::PriError, "RegHal lookup failed for 0x%x\n", chipId);
        return NoTable;
    }

    // Read next little endian delta value and add it to existing value, then advance the pointer
    template<typename T>
    void ReadDeltaLE(const UINT08** pBuf, const UINT08* end, UINT32 elemIndex, UINT32 numElements, T* pValue)
    {
        const UINT08* pSrc = *pBuf + elemIndex * sizeof(T);

        MASSERT(pSrc + sizeof(T) <= end);

        T delta;
        ReadLE(pSrc, &delta);

        *pValue += delta;

        *pBuf += numElements * sizeof(T);
    }

    void NextElement(const std::vector<UINT08>& table,
                     UINT32                     elemIndex,
                     UINT32                     numElements,
                     RegHalTable::Element*      pElement)
    {
        const UINT08*       buf = &table[0];
        const UINT08* const end = buf + table.size();

        ReadDeltaLE(&buf, end, elemIndex, numElements, &pElement->regIndex);

        static_assert(RegHalTable::MAX_INDEXES == 4,
                      "bad number of array indexes, if you change this, also change reghaldump");
        for (UINT32 i = 0; i < RegHalTable::MAX_INDEXES; i++)
        {
            ReadDeltaLE(&buf, end, elemIndex, numElements, &pElement->arrayIndexes[i]);
        }

        static_assert(sizeof(pElement->domain) == 4,
                      "domain field has incorrect size, expected 4");
        ReadDeltaLE(&buf, end, elemIndex, numElements, reinterpret_cast<UINT32*>(&pElement->domain));
        ReadDeltaLE(&buf, end, elemIndex, numElements, &pElement->capabilityId);
        ReadDeltaLE(&buf, end, elemIndex, numElements, &pElement->flags);
        ReadDeltaLE(&buf, end, elemIndex, numElements, &pElement->regValue);
    }
}

//--------------------------------------------------------------------
//! \brief Initialize the table
//!
//! This method finds the compile-time HAL table generated by
//! genreghalimpl.py for this GPU, and colwerts it to an internal STL
//! map for easy lookup.
//!
void RegHalTable::Initialize(Device::LwDeviceId deviceId)
{
    if (m_Initialized)
    {
        return;
    }

#ifdef DEBUG
    if (RegHalTableInfo::g_StringToModsGpuRegAddress.empty())
    {
        for (const RawModsGpuRegAddressMap* pEntry = RegHalTableInfo::g_ModsGpuRegAddressMap; pEntry->name; pEntry++)
        {
            string name(pEntry->name);
            RegHalTableInfo::g_StringToModsGpuRegAddress[name] = pEntry->value;
            RegHalTableInfo::g_ModsGpuRegAddressToString[pEntry->value] = name;
        }

        for (const RawModsGpuRegFieldMap* pEntry = RegHalTableInfo::g_ModsGpuRegFieldMap; pEntry->name; pEntry++)
        {
            string name(pEntry->name);
            RegHalTableInfo::g_StringToModsGpuRegField[name] = pEntry->value;
            RegHalTableInfo::g_ModsGpuRegFieldToString[pEntry->value] = name;
        }

        for (const RawModsGpuRegValueMap* pEntry = RegHalTableInfo::g_ModsGpuRegValueMap; pEntry->name; pEntry++)
        {
            string name(pEntry->name);
            RegHalTableInfo::g_StringToModsGpuRegValue[name] = pEntry->value;
            RegHalTableInfo::g_ModsGpuRegValueToString[pEntry->value] = name;
        }
    }
#endif

    const auto foundHalTableIt = s_HalTables.find(deviceId);
    if (foundHalTableIt != s_HalTables.end())
    {
        m_pHalTable   = foundHalTableIt->second.get();
        m_Initialized = true;
        return;
    }

    // Find RegHal table entry for the specified device
    //
    const UINT32 pos = FindRegHalInCompressedTables(deviceId);
    if (pos == NoTable)
    {
        m_Initialized = true;
        return;
    }

    // Decompress the table
    //
    const UINT32  compressedSize   = ReadCompressedLE(pos + uniqueTableCompressedSize);
    unsigned long decompressedSize = ReadCompressedLE(pos + uniqueTableDecompressedSize);
    const UINT32  numElements      = ReadCompressedLE(pos + uniqueTableNumberOfElements);
    vector<UINT08> table(decompressedSize);
    if (compressedSize != decompressedSize)
    {
        if (Z_OK != uncompress(&table[0],
                               &decompressedSize,
                               &RegHalTableInfo::g_CompressedRegHalTables[pos + uniqueTableHeaderSize],
                               compressedSize))
        {
            Printf(Tee::PriError, "RegHal decompression failed for 0x%x\n", deviceId);
            m_Initialized = true;
            return;
        }
        // uncompress() can update decompressedSize, make sure it is as expected
        MASSERT(decompressedSize == table.size());
    }
    else
    {
        memcpy(&table[0],
               &RegHalTableInfo::g_CompressedRegHalTables[pos + uniqueTableHeaderSize],
               compressedSize);
    }

    // Copy the compile-time HAL table into the internal HAL table
    //
    s_HalTables[deviceId] = make_unique<HalTable>();
    m_pHalTable = s_HalTables[deviceId].get();
    RegHalTable::Element element = { };
    for (UINT32 ii = 0; ii < numElements; ++ii)
    {
        NextElement(table, ii, numElements, &element);

        // Skip the dummy entry that was added to prevent the HAL
        // table from being  a zero-size array on stub GPUs
        //
        if (element.regIndex ==
            static_cast<UINT32>(MODS_REGISTER_ADDRESS_NULL))
        {
            continue;
        }

        // Skip virtual SRIOV registers on a physical GPU, and
        // vice-versa
        //
        if ((element.flags & FLAG_VIRTUAL_MASK) == FLAG_PHYSICAL_ONLY &&
            Platform::IsVirtFunMode())
        {
            continue;
        }
        if ((element.flags & FLAG_VIRTUAL_MASK) == FLAG_VIRTUAL_ONLY &&
            !Platform::IsVirtFunMode())
        {
            continue;
        }

        // Error if the argument of -cap isn't a ModsGpuRegValue
        //
        if (element.capabilityId != 0 &&
            MODS_REGISTER_VALUE != (element.capabilityId &
                                    MODS_REGISTER_TYPE_MASK) &&
            MODS_REGISTER_ADDRESS == (element.regIndex &
                                      MODS_REGISTER_TYPE_MASK))
        {
            const char *pName = ColwertToString(
                    static_cast<ModsGpuRegAddress>(element.regIndex));
            string desc = pName ? Utility::StrPrintf(" (%s)", pName) : "";
            Printf(Tee::PriError,
                   "Invalid -cap value in register 0x%x%s\n",
                   element.regIndex, desc.c_str());
            MASSERT(!"Bad -cap value in reghal.def");
        }

        // Add the element to the HAL table
        //
        HalKey  key  = { element.regIndex, element.arrayIndexes };
        HalData data =
        {
            element.regValue,
            element.domain,
            static_cast<ModsGpuRegValue>(element.capabilityId)
        };
        m_pHalTable->emplace(key, data);
    }

    // Make sure registers with -cap use the same domain as the
    // capability header
    //
    for (auto& iter: *m_pHalTable)
    {
        HalData *pHalData = &iter.second;
        const ModsGpuRegValue capabilityId = pHalData->capabilityId;
        if (capabilityId != MODS_REGISTER_VALUE_NULL)
        {
            const HalKey key = { static_cast<UINT32>(pHalData->capabilityId) };
            const RegHalDomain capDomain = (*m_pHalTable)[key].domain;
            if (pHalData->domain == RegHalDomain::RAW)
            {
                pHalData->domain = capDomain;
            }
            MASSERT(pHalData->domain == capDomain);
        }
    }

    m_Initialized = true;
}

//--------------------------------------------------------------------
//! \brief Look up register address in the HAL table
//!
UINT32 RegHalTable::LookupAddress
(
    ModsGpuRegAddress address,
    ArrayIndexes      arrayIndexes
) const
{
    // Look up register in HAL table
    const HalData* pHalData = LookupOrDie(address, arrayIndexes);

    // Check whether this register is part of a capability struct.
    // If not, return the register address.  If so, find the offset of
    // the register within the struct, and add the address of the
    // struct.
    //
    const CapabilityData* pCapData = LookupCapabilityId(pHalData->capabilityId);
    if (pCapData == nullptr)
    {
        return pHalData->regData;
    }
    else
    {
        const UINT32 capOffset = pHalData->regData - pCapData->hwrefAddress;
        return pCapData->actualAddress + capOffset;
    }
}
//--------------------------------------------------------------------
//! \brief Look up size of register array
//!
//! \param address The base address of the array
//! \param dimension Tells which dimension to get the size of.  Must
//! be 1 for one-dimensional arrays, and may be 1 or 2 for
//! two-dimensional arrays.
//!
UINT32 RegHalTable::LookupArraySize
(
    ModsGpuRegAddress address,
    UINT32 dimension
) const
{
    return LookupOrDie(address, {0xFFFFU, dimension})->regData;
}

//--------------------------------------------------------------------
//! \brief Look up size of register array
//!
//! \param field The base field of the array
//! \param dimension Tells which dimension to get the size of.  Must
//! be 1 for one-dimensional arrays, and may be 1 or 2 for
//! two-dimensional arrays.
//!
UINT32 RegHalTable::LookupArraySize
(
    ModsGpuRegField field,
    UINT32 dimension
) const
{
    UINT32 lo = 0, hi = 0;
    LookupOrDie(field, {0xFFFFU, dimension}, &hi, &lo);
    return lo | (hi << 16);
}

//--------------------------------------------------------------------
//! \brief Look up size of register array
//!
//! \param value The base value of the array
//! \param dimension Tells which dimension to get the size of.  Must
//! be 1 for one-dimensional arrays, and may be 1 or 2 for
//! two-dimensional arrays.
//!
UINT32 RegHalTable::LookupArraySize
(
    ModsGpuRegValue value,
    UINT32 dimension
) const
{
    return LookupOrDie(ColwertToAddress(value), {0xFFFFU, dimension})->regData;
}

//--------------------------------------------------------------------
//! \brief Look up address of corresponding priv register
//!
//! Return the address of the corresponding priv register, or 0 if the
//! register has no corresponding priv register
//!
UINT32 RegHalTable::LookupPrivAddress
(
    ModsGpuRegAddress address,
    ArrayIndexes      arrayIndexes
) const
{
    ArrayIndexes_t privIndexes(arrayIndexes.size() + 1);
    privIndexes[0] = 0xFFFEU;
    if (!arrayIndexes.empty())
    {
        copy(arrayIndexes.begin(), arrayIndexes.end(), &privIndexes[1]);
    }

    const HalData *pHalData;
    return TryLookup(address, privIndexes, &pHalData) ? pHalData->regData : 0;
}

//--------------------------------------------------------------------
//! \brief Look up the high and low bits of a bitfield.
//!
//! On exit, if pHiBit & pLoBit are non-null, they contain the high
//! bit and low bit numbers respectively.
//!
void RegHalTable::LookupField
(
    ModsGpuRegField field,
    ArrayIndexes    indexes,
    UINT32*         pHiBit,
    UINT32*         pLoBit
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    if (pHiBit)
        *pHiBit = hiBit;
    if (pLoBit)
        *pLoBit = loBit;
}

//--------------------------------------------------------------------
//! \brief Look up the shifted mask corresponding to a register field
UINT32 RegHalTable::LookupMask(ModsGpuRegField field, ArrayIndexes indexes) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return DRF_SHIFTMASK(hiBit:loBit);
}

//--------------------------------------------------------------------
//! \brief Look up the field value mask corresponding to a register field
//!
UINT32 RegHalTable::LookupFieldValueMask(ModsGpuRegField field, ArrayIndexes indexes) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return DRF_MASK(hiBit:loBit);
}

//--------------------------------------------------------------------
//! \brief Look up the size of a mask corresponding to a register field
UINT32 RegHalTable::LookupMaskSize(ModsGpuRegField field, ArrayIndexes indexes) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return DRF_SIZE(hiBit:loBit);
}

//--------------------------------------------------------------------
//! \brief Get a field from a pre-read register value.
UINT32 RegHalTable::GetField
(
    UINT32 regValue,
    ModsGpuRegField field,
    ArrayIndexes indexes
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return REF_VAL(hiBit:loBit, regValue);
}

//--------------------------------------------------------------------
//! \brief Set a field in a pre-read register value.
void RegHalTable::SetField
(
    UINT32 *pRegValue,
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT32 fieldValue
) const
{
    MASSERT(pRegValue != nullptr);
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    *pRegValue = FLD_SET_REF_NUM(hiBit:loBit, fieldValue, *pRegValue);
}

//-----------------------------------------------------------------------------
//! \brief Set a field value in a pre-read register value.
void RegHalTable::SetField
(
    UINT32 *pRegValue,
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return SetField(pRegValue, ColwertToField(value), addressIndexes, LookupValue(value, valueIndexes));
}

//--------------------------------------------------------------------
//! \brief Return a register value with one field set; replaces DRF_NUM
UINT32 RegHalTable::SetField
(
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT32 fieldValue
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return REF_NUM(hiBit:loBit, fieldValue);
}

//-----------------------------------------------------------------------------
//! \brief Return a register value with one field value set; replaces DRF_DEF
UINT32 RegHalTable::SetField
(
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return SetField(ColwertToField(value), addressIndexes, LookupValue(value, valueIndexes));
}

//--------------------------------------------------------------------
//! \brief Check whether a field has the specified value in a pre-read register
//!
//! Return false if the field or value isn't supported.
bool RegHalTable::TestField
(
    UINT32 regValue,
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT32 fieldValue
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    if (!TryLookup(field, indexes, &hiBit, &loBit))
        return false;
    return REF_VAL(hiBit:loBit, regValue) == fieldValue;
}

//--------------------------------------------------------------------
//! \brief Check whether a field has the specified value in a pre-read register
//!
//! Return false if the field or value isn't supported.
bool RegHalTable::TestField
(
    UINT32 regValue,
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    UINT32 fieldValue;
    if (!TryLookup(value, indexes, &fieldValue))
        return false;

    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return TestField(regValue, ColwertToField(value), addressIndexes, fieldValue);
}

//--------------------------------------------------------------------
//! \brief Get a field from a pre-read register value.
UINT64 RegHalTable::GetField64
(
    UINT64 regValue,
    ModsGpuRegField field,
    ArrayIndexes indexes
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return REF_VAL64(hiBit:loBit, regValue);
}

//--------------------------------------------------------------------
//! \brief Set a field in a pre-read register value.
void RegHalTable::SetField64
(
    UINT64 *pRegValue,
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT64 fieldValue
) const
{
    MASSERT(pRegValue != nullptr);
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    *pRegValue = FLD_SET_REF_NUM64(hiBit:loBit, fieldValue, *pRegValue);
}

//-----------------------------------------------------------------------------
//! \brief Set a field value in a pre-read register value.
void RegHalTable::SetField64
(
    UINT64 *pRegValue,
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return SetField64(pRegValue, ColwertToField(value), addressIndexes, LookupValue(value, valueIndexes));
}

//--------------------------------------------------------------------
//! \brief Return a register value with one field set; replaces DRF_NUM
UINT64 RegHalTable::SetField64
(
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT64 fieldValue
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    LookupOrDie(field, indexes, &hiBit, &loBit);
    return REF_NUM64(hiBit:loBit, fieldValue);
}

//-----------------------------------------------------------------------------
//! \brief Return a register value with one field value set; replaces DRF_DEF
UINT64 RegHalTable::SetField64
(
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return SetField64(ColwertToField(value), addressIndexes, LookupValue(value, valueIndexes));
}

//--------------------------------------------------------------------
//! \brief Check whether a field has the specified value in a pre-read register
//!
//! Return false if the field or value isn't supported.
bool RegHalTable::TestField64
(
    UINT64 regValue,
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT64 fieldValue
) const
{
    UINT32 hiBit;
    UINT32 loBit;
    if (!TryLookup(field, indexes, &hiBit, &loBit))
        return false;
    return REF_VAL64(hiBit:loBit, regValue) == fieldValue;
}

//--------------------------------------------------------------------
//! \brief Check whether a field has the specified value in a pre-read register
//!
//! Return false if the field or value isn't supported.
bool RegHalTable::TestField64
(
    UINT64 regValue,
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    UINT32 fieldValue;
    if (!TryLookup(value, indexes, &fieldValue))
        return false;

    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    addressIndexes.insert(addressIndexes.end(), fieldIndexes.begin(), fieldIndexes.end());
    return TestField64(regValue, ColwertToField(value), addressIndexes, static_cast<UINT64>(fieldValue));
}

//--------------------------------------------------------------------
//! \brief Colwert a register value to the register field that contains it
/* static */ ModsGpuRegField RegHalTable::ColwertToField(ModsGpuRegValue value)
{
    const UINT32 uValue = static_cast<UINT32>(value);
    MASSERT((uValue & MODS_REGISTER_VALUE) != 0);
    return static_cast<ModsGpuRegField>(MODS_REGISTER_FIELD |
                                        (uValue &
                                         ~MODS_REGISTER_VALUE_MASK &
                                         ~MODS_REGISTER_TYPE_MASK));
}

//--------------------------------------------------------------------
//! \brief Colwert a register value to the register address that contains it
/* static */ ModsGpuRegAddress RegHalTable::ColwertToAddress(ModsGpuRegValue value)
{
    const UINT32 uValue = static_cast<UINT32>(value);
    MASSERT((uValue & MODS_REGISTER_VALUE) != 0);
    return static_cast<ModsGpuRegAddress>(MODS_REGISTER_ADDRESS |
                                          (uValue &
                                           ~MODS_REGISTER_FIELD_MASK &
                                           ~MODS_REGISTER_VALUE_MASK &
                                           ~MODS_REGISTER_TYPE_MASK));
}

//--------------------------------------------------------------------
//! \brief Colwert a register field to the register address that contains it
/* static */ ModsGpuRegAddress RegHalTable::ColwertToAddress(ModsGpuRegField field)
{
    const UINT32 uField = static_cast<UINT32>(field);
    MASSERT((uField & MODS_REGISTER_FIELD) != 0);
    return static_cast<ModsGpuRegAddress>(MODS_REGISTER_ADDRESS |
                                          (uField &
                                           ~MODS_REGISTER_FIELD_MASK &
                                           ~MODS_REGISTER_TYPE_MASK));
}

//--------------------------------------------------------------------
/* static */ RegHalDomain RegHalTable::ColwertToMulticast(RegHalDomain domain)
{
    const UINT32 uDomain = static_cast<UINT32>(domain);
    const UINT32 uBit = static_cast<UINT32>(RegHalDomain::MULTICAST_BIT);
    return static_cast<RegHalDomain>(uDomain | uBit);
}

//--------------------------------------------------------------------
//! \brief Colwert a string to a register address, or 0 if not found
//!
/* static */ ModsGpuRegAddress RegHalTable::ColwertToAddress(const string &str)
{
    auto iter = RegHalTableInfo::g_StringToModsGpuRegAddress.find(str);
    return (iter == RegHalTableInfo::g_StringToModsGpuRegAddress.end() ?
            MODS_REGISTER_ADDRESS_NULL : iter->second);
}

//--------------------------------------------------------------------
//! \brief Colwert a string to a register field, or 0 if not found
//!
/* static */ ModsGpuRegField RegHalTable::ColwertToField(const string &str)
{
    auto iter = RegHalTableInfo::g_StringToModsGpuRegField.find(str);
    return (iter == RegHalTableInfo::g_StringToModsGpuRegField.end() ?
            MODS_REGISTER_FIELD_NULL : iter->second);
}

//--------------------------------------------------------------------
//! \brief Colwert a string to a register value, or 0 if not found
//!
/* static */ ModsGpuRegValue RegHalTable::ColwertToValue(const string &str)
{
    auto iter = RegHalTableInfo::g_StringToModsGpuRegValue.find(str);
    return (iter == RegHalTableInfo::g_StringToModsGpuRegValue.end() ?
            MODS_REGISTER_VALUE_NULL : iter->second);
}

//--------------------------------------------------------------------
//! \brief Colwert a register address to a string, or nullptr if not found
//!
/* static */ const char *RegHalTable::ColwertToString(ModsGpuRegAddress addr)
{
    auto iter = RegHalTableInfo::g_ModsGpuRegAddressToString.find(addr);
    return (iter == RegHalTableInfo::g_ModsGpuRegAddressToString.end() ?
            nullptr : iter->second.c_str());
}

//--------------------------------------------------------------------
//! \brief Colwert a register field to a string, or nullptr if not found
//!
/* static */ const char *RegHalTable::ColwertToString(ModsGpuRegField field)
{
    auto iter = RegHalTableInfo::g_ModsGpuRegFieldToString.find(field);
    return (iter == RegHalTableInfo::g_ModsGpuRegFieldToString.end() ?
            nullptr : iter->second.c_str());
}

//--------------------------------------------------------------------
//! \brief Colwert a register value to a string, or nullptr if not found
//!
/* static */ const char *RegHalTable::ColwertToString(ModsGpuRegValue value)
{
    auto iter = RegHalTableInfo::g_ModsGpuRegValueToString.find(value);
    return (iter == RegHalTableInfo::g_ModsGpuRegValueToString.end() ?
            nullptr : iter->second.c_str());
}

//--------------------------------------------------------------------
/* static */ string RegHalTable::ColwertToString(RegHalDomain domain)
{
    switch (domain)
    {
        case RegHalDomain::AFS:                return "AFS";
        case RegHalDomain::AFS_PERFMON:        return "AFS_PERFMON";
        case RegHalDomain::CLKS:               return "CLKS";
        case RegHalDomain::DLPL:               return "DLPL";
        case RegHalDomain::FUSE:               return "FUSE";
        case RegHalDomain::GLUE:               return "GLUE";
        case RegHalDomain::JTAG:               return "JTAG";
        case RegHalDomain::MINION:             return "MINION";
        case RegHalDomain::NPG:                return "NPG";
        case RegHalDomain::NPORT:              return "NPORT";
        case RegHalDomain::NTL:                return "NTL";
        case RegHalDomain::LWLDL:              return "LWLDL";
        case RegHalDomain::LWLCPR:             return "LWLCPR";
        case RegHalDomain::LWLDL_MULTI:        return "LWLDL_MULTI";
        case RegHalDomain::LWLIPT:             return "LWLIPT";
        case RegHalDomain::LWLIPT_LNK:         return "LWLIPT_LNK";
        case RegHalDomain::LWLIPT_LNK_MULTI:   return "LWLIPT_LNK_MULTI";
        case RegHalDomain::LWLPLL:             return "LWLPLL";
        case RegHalDomain::LWLTLC:             return "LWLTLC";
        case RegHalDomain::LWLTLC_MULTI:       return "LWLTLC_MULTI";
        case RegHalDomain::LWLW:               return "LWLW";
        case RegHalDomain::PHY:                return "PHY";
        case RegHalDomain::PMGR:               return "PMGR";
        case RegHalDomain::RAW:                return "RAW";
        case RegHalDomain::SAW:                return "SAW";
        case RegHalDomain::SIOCTRL:            return "SIOCTRL";
        case RegHalDomain::SWX:                return "SWX";
        case RegHalDomain::SWX_PERFMON:        return "SWX_PERFMON";
        case RegHalDomain::XP3G:               return "XP3G";
        case RegHalDomain::XVE:                return "XVE";
        case RegHalDomain::RUNLIST:            return "RUNLIST";
        case RegHalDomain::CHRAM:              return "CHRAM";
        case RegHalDomain::PCIE:               return "PCIE";
        case RegHalDomain::XTL:                return "XTL";
        case RegHalDomain::XPL:                return "XPL";
        case RegHalDomain::CLKS_P0:            return "CLKS_P0";
        default:                               break;
    }
    return "UNKNOWN";
}

//--------------------------------------------------------------------
// Internal function for looking up a register address in the HAL
//   MASSERT if the register is not supported.
//
const RegHalTable::HalData *RegHalTable::LookupOrDie
(
    ModsGpuRegAddress address,
    ArrayIndexes      arrayIndexes
) const
{
    const HalData *pHalData;
    if (!TryLookup(address, arrayIndexes, &pHalData))
    {
        string desc;
        const char *pName = ColwertToString(address);
        if (pName)
            desc = Utility::StrPrintf(" (%s)", pName);
        Printf(Tee::PriError,
               "Invalid register 0x%x%s specified for this GPU\n",
               static_cast<UINT32>(address), desc.c_str());
        MASSERT(!"Invalid register specified for this GPU");
    }
    return pHalData;
}

//--------------------------------------------------------------------
// Internal function for looking up a register field in the HAL
//   MASSERT if the field is not supported.  Return the field in
// *pHiBit and *pLoBit; for example, a field 7:3 would get returned as
// *pHiBit=7 *pLoBit=3.
//
void RegHalTable::LookupOrDie
(
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT32 *pHiBit,
    UINT32 *pLoBit
) const
{
    if (!TryLookup(field, indexes, pHiBit, pLoBit))
    {
        string desc;
        const char *pName = ColwertToString(field);
        if (pName)
            desc = Utility::StrPrintf(" (%s)", pName);
        Printf(Tee::PriError,
               "Invalid register field 0x%x%s specified for this GPU\n",
               static_cast<UINT32>(field), desc.c_str());
        MASSERT(!"Invalid register field specified for this GPU");
    }
}

//--------------------------------------------------------------------
// Internal function for looking up a register value in the HAL
//   MASSERT if the value is not supported.
//
UINT32 RegHalTable::LookupOrDie
(
    ModsGpuRegValue value,
    ArrayIndexes indexes
) const
{
    UINT32 regValue;
    if (!TryLookup(value, indexes, &regValue))
    {
        string desc;
        const char *pName = ColwertToString(value);
        if (pName)
            desc = Utility::StrPrintf(" (%s)", pName);
        Printf(Tee::PriError,
               "Invalid register value 0x%x%s specified for this GPU\n",
               static_cast<UINT32>(value), desc.c_str());
        MASSERT(!"Invalid register value specified for this GPU");
    }
    return regValue;
}

//--------------------------------------------------------------------
//! Internal function to look up a register address in the HAL
//! Return false if the register is not supported.  On success, store
//! the address data in **ppHalData.
//!
bool RegHalTable::TryLookup
(
    ModsGpuRegAddress address,
    ArrayIndexes      arrayIndexes,
    const RegHalTable::HalData **ppHalData
) const
{
    MASSERT(m_Initialized);
    MASSERT((static_cast<UINT32>(address) & MODS_REGISTER_ADDRESS) != 0);
    MASSERT(ppHalData != nullptr);
    MASSERT(arrayIndexes.size() <= MAX_INDEXES);

    static const HalData badData = { 0xdeadbeef, RegHalDomain::RAW };

    array<UINT16, MAX_INDEXES> arrayIndexes2 = {};
    for (UINT32 ii = 0; ii < arrayIndexes.size(); ++ii)
    {
        MASSERT(arrayIndexes[ii] < 0x10000);
        if (arrayIndexes[ii] >= 0x10000)
        {
            Printf(Tee::PriError,
                   "Out of bounds register index specified - %u\n",
                   arrayIndexes[ii]);
            *ppHalData = &badData;
            return false;
        }
        arrayIndexes2[ii] = static_cast<UINT16>(arrayIndexes[ii]);
    }

    const HalKey key = { static_cast<UINT32>(address), arrayIndexes2 };
    const HalTable::const_iterator findIt = m_pHalTable->find(key);
    if (findIt == m_pHalTable->end())
    {
        *ppHalData = &badData;
        return false;
    }
    *ppHalData = &findIt->second;
    return true;
}

//--------------------------------------------------------------------
// Internal function for looking up a register field in the HAL
// Return false if the field is not supported.  On success, store the
// field in *pHiBit and *pLoBit; for example, a field 7:3 would get
// returned as *pHiBit=7 *pLoBit=3.
//
bool RegHalTable::TryLookup
(
    ModsGpuRegField field,
    ArrayIndexes indexes,
    UINT32 *pHiBit,
    UINT32 *pLoBit
) const
{
    MASSERT(m_Initialized);
    MASSERT((static_cast<UINT32>(field) & MODS_REGISTER_FIELD) != 0);
    MASSERT(pHiBit != nullptr);
    MASSERT(pLoBit != nullptr);

    *pHiBit = 0xdeadbeef;
    *pLoBit = 0xdeadbeef;

    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    LookupArrayIndexes(field, indexes, &addressIndexes, &fieldIndexes);
    if (indexes.size() > 0 && addressIndexes.size() == 0 && fieldIndexes.size() == 0)
    {
        return false;
    }
    array<UINT16, MAX_INDEXES> arrayIndexes = {};
    for (UINT32 ii = 0; ii < fieldIndexes.size(); ++ii)
    {
        MASSERT(fieldIndexes[ii] < 0x10000);
        if (fieldIndexes[ii] >= 0x10000)
        {
            Printf(Tee::PriError,
                   "Out of bounds register index specified - %u\n",
                   fieldIndexes[ii]);
            return false;
        }
        arrayIndexes[ii] = static_cast<UINT16>(fieldIndexes[ii]);
    }

    const HalKey key = { static_cast<UINT32>(field), arrayIndexes };
    const HalTable::const_iterator findIt = m_pHalTable->find(key);
    if (findIt == m_pHalTable->end())
    {
        return false;
    }
    *pHiBit = findIt->second.regData >> 16;
    *pLoBit = findIt->second.regData & 0xFFFFU;
    return true;
}

//--------------------------------------------------------------------
// Internal function for looking up a register value in the HAL
//   MASSERT if the value is not supported.
//
bool RegHalTable::TryLookup
(
    ModsGpuRegValue value,
    ArrayIndexes indexes,
    UINT32 *pValue
) const
{
    MASSERT(m_Initialized);
    MASSERT((static_cast<UINT32>(value) & MODS_REGISTER_VALUE) != 0);
    MASSERT(pValue != nullptr);

    *pValue = 0xdeadbeef;

    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    ArrayIndexes_t valueIndexes;
    LookupArrayIndexes(value, indexes, &addressIndexes, &fieldIndexes, &valueIndexes);
    if (indexes.size() > 0 && addressIndexes.size() == 0 &&
                              fieldIndexes.size() == 0 &&
                              valueIndexes.size() == 0)
    {
        return false;
    }
    array<UINT16, MAX_INDEXES> arrayIndexes = {};
    for (UINT32 ii = 0; ii < valueIndexes.size(); ++ii)
    {
        MASSERT(valueIndexes[ii] < 0x10000);
        if (valueIndexes[ii] >= 0x10000)
        {
            Printf(Tee::PriError,
                   "Out of bounds register index specified - %u\n",
                   valueIndexes[ii]);
            return false;
        }
        arrayIndexes[ii] = static_cast<UINT16>(valueIndexes[ii]);
    }

    const HalKey key = { static_cast<UINT32>(value), arrayIndexes };
    const HalTable::const_iterator findIt = m_pHalTable->find(key);
    if (findIt == m_pHalTable->end())
    {
        return false;
    }
    *pValue = findIt->second.regData;
    return true;
}

//-----------------------------------------------------------------------------
// Split the array indices into those used by the address and those used
// by the field.
//
// The address tries to greedily use as many of the indices as possible and
// gradually attempts to use fewer and fewer until it returns successfully
// with a set of indicies. If the address can't use any of the indices,
// then it is assumed that they are all meant for the field instead.
//
void RegHalTable::LookupArrayIndexes
(
    ModsGpuRegField field,
    ArrayIndexes indexes,
    ArrayIndexes_t* pAddressIndexes,
    ArrayIndexes_t* pFieldIndexes
) const
{
    MASSERT(pAddressIndexes);
    MASSERT(pFieldIndexes);

    ArrayIndexes_t addressIndexes;
    for (auto arrayOffset = indexes.end(); /*arrayOffset >= indexes.begin()*/; arrayOffset--)
    {
        addressIndexes.assign(indexes.begin(), arrayOffset);
        if (addressIndexes.size() > MAX_INDEXES)
            continue;
        if (IsSupported(ColwertToAddress(field), addressIndexes))
        {
            pAddressIndexes->assign(addressIndexes.begin(), addressIndexes.end());
            pFieldIndexes->assign(arrayOffset, indexes.end());
            return;
        }
        if (arrayOffset == indexes.begin())
            break;
    }
}

//-----------------------------------------------------------------------------
// Split the array indices into those used by the address, the field,
// and the value.
//
// Similar to the algorithm above.
//
void RegHalTable::LookupArrayIndexes
(
    ModsGpuRegValue value,
    ArrayIndexes indexes,
    ArrayIndexes_t* pAddressIndexes,
    ArrayIndexes_t* pFieldIndexes,
    ArrayIndexes_t* pValueIndexes
) const
{
    MASSERT(pAddressIndexes);
    MASSERT(pFieldIndexes);
    MASSERT(pValueIndexes);

    ArrayIndexes_t addressIndexes;
    ArrayIndexes_t fieldIndexes;
    for (auto fieldOffset = indexes.end(); /*fieldOffset >= indexes.begin()*/; fieldOffset--)
    {
        addressIndexes.assign(indexes.begin(), fieldOffset);
        if (addressIndexes.size() > MAX_INDEXES)
            continue;
        if (IsSupported(ColwertToAddress(value), addressIndexes))
        {
            for (auto valueOffset = indexes.end(); /*valueOffset >= indexes.begin()*/; valueOffset--)
            {
                fieldIndexes.assign(indexes.begin(), valueOffset);
                if (fieldIndexes.size() > MAX_INDEXES)
                    continue;
                if (IsSupported(ColwertToField(value), fieldIndexes))
                {
                    pAddressIndexes->assign(indexes.begin(), fieldOffset);
                    pFieldIndexes->assign(fieldOffset, valueOffset);
                    pValueIndexes->assign(valueOffset, indexes.end());
                    return;
                }
                if (valueOffset == fieldOffset)
                    break;
            }
        }
        if (fieldOffset == indexes.begin())
            break;
    }
}

const RegHalTable::CapabilityData* RegHalTable::LookupCapabilityId
(
    ModsGpuRegValue capabilityId
) const
{
    MASSERT(m_Initialized);

    if (capabilityId == MODS_REGISTER_VALUE_NULL)
    {
        return nullptr;
    }
    else
    {
        const auto iter = m_pCapabilityTable->find(capabilityId);
        if (iter != m_pCapabilityTable->end())
        {
            return &iter->second;
        }
        else if (!m_pCapabilityTable->empty())
        {
            return nullptr;
        }
    }

    set<ModsGpuRegValue> capIds;
    for (const auto& iter: *m_pHalTable)
    {
        if (iter.second.capabilityId != MODS_REGISTER_VALUE_NULL)
        {
            capIds.insert(iter.second.capabilityId);
        }
    }

    map<RegHalDomain, map<UINT32, UINT32>> capAddrs;
    map<RegHalDomain, map<UINT32, UINT32>> extCapAddrs;
    for (const ModsGpuRegValue capId: capIds)
    {
        const HalKey addrKey = { static_cast<UINT32>(ColwertToAddress(capId)) };
        const HalKey fieldKey = { static_cast<UINT32>(ColwertToField(capId)) };
        const HalKey valueKey = { static_cast<UINT32>(capId) };
        const HalTable::const_iterator pAddr  = m_pHalTable->find(addrKey);
        const HalTable::const_iterator pField = m_pHalTable->find(fieldKey);
        const HalTable::const_iterator pValue = m_pHalTable->find(valueKey);
        if (pAddr  == m_pHalTable->end() ||
            pField == m_pHalTable->end() ||
            pValue == m_pHalTable->end())
        {
            const char* pName = ColwertToString(capId);
            const string desc = pName ? Utility::StrPrintf(" (%s)", pName) : "";
            Printf(Tee::PriError,
                   "Cannot find cap id 0x%x%s in reghal.def\n",
                   static_cast<UINT32>(capId), desc.c_str());
            MASSERT(!"Cannot find -cap in reghal.def");
            continue;
        }

        const UINT32       hwrefAddress = pAddr->second.regData;
        const RegHalDomain domain       = pAddr->second.domain;
        const UINT32       capIdField   = pField->second.regData;
        const UINT32       capIdNumber  = pValue->second.regData;

        const bool extended = (capIdField ==
                               MODS_FIELD_RANGE(PCIE_EXT_HDR_CAP_ID));
        if (!extended && capIdField != MODS_FIELD_RANGE(PCIE_CAP_HDR_CAP_ID))
        {
            const char* pName = ColwertToString(capId);
            const string desc = pName ? Utility::StrPrintf(" (%s)", pName) : "";
            Printf(Tee::PriError,
                   "In reghal.def, 0x%x%s is not a cap id or extended cap id\n",
                   static_cast<UINT32>(capId), desc.c_str());
            MASSERT(!"Bad -cap in reghal.def");
            continue;
        }

        if (extended)
        {
            if (extCapAddrs.count(domain) == 0)
            {
                UINT32 headerData = 0;
                set<UINT32> headerAddrsSeen;
                for (UINT32 headerAddr = PCIE_EXT_HDR;
                     headerAddr != 0;
                     headerAddr = REF_VAL(PCIE_EXT_HDR_NEXT_PTR, headerData))
                {
                    if (headerAddr > 0 && headerAddr < PCIE_EXT_HDR)
                    {
                        Printf(Tee::PriWarn,
                               "Bad addr in extended capability header 0x%03x\n",
                               headerAddr);
                        break;
                    }
                    else if (headerAddrsSeen.count(headerAddr) != 0)
                    {
                        Printf(Tee::PriWarn,
                               "Infinite loop in extended capability header\n");
                        break;
                    }
                    headerData = ReadCapability32(domain, headerAddr);
                    const UINT32 headerCapId = REF_VAL(PCIE_EXT_HDR_CAP_ID,
                                                       headerData);
                    if (headerCapId != 0)
                    {
                        extCapAddrs[domain][headerCapId] = headerAddr;
                    }
                    headerAddrsSeen.insert(headerAddr);
                }
            }
            const auto pAddr = extCapAddrs[domain].find(capIdNumber);
            if (pAddr != extCapAddrs[domain].end())
            {
                CapabilityData newEntry;
                newEntry.hwrefAddress = hwrefAddress;
                newEntry.actualAddress = pAddr->second;
                (*m_pCapabilityTable)[capId] = newEntry;
            }
        }
        else
        {
            if (capAddrs.count(domain) == 0)
            {
                UINT32 headerData = ReadCapability32(domain, PCIE_CAP_LIST);
                set<UINT32> headerAddrsSeen;
                for (UINT32 headerAddr = REF_VAL(PCIE_CAP_LIST_CAP_PTR,
                                                 headerData);
                     headerAddr != 0;
                     headerAddr = REF_VAL(PCIE_CAP_HDR_NEXT_PTR, headerData))
                {
                    if (headerAddrsSeen.count(headerAddr) != 0)
                    {
                        Printf(Tee::PriWarn,
                               "Infinite loop in capability header\n");
                        break;
                    }
                    headerData = ReadCapability32(domain, headerAddr);
                    const UINT32 headerCapId = REF_VAL(PCIE_CAP_HDR_CAP_ID,
                                                       headerData);
                    capAddrs[domain][headerCapId] = headerAddr;
                    headerAddrsSeen.insert(headerAddr);
                }
            }
            const auto pAddr = capAddrs[domain].find(capIdNumber);
            if (pAddr != capAddrs[domain].end())
            {
                CapabilityData newEntry;
                newEntry.hwrefAddress = hwrefAddress;
                newEntry.actualAddress = pAddr->second;
                (*m_pCapabilityTable)[capId] = newEntry;
            }
        }
    }

    m_pCapabilityTable->emplace(MODS_REGISTER_VALUE_NULL, CapabilityData());

    const auto iter2 = m_pCapabilityTable->find(capabilityId);
    return (iter2 != m_pCapabilityTable->end()) ? &iter2->second : nullptr;
}

UINT32 RegHalTable::ReadCapability32(RegHalDomain domain, UINT32 addr) const
{
    return 0;
}
