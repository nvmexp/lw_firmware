/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2016,2019 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#include "gputest.h"
#include "core/include/platform.h"
#include "core/include/jscript.h"
#include "core/include/utility.h"
#include "gpu/include/gpudev.h"
#include "core/include/rc.h"
#include "gpu/include/displaycleanup.h"
#include "random.h"

// based on   // hw/doc/gpu/display/GPUDisplay/2.6/specfications/GP10x_MIO_loopback.docx

/*
    PIOR_LOOPBACK_CONTROL
   ---------------------

    Program sequence:
    1. Set CONTROL.MODE to ENABLE;
    2. Program CONTROL.RUN_MODE, RASTER_TIMING.HEIGHT, RASTER_TIMING.WIDTH
    ACTIVE_TIMING.HEIGHT, ACTIVE_TIMING.WIDTH and TEST_pat0/1/2/3.
    3. Program CONTROL.RUN to kick MIO loopback.
    4. Check the ERROR_CHK* register for final result. If the field is non-zero,
    there is something wrong happening on corresponding bit.
    5. Clear the ERROR_CHK* register for next running by setting CONTROL.ERRCHK_CLEAR
    to TRIGGER or exiting loopback mode (set CONTROL.MODE to DISABLE).

    PIOR_LOOPBACK_RASTER_TIMING
   ---------------------

    This register is used to create raster timing for loopback for SLI
    HEIGHT
    use this field for height of raster
    WIDTH
    use this field for width of raster

    PIOR_LOOPBACK_ACTIVE_TIMING
   ---------------------

    This register is used to create active timing for loopback for SLI
    HEIGHT
    use this field for height of active range
    WIDTH
    use this field for width of active range

    PIOR_LOOPBACK_TEST_pat0/1/2/3
   ---------------------
    We have 4 test pat registers for SW fill specified test pat for loopback test.
    the test pats are sent as following sequence: TP0, TP1, TP2, TP3, TP0, TP1, ...

    This register is used to create test pat0-1-2-3 for MIO loopback
    LO
    use this field to fill LO data
    HI
    use this field to fill HI data
    note that:
    LW_PDISP_PIOR_LOOPBACK_TEST_pat(0/1/2/3)__SIZE_1 is fixed to 4

    PIOR_LOOPBACK_PRBS_SEEDS
   ---------------------
    This register is used to set PRBS(Pseudo-Random Binary Sequence) Seed.
    VALUE
    use this field to set PRBS Seed.
    To avoid the PRBS stays at 0, set initial value is non-zero value.

    PIOR_LOOPBACK_ERROR_CHK
   ---------------------

    This register is used to check per bit error for loopback for SLI
    The register is Read-Only.
    The bits are used to record how many errors oclwrred in corresponding bit,
    The counters are cleared when the loopback is kicked off by setting
    CONTROL.ERRCNT_CLEAR to TRIGGER or exiting loopback mode.
    D0~DE is used to check bit0 to bit14,
    The maximum error count is 15. When the counter reaches 15,
    it stays at 15 until cleared by the CONTROL.ERROR_CLEAR bit.
    DNB is used to check new buf bit.
    The new buf bit always asserts at 1st pixel of last line in every frame.
    This bit checks whether the assert is correct.
    DFP is used to check first pix bit.
    The first pix bit always asserts at 1st pixel of 1nd line in every frame.
    This bit will check whether the assert is correct.

    PIOR_LOOPBACK_STATUS
   ---------------------

    This register is used to check per bit error for loopback for SLI
    The register is Read-Only.
    The fields are used to record how many errors oclwrred in corresponding bit,
    The counters are cleared when the loopback is kicked off by setting
    CONTROL.ERRCNT_CLEAR to TRIGGER or exiting loopback mode.
    D0~DE is used to check bit0 to bit14,
    The maxium error count is 15, that is, when the counter reaches 15,
    and it will stay at 15 until cleared by CONTROL.ERROR_CLEAR bit.
    DNB is used to check new buf bit.
    The new buf bit always asserts at 1st pixel of last line in every frame.
    This bit will check whether the assert is correct.
    DFP is used to check first pix bit.
    The first pix bit always asserts at 1st pixel of 2nd line in every frame.
    This bit will check whether the assert is correct.

    In the loopback Gen module, the raster will be generated by setting RASTER_TIMING, ACTIVE_TIMING.
    The pat on the path could be filled by either PRBS with programming seeds or programmed test
    pat. The pat will be used by Loopback Checker as golden data

*/

class SliLoopback: public GpuTest
{
public:
    SliLoopback();
    bool IsSupported();
    RC Setup();
    RC Run();
    SETGET_PROP(RasterWd, UINT32);
    SETGET_PROP(ActiveWd, UINT32);
    SETGET_PROP(RasterHt, UINT32);
    SETGET_PROP(ActiveHt, UINT32);
    SETGET_PROP(TestMioIndex, UINT08);
    SETGET_PROP(TestMioPinSet, UINT08);
    SETGET_PROP(OverrideDisplayId, UINT32);
    SETGET_PROP(OverridePclkHz, UINT32);
private:
    enum Runmode {CONTINUOUS, ONESHOT};
    enum Mios {MIOA = 1, MIOB = 2};
    enum MioPinSet {DISABLE = 0, A = 1, B = 2, AB = 3};
    enum DqPins{NUMDQPINS = 15};
    struct
    {
        UINT32 width;
        UINT32 height;
        UINT32 depth;
        UINT32 refreshRate;
    } m_Mode = {};
    EvoRasterSettings m_Ers;
    UINT32 m_PrbsSeed;
    UINT32 m_RasterWd, m_RasterHt;
    UINT32 m_ActiveWd, m_ActiveHt;
    bool m_ShallowLoopback; // if false (test deep), true (test shallowlbk)
    UINT08 m_TestMioIndex; // MIOA|MIOB
    UINT08 m_TestMioPinSet; // pinsetA or PinSetB, pinSetAB is invalid
    UINT08 m_NumTestFrames;
    GpuTestConfiguration *  m_pTestConfig;
    UINT32 m_OverrideDisplayId;
    UINT32 m_OverridePclkHz;
    UINT32 m_PinErrors[NUMDQPINS];
    UINT32 m_FailingIterations;
    struct MioLoopBackRegisterState
    {
        UINT32 activeOrIdx;
        UINT32 piorOutputPort;
        UINT32 piorInputPort;
        UINT32 valPmgrPadMioInput;
        UINT32 valPmgrPadMioSpare;
        UINT32 testDisplayId;
        bool   loopbackCtrlMode;
        bool   dispEnableLoopback;
    } m_InitContext = {};
    RC SetMIOLoopBackRegisterStates(MioLoopBackRegisterState regState);

    UINT32 GetPIOROutputPort(UINT32 piorIdx);
    void SetPIOROutputPort(UINT32 piorIdx, UINT32 port);
    UINT32 GetPIORInputPort(UINT32 piorIdx);
    void SetPIORInputPort(UINT32 piorIdx, UINT32 port);
    bool GetPIORLoopbackCtrlMode(UINT32 piorIdx);
    RC SetPIORLoopbackCtrlMode(UINT32 piorIdx, bool enable);
    UINT32 GetPmgrPadMioSpare(UINT32 pioridx);
    void SetPmgrPadMioSpare(UINT32 val, UINT32 pioridx);
    UINT32 GetPmgrPadMioInput(UINT32 oridx);
    void SetPmgrPadMioInput(UINT32 val, UINT32 oridx);

    RC TurnOnPadDroClk
    (
        UINT32 piorIdx,
        UINT32 activeHt, UINT32 activeWd,
        UINT32 rasterHt, UINT32 rasterWd
    );
    RC RxCountReset(UINT32 piorIdx, UINT32 *pfailures);

    void StartMioLoopbackOneShot(UINT32 piorIdx);
    void StartMioLoopbackContinuous(UINT32 piorIdx);

    RC PollLoopbackRunStop(UINT32 piorIdx);
    RC PollLoopbackStatusFrameCount(UINT32 framecount, UINT32 piorIdx);
    RC PollLoopbackCtlClear(UINT32 piorIdx);
    RC WriteMIOLoopbackPrbsSeed(UINT32 seedValue, UINT32 piorIdx);

    // subtests
    RC RunLoopBack(GpuSubdevice *pSub, UINT32 piorIdx, Runmode mode);
    void ReadMIOLoopbackErrorStatus
    (
        bool *pErrDnb,
        bool *pErrDfp,
        UINT32 piorIdx
    );
    void ReportError(UINT32 piorIdx);
};

//------------------------------------------------------------------------------
// Raster timings are picked arbitrarily. No input from HWQA
SliLoopback::SliLoopback():
    m_PrbsSeed(0),
    m_RasterWd(105),
    m_RasterHt(110),
    m_ActiveWd(103),
    m_ActiveHt(105),
    m_ShallowLoopback(true),
    m_TestMioIndex(MIOB),
    m_TestMioPinSet(A),
    m_NumTestFrames(10), // any number E [1, 1<<16). Consider test run time
    m_pTestConfig(nullptr),
    m_OverrideDisplayId(0), // Disabled
    m_OverridePclkHz(0), // Disabled
    m_FailingIterations(0)
{
    SetName("SliLoopback");
}

//------------------------------------------------------------------------------
bool SliLoopback::IsSupported()
{
    if (GetDisplay()->GetNumSLIHeads() < 1)
    {
        //Pinset count is less than 1. Hence, SLI isn't supported
        return false;
    }
    return GetBoundGpuSubdevice()->HasFeature(Device::GPUSUB_SUPPORTS_MIO_LOOPBACK);
}

//------------------------------------------------------------------------------
RC SliLoopback::Setup()
{
    RC rc;
    CHECK_RC(GpuTest::Setup());
    m_pTestConfig = GetTestConfiguration();
    CHECK_RC(GpuTest::AllocDisplay());

    Random random;
    random.SeedRandom(m_pTestConfig->Seed());
    m_PrbsSeed = random.GetRandom(0, _UINT16_MAX);

    /* SetMode is needed to activate PIOR */
    m_Mode.width      = m_pTestConfig->DisplayWidth();
    m_Mode.height     = m_pTestConfig->DisplayHeight();
    m_Mode.depth      = m_pTestConfig->DisplayDepth();
    m_Mode.refreshRate= m_pTestConfig->RefreshRate();

    /* Prepare raster */
    m_Ers.RasterWidth  = m_Mode.width + 10;
    m_Ers.ActiveX      = m_Mode.width;
    m_Ers.SyncEndX     = 1;
    m_Ers.BlankStartX  = m_Mode.width + 1;
    m_Ers.BlankEndX    = m_Ers.SyncEndX;
    m_Ers.PolarityX    = false;
    m_Ers.RasterHeight = m_Mode.height + 10;
    m_Ers.ActiveY      = m_Mode.height;
    m_Ers.SyncEndY     = 1;
    m_Ers.BlankStartY  = m_Mode.height + 1;
    m_Ers.BlankEndY    = m_Ers.SyncEndY;
    m_Ers.PolarityY    = false;
    m_Ers.Interlaced   = false;
    m_Ers.PixelClockHz = m_Ers.RasterWidth * m_Ers.RasterHeight * m_Mode.refreshRate;

    return OK;
}

//------------------------------------------------------------------------------
RC SliLoopback::SetMIOLoopBackRegisterStates(MioLoopBackRegisterState regState)
{
    Display *pDisplay = GetDisplay();
    RC rc;
    UINT32 piorIdx = regState.activeOrIdx;
    SetPIOROutputPort(piorIdx, regState.piorOutputPort);
    SetPIORInputPort(piorIdx, regState.piorInputPort);
    SetPmgrPadMioSpare(regState.valPmgrPadMioSpare, piorIdx);
    SetPmgrPadMioInput(regState.valPmgrPadMioInput, piorIdx);
    CHECK_RC(SetPIORLoopbackCtrlMode(piorIdx, regState.loopbackCtrlMode));
    CHECK_RC(pDisplay->EnablePiorLoopback(
                    regState.testDisplayId,
                    regState.dispEnableLoopback));
    return rc;
}

//------------------------------------------------------------------------------
UINT32 SliLoopback::GetPIORInputPort
(
    UINT32 piorIdx
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    return regs.Read32(MODS_PDISP_PIOR_IN_PIN_SET, piorIdx);
}

//------------------------------------------------------------------------------
UINT32 SliLoopback::GetPIOROutputPort
(
    UINT32 piorIdx
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    return regs.Read32(MODS_PDISP_PIOR_OUT_PIN_SET, piorIdx);
}

//------------------------------------------------------------------------------
void SliLoopback::SetPIOROutputPort
(
    UINT32 piorIdx, // mio index
    UINT32 port // pinset from assigned mio
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    switch (port)
    {
        case A:
            regs.Write32(MODS_PDISP_PIOR_OUT_PIN_SET_A, piorIdx);
            break;
        case B:
            regs.Write32(MODS_PDISP_PIOR_OUT_PIN_SET_B, piorIdx);
            break;
        default:
            regs.Write32(MODS_PDISP_PIOR_OUT_PIN_SET_NONE, piorIdx);
            break;
    }
}

//------------------------------------------------------------------------------
void SliLoopback::SetPIORInputPort
(
    UINT32 piorIdx,
    UINT32 port
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    switch (port)
    {
        case A:
            regs.Write32(MODS_PDISP_PIOR_IN_PIN_SET_A, piorIdx);
            break;
        case B:
            regs.Write32(MODS_PDISP_PIOR_IN_PIN_SET_B, piorIdx);
            break;
        default:
            regs.Write32(MODS_PDISP_PIOR_IN_PIN_SET_NONE, piorIdx);
            break;
    }
}

//------------------------------------------------------------------------------
bool SliLoopback::GetPIORLoopbackCtrlMode(UINT32 piorIdx)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    return regs.Test32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_MODE_ENABLE, piorIdx);
}

//------------------------------------------------------------------------------
RC SliLoopback::SetPIORLoopbackCtrlMode
(
    UINT32 piorIdx,
    bool enableCtrlMode
)
{
    RC rc;
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    ModsGpuRegValue regWrVal = enableCtrlMode ?
        MODS_PDISP_PIOR_LOOPBACK_CONTROL_MODE_ENABLE :
        MODS_PDISP_PIOR_LOOPBACK_CONTROL_MODE_DISABLE ;
    pSub->Regs().Write32(regWrVal, piorIdx);
    CHECK_RC(pSub->PollGpuRegValue(
                regWrVal,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));
    return rc;
}

//------------------------------------------------------------------------------
UINT32 SliLoopback::GetPmgrPadMioSpare(UINT32 piorIdx)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    if (piorIdx == MIOA)
    {
        return regs.Read32(MODS_PMGR_PAD_MIOA_SPARE);
    }
    else if (piorIdx == MIOB)
    {
        return regs.Read32(MODS_PMGR_PAD_MIOB_SPARE);
    }
    else
    {
        MASSERT(0);
        Printf(Tee::PriError, "Unsupported Pior index\n");
        return 0; // init value
    }
}

//------------------------------------------------------------------------------
void SliLoopback::SetPmgrPadMioSpare(UINT32 spareVal, UINT32 piorIdx)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    if (piorIdx == MIOA)
    {
        regs.Write32(MODS_PMGR_PAD_MIOA_SPARE, spareVal);
    }
    else if (piorIdx == MIOB)
    {
        regs.Write32(MODS_PMGR_PAD_MIOB_SPARE, spareVal);
    }
    else
    {
        Printf(Tee::PriError, "Unsupported Pior index\n");
        MASSERT(0);
    }
}

//------------------------------------------------------------------------------
UINT32 SliLoopback::GetPmgrPadMioInput(UINT32 piorIdx)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    if (piorIdx == MIOA)
    {
        return regs.Read32(MODS_PMGR_POWERCTRL_5_MIOA_PAD_INPUT_RCV);
    }
    else if (piorIdx == MIOB)
    {
        return regs.Read32(MODS_PMGR_POWERCTRL_5_MIOB_PAD_INPUT_RCV);
    }
    else
    {
        Printf(Tee::PriError, "Unsupported Pior index\n");
        MASSERT(0);
        return _UINT32_MAX;
    }
}

//------------------------------------------------------------------------------
void SliLoopback::SetPmgrPadMioInput(UINT32 mioPadInputRcv, UINT32 piorIdx)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    if (piorIdx == MIOA)
    {
        regs.Write32(MODS_PMGR_POWERCTRL_5_MIOA_PAD_INPUT_RCV, mioPadInputRcv);
    }
    else if (piorIdx == MIOB)
    {
        regs.Write32(MODS_PMGR_POWERCTRL_5_MIOB_PAD_INPUT_RCV, mioPadInputRcv);
    }
    else
    {
        Printf(Tee::PriError, "Unsupported Pior index\n");
        MASSERT(0);
    }
}

//------------------------------------------------------------------------------
RC SliLoopback::TurnOnPadDroClk
(
    UINT32 piorIdx,
    UINT32 activeHt, UINT32 activeWd,
    UINT32 rasterHt, UINT32 rasterWd
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    RC rc;
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_RASTER_TIMING_HEIGHT,
            piorIdx,
            rasterHt);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_RASTER_TIMING_WIDTH,
            piorIdx,
            rasterWd);

    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_ACTIVE_TIMING_HEIGHT,
            piorIdx,
            activeHt);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_ACTIVE_TIMING_WIDTH,
            piorIdx,
            activeWd);

    Printf(Tee::PriDebug, "Trigger loopback one-shot to run\n");
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_MODE_ONE_SHOT);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_START);

    Printf(Tee::PriDebug, "Polling LW_PDISP_PIOR_LOOPBACK_CONTROL_RUN for _STOP\n");
    CHECK_RC(PollLoopbackRunStop(piorIdx));
    Printf(Tee::PriDebug, "Done Polling LW_PDISP_PIOR_LOOPBACK_CONTROL_RUN\n");

    Printf(Tee::PriDebug,
            "Polling LW_PDISP_PIOR_LOOPBACK_STATUS_FRAME_CNT for non-zero\n");
    CHECK_RC(PollLoopbackStatusFrameCount(1, piorIdx));
    Printf(Tee::PriDebug,
            "Done Polling LW_PDISP_PIOR_LOOPBACK_STATUS_TX_FRAME_CNT\n");

    UINT32 ctrlRunModeContinuous =
        regs.Read32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx);
    regs.SetField(&ctrlRunModeContinuous,
            MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_MODE_CONTINUOUS);
    regs.SetField(&ctrlRunModeContinuous,
            MODS_PDISP_PIOR_LOOPBACK_CONTROL_TX_STATUS_CLEAR_TRIGGER);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx, ctrlRunModeContinuous);

    CHECK_RC(PollLoopbackCtlClear(piorIdx));
    Printf(Tee::PriDebug,
            "Poll done for _STATUS_CLEAR to be _DONE and clear RUN_MODE to _CONTINUOUS\n");
    return rc;
}

//------------------------------------------------------------------------------
RC SliLoopback::RxCountReset(UINT32 piorIdx, UINT32 *pFailures)
{
    RC rc;
    MASSERT(pFailures);
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    RegHal &regs = pSub->Regs();

    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_RXCNT_CLEAR_TRIGGER, piorIdx);
    CHECK_RC(pSub->PollGpuRegValue(
                MODS_PDISP_PIOR_LOOPBACK_CONTROL_RXCNT_CLEAR_DONE,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));

    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_ERRCHK_CLEAR_TRIGGER, piorIdx);
    CHECK_RC(pSub->PollGpuRegValue(
                MODS_PDISP_PIOR_LOOPBACK_CONTROL_ERRCHK_CLEAR_DONE,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));

    if (regs.Read32(MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0, piorIdx) > 0)
    {
        *pFailures = (*pFailures) + 1;
    }
    if (regs.Read32(MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1, piorIdx) > 0)
    {
        *pFailures = (*pFailures) + 1;
    }
    return rc;
}

//------------------------------------------------------------------------------
void SliLoopback::StartMioLoopbackOneShot(UINT32 orIdx)
{
    // Send One frame
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_MODE_ONE_SHOT, orIdx);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_START, orIdx);
}

//------------------------------------------------------------------------------
void SliLoopback::StartMioLoopbackContinuous(UINT32 piorIdx)
{
    UINT32 loopbackReg = 0;
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    loopbackReg = regs.Read32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx);
    regs.SetField(&loopbackReg,
            MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_MODE_CONTINUOUS);
    regs.SetField(&loopbackReg,
            MODS_PDISP_PIOR_LOOPBACK_CONTROL_TX_STATUS_CLEAR_TRIGGER);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx, loopbackReg);
}

//------------------------------------------------------------------------------
RC SliLoopback::PollLoopbackRunStop
(
    UINT32 piorIdx
)
{
    RC rc;
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    CHECK_RC(pSub->PollGpuRegValue(
                MODS_PDISP_PIOR_LOOPBACK_CONTROL_RUN_STOP,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));
    return rc;
}

//------------------------------------------------------------------------------
RC SliLoopback::PollLoopbackStatusFrameCount
(
    UINT32 expectedFrameCnt,
    UINT32 piorIdx
)
{
    RC rc;
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    CHECK_RC(pSub->PollGpuRegFieldGreaterOrEqual(
                MODS_PDISP_PIOR_LOOPBACK_STATUS_TX_FRAME_CNT,
                piorIdx,
                expectedFrameCnt,
                Tasker::GetDefaultTimeoutMs()));
    return rc;
}

//------------------------------------------------------------------------------
RC SliLoopback::PollLoopbackCtlClear
(
    UINT32 piorIdx
)
{
    RC rc;
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    Printf(Tee::PriDebug, "RunStop Register in the beginning 0x%x\n",
            pSub->Regs().Read32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx));
    CHECK_RC(pSub->PollGpuRegValue(
                MODS_PDISP_PIOR_LOOPBACK_CONTROL_TX_STATUS_CLEAR_DONE,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));
    Printf(Tee::PriDebug,
            "Poll done for TX_STATUS_CLEAR to be _DONE\n");
    return rc;
}

//------------------------------------------------------------------------------
RC SliLoopback::WriteMIOLoopbackPrbsSeed
(
    UINT32 seedVal,
    UINT32 piorIdx
)
{
    RC rc;
    GpuSubdevice *pSub = GetBoundGpuSubdevice();
    RegHal &regs = pSub->Regs();
    Printf(Tee::PriDebug, "Use PRBS pattern for mio loopback ctrl 0x%x\n",
            regs.Read32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx));

    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_PRBS_SEEDS_VALUE, piorIdx, seedVal);

    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_PRBS_EN_ENABLE, piorIdx);
    regs.Write32(MODS_PDISP_PIOR_LOOPBACK_CONTROL_SET_PRBS_SEED_TRIGGER, piorIdx);

    CHECK_RC(pSub->PollGpuRegValue(
                MODS_PDISP_PIOR_LOOPBACK_CONTROL_SET_PRBS_SEED_DONE,
                piorIdx,
                Tasker::GetDefaultTimeoutMs()));
    Printf(Tee::PriDebug, "after PRBS seed written to  mio loopback ctrl 0x%x\n",
            regs.Read32(MODS_PDISP_PIOR_LOOPBACK_CONTROL, piorIdx));
    return rc;
}

//------------------------------------------------------------------------------
// SLI loopback test function
RC SliLoopback::RunLoopBack(GpuSubdevice *pSub, UINT32 piorIdx, Runmode mode)
{
    MASSERT(pSub);
    RC rc;
    Display *pDisplay = GetDisplay();

    // PIOR overrides
    m_InitContext.activeOrIdx = piorIdx;
    m_InitContext.piorOutputPort = GetPIOROutputPort(piorIdx);
    m_InitContext.piorInputPort = GetPIORInputPort(piorIdx);
    m_InitContext.loopbackCtrlMode = GetPIORLoopbackCtrlMode(piorIdx);
    m_InitContext.dispEnableLoopback = false;
    m_InitContext.valPmgrPadMioInput = GetPmgrPadMioInput(piorIdx);
    m_InitContext.valPmgrPadMioSpare = GetPmgrPadMioSpare(piorIdx);

    Utility::CleanupOnReturnArg<SliLoopback , RC, MioLoopBackRegisterState>
        RestorePiorInputPort (this, &SliLoopback::SetMIOLoopBackRegisterStates, m_InitContext);

    /* Display settings restore*/
    DisplayCleanup::SetModeCleanup
        RestoreMode(pDisplay, m_Mode.width, m_Mode.height, m_Mode.depth, m_Mode.refreshRate);
    Utility::CleanupOnReturnArg<Display, RC, bool>
        UnblockHotPlugEvents(pDisplay, &Display::SetBlockHotPlugEvents, false);
    bool OrigEnableDefaultImage = pDisplay->GetEnableDefaultImage();
    Utility::CleanupOnReturnArg<Display, RC, bool>
        RestoreEnableDefaultImage(pDisplay, &Display::SetEnableDefaultImage, OrigEnableDefaultImage);

    CHECK_RC(pDisplay->SetBlockHotPlugEvents(true));

    SetPIOROutputPort(piorIdx, m_TestMioPinSet);

    CHECK_RC(SetPIORLoopbackCtrlMode(piorIdx, true)); // Enable loopback mode

    // Do Setmode for pixel clock programming
    UINT32 selectedDisplayId = 0;
    UINT32 defaultDisplayId = pDisplay->Selected();
    if (!m_OverrideDisplayId)
    {
        selectedDisplayId = defaultDisplayId;
    }
    else
    {
        selectedDisplayId = m_OverrideDisplayId;
        CHECK_RC(pDisplay->Select(selectedDisplayId));
    }
    m_InitContext.testDisplayId = selectedDisplayId;
    Utility::CleanupOnReturnArg<Display, RC, UINT32>
        RestoreDisplay(pDisplay, &Display::Select, defaultDisplayId);
    // Set a flag in display class which will be checked again at the time of set mode.
    pDisplay->EnablePiorLoopback(selectedDisplayId, true);
    if (m_OverridePclkHz)
    {
        CHECK_RC(pDisplay->SetPixelClock(selectedDisplayId, m_OverridePclkHz));
    }
    else
    {
        Display::MaxPclkQueryInput maxPclkQuery = {selectedDisplayId,
                                                   &m_Ers};
        vector<Display::MaxPclkQueryInput> maxPclkQueryVector(1, maxPclkQuery);

        CHECK_RC(pDisplay->SetRasterForMaxPclkPossible(&maxPclkQueryVector, 0));
    }
    CHECK_RC(pDisplay->SetMode(m_Mode.width, m_Mode.height, m_Mode.depth, m_Mode.refreshRate));

    // clear the RX's h/v_counter which may not be zero due to glitch when attach
    // MIO to Pior
    // setup PAD input enable and PIOR_IN after RM modset which may program
    // such PAD input enable and check PIOR_IN/PIOR_OUT bit
    SetPIOROutputPort(piorIdx, m_TestMioPinSet);
    SetPIORInputPort(piorIdx, m_TestMioPinSet);
    SetPmgrPadMioInput(
            pSub->Regs().LookupValue(MODS_PMGR_POWERCTRL_5_MIOA_PAD_INPUT_RCV_EN),
            piorIdx);
    if (m_ShallowLoopback)
    {
        // spare_bit0 is used for shallow loopback
        SetPmgrPadMioSpare(m_TestMioPinSet, piorIdx);
    }
    CHECK_RC(TurnOnPadDroClk
                (
                 piorIdx,
                 m_ActiveHt,
                 m_ActiveWd,
                 m_RasterHt,
                 m_RasterWd
                 )
            );
    CHECK_RC(RxCountReset(piorIdx, &m_FailingIterations));

    if (mode == ONESHOT)
    {
        CHECK_RC(WriteMIOLoopbackPrbsSeed(m_PrbsSeed, piorIdx));
        // In one-shot mode, the _RUN_ bit is cleared to 0 by HW after 1 cycle
        for (UINT16 frames = 1; frames < m_NumTestFrames; frames++)
        {
            // Send One frame
            StartMioLoopbackOneShot(piorIdx);
            CHECK_RC(PollLoopbackStatusFrameCount(frames, piorIdx)); // Count frame
            // Poll for one frame run to stop
            CHECK_RC(PollLoopbackRunStop(piorIdx));
        }
    }
    else
    {
        // mode == CONTINUOUS
        StartMioLoopbackContinuous(piorIdx);
        CHECK_RC(PollLoopbackCtlClear(piorIdx)); // Count frame
    }

    return rc;
}

//------------------------------------------------------------------------------
// Fill up per DQ pin error count read from error check registers
void SliLoopback::ReadMIOLoopbackErrorStatus
(
    bool *pErrDnb,
    bool *pErrDfp,
    UINT32 piorIdx
)
{
    RegHal &regs = GetBoundGpuSubdevice()->Regs();
    UINT32 chk0 = regs.Read32(MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0, piorIdx);
    m_PinErrors[0] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D0);
    m_PinErrors[1] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D1);
    m_PinErrors[2] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D2);
    m_PinErrors[3] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D3);
    m_PinErrors[4] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D4);
    m_PinErrors[5] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D5);
    m_PinErrors[6] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D6);
    m_PinErrors[7] = regs.GetField(chk0, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK0_D7);

    UINT32 chk1 = regs.Read32(MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1, piorIdx);
    m_PinErrors[8] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_D8);
    m_PinErrors[9] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_D9);
    m_PinErrors[10] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DA);
    m_PinErrors[11] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DB);
    m_PinErrors[12] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DC);
    m_PinErrors[13] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DD);
    m_PinErrors[14] = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DE);
    *pErrDnb = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DNB)
        ? true : false;
    *pErrDfp = regs.GetField(chk1, MODS_PDISP_PIOR_LOOPBACK_ERROR_CHK1_DFP)
        ? true : false;
}

//------------------------------------------------------------------------------
void SliLoopback::ReportError(UINT32 piorIdx)
{
    bool errDnb = false;
    bool errDfp = false;
    ReadMIOLoopbackErrorStatus
    (
        &errDnb,
        &errDfp,
        piorIdx
     );
#define PRINT_IF_ERROR(pin) if (m_PinErrors[pin]) \
    {\
        Printf(GetVerbosePrintPri(), "SLI: %u errors in pin %u\n", m_PinErrors[pin], pin);\
    }
#define PRINT_PIN_ERRORS() for(UINT32 pin = 0; pin < NUMELEMS(m_PinErrors); pin++)\
    {\
        PRINT_IF_ERROR(pin);\
    }
    PRINT_PIN_ERRORS()
#undef PRINT_PIN_ERRORS
#undef PRINT_IF_ERROR
    if (errDnb)
    {
        Printf(Tee::PriError, "SLI: DNB is asserted");
    }
    if (errDfp)
    {
        Printf(Tee::PriError, "SLI: DNE is asserted");
    }
}

RC SliLoopback::Run()
{
    StickyRC firstrc;
    //
    // Setup display (not sure why)
    // 1.ConfigurePiorLoopBackControl();
    // 2.clear the RX's h/v_counter
    // 3.Gpu.TurnOnPadDroClk()
    // 4.Gpu.Tasker::GetDefaultTimeoutMs()()
    // 5.LoopbackRun():custom;error;stoplbk

    // only PIOR1/2 suppots DR. Only PIOR 2 supports Loopback
    UINT32 piorIdx = m_TestMioIndex;
    // SaveLoopbackContext
    firstrc = RunLoopBack(GetBoundGpuSubdevice(), piorIdx, ONESHOT);
    firstrc = RunLoopBack(GetBoundGpuSubdevice(), piorIdx, CONTINUOUS);
    // RestoreLoopbackContext
    ReportError(piorIdx);
    return firstrc;
}

JS_CLASS_INHERIT(SliLoopback, GpuTest, "SLI MIO Loopback test.");
CLASS_PROP_READWRITE(SliLoopback, RasterWd, UINT32, "set Raster width");
CLASS_PROP_READWRITE(SliLoopback, ActiveWd, UINT32, "set Active width");
CLASS_PROP_READWRITE(SliLoopback, RasterHt, UINT32, "set Raster height");
CLASS_PROP_READWRITE(SliLoopback, ActiveHt, UINT32, "set Active height");
CLASS_PROP_READWRITE(SliLoopback, TestMioIndex, UINT08,
        "1 or 2, indicating test MIOA only or MIOB only");
CLASS_PROP_READWRITE(SliLoopback, TestMioPinSet, UINT08,
        "1 or 2, indicating Sli port");
CLASS_PROP_READWRITE(SliLoopback, OverrideDisplayId, UINT32,
        "Display Id overridden");
