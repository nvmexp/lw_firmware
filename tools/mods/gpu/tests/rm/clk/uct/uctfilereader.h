/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2012-2017, 2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#ifndef UCTFILEREADER_H_
#define UCTFILEREADER_H_

#include <queue>

#include "gpu/include/gpusbdev.h"

#include "gpu/tests/rm/utility/rmtstring.h"
#include "uctdomain.h"
#include "uctchip.h"
#include "ucttestspec.h"
#include "ucttrialspec.h"
#include "uctexception.h"

namespace uct
{
    class CtpFileReader;

    //!
    //! \brief      Clock Test Profile (CTP) Reader
    //!
    //! \details    An object of this class parses the files and generates
    //!             CtpBlock objects (per each pseudo pstate definition) each
    //!             of which contain UCTSubField object consisting of the fields
    //!             in that block. PStates are not generated by the reader;
    //!             they are solved by UCTSolver.
    //!
    class CtpFileReader
    {
    public:
        //!
        //! \brief      Include Directive Field
        //! \see        https://wiki.lwpu.com/engwiki/index.php/Resman/Resman_Components/Clocks/UniversalClockTest/Writing#include_Directive
        //!
        //! Syntax:     <include-directive> ::= "include=" [ " ] <file-group> [.ctp] [ " ]
        //!
        struct IncludeField: public Field
        {
            //! \brief      Default construction
            inline IncludeField(): Field()
            {   }

            //! \brief      Construction from a statement
            inline IncludeField(const CtpStatement &statement): Field(statement)
            {   }

            //! \brief      Create a new field
            static Field *newField(const CtpStatement &statement);

            //! \brief      Create an exact copy of 'this'.
            virtual Field *clone() const;

            //! \brief      Check the statement argument.
            virtual ExceptionList parse();

            //! \brief      Apply the field to the reader
            virtual ExceptionList apply(CtpFileReader &reader) const;
        };

        //!
        //! \brief      Dry Run Directive Field
        //! \see        https://wiki.lwpu.com/engwiki/index.php/Resman/Resman_Components/Clocks/UniversalClockTest/Writing#dryrun_Directive
        //!
        //! \details    If 'false', nothing happens; the field is a nop.
        //!
        //!             If 'true', an 'Unsupported' exception is generated by the
        //!             'parse' function.  The default is 'true'.
        //!
        //!             None of the 'apply' functions are implemented since the
        //!             exception serves the purpose of indicating dry-run mode.
        //!
        //! Syntax:     <dryrun-directive> ::= "dryrun=" ( "true" | "false" )
        //!
        struct DryRunField: public Field
        {
            //! \brief      Default construction
            inline DryRunField(): Field()
            {   }

            //! \brief      Construction from a statement
            inline DryRunField(const CtpStatement &statement): Field(statement)
            {   }

            //! \brief      Create a new field
            static Field *newField(const CtpStatement &statement);

            //! \brief      Create an exact copy of 'this'.
            virtual Field *clone() const;

            //! \brief      Return an exception unless 'false'.
            virtual ExceptionList parse();
        };

    private:
        // \brief       List of CTP file paths
        struct CtpFileList: public list<rmt::String>
        {
        };

        //!
        //! \brief      Group of Clock Test Profile (CTP) Files
        //! \see        PlatformSuffix
        //!
        //! \details    The file path specified in an 'include' directive or from
        //!             the MODS command line represents a group of CTP files
        //!             that are organized as a hierarchy based on the chip.
        //!
        //!             For example, "sanity.ctp" on a gf119 implies these files:
        //!             - sanity.ctp
        //!             - sanity.fermi.ctp
        //!             - sanity.gfxxx.ctp
        //!             - sanity.gf1xx.ctp
        //!             - sanity.gf11x.ctp
        //!             - sanity.gf119.ctp
        //!
        //!             On duplicate settings, bottommost (i.e. most specific)
        //!             of the hierarchy take precedence.  The text between the
        //!             periods is the 'suffix' in this documentation.
        //!
        //!             This class also contains logic to search for the CTP
        //!             files (and groups) in the present working directory and
        //!             directories listed in LD_LIBRARY_PATH.
        //!
        //!             Furthermore, an empty object of this class is used by
        //!             CtpFileGroupQueue to represent the end of the queue.
        //!
        class CtpFileGroup
        {
        public:

            //! \brief      'include' Directive Location (if applicable)
            rmt::FileLocation   from;

            //!
            //! \brief      Path excluding the file name
            //!
            //! \details    For example, "mypath" in "mypath/fred.ctp"
            //!
            rmt::String         path;

            //!
            //! \brief      Base name excluding path and extension
            //!
            //! \details    For example, "fred" in "mypath/fred.ctp"
            //!
            //!             If 'base' is the empty string, this object represents
            //!             the end-of-queue flag.
            //!
            rmt::String         base;

        public:
            //!
            //! \brief      Construct an end-of-queue flag
            //! \see        CtpFileGroupQueue
            //!
            inline CtpFileGroup()
            { }

            //! \brief      Construction from an 'include' directive
            inline CtpFileGroup(const CtpStatement &include)
            {
                MASSERT(include.type == CtpStatement::Type::Include);
                from = include;
                initialize(include);
            }

            //! \brief      Construction from a file path string
            inline CtpFileGroup(const rmt::String &filepath)
            {
                initialize(filepath);
            }

            //!
            //! \brief      Is this an end-of-queue flag?
            //! \see        CtpFileGroupQueue
            //!
            inline bool end() const
            {
                return base.empty();
            }

            //!
            //! \brief      Name of file with specified chip suffix
            //!
            //! \param[in]  suffix  Suffix of the chip hierarchy
            //!
            inline rmt::String name(const rmt::String &suffix = "") const
            {
                rmt::String file = base + suffix + CTP_EXTENSION;
                if (!path.empty())
                    file = path + PATH_SEPARATOR + file;
                return file;
            }

        protected:
            //! \brief      Initialize 'base' and 'path'
            void initialize(rmt::String filepath);

            //!
            //! \brief      Find the specified file
            //! \see        Utility::FindFile
            //!
            //! \details    This method wraps Utility::FindFile to search for a
            //!             file and guarentees that the filename is openable
            //!             from the present working directory.  No logic within
            //!             this method is specific to CTP files.
            //!
            //! \param[in]  fileName    File name (with relative or absolute path)
            //! \param[out] prefix      Path prefix required to oen the file (if any)
            //!
            //! \retval     true        File was found and 'prefix' contains the prefix path
            //! \retval     false       File could not be found in the search path list
            //!
            static bool resolveFilePath(const rmt::String &fileName, rmt::String &prefix);

            //!
            //! \brief      Find the specified CTP file group
            //! \see        resolveFilePath
            //!
            //! \details    This method uses 'resolveFilePath' to search for this
            //!             file group.  The first directory which contains any
            //!             one file in the group is deemed to contain the entire
            //!             group.
            //!
            //! \param[in]  suffix      List of suffixes for the chip
            //! \param[out] prefix      Path prefix required to oen the file (if any)
            //!
            //! \retval     true        File was found and 'prefix' contains the prefix path
            //! \retval     false       File could not be found in the search path list
            //!
            bool resolvePath(const PlatformSuffix &suffix, rmt::String &prefix) const;

        public:
            //!
            //! \brief      List of file paths represented by this group
            //! \see        resolvePath
            //!
            //! \details    Using the specified chip suffixes, this method uses
            //!             'resolvePath' to create a list of file names (with
            //!             path) represented by this file group.  The paths may
            //!             be absolute or relative to the present working directory.
            //!
            //! \param[in]  suffix      List of suffixes for the chip
            //! \param[out] fileList    List of file names with paths
            //!
            //! \retval     true        At least one file was found
            //! \retval     false       No files could be found
            //!
            bool getFileList(const PlatformSuffix &suffix, CtpFileList &fileList) const;
        };

        //!
        //! \brief      Queue of CTP file groups
        //! \see        CtpFileGroup
        //!
        //! \details    This is the pending task queue for the CtpFileReader object.
        //!             Groups are pushtd onto the queue for an 'include' directive
        //!             and from the MODS command line.  Redundancies are automatically
        //!             eliminated.
        //!
        class CtpFileGroupQueue: protected queue<CtpFileGroup>
        {
        protected:
            //!
            //! \brief      File groups that have been processed
            //!
            //! \details    This set eliminates cirlwlar dependencies and other
            //!             redundancies from 'include' directives by keeping
            //!             track of the group names that have already been
            //!             popped.
            //!
            set<rmt::String> done;

        public:
            //!
            //! \brief      Initialize from the command line parameter
            //!
            inline void initialize(const rmt::String &filepath)
            {
                queue<CtpFileGroup>::push(CtpFileGroup(filepath));
            }

            //!
            //! \brief      Add a file group from an 'include' directive
            //!
            inline void push(const CtpStatement &statement)
            {
                queue<CtpFileGroup>::push(CtpFileGroup(statement));
            }

            //!
            //! \brief      Next file group in queue
            //! \see        CtpFileGroup::end
            //!
            //! \details    If the same group has been pushed into the queue, only the
            //!             first is returned.  The redundant groups are discarded.
            //!
            //! \return     Next file group to be processed.
            //! \retval     Group where 'end()' is true iff this queue is empty
            //!
            CtpFileGroup pop();
        };

    protected:
        //! \brief      Extension used by the ctp files
        static const char          *CTP_EXTENSION;

        // \brief       Path separator used by the operating system
        static const char           PATH_SEPARATOR;

        //!
        //! \brief      Chip- or plaform-specific context
        //!
        //! \details    These data are passed to the 'Field::apply' functions.
        //!
        ChipContext                 context;

        //! \brief      Suffixes appropriate to the chip hierarchy
        PlatformSuffix              suffixList;

        //! \brief      Lwrrently open CTP input file stream
        rmt::TextFileInputStream    is;

        //! \brief      Most recently read source line
        CtpStatement                statement;

        //! \brief    This map maps the test spec names to the definitions.
        TestSpec::NameMap           mTestSpecs;

        //! \brief      Trial specs parsed from CTP files
        TrialSpec::List             vTrials;

        //!
        //! \brief      Read the next CTP statement block
        //! \see        CtpStatementBlock
        //!
        //! \details    A CTP statement block is a set of lines that starts with
        //!             a 'name' statement, or a singleton directive such as
        //!             'include'.  Comments and blank lines are discarded.
        //!
        //!             The next block is returned in 'this->block' and the first
        //!             statement of the next block (if any) is cached into
        //!             'this->statement'.  Either may be empty on exit.
        //!
        ExceptionList readNextBlock(FieldVector &block, bool &eof);

    public:
        //! \brief      CTP files that need parsing
        CtpFileGroupQueue includeFiles;

        //!
        //! \brief      Initialization
        //!
        //! \details    An object of this class cannot be used until it is initialized.
        //!
        //! \param[in]  ctpFilePath  Starting CTP file group
        //! \param[in]  pSubdevice   Target chip under test
        //!
        ExceptionList initialize(const rmt::String& ctpFilePath, GpuSubdevice *pSubdevice,
                    const rmt::String &exclude);

        //!
        //! \brief      Parse the CTP files
        //!
        //! \details    This method parses the file group specified when
        //!             'initialize' was called as well as any file groups
        //!             that are included via the 'include' directive.
        //!
        ExceptionList scanFile(GpuSubdevice *m_pSubdevice);

        //!
        //! \brief      Resolve P-State References for All Trials
        //!
        //! \pre        scanFile must have been successfully called.
        //!
        //! \post       P-state and sine references in each trial specification have been
        //!             resolved.
        //!
        inline ExceptionList resolve(const VbiosPStateArray &vbiosPStateMap)
        {
            return vTrials.resolve(vbiosPStateMap, mTestSpecs);
        }

        //! \brief      Print the content of this object
        void dumpContent() const;

        //! \brief      Parsed trial specs
        inline const TrialSpec::List &getTrialSpecs()
        {
            return vTrials;
        }
    };
};

#endif /* UCTFILEREADER_H_ */

