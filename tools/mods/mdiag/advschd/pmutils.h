/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2006-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

//! \file
//! \brief Defines utility functions & classes for PolicyManager

#pragma once
#ifndef INCLUDED_PMUTILS_H
#define INCLUDED_PMUTILS_H

#include "containers/type_safety.h"
#include "core/include/fpicker.h"
#include "core/include/regexp.h"
#include "core/utility/errloggr.h"
#include "gpu/reghal/reghal.h"
#include "gpu/utility/surf2d.h"
#include "mdiag/utils/mmufaultbuffers.h"
#include "policymn.h"
#include <cstdarg>
#include <map>
#include <set>
#include <stack>

class LWGpuTsg;
class LWGpuResource;

//--------------------------------------------------------------------
//! \brief STL comparator to sort GpuDevice* by instance numbers
//!
//! This is used to sort GpuDevices, so that any PM code that loops
//! through GpuDevices uses a consistent order.
//!
class CmpGpuDevicesByInst
{
public:
    bool operator()(const GpuDevice *pLhs, const GpuDevice *pRhs) const;
};

//--------------------------------------------------------------------
//! \brief Wrapper around FancyPicker that handles incrementing counters
//!
//! This class handles a situation that comes up every so often in
//! PolicyManager: we want to do something every Nth time some event
//! oclwrs, and we use a FancyPicker to choose N.
//!
//! To put it another way: we want a counter that starts at 0, and
//! every Nth counter value is "special".  Each time a "special" count
//! oclwrs, the fancyPicker picks the next value of N.
//!
//! In order to start the sequence, the first "special" count is N-1.
//! The sequence ends if/when the FancyPicker picks 0; no more counts
//! will be "special" after that point.  The method that checks for
//! "special" counts is CheckCounter().
//!
//! So, for example, suppose the FancyPicker picks the following
//! numbers: [3, 2, 1, 1, 2, 3].  The "special" counts are:
//!
//! \verbatim
//! COUNT special?
//! ----- --------
//!   0   false
//!   1   false
//!   2   true  // 3 - 1
//!   3   false
//!   4   true  // 2 + 2
//!   5   true  // 1 + 4
//!   6   true  // 1 + 5
//!   7   false
//!   8   true  // 2 + 6
//!   9   false
//!  10   false
//!  11   true  // 3 + 8
//! \endverbatim
//!
class PmPickCounter
{
public:
    PmPickCounter(FancyPicker  *pFancyPicker,
                  bool          bUseSeedString,
                  UINT32        seed,
                  const string &seedString);
    RC FromJsval(jsval value) { return m_pFancyPicker->FromJsval(value); }
    FancyPicker *GetPicker() const { return m_pFancyPicker; }

    void   IncrCounter(UINT64 incr = 1);
    UINT64 GetCounter() const { return m_Counter; }
    UINT64 GetCountRemaining() const;
    UINT64 GetNextCount() const { return m_NextCount; }
    bool   Done() const { return m_Done; }
    bool   CheckCounter() const { return m_bCounterMatches; }
    void   Restart();

private:
    UINT64 PickIncrement();

    FancyPicker *m_pFancyPicker;    //!< Fancy Picker
    bool m_UsesExternalFancyPicker; //!< True if fancyPicker was passed to ctor
    FancyPicker::FpContext  m_FpContext;      //!< FancyPicker context
    UINT64 m_Counter;    //!< Current counter value
    bool   m_Done;       //!< true if fancyPicker picked 0; sequence is done
    UINT64 m_NextCount;  //!< The next "special" count, unless m_Done=true
    bool   m_bCounterMatches; //!< true if CheckCounter should return true
};

//--------------------------------------------------------------------
//! \brief A description of a set of surfaces
//!
//! A PmSurfaceDesc is a set of criteria that describe the name, type,
//! etc of a surface or set of surfaces.  Any surface that matches all
//! the criteria matches the PmSurfaceDesc.
//!
//! PmSurfaceDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmSurfaceDesc
{
public:
    PmSurfaceDesc(const string &id);
    string GetId() const { return m_Id; }

    RC SetName(const string &str) { return m_Name.Set(str, RegExp::FULL); }
    RC SetType(const string &str) { return m_Type.Set(str, RegExp::FULL); }
    RC SetNotName(const string &str);
    RC SetNotType(const string &str);
    RC SetGpuDesc(const PmGpuDesc* pGpuDesc);
    RC SetFaulting(bool val)            { m_Faulting = val; return OK; }
    RC SetTestDesc(const PmTestDesc * pTestDesc);
    const PmTestDesc * GetTestDesc() const { return m_pTestDesc; }

    string           GetName()     const { return m_Name.ToString(); }
    RegExp           GetRegName()     const { return m_Name;}
    string           GetType()     const { return m_Type.ToString(); }
    string           GetNotName()  const { return m_NotName.ToString(); }
    string           GetNotType()  const { return m_NotName.ToString(); }
    const PmGpuDesc *GetGpuDesc()  const { return m_pGpuDesc; }
    bool             GetFaulting() const { return m_Faulting; }

    RC IsSupportedInTrigger() const;
    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    bool Matches(const PmEvent *pEvent) const;
    PmSubsurfaces GetMatchingSubsurfaces(const PmTrigger *pTrigger,
                                         const PmEvent *pEvent) const;
    PmSubsurfaces GetMatchingSubsurfacesInTrigger(
                               const PolicyManager *pPolicyManager) const;

private:
    friend class PmPageDesc;
    bool SimpleMatch(const PmSubsurface *pSubsurface) const;

    string m_Id;       //!< Name of the PmSurfaceDesc
    RegExp m_Name;     //!< Matches the surface name
    RegExp m_Type;     //!< Matches the surface type
    RegExp m_NotName;  //!< Matches all surfaces except those with this name
    RegExp m_NotType;  //!< Matches all surfaces except those with this type
    const PmGpuDesc *m_pGpuDesc; //!< Matches the GpuDevice the surface is on
    bool   m_Faulting; //!< Matches the faulting surface
    const PmTestDesc *m_pTestDesc; //!< Matches the Test the channel is on
};

//--------------------------------------------------------------------
//! \brief A description of a set of pages
//!
//! This is just a tuple (PmSurfaceDesc*, offset, size) that describes
//! all pages that overlap the range [offset, offset+size) in the
//! indicated surfaces.  A size of 0 means "until the end of the
//! surface".
//!
//! Unlike other Pm*Desc objects, PmPageDescs are not generated by the
//! parser, nor are they stored in the eventManager.  They are
//! generally just members of triggers and actions.
//!
class PmPageDesc
{
public:
    PmPageDesc(const PmSurfaceDesc *pSurfaceDesc, UINT64 offset, UINT64 size);

    const PmSurfaceDesc *GetSurfaceDesc() const { return m_pSurfaceDesc; }
    UINT64               GetOffset()      const { return m_Offset; }
    UINT64               GetSize()        const { return m_Size; }

    RC IsSupportedInTrigger() const;
    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    bool Matches(const PmEvent *pEvent) const;
    PmMemRanges GetMatchingRanges(const PmTrigger *pTrigger,
                                  const PmEvent *pEvent) const;
    PmMemRanges GetMatchingRangesInTrigger(
                               const PolicyManager *pPolicyManager) const;

private:
    friend class PmSurfaceDesc;
    bool SimpleMatch(const PmSubsurface *pSubsurface,
                     const PmMemRange *pMemRange) const;

    const PmSurfaceDesc *m_pSurfaceDesc;
    UINT64 m_Offset;
    UINT64 m_Size;
};

//--------------------------------------------------------------------
//! \brief A description of a set of Vfs
//!
//! A PmVfTestDesc is a set of criteria that describe a Vf or
//! set of Vfs.  Any Vf that matches all the criteria
//! matches the PmVfTestDesc.
//!
//! PmVfTestDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmVfTestDesc
{
public:
    PmVfTestDesc(const string &id);

    const string & GetId() const { return m_Id; }
    RC SetGFID(const string &str) { return m_GFID.Set(str, RegExp::FULL); }
    RC SetSeqId(const string &str) { return m_SeqId.Set(str, RegExp::FULL); }

    string           GetGFID()     const { return m_GFID.ToString(); }
    string           GetSeqId()     const { return m_SeqId.ToString(); }
    PmVfTests GetMatchingVfs(const PmTrigger * pTrigger, const PmEvent * pEvent) const;
private:
    bool SimpleMatch(const PmVfTest * pVf) const;

    string m_Id;       //!< Name of the PmVaSpaceDesc
    RegExp m_GFID;     //!< Matches the Vf GFID
    RegExp m_SeqId;     //!< Matches the Vf whose sequence at Vf_testlist.yml can
                             //  match this value
    vector<UINT32> m_VfNumbers;    //!< Matches the Vf number
};

//--------------------------------------------------------------------
//! \brief A description of a set of SmcEngines
//!
//! A PmSmcEngineDesc is a set of criteria that describe an SmcEngine or
//! set of SmcEngines.  Any SmcEngine that matches all the criteria
//! matches the PmSmcEngineDesc.
//!
//! PmSmcEngineDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmSmcEngineDesc
{
public:
    PmSmcEngineDesc(const string &id);
 
    const string &   GetId() const { return m_Id; }
    RC               SetSysPipe(const string &str) { return m_SysPipe.Set(str, RegExp::FULL); }
    string           GetSysPipe() const { return m_SysPipe.ToString(); }
    PmSmcEngines     GetMatchingSmcEngines(const PmTrigger * pTrigger, const PmEvent * pEvent) const;
    RC               SetTestDesc(const PmTestDesc * pTestDesc) { m_pTestDesc = pTestDesc; return OK; }
    const PmTestDesc * GetTestDesc() const  { return m_pTestDesc; }
    RC               SetName(const string &str) { return m_Name.Set(str, RegExp::FULL); }
    string           GetName() const { return m_Name.ToString(); }
    bool SimpleMatch(const PmSmcEngine * pSmcEngine) const;
 
private:
    string m_Id;              //!< Name of the PmSmcEngineDesc
    RegExp m_SysPipe;         //!< Matches the SysPipe match this value
    const PmTestDesc *m_pTestDesc; //!< Matches the Test's smcengine
    RegExp m_Name;            //!< Matches the Name of the SmcEngine
};

//--------------------------------------------------------------------
//! \brief A description of a set of vaspaces
//!
//! A PmVaSpaceDesc is a set of criteria that describe a vaspace or
//! set of vaspaces.  Any vaspace that matches all the criteria
//! matches the PmVaSpaceDesc.
//!
//! PmVaSpaceDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmVaSpaceDesc
{
public:
    PmVaSpaceDesc(const string &id);
    const string & GetId() const { return m_Id; }

    RC SetName(const string &str) { return m_Name.Set(str, RegExp::FULL); }
    RC SetTestDesc(const PmTestDesc * pTestDesc) { m_pTestDesc = pTestDesc; return OK; }

    string           GetName()     const { return m_Name.ToString(); }
    const PmTestDesc * GetTestDesc() const { return m_pTestDesc; }
    PmVaSpaces GetMatchingVaSpaces(const PmTrigger * pTrigger, const PmEvent * pEvent, const LwRm* pLwRm) const;
private:
    bool SimpleMatch(const PmVaSpace * pVaSpace) const;

    string m_Id;       //!< Name of the PmVaSpaceDesc
    RegExp m_Name;     //!< Matches the vaspace name
    vector<UINT32> m_VaSpaceNumbers;    //!< Matches the vaspace number
    const PmTestDesc *m_pTestDesc; //!< Matches the Test the vaspace is on
};

//--------------------------------------------------------------------
//! \brief A description of a set of channels
//!
//! A PmChannelDesc is a set of criteria that describe a channel or
//! set of channels.  Any channel that matches all the criteria
//! matches the PmChannelDesc.
//!
//! PmChannelDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmChannelDesc
{
public:
    PmChannelDesc(const string &id);
    string GetId() const { return m_Id; }

    RC SetName(const string &str) { return m_Name.Set(str, RegExp::FULL); }
    RC SetChannelNumbers(const vector<UINT32> &val)
                                        { m_ChannelNumbers = val; return OK; }
    RC SetGpuDesc(const PmGpuDesc *pGpuDesc);
    RC SetTestDesc(const PmTestDesc * pTestDesc);
    const PmTestDesc * GetTestDesc() const  { return m_pTestDesc; }
    RC SetFaulting(bool val)            { m_Faulting = val; return OK; }

    string           GetName()     const { return m_Name.ToString(); }
    const vector<UINT32> &GetChannelNumbers() const { return m_ChannelNumbers;}
    const PmGpuDesc *GetGpuDesc()  const { return m_pGpuDesc; }
    bool             GetFaulting() const { return m_Faulting; }

    RC IsSupportedInTrigger() const;
    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    bool Matches(const PmEvent *pEvent) const;
    PmChannels GetMatchingChannels(const PmTrigger *pTrigger,
                                   const PmEvent *pEvent) const;
    UINT32 GetMatchingSubdevices(const PmChannel *pChannel,
                                 const PmTrigger *pTrigger,
                                 const PmEvent *pEvent) const;
    vector<UINT32> GetMatchingSubchannels(const PmChannel *pChannel,
                                          const PmTrigger *pTrigger,
                                          const PmEvent *pEvent) const;

private:
    friend class PmTestDesc;
    bool SimpleMatch(const PmChannel *pChannel) const;

    string m_Id;       //!< Name of the PmChannelDesc
    RegExp m_Name;     //!< Matches the channel name
    vector<UINT32> m_ChannelNumbers;    //!< Matches the channel number
    const PmGpuDesc *m_pGpuDesc; //!< Matches the GpuDevice the channel is on
    bool   m_Faulting; //!< Matches the faulting channel
    const PmTestDesc *m_pTestDesc; //!< Matches the Test the channel is on
};

//--------------------------------------------------------------------
//! \brief A description of a set of GpuDevices and/or GpuSubdevices
//!
//! A PmGpuDesc is a set of criteria that describe a set of
//! GpuSubdevices.  Any subdevice that matches all the criteria
//! matches the PmGpuDesc.
//!
//! PmGpuDesc is also used to match GpuDevices, in which case any device
//! that has a matching subdevice matches.
//!
//! PmGpuDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmGpuDesc
{
public:
    PmGpuDesc(const string &id);
    string GetId() const { return m_Id; }
    string ToString() const;

    RC SetDevInst(const string &str);
    RC SetSubdevInst(const string &str);
    RC SetFaulting(bool val) { m_Faulting = val; return OK; }

    string GetDevInst()    const { return m_DevInst.ToString(); }
    string GetSubdevInst() const { return m_SubdevInst.ToString(); }
    bool   GetFaulting()   const { return m_Faulting; }

    RC IsSupportedInTrigger() const;
    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    bool Matches(const PmEvent *pEvent) const;
    GpuSubdevices GetMatchingSubdevices(const PmTrigger *pTrigger,
                                        const PmEvent *pEvent) const;
    GpuSubdevices GetMatchingSubdevicesInTrigger(
                               const PolicyManager *pPolicyManager) const;
    GpuDevices GetMatchingDevices(const PmTrigger *pTrigger,
                                  const PmEvent *pEvent) const;
    GpuDevices GetMatchingDevicesInTrigger(
                               const PolicyManager *pPolicyManager) const;

private:
    friend class PmSurfaceDesc;
    friend class PmChannelDesc;
    friend class PmTestDesc;
    bool SimpleMatch(const GpuSubdevice *pGpuSubdevice) const;
    bool SimpleMatch(const GpuDevice *pGpuDevice) const;

    string m_Id;           //!< Name of the PmGpuDesc
    RegExp m_DevInst;      //!< Matches the device's instance number
    RegExp m_SubdevInst;   //!< Matches the subdevice instance
    bool   m_Faulting;     //!< Matches the faulting device/subdevice
};

//--------------------------------------------------------------------
//! \brief A description of a set of runlists
//!
//! A PmRunlistDesc is a set of criteria that describe the name, type,
//! etc of a runlist or set of runlists.  Any surface that matches all
//! the criteria matches the PmRunlistDesc.
//!
//! PmRunlistDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmRunlistDesc
{
public:
    PmRunlistDesc(const string &id);
    string GetId() const { return m_Id; }

    RC SetName(const string &str);
    RC SetChannelDesc(const PmChannelDesc *pChannelDesc);
    RC SetGpuDesc(const PmGpuDesc *pGpuDesc);

    string               GetName()         const { return m_Name.ToString(); }
    const PmChannelDesc *GetChannelDesc()  const { return m_pChannelDesc; }
    const PmGpuDesc     *GetGpuDesc()      const { return m_pGpuDesc; }

    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    RC GetMatchingRunlists(const PmTrigger *pTrigger,
                           const PmEvent *pEvent,
                           Runlists *pRunlists) const;
    RC GetChannelsEngines(const PmTrigger *pTrigger,
                          const PmEvent   *pEvent,
                          vector< tuple<GpuDevice*, LwRm*, UINT32> >
                              *pGpuDevicesEngines) const;
    RC GetMatchingEngines(const PmTrigger *pTrigger,
                          const PmEvent   *pEvent,
                          vector< pair<GpuDevice*, UINT32> >
                              *pGpuDevicesEngines,
                          LwRm* pLwRm,
                          PmSmcEngines smcEngines) const;

private:
    bool SimpleMatch(const GpuDevices &MatchingDevices,
                     const GpuDevice *pGpuDevice,
                     UINT32 Engine) const;

    string m_Id;       //!< Name of the PmRunlistDesc
    RegExp m_Name;     //!< Matches the runlist (engine) name
    const PmChannelDesc *m_pChannelDesc; //!< Matches Channels using runlist
    const PmGpuDesc *m_pGpuDesc; //!< Matches the GpuDevice the runlist is on
};

//--------------------------------------------------------------------
//! \brief A description of a set of conlwrrent tests
//!
//! A PmTestDesc is a set of criteria that describe a conlwrrent test
//! or set of tests.  Any test that matches all the criteria matches
//! the PmTestDesc.
//!
//! PmTestDescs are generated by the parser, and stored in the
//! eventManager.
//!
class PmTestDesc
{
public:
    PmTestDesc(const string &id);
    string GetId() const { return m_Id; }

    UINT32 GetTestId() const { return m_TestId;  }
    RC SetTestId(const UINT32 testId) { m_TestId = testId; return OK;  }

    RC SetName(const string &str) { return m_Name.Set(str, RegExp::FULL); }
    RC SetType(const string &str) { return m_Type.Set(str, RegExp::FULL); }
    RC SetChannelDesc(const PmChannelDesc *pChannelDesc);
    RC SetGpuDesc(const PmGpuDesc *pGpuDesc);
    RC SetFaulting(bool val) { m_Faulting = val; return OK; }

    string GetName() const { return m_Name.ToString(); }
    string GetType() const { return m_Type.ToString(); }
    const PmChannelDesc *GetChannelDesc()  const { return m_pChannelDesc; }
    const PmGpuDesc *GetGpuDesc() const { return m_pGpuDesc; }
    bool GetFaulting() const { return m_Faulting; }

    RC IsSupportedInAction(const PmTrigger *pTrigger) const;
    PmTests GetMatchingTests(const PmTrigger *pTrigger,
                             const PmEvent *pEvent,
                             const PmSmcEngineDesc *pSmcEngineDesc) const;

private:
    friend class PmChannelDesc;
    friend class PmSurfaceDesc;
    friend class PmVaSpaceDesc;
    bool SimpleMatch(PmTest *pTest, 
                     const PmSmcEngineDesc *pSmcEngineDesc = nullptr) const;

    static const UINT32 m_UnknonwTestId = ~0x0;

    string m_Id;       //!< Name of the PmTestDesc
    RegExp m_Name;     //!< Matches the test name
    RegExp m_Type;     //!< Matches the test type
    const PmChannelDesc *m_pChannelDesc;//!< Matches channel(s) in the test
    const PmGpuDesc *m_pGpuDesc;        //!< Matches GpuDevice the test runs on
    bool   m_Faulting;                  //!< Matches the faulting test
    UINT32 m_TestId;    //!< Matches the test Id
};

//--------------------------------------------------------------------
//! \brief Represents a named non-stalling interrupt
//!
//! By itself, an interrupt does not carry any data.  So in order to
//! distinguish between them, PolicyManager puts a semaphore-release
//! on the stack just before each non-stalling int.  The policyfile
//! refers to each non-stalling interrupt by name.
//!
//! There should be one instance of this class for each (intName,
//! channel) tuple.  This class is in charge of writing the
//! non-stalling interrput request to the channel, checking the
//! semaphore to see if the interrupt has oclwrred, manages the
//! semaphore.
//!
class PmNonStallInt
{
public:
    PmNonStallInt(const string &intName, PmChannel *pChannel);
    ~PmNonStallInt();
    string     GetName()    const { return m_IntName; }
    PmChannel *GetChannel() const { return m_pChannel; }
    RC PrepareInterruptRequest(UINT64 *pSemaphoreOffset, UINT64 *pPayload);
    static RC HandleResmanEvent(void *ppThis);
    string ToString() const;

private:
    string     m_IntName;      //!< Name of the int; set by constructor
    PmChannel *m_pChannel;     //!< Channel that int is on; set by constructor
    bool       m_IsAllocated;  //!< Tells whether m_Semaphore was alloced yet
    Surface2D  m_Semaphore;    //!< 4-byte surface containing the semaphore
    UINT64     m_LastReceivedValue;  //!< Value that was in the semaphore
    UINT64     m_LastRequestedValue; //!< Next value to release to semaphore
};

//--------------------------------------------------------------------
//! \brief Represents an interrupt oclwring at particular methods in
//! the channel
//!
//! Interrupt.
//!
//! There should be one instance of this class for each (intName,
//! channel) tuple.  This class is in charge of writing the
//! non-stalling interrput request to the channel, checking the
//! semaphore to see if the interrupt has oclwrred, manages the
//! semaphore.
//!
class PmMethodInt
{
public:
    PmMethodInt(PmChannel *pChannel);
    ~PmMethodInt();
    PmChannel *GetChannel() const { return m_pChannel; }
    RC RequestInterrupt(UINT32 methodCount, bool bWfiOnRelease,
                        bool bWaitEventHandled);
    static RC RespondToSemaphore(void *ppThis);
    string ToString() const;

    enum
    {
        METHOD_INT_COMPLETE = _UINT32_MAX,
        MAX_METHOD_COUNT = METHOD_INT_COMPLETE - 1
    };
private:
    PmChannel * m_pChannel;     //!< Channel that int is on; set by constructor
    bool        m_IsAllocated;  //!< Tells whether m_Semaphore was alloced yet
    Surface2D   m_Semaphore;    //!< 4-byte surface containing the semaphore
    UINT32      m_LastInt;      //!< Last method that where an interrupt was
                                //!< requested
    vector<UINT32> m_RespondIntList;//!< A list of method count to be responded.
};

//--------------------------------------------------------------------
//! \brief Represents an interrupt oclwring ...
//!
//! Interrupt.
//!
//! There should be one instance of this class for each (intName,
//! channel) tuple.  This class is in charge of writing the
//! interrput request to the channel, checking the semaphore
//! to see if the interrupt has oclwrred, manages the
//! semaphore.
//!
class PmContextSwitchInt
{
public:
    PmContextSwitchInt(PmChannel* pChannel, bool blocking);
    ~PmContextSwitchInt();
    RC RequestInterrupt();
    static RC RespondToSemaphore(void *ppThis);
    string ToString() const;

private:
    PmChannel  *m_pChannel;     //!< Channel that int is on; set by constructor
    bool        m_IsAllocated;  //!< Tells whether m_Semaphore was alloced yet
    Surface2D   m_Semaphore;    //!< 4-byte surface containing the semaphore
    UINT32      m_IntCount;     //!< Count of context switch interrupts
    bool        m_BlockingInt;  //!< Controls blocking/non-blocking mode

    const static UINT32 CTXSW_INT_COMPLETE = 0;
};

namespace PmFaulting
{
    class FaultBufferEntry; //!< Forward declaration
}

//--------------------------------------------------------------------
//! \brief Represents a replayable fault interrupt
//!
class PmReplayableInt
{
public:
    PmReplayableInt(PolicyManager *policyManager, GpuSubdevice *gpuSubdevice);
    ~PmReplayableInt();
    RC PrepareForInterrupt();
    static RC HandleResmanEvent(void *ppThis);
    string ToString() const { return "0"; };
    RC ClearFaultBuffer();

private:
    RC CreateReplayableFaultEvent(const PmFaulting::FaultBufferEntry* const faultEntry);
    RC GetFaultingTsg(const PmFaulting::FaultBufferEntry* const faultEntry,
                        LWGpuTsg ** pTsg);
    RC GetFaultingVeid(const PmFaulting::FaultBufferEntry* const faultEntry,
                        UINT32 * pVEID);
    RC GetFaultingRange(const PmFaulting::FaultBufferEntry* const faultEntry,
                        PmMemRange *faultingRange);
    RC CreateFaultBufferOverflowEvent();
    shared_ptr<PmFaulting::FaultBufferEntry> GetFaultEntry();
    void SetfaultEntry(const PmFaulting::FaultBufferEntry * const pFaultEntr );
    RC IlwalidFaultEntry(PmFaulting::FaultBufferEntry *pFaultEntry);

    PolicyManager *m_PolicyManager;
    GpuSubdevice *m_GpuSubdevice;
    LwRm::Handle m_FaultBufferHandle;
    UINT32 *m_FaultBufferEntries;
    UINT32 m_FaultBufferSize;
    UINT32 m_MaxFaultBufferEntries;
    UINT32 m_GetIndex;
    UINT32 m_PutIndex;
};

//--------------------------------------------------------------------
//! \brief Represents a non-replayable fault interrupt
//!
class PmNonReplayableInt
{
public:
    PmNonReplayableInt(PolicyManager *policyManager, GpuSubdevice *gpuSubdevice);
    ~PmNonReplayableInt();
    RC PrepareForInterrupt();
    static RC HandleFaultInPrivs(void *ppThis);
    static RC HandleFaultInBuffer(void *ppThis);
    static RC HandleOverflowEvent(void *ppThis);
    RC ForceNonReplayableFaultBufferOverflow();
    string ToString() const { return "0"; }

private:

    RC CreateFaultEvent(const PmFaulting::FaultBufferEntry* const faultEntry);
    bool IsCEEngineID(UINT32 engineID, LwRm* pLwRm) const;

    PolicyManager *m_PolicyManager;
    GpuSubdevice *m_GpuSubdevice;
    LwRm::Handle m_FaultBufferHandle;
    SubdeviceShadowFaultBuffer *m_pSubdevShadowBuffer;
};

//--------------------------------------------------------------------
//! \brief Represents a physical page fault interrupt
//!
class PmPhysicalPageFaultInt
{
public:
    PmPhysicalPageFaultInt(PolicyManager * pPolicyManager,
                           GpuSubdevice * pGpuSubdevice);
    ~PmPhysicalPageFaultInt();
    RC PrepareForInterrupt();
    PolicyManager * GetPolicyManger() { return m_PolicyManager; }
private:
    static RC HandleResmanEvent(void * ppThis);
    PolicyManager * m_PolicyManager;
    GpuSubdevice * m_pGpuSubdevice;
};

class PmAccessCounterInt
{
public:
    PmAccessCounterInt(PolicyManager *policyManager, GpuSubdevice *gpuSubdevice, FLOAT64 timeoutMs);
    ~PmAccessCounterInt();
    RC PrepareForInterrupt();
    static RC HandleResmanEvent(void *ppThis);
    string ToString() const { return "0"; }
    RC ClearAccessCounterBuffer();
    void ResetCachedGetPointer() { m_GetIndex = 0; }
    GpuSubdevice* GetGpuSubDevice() const { return m_GpuSubdevice; }

private:
    RC CreateAccessCounterNotificationEvent(const PmFaulting::FaultBufferEntry * const faultEntry);
    RC UpdateAccessCounterBufferGetPointer(UINT32 newIndex);
    vector<UINT32> GetAccessCounterEntry();
    void SetAccessCounterEntry(const vector<UINT32> &accessCounterEntry);
    void IlwalidateAccessCounterEntry(vector<UINT32> *pAccessCounterEntry);

    PolicyManager *m_PolicyManager;
    GpuSubdevice *m_GpuSubdevice;
    LwRm::Handle m_AccessCounterBufferHandle;
    UINT32 *m_AccessCounterBufferEntries;
    UINT32 m_AccessCounterBufferSize;
    UINT32 m_MaxAccessCounterBufferEntries;
    UINT32 m_GetIndex;
    UINT32 m_PutIndex;
    FLOAT64 m_TimeoutMs;
};

//--------------------------------------------------------------------
//! \brief Represents an error logger interrupt
//!
class PmErrorLoggerInt
{
public:
    class Event
    {
    public:
        void Set() { m_Set = true; }
        void Clear() { m_Set = false; }
        bool IsSet() { return m_Set; }
    private:
        bool m_Set = false;
    };

    typedef std::vector<std::tuple<std::string, Event*>> Events;

    PmErrorLoggerInt(PolicyManager *policyManager, GpuSubdevice *gpuSubdevice,
        const PolicyManager::InterruptNames *pNames);
    ~PmErrorLoggerInt();
    RC PrepareForInterrupt();
    string ToString() const { return "0"; }
    const Events* GetEvents() { return &m_Events; }
private:
    PolicyManager *m_PolicyManager;
    GpuSubdevice *m_GpuSubdevice;
    Events m_Events;
    int m_LastIndex;
    static RC HandleErrorLoggerEvent(void *ppThis);
};

//--------------------------------------------------------------------
//! \brief Represents a none fatal poison error interrupt
//!
class PmNonfatalPoisonErrorInt
{
public:
    PmNonfatalPoisonErrorInt(PolicyManager * pPolicyManager,
                           GpuSubdevice * pGpuSubdevice);
    ~PmNonfatalPoisonErrorInt();
    RC PrepareForInterrupt();
    PolicyManager * GetPolicyManger() { return m_PolicyManager; }
private:
    static RC HandleResmanEvent(void * ppThis);
    PolicyManager * m_PolicyManager;
    GpuSubdevice * m_pGpuSubdevice;
};

//--------------------------------------------------------------------
//! \brief Represents a fatal poison error interrupt
//!
class PmFatalPoisonErrorInt
{
public:
    PmFatalPoisonErrorInt(PolicyManager * pPolicyManager,
                          GpuSubdevice * pGpuSubdevice);
    ~PmFatalPoisonErrorInt();
    RC PrepareForInterrupt();
    PolicyManager * GetPolicyManger() { return m_PolicyManager; }
private:
    static RC HandleResmanEvent(void * ppThis);
    PolicyManager * m_PolicyManager;
    GpuSubdevice * m_pGpuSubdevice;
};

//--------------------------------------------------------------------
//! \brief Clear a vector of pointers and delete the elements, in that order.
//!
//! Clearing the vector first ensures that we don't follow any deleted
//! pointers if one of the destructors calls Tasker::Yield.
template<typename T>
void DeletePtrContainer(vector<T*> &container)
{
    vector<T*> tmp;
    tmp.swap(container);
    for (typename vector<T*>::iterator iter = tmp.begin();
         iter != tmp.end(); ++iter)
    {
        delete *iter;
    }
}

//--------------------------------------------------------------------
//! \brief Clear a set of pointers and delete the elements, in that order.
//!
//! Clearing the set first ensures that we don't follow any deleted
//! pointers if one of the destructors calls Tasker::Yield.
template<typename T>
void DeletePtrContainer(set<T*> &container)
{
    set<T*> tmp;
    tmp.swap(container);
    for (typename set<T*>::iterator iter = tmp.begin();
         iter != tmp.end(); ++iter)
    {
        delete *iter;
    }
}

//--------------------------------------------------------------------
//! \brief Clear a map of pointers and delete the elements, in that order.
//!
//! Clearing the map first ensures that we don't follow any deleted
//! pointers if one of the destructors calls Tasker::Yield.
template<typename T1, typename T2>
void DeletePtrContainer(map<T1, T2*> &container)
{
    map<T1, T2*> tmp;
    tmp.swap(container);
    for (typename map<T1, T2*>::iterator iter = tmp.begin();
         iter != tmp.end(); ++iter)
    {
        delete (*iter).second;
    }
}

class RefManual; //!< Forward declaration
class RefManualRegister; //!< Forward declaration
class RefManualRegisterField; //!< Forward declaration

//--------------------------------------------------------------------
//! \brief A description of a register
//!
//! A PmRegister is a set of criteria that describe register parsed
//! from ref manuals or RegHal, and data read from GPU
//!
class PmRegister
{
public:
    PmRegister(LWGpuResource *pGpuRes, UINT32 subdev, const string& regName, PmSmcEngine* pPmSmcEngine = nullptr, const string& regSpace = "");
    PmRegister(LWGpuResource *pGpuRes, UINT32 subdev, const string& regName, const vector<UINT32> &regIndexes, PmSmcEngine* pPmSmcEngine = nullptr, const string& regSpace = "");
    bool IsReadable() const;
    bool IsWriteable() const;
    RC Read();
    RC Write();
    RC SetField(const string& fieldName, UINT32 value);
    RC SetMasked(UINT32 andMask, UINT32 value);
    void SetRegValue(UINT32 val);
    UINT32 GetRegOffset() const;
    friend class PmAction_WaitPriReg32;

private:
    LWGpuResource* m_pGpuRes;
    UINT32 m_Subdev;
    const string m_RegName;
    const vector<UINT32> m_RegIndexes;
    const string m_RegSpace;
    PmSmcEngine* m_pPmSmcEngine;
    const RefManualRegister* m_pRefManualRegister;
    ModsGpuRegAddress m_RegHalAddress;
    UINT32 m_RegOffset;
    UINT32 m_Data;
    static const vector<string> m_RegRestoreExclude;
};

#endif // INCLUDED_PMUTILS_H
