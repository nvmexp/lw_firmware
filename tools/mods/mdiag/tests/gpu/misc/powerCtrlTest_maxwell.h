/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2006-2018, 2020-2021 by LWPU Corporation.  All rights reserved. 
 * All information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */
#ifndef _POWMGMTTEST_MAXWELL_H_
#define _POWMGMTTEST_MAXWELL_H_

#include "pwr_macro.h"
#include "mdiag/utils/types.h"
#include "mdiag/tests/test.h"
#include "mdiag/lwgpu.h"
// Contains an autogenerated struct to define each clk, rtl map name and info about the clk
#include "maxwell_rtl_clocks.h"
// Lots of routines to program pll's, set clks, etc

#include "ctrl/ctrl2080.h"
#include "ctrl/ctrl0080.h"
#include "ctrl/ctrl2080/ctrl2080fb.h"
#include "core/include/platform.h"

#include "mdiag/tests/gpu/lwgpu_single.h"

// Since we now have an autogenerated struct to define each clk and rtl map name, just need
// an array of clks to represent each one
enum LW_SLOWDOWN_TYPE {
    HW_FAILSAFE   = 0,
    IDLE_SLOWDOWN = 1,
    SW_SLOWDOWN   = 2
};
typedef struct {
UINT32    GR     = 500; //0,
UINT32    CE0    = 500; //1,
UINT32    CE1    = 500; //2,
UINT32    CE2    = 500; //3,
UINT32    CE3    = 500; //4,
UINT32    CE4    = 500; //18,
UINT32    CE5    = 500; //180,
UINT32    CE6    = 500; //200,
UINT32    CE7    = 500; //220,
UINT32    CE8    = 500; //290,
UINT32    CE9    = 500; //310,
UINT32    LWDEC  = 500; //5,
UINT32    LWDEC1 = 500; //12, 
UINT32    LWDEC2 = 500; //8,
UINT32    LWDEC3 = 500; //15,
UINT32    LWDEC4 = 500; //230,
UINT32    LWDEC5 = 500; //250,
UINT32    LWDEC6 = 500; //320,
UINT32    LWDEC7 = 500; //340,
UINT32    LWJPG0 = 500; //10,
UINT32    LWJPG1 = 500; //11,
UINT32    LWJPG2 = 500; //16,
UINT32    LWJPG3 = 500; //17,
UINT32    LWJPG4 = 500; //240,
UINT32    LWJPG5 = 500; //360,
UINT32    LWJPG6 = 500; //330,
UINT32    LWJPG7 = 500; //350,
UINT32    SEC    = 500; //13,
UINT32    OFA    = 500; //7,
UINT32    LWENC  = 500; //6,
UINT32    LWENC1 = 500; //14,
UINT32    LWENC2 = 500; //9,
} LW_ENGINE_TYPE;

// Engine-level clock gating modes
enum LW_ENGINE_MODE {
    CG_FULLPOWER   = 0,   // No engine-level clock gating
    CG_AUTOMATIC   = 1,   // Engine & block-level clock gate when no activity
    CG_BLOCK_LEVEL = 2,   // Just block-level clock-gating but no engine-level clock-gating
    CG_SUSPENDED   = 3,   // Gate engine when no reset or sw activity (datapath activity ignored)
    CG_DISABLED    = 4    // Gate engine unconditionally
};

class clk_info {
public:
    UINT32 period;
    UINT32 count;
};

typedef struct
{
    LW2080_CTRL_GR_INFO bufferAlignment;
    LW2080_CTRL_GR_INFO swizzleAlignment;
    LW2080_CTRL_GR_INFO vertexCacheSize;
    LW2080_CTRL_GR_INFO vpeCount;
    LW2080_CTRL_GR_INFO shaderPipeCount;
    LW2080_CTRL_GR_INFO threadStackScalingFactor;
    LW2080_CTRL_GR_INFO shaderPipeSubCount;
    LW2080_CTRL_GR_INFO smRegBankCount;
    LW2080_CTRL_GR_INFO smRegBankRegCount;
    LW2080_CTRL_GR_INFO smVersion;
    LW2080_CTRL_GR_INFO maxWarpsPerSm;
    LW2080_CTRL_GR_INFO maxThreadsPerWarp;
    LW2080_CTRL_GR_INFO geomGsObufEntries;
    LW2080_CTRL_GR_INFO geomXbufEntries;
    LW2080_CTRL_GR_INFO fbMemReqGranularity;
    LW2080_CTRL_GR_INFO hostMemReqGranularity;
    LW2080_CTRL_GR_INFO litterNumFbps;
    LW2080_CTRL_GR_INFO litterNumGpcs;
    LW2080_CTRL_GR_INFO litterNumTpcPerGpc;
    LW2080_CTRL_GR_INFO litterNumZlwllBanks;
} MYGRINFO;



class MaxwellClkCount
{
public:
    MaxwellClkCount() {
        LWGpuResource* lwgpu = LWGpuResource::FindFirstResource();
        m_arch = lwgpu->GetArchitecture();
        clk_elcg = new clk_info[NumMappedClocks_maxwell()];
    }
    MaxwellClkCount(const MaxwellClkCount& that)
    {
        m_arch = that.m_arch;
        clk_elcg = new clk_info[NumMappedClocks_maxwell()];
        copy(that.clk_elcg, that.clk_elcg + NumMappedClocks_maxwell(), clk_elcg);
    }
    MaxwellClkCount& operator=(const MaxwellClkCount& that)
    {
        delete[] clk_elcg;
        m_arch = that.m_arch;
        clk_elcg = new clk_info[NumMappedClocks_maxwell()];
        copy(that.clk_elcg, that.clk_elcg + NumMappedClocks_maxwell(), clk_elcg);
        return *this;
    }

    ~MaxwellClkCount() {  delete[] clk_elcg;}
    clk_info* clk_elcg;
 private:
    UINT32 m_arch;
};

class powerCtrlTest_maxwell : public LWGpuSingleChannelTest
{
public:
  powerCtrlTest_maxwell(ArgReader *reader);

  virtual ~powerCtrlTest_maxwell(void);

  static Test *Factory(ArgDatabase *args);
  // A little extra setup to be done
  virtual int Setup(void);

  // Run() overridden - now we're a real test!
  virtual void Run(void);

  // A little extra cleanup to be done
  virtual void CleanUp(void);

  // useful functions to modify low-level registers
  virtual void DisableclkSlowdown();

  virtual UINT32 setupPMC_ENABLE();

  virtual void ResetELCGClkCounters();
  virtual void EnableELCGClkCounters();
  virtual MaxwellClkCount SubtractEngineClkCounters(MaxwellClkCount clk_count_start, MaxwellClkCount clk_count_stop);
  virtual MaxwellClkCount ReadELCGClkCounters(void);
  virtual void printEngineClkCounters(MaxwellClkCount clk_count);
  virtual void checkClkGating(MaxwellClkCount clkcount, bool suspended_or_disabled, unsigned long long int gatingType, bool CheckComplement);

  virtual void AllEngineMode(LW_ENGINE_MODE eng_mode);
  virtual void SetEngineMode(UINT32 engine, LW_ENGINE_MODE mode);
  virtual void ForceEngineClksOn(UINT32 engine, LW_ENGINE_MODE mode);
  virtual void AllEngineForceClksOn(LW_ENGINE_MODE mode);

  virtual void testPerEngineClkGating(void);
  virtual void testClkOnForReset(void);
  virtual void testELCGPriWakeup(void);
  virtual void testELCGHubmmuWakeup(void);
  virtual void testELCGfecsInterfaceReset(void);
  virtual void testELCGhubmmuInterfaceReset(void);
  virtual void testELCGgpccsInterfaceReset(void);
  virtual void testELCGbecsInterfaceReset(void);
  virtual void testPowerModeInterface(void);
  virtual void testSMCFloorsweep(void);
  virtual void DelayNs(UINT32);
  virtual int InitSetup(void);
  virtual int WritePowerMode(string, UINT32);
protected:
  bool                  test_status_fail;

private:
  ArgReader*            m_params;
  LWGpuChannel*         m_ch;

  UINT32                m_arch;
  Macro                 macros;
  LW_ENGINE_TYPE        eng_type;
  MAXWELL_CLOCK_GATING  maxwell_clock_gating;
  UINT32                n_gpc;
  UINT32                n_fbp;
  UINT32                n_tpc;
  IRegisterMap* m_regMap;
  unsigned long long int    allELCGGatedType;
};

#ifdef MAKE_TEST_LIST
CREATE_TEST_LIST_ENTRY(powerCtrlTest_maxwell, powerCtrlTest_maxwell, "CHIP power management test");
#undef TEST_LIST_HEAD
#define TEST_LIST_HEAD &powerCtrlTest_maxwell_testentry
#endif

#endif // _POWMGMTTEST_H_
