/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2016-2018 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

const char * defaultComputeShader =
    "// -*- mode: C -*- \n"
    "#version 430  // GL version 4.3 assumed \n"
    "#extension GL_ARB_compute_shader: enable \n"
    "#extension GL_ARB_shader_storage_buffer_object: enable \n"
    "#extension GL_LW_shader_thread_group : require \n"
    "#extension GL_ARB_gpu_shader_int64 : enable\n"
    "#extension GL_LW_shader_buffer_load : enable \n"
    "#extension GL_LW_gpu_shader5 : enable \n"
    "// WAR for Bug 2168478 (aka Bug 2315762) \n"
    "// GLSL compiler fails to propagate memory qualifiers from SSBOs to array members.\n"
    " \n"
    "layout(std430, binding=1) volatile coherent buffer SSBO \n"
    "{ \n" //$
    "    uint owner; \n"
    "    uint ownershipChanges; \n"
    "    uint smCountsGraphics[128]; \n"
    "    uint smCountsCompute[128]; \n"
    "}; \n"
    " \n"
    "// Our Cooperative Thread Array (CTA) is 16x16 threads. \n"
    "layout (local_size_x = 16, local_size_y = 16) in; \n"
    "\n"
    "// First half is buffer 0, second half is buffer 1. \n"
    "// Actual size set at runtime when we bind a buffer to slot 0 (arbitrary slot). \n"
    "// Note that std430 is magic, using std140 causes the compute shader \n"
    "// to use only every 4th integer in cells! \n"
    "// adding volatile coherent for B2315762 \n"
    "layout(std430, binding=0) volatile coherent buffer Cells { int cells[]; }; \n"
    "\n"
    "// Generation count, set from glcompute.cpp. \n"
    "uniform int generation; \n"
    "// Time direction: 1 or -1, set from glcompute.cpp. \n"
    "uniform int genStep; \n"
    "// Size of the sim world (not necessarily a multiple of local_size_x). \n"
    "// Set from glcompute.cpp. \n"
    "uniform int simWidthCells; \n"
    "uniform int simHeightCells; \n"
    "// see B2315762 \n"
    "volatile coherent uniform int* pCells;\n"
    "\n"
    "// Handle toriodal wraparound. \n"
    "// We know d will be no more than one cell over the edge of the grid, \n"
    "// but here we handle the range of -max to 2*max-1. \n"
    "int wrap(int d, int max) \n"
    "{ \n"
    "    if (d < 0) \n"
    "        d += max; \n"
    "    else if (d >= max) \n"
    "        d -= max; \n"
    "    return d; \n"
    "} \n"
    "\n"
    "// Colwert an x,y cell index into an offset into cells. \n"
    "int calcIdx(int x, int y) \n"
    "{ \n"
    "    return simWidthCells * wrap(y, simHeightCells) + wrap(x, simWidthCells); \n"
    "} \n"
    "         "
    "// The main compute program does Margolus' \"Critters\" time-reversible cellular \n"
    "// automaton.  This is a little like the more well-known Game of Life, \n"
    "// but is time-reversible so that we can run it backwards to check \n"
    "// for errors colweniently. \n"
    "// \n"
    "// Because Critters is time-reversible, there's no obvious sense that \n"
    "// the image is evolving in any particular direction unless we start from a \n"
    "// low-entropy state with all the live cells in a clump.  The analogy \n"
    "// to the big bang as the source of the \"arrow of time\" in real physics \n"
    "// is entertaining (to me anyway). \n"
    "// \n"
    "// Critters rule: \n"
    "// * Two compute buffers, each a same-size 2D array of ints. \n"
    "//   We wrap left-right and top-bottom edges, so toplogically a torus. \n"
    "// * The low buffer is used for the initial random fill, call it \"generation 0\". \n"
    "// * Each step reads one buffer and writes the other. \n"
    "//   Going forwards in \"time\": \n"
    "//     read gen0 from low, write gen1 to high. \n"
    "//     read gen1 from high, write gen2 to low. \n"
    "//   Going backwards in \"time\": \n"
    "//     read gen2 from low, write gen1 to high. \n"
    "//     read gen1 from high, write gen0 to low. \n"
    "// * The rule is reversible, so we can go from gen0 to genN and then back to \n"
    "//   gen0 and expect to get the original random setup back. \n"
    "// * The rule uses 2x2 blocks of adjacent cells. \n"
    "// * On forwards steps that read from an even generation, \n"
    "//   and backwards steps that write to an even generation, \n"
    "//   the blocks start at even offsets, i.e. cells (0,0 to 1,1) are a block. \n"
    "// * The other steps (forwards from odd, backwards to odd), \n"
    "//   the blocks start at odd  offsets, i.e. cells (1,1 to 2,2) are a block. \n"
    "// * A cell is \"live\" if its value is positive. \n"
    "// * A cell is \"dead\" if its value is negative. \n"
    "// * Going forwards in time,  \n"
    "//     If a block has 2 live cells, it is left unchanged in the new generation. \n"
    "//     If a block has 3 cells, it is reversed 180 degrees and live/dead ilwerted. \n"
    "//     Otherwise the block is live/dead ilwerted. \n"
    "// * Going backwards in time, \n"
    "//     Same rules, except do the 180 rotation for 1 live cells instead of 3. \n"
    "// \n"
    "// To make the sim prettier on-screen we also track the \"age\" of each cell \n"
    "// so the \"travellers\" make streaks on the screen. \n"
    "\n"
    "void main() \n"
    "{ \n"
    "    if (1 != atomicExchange(owner,1)) { \n"
    "        atomicAdd(ownershipChanges,1); \n"
    "    } \n"
    "    atomicAdd(smCountsCompute[gl_SMIDLW],1); \n"
    "    int gX = int(gl_GlobalIlwocationID.x); \n"
    "    int gY = int(gl_GlobalIlwocationID.y); \n"
    "\n"
    "    if ((gX >= simWidthCells) || (gY >= simHeightCells)) \n"
    "    { \n"
    "        // We launch a grid of N 16x16 CTAs, but the sim world can \n"
    "        // be any even width or height.  Some launched threads \n"
    "        // don't get their own cell to write and just exit. \n"
    "        return; \n"
    "    } \n"
    "\n"
    "    // When running the sim forwards in time (genStep == 1): \n"
    "    //  - generation == 0 and all even, read 1st half, write 2nd half \n"
    "    //  - generation == 1 and all odd,  read 2nd half, write 1st half \n"
    "    // When running the sim in reverse (genStep == -1), this is swapped. \n"
    "\n"
    "    const int simCells = simWidthCells * simHeightCells; \n"
    "    const int readBase = (generation & 1) * simCells; \n"
    "    const int writeBase = ((generation + genStep) & 1) * simCells; \n"
    "    const bool readEven = (0 == (generation & 1)); \n"
    "    const bool forwards = (1 == genStep); \n"
    "\n"
    "    // X,Y of upper-left corner of the quad-cell containing this cell. \n"
    "    // Note qX,qY might be out-of-bounds and need wraparound later. \n"
    "    int qX, qY; \n"
    "    if (forwards == readEven) \n"
    "    {   // quads start at even row,column. \n"
    "        // (read even forwards and write even backwards) \n"
    "        qX = bool(gX & 1) ? (gX-1) : gX; \n"
    "        qY = bool(gY & 1) ? (gY-1) : gY; \n"
    "    } \n"
    "    else \n"
    "    {   // quads start at odd row,column.  \n"
    "        // (read odd forwards and write odd backwards) \n"
    "        qX = bool(gX & 1) ? gX : (gX-1); \n"
    "        qY = bool(gY & 1) ? gY : (gY-1); \n"
    "    } \n"
    "\n"
    "    // Read the 4 quad-cells, count the live cells. \n"
    "    int q[2][2]; \n"
    "    q[0][0] = pCells[readBase + calcIdx(qX,   qY)]; \n"
    "    q[0][1] = pCells[readBase + calcIdx(qX+1, qY)]; \n"
    "    q[1][0] = pCells[readBase + calcIdx(qX,   qY+1)]; \n"
    "    q[1][1] = pCells[readBase + calcIdx(qX+1, qY+1)]; \n"
    "    int nLive = \n"
    "        int(q[0][0] > 0) + int(q[1][0] > 0) + \n"
    "        int(q[0][1] > 0) + int(q[1][1] > 0); \n"
    "\n"
    "    // Find this cell's index in q[][], and current value. \n"
    "    int qiX = int(gX != qX); \n"
    "    int qiY = int(gY != qY); \n"
    "    int lwrCell = q[qiY][qiX]; \n"
    "\n"
    "    // Callwlate the new value for this cell. \n"
    "    int newCell; \n"
    "    if (forwards) \n"
    "    { \n"
    "        switch (nLive) \n"
    "        { \n"
    "            case 0: \n"
    "            case 1: \n"
    "            case 4: // ilwert  \n"
    "                newCell = -lwrCell; \n"
    "                break; \n"
    "            case 2: // keep  \n"
    "                newCell = lwrCell; \n"
    "                break; \n"
    "            case 3: // rotate 180 and ilwert \n"
    "                newCell = q[qiX^1][qiY^1]; \n"
    "                newCell = -newCell; \n"
    "                break; \n"
    "        } \n"
    "    } \n"
    "    else \n"
    "    { \n"
    "        switch (nLive) \n"
    "        { \n"
    "            case 0: \n"
    "            case 3: \n"
    "            case 4: // ilwert  \n"
    "                newCell = -lwrCell; \n"
    "                break; \n"
    "            case 2: // keep  \n"
    "                newCell = lwrCell; \n"
    "                break; \n"
    "            case 1: // rotate 180 and ilwert \n"
    "                newCell = q[qiX^1][qiY^1]; \n"
    "                newCell = -newCell; \n"
    "                break; \n"
    "        } \n"
    "    } \n"
    "\n"
    "    // Aging: since most cells ilwert each generation, \"age\" the cell \n"
    "    // when it ilwerts and treat it as \"new\" when it is kept. \n"
    "    if (newCell == -lwrCell) \n"
    "    { \n"
    "        if (newCell > 0) \n"
    "            newCell++; \n"
    "        else \n"
    "            newCell--; \n"
    "    } \n"
    "    else \n"
    "    { \n"
    "        if (newCell > 0) \n"
    "            newCell = 1; \n"
    "        else \n"
    "            newCell = -1; \n"
    "    } \n"
    "\n"
    "    barrier(); \n"
    "    pCells[writeBase + gY * simWidthCells + gX] = newCell; \n"
    "} \n";

const char * defaultVertexShader =
    "// -*- mode: C -*- \n"
    "#version 430 \n"
    "uniform float screenWidth; \n"
    "uniform float screenHeight; \n"
    "uniform int simWidthCells; \n"
    "uniform int simHeightCells; \n"
    "uniform int generation; \n"
    "uniform int genStep; \n"
    " \n"
    "layout(location=0) in vec2 inPosition; \n"
    "layout(location=1) in vec2 inTexCoord; \n"
    " \n"
    "out gl_PerVertex \n"
    "{ \n"
    "    vec4 gl_Position; \n"
    "}; \n"
    "out vxData \n"
    "{ \n"
    "    vec2 texCoord; \n"
    "}; \n"
    " \n"
    "void main() \n"
    "{ \n"
    "    // Generate clip-space position. \n"
    "    // inPosition is in pixels from lower-left, output is in the -1.0 to 1.0 \n"
    "    // scaling, with Y origin at lower.  Force Z to 0 and W to 1.0 to get a \n"
    "    // simple orthographic projection. \n"
    "    vec4 temp; \n"
    "    temp.x = (inPosition.x * (2.0/screenWidth)) - 1.0; \n"
    "    temp.y = (inPosition.y * (2.0/screenHeight)) - 1.0; \n"
    "    temp.z = 0.0; \n"
    "    temp.w = 1.0; \n"
    " \n"
    "    //gl_Position.x = (inPosition.x * (2.0/screenWidth)) - 1.0; \n"
    "    //gl_Position.y = (inPosition.y * (2.0/screenHeight)) - 1.0; \n"
    "    //gl_Position.z = 0.0; \n"
    "    //gl_Position.w = 1.0; \n"
    " \n"
    "    // Pass through the texture coord. \n"
    "    texCoord = inTexCoord; \n"
    " \n"
    "    gl_Position = temp; \n"
    "}\n";

const char * defaultFragmentShader =
    "// -*- mode: C -*- \n"
    "#version 430  // GL version 4.3 assumed \n"
    "#extension GL_LW_shader_thread_group : require \n"
    " \n"
    "layout(std430, binding=1) buffer SSBO { \n"
    "    uint owner; \n"
    "    uint ownershipChanges; \n"
    "    uint smCountsGraphics[128]; \n"
    "    uint smCountsCompute[128]; \n"
    "}; \n"
    " \n"
    "uniform float screenWidth; \n"
    "uniform float screenHeight; \n"
    "uniform int simWidthCells; \n"
    "uniform int simHeightCells; \n"
    "uniform int generation; \n"
    "uniform int genStep; \n"
    " \n"
    "// Must match declaration in vertex shader \n"
    "in vxData \n"
    "{ \n"
    "    vec2 texCoord; \n"
    "}; \n"
    " \n"
    "// This output will go to COLOR_ATTACHMENT0 because of location=0. \n"
    "layout(location=0) out vec4 outFragmentColor; \n"
    " \n"
    "layout(std430, binding=0) buffer Cells { int cells[]; }; \n"
    " \n"
    "// Textures for live and dead cells. \n"
    "uniform sampler2D live; \n"
    "uniform sampler2D dead; \n"
    " \n"
    "void main() \n"
    "{ \n"
    "    if (2 != atomicExchange(owner,2)) { \n"
    "        atomicAdd(ownershipChanges,1); \n"
    "    } \n"
    "    atomicAdd(smCountsGraphics[gl_SMIDLW],1); \n"
    "    const int readBase = (generation & 1) * simWidthCells * simHeightCells; \n"
    " \n"
    "    // Read our value from the sim-world array. \n"
    "    const int cellX = clamp(int(texCoord.x), 0, simWidthCells); \n"
    "    const int cellY = clamp(int(texCoord.y), 0, simHeightCells); \n"
    "    const int simCell = cells[readBase + cellX + cellY * simWidthCells]; \n"
    " \n"
    "    const bool  cellLive = (simCell > 0) == (readBase == 0); \n"
    "    const float cellAge  = log2(abs(float(simCell))); \n"
    " \n"
    "    vec4 color; \n"
    "     "
    "    // Cell value is \"generations alive\" for live cells and \n"
    "    // zero minus \"generations dead\" for dead cells. \n"
    "    // Use the live/dead value to choose a texture. \n"
    "    // Use the generations alive/dead to pick a color. \n"
    "    if (int(simCell > 0) != (generation & 1)) \n"
    "    { \n"
    "        // \"live\" cell, green turning more yellow with age. \n"
    "        color = vec4(0.50, 0.9, 0.50, 1.0) + \n"
    "            vec4(0.02, 0.0, 0.02, 0.0) * cellAge; \n"
    "        color *= texture(live, fract(texCoord)); \n"
    "    } \n"
    "    else \n"
    "    { \n"
    "        // \"dead\" cell, red turning darker with age. \n"
    "        color = vec4(1.00, 0.50, 0.50, 1.0) - \n"
    "            vec4(0.1, 0.1, 0.1, 0.0) * cellAge; \n"
    "        color *= texture(dead, fract(texCoord)); \n"
    "    } \n"
    "    outFragmentColor = color; \n"
    "}\n";

