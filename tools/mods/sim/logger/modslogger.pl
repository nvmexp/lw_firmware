#!/home/utils/perl-5.20/5.20.1-008/bin/perl

#
# LWIDIA_COPYRIGHT_BEGIN
#
# Copyright 2017-2021 by LWPU Corporation.  All rights reserved.  All
# information contained herein is proprietary and confidential to LWPU
# Corporation.  Any use, reproduction, or disclosure without the written
# permission of LWPU Corporation is prohibited.
#
# LWIDIA_COPYRIGHT_END
#-------------------------------------------------------------------------------

use strict;

# redirect any output of mods logger into modslogger.out
open(STDOUT, '>', ".modslogger.log") or die "Can't redirect STDOUT: $!";
open(STDERR, ">&STDOUT") or die "Can't dup STDOUT: $!";
use IO::Handle;
STDERR->autoflush(1);
STDOUT->autoflush(1);

use FindBin;                                # locate this script
use File::Basename;
use Cwd;

# load MODS Logger
use lib "$FindBin::RealBin";         # the directory of logger lib
use ModsLogger;
use Data::Dumper;
use Getopt::Long;

# for LWDataflow
use FindBin;
use lib ('/home/lw/utils/gpuwa/client-api/1.0/lib/perl5', '/home/lw/lib/perl5', '/home/lw/utils/lwperl/1.3/lib/perl5');
use LW::GPUWA::Dataflow::RestClient;

use Const::Fast;
const my $DEBUGMODE => 0;

# configuration for ModsLogger
my %options = (
                'chipLog'           =>  1,
                'userLog'           =>  1,
                'runTimeLog'        =>  1,
                'errorLog'          =>  1,
                'argsLog'           =>  1,
                'timeProfileLog'    =>  1,
               );

my %AllowList = (
        'model'     =>      ['amod', 'cmod', 'fmod', 'multifmod', 'vmod'],
        'chip'      =>      ['gb.*', 'ad.*', 'gh.*', 'tu.*', 'gv.*', 'ga.*', 'g000', 'gp.*', 'gm.*', 'gk.*', 'gf.*',
                             't25*', 't23*', 't19*'],
    );

my $modslogger;

my $startTime = time;


my ($simPerlExitNormally, $rc, $model, $chip, $remoteFlag, $cmdline, $msg, $metadata) =
    (undef, undef, undef, undef, undef, undef, undef, undef);

print STDOUT "MODS Logger cmd:@ARGV\n";

GetOptions ('simPerlExitNormally=i'   => \$simPerlExitNormally, 
            'rc=i'                    => \$rc,
            'model=s'                 => \$model,
            'chip=s'                  => \$chip,
            'remoteFlag=i'            => \$remoteFlag,
            'msg=s'                   => \$msg,
            'metadata=s'              => \$metadata,
            );

my %lwrrentOpts = (
        'model'     =>      $model,
        'chip'      =>      $chip,
    );

my $filterArgsFlag = 1;

eval {
    foreach my $key (keys %lwrrentOpts) {
        if (not defined $lwrrentOpts{$key}) {
            $filterArgsFlag = 0;
            last;
        }
    }

    # Get command line from command.sh or .command.txt, they are generated by sim.pl
    # 1. check which file exist.
    my $commandFileName = "command.sh";
    if(not (-e $commandFileName)) {
        if(-e ".command.txt") {
            $commandFileName = ".command.txt";
        } else {
            warn "\nCould not find $commandFileName!\n";
        }
    }
    # 2. read command line from command.sh or .command.txt
    if (open(my $cmdFH, '<', $commandFileName)) {
        $cmdline = <$cmdFH>;
        close $cmdFH;
    } else {
        die "\nCould not open $commandFileName:$!\n";
    }

    # if current test uses dispatch, get real $cmdline
    if ($cmdline =~ m/dispatch/g) {
        print STDOUT "\nDispatch Used, getting real \$cmdline\n" if ($DEBUGMODE);
        if ($cmdline =~ /.*-tstFile (\S*) .*/) {
            my $tstFileDir;
            $tstFileDir = $1;
            print STDOUT "\nDispatch Test File Directory: $tstFileDir" if ($DEBUGMODE);
            $cmdline = getRealCmdline($tstFileDir);
        } else {
            print STDOUT "\nNo Dispatch File Found\n" if ($DEBUGMODE);
        }
    }
    
    # remove all single/double quote, multiple nested quotes may cause problems for regex match.
    $cmdline =~ s/'//g;
    $cmdline =~ s/"//g;

    print STDOUT "Post-processed MODS Logger cmd: $cmdline\n" if ($DEBUGMODE);

    if ($filterArgsFlag) {
        exit(0) if filterTests();
    }

    if ($simPerlExitNormally) {
        $cmdline =~ s/'//g;

        if ($cmdline =~ m/mdiag.js/g) {
            my %attributes = (
                'cmdline'    => $cmdline,
                'rc'         => $rc,
                'model'      => $model,
                'chip'       => $chip,
                'remoteFlag' => $remoteFlag,
                'metadata'   => $metadata,
            );
            $modslogger = ModsLogger->new (\%options, $DEBUGMODE, \%attributes);
            $modslogger->start();
        } else {
            warn "\nNo mdiag.js, current Test is not needed\n" if ($DEBUGMODE);
            printDuration($startTime) if $DEBUGMODE;
            exit(0);
        }
    } else {
        # input $msg not checked
        $rc = 0;
        my $failureType = "mods does not run";
        $msg =~ s/'//g;

        my %attributes = (
            'rc'          => $rc,
            'msg'         => $msg,
            'failureType' => $failureType,
        );
        $modslogger = ModsLogger->new (\%options, $DEBUGMODE, \%attributes);
        $modslogger->reportInternalError();
    }

    if ($DEBUGMODE) {
        printDuration($startTime);
    }

};

# if eval capture a error of exelwtion
if ($@) {
    my $errorLogName = './.modslogger.log';
    if (-e $errorLogName) {
        open(my $fh, '<', $errorLogName);
        my $errText = '';
        while ( my $line = <$fh> ) {
            $errText .= $line;
        }
        close $fh;
        my @errLogArray;
        my %errLogHash = ();
        $errLogHash{'text_errorLog'} = $errText . "\n**** ERROR or WARN Message of MODS Logger ****\n" . $@;

        # get id for current test
        my $cwd = getcwd();
        my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
        $year += 1900;  # transfer to normal year
        $mon += 1;      # transfer to 1-12
        $errLogHash{'s_test_id'} = "$cwd-$year$mon$mday$hour$min$sec";
        $errLogHash{'s_test_dir'} = "$cwd";

        # set other basic entry attributes
        $errLogHash{'s_docType'} = 'Internal Crash Report';

        # prepare to post to LWDataFlow
        push @errLogArray, \%errLogHash;

        warn "\nEncountered error during eval. Posting status...\n";
        ModsLogger->postDataToLwDataflow(@errLogArray);
        warn "\nDone.\n";
    } 
}

sub getRealCmdline{
    my $tstFileDir = shift;
    my $realCmdline = '';
    if (open(my $ifh, '<', $tstFileDir)) {
        # read first line
        my $line = <$ifh>;
        # read second line, where real $cmdline is
        $realCmdline = <$ifh>;
        close $ifh;
    } else {
        die "\nCould not open $tstFileDir file!";
    }
    return $realCmdline;
}

sub printDuration{
    my $startTime = shift;
    my $duration = time - $startTime;
    print STDOUT "\nMODS Logger: Duration " . $duration . " sec.\n";
}

sub filterTests(){
    my $notInAllowList = 1;
    foreach my $key (keys %AllowList) {
        if (exists $lwrrentOpts{$key}) {
            $notInAllowList = 1;
            foreach my $value (@{$AllowList{$key}}) {
                if ($lwrrentOpts{$key} =~ /$value/) {
                    $notInAllowList = 0;
                    last;
                }
            }
            if ($notInAllowList) {
                warn "\nLwrrent Test is not needed\n" if ($DEBUGMODE);
                printDuration($startTime) if $DEBUGMODE;
                return $notInAllowList;
            }
        }
    }

    return $notInAllowList;
}

exit 0;
