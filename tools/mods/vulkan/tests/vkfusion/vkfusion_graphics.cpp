/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2021-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#include "vkfusion_graphics.h"
#include "core/include/imagefil.h"
#include "core/utility/ptrnclss.h"
#include "vulkan/vkbuffer.h"
#include "vulkan/vkimage.h"
#include "vulkan/vkfence.h"
#include "vulkan/shared_sources/lwmath/lwmath.h"

namespace
{
    using vec2 = lwmath::vec2f;
    using vec3 = lwmath::vec3f;
    using vec4 = lwmath::vec4f;
    using mat3 = lwmath::mat3f;
    using mat4 = lwmath::mat4f;
    using quat = lwmath::quatf;

    struct Vertex
    {
        vec3 pos;
        vec3 normal;
        vec2 texCoord;
    };

    constexpr UINT32 maxLights = 32;
    struct UniformData
    {
        mat4 modelViewProj;
        mat4 modelView; // For Blinn-Phong spelwlar and rotation of normals
        vec4 lights[maxLights];
    };
}

// Vertex shader used for geometry generated on the CPU
static const char* const s_VertexShader = HS_(R"glsl(
    #version 460 core

    layout(location = 0) in  vec3 pos;
    layout(location = 1) in  vec3 normal;
    layout(location = 2) in  vec2 texCoord;
    layout(location = 0) out vec3 outPos;
    layout(location = 1) out vec3 outNormal;
    layout(location = 2) out vec2 outTexCoord;

    layout(set = 0, binding = 0) uniform UniformData
    {
        mat4 modelViewProj;
        mat4 modelView;
        vec4 lights[];
    };

    void main()
    {
        gl_Position = modelViewProj * vec4(pos, 1);
        outPos      = (modelView * vec4(pos, 1)).xyz;
        // Use modelView matrix directly without ilwerse transpose.
        // We don't need ilwerse transpose since all scaling we have is uniform.
        outNormal   = mat3(modelView) * normal;
        outTexCoord = texCoord;
    }
)glsl");

// Vertex shader used for tessellated geometry
//
// The magic happens in the tessellation evaluation shader.
//
// We don't use input vertices, so there's nothing to pass between vertex
// shader and tessellation evaluation shader.  Vertices are generated by
// the tessellation evaluation shader from gl_TessCoord.xy which are
// the coefficients of the patch.
static const char* const s_TessellatedVertexShader = HS_(R"glsl(
    #version 460 core

    void main()
    {
    }
)glsl");

// The tessellation control shaders runs only once, because we need to set
// the tessellation parameters only once.
// The patch is tessellated into an equal amount of quads both
// on the inside and on the outside, so we get a uniform grid.
static const char* const s_TessellationControlShader = HS_(R"glsl(
    #version 460 core

    // The torus consists of a single quad patch, with 4 vertices for the quad.
    // This quad is then tessellated and formed into a torus.
    layout(vertices = 4) out;

    layout(constant_id = 0) const uint numRibs    = 1;
    layout(constant_id = 1) const uint vtxPerRib  = 1;
    layout(constant_id = 2) const uint torusMajor = 1;

    void main()
    {
        if (gl_IlwocationID == 0)
        {
            const uint width  = torusMajor == 0 ? numRibs : vtxPerRib;
            const uint height = torusMajor == 0 ? vtxPerRib : numRibs;

            gl_TessLevelOuter[0] = height;
            gl_TessLevelOuter[1] = width;
            gl_TessLevelOuter[2] = height;
            gl_TessLevelOuter[3] = width;

            gl_TessLevelInner[0] = width;
            gl_TessLevelInner[1] = height;
        }
    }
)glsl");

// The tessellation evaluation shader generates vertices on the torus in the same way
// SetupGeometry() does on the CPU and then applies transforms in the same way
// the normal vertex shader does.
static const char* const s_TessellationEvaluationShader = HS_(R"glsl(
    #version 460 core

    layout(quads, cw) in;

    layout(location = 0) out vec3 outPos;
    layout(location = 1) out vec3 outNormal;
    layout(location = 2) out vec2 outTexCoord;

    layout(constant_id = 0) const float majorR     = 1;
    layout(constant_id = 1) const float minorR     = 0.25;
    layout(constant_id = 2) const uint  torusMajor = 1;

    layout(set = 0, binding = 0) uniform UniformData
    {
        mat4 modelViewProj;
        mat4 modelView;
        vec4 lights[];
    };

    // [z'] = [ cosA, -sinA ] * [z]
    // [y']   [ sinA, cosA  ]   [y]
    vec3 RotateAroundX(vec3 v, float sinAngle, float cosAngle)
    {
        return vec3(v.x,
                    sinAngle * v.z + cosAngle * v.y,
                    cosAngle * v.z - sinAngle * v.y);
    }

    // [x'] = [ cosA, -sinA ] * [x]
    // [z']   [ sinA, cosA  ]   [z]
    vec3 RotateAroundY(vec3 v, float sinAngle, float cosAngle)
    {
        return vec3(cosAngle * v.x - sinAngle * v.z,
                    v.y,
                    sinAngle * v.x + cosAngle * v.z);
    }

    void main()
    {
        const float cx       = torusMajor == 0 ? gl_TessCoord.x : gl_TessCoord.y;
        const float cy       = torusMajor == 0 ? gl_TessCoord.y : 1 - gl_TessCoord.x;
        const float twoPi    = 6.28318530718;
        const float ribAngle = cx * twoPi;
        const float vtxAngle = cy * twoPi;
        const float sinRib   = sin(ribAngle);
        const float cosRib   = cos(ribAngle);
        const float silwtx   = sin(vtxAngle);
        const float cosVtx   = cos(vtxAngle);

        vec3 pointOnMinorCircle = RotateAroundX(vec3(0, 0, -minorR), silwtx, cosVtx);
        pointOnMinorCircle.z += majorR;

        const vec3 pos = RotateAroundY(pointOnMinorCircle, sinRib, cosRib);

        const vec3 normal = RotateAroundY(RotateAroundX(vec3(0, 0, -1), silwtx, cosVtx),
                                          sinRib, cosRib);

        gl_Position = modelViewProj * vec4(pos, 1);
        outPos      = (modelView * vec4(pos, 1)).xyz;
        // Use modelView matrix directly without ilwerse transpose.
        // We don't need ilwerse transpose since all scaling we have is uniform.
        outNormal   = mat3(modelView) * normal;
        outTexCoord = vec2(cx * 2, cy);
    }
)glsl");

// Note: USE_ray_query is modified to be 0 if ray tracing is disabled
static const char* const s_FragmentShader = HS_(R"glsl(
    #version 460 core
    #extension GL_EXT_ray_query : require
    #define USE_ray_query 1

    layout(location = 0) in  vec3 pos;      // Pixel position in view space
    layout(location = 1) in  vec3 normal;   // Normal in view space
    layout(location = 2) in  vec2 texCoord; // Texture coordinates
    layout(location = 0) out vec4 outColor;

    // numSamplers and numTextures must be >= 1, because they are used
    // for array sizes, so if we want to read 0 textures, we need to keep
    // a separate variable for that.
    layout(constant_id = 0) const uint numTexReads = 1;
    layout(constant_id = 1) const uint numSamplers = 1;
    layout(constant_id = 2) const uint numTextures = 1;
    layout(constant_id = 3) const uint numDraws    = 1;
    layout(constant_id = 4) const uint numLights   = 1;
    layout(constant_id = 5) const uint numRays     = 0;
    layout(constant_id = 6) const uint rtXMask     = 0;

    layout(set = 0, binding = 0) uniform UniformData
    {
        mat4 modelViewProj;
        mat4 modelView;
        vec4 lights[numLights > 0 ? numLights : 1];
    };
    layout(set = 0, binding = 1) uniform sampler   samplers[numSamplers];
    layout(set = 0, binding = 2) uniform texture2D textures[numTextures];

    float CalcLighting(vec3 lightPos, vec3 surfacePos, vec3 surfaceNormal)
    {
        const float shininess     = 16;
        const float ambient       = 0.1;
        const vec3  lightDir      = lightPos - surfacePos;
        const float lightDistance = length(lightDir);
        const vec3  normLightDir  = lightDir / lightDistance;
        const float diffuse       = max(0, dot(surfaceNormal, normLightDir));
        float       spelwlar      = 0;

        // Blinn-Phong spelwlar
        if (diffuse > 0)
        {
            const vec3  viewDir = normalize(-surfacePos); // Eye is at [0, 0, 0] in view space
            const vec3  halfDir = normalize(lightDir + viewDir);
            const float specCos = max(0, dot(halfDir, surfaceNormal));
            spelwlar            = pow(specCos, shininess);
        }

        return ambient + diffuse + spelwlar;
    }

#if USE_ray_query
    layout(set = 0, binding = 3) uniform accelerationStructureEXT scene;

    // Traces a ray through 'scene' and returns t (intersection distance)
    float IntersectRay(vec3 rayOrigin, vec3 rayDirection)
    {
        rayQueryEXT rayQuery;
        rayQueryInitializeEXT(rayQuery,
                              scene,
                              gl_RayFlagsOpaqueEXT,
                              0xFF,         // lwllMask
                              rayOrigin,
                              0.001,        // tMin
                              rayDirection,
                              10000);       // tMax

        while (rayQueryProceedEXT(rayQuery))
        {
        }

        if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
        {
            return rayQueryGetIntersectionTEXT(rayQuery, true);
        }
        else
        {
            return 0;
        }
    }

    // Determines whether rays should be traced for the current pixel
    bool ShouldTraceRay()
    {
        if (rtXMask == 0)
        {
            return true;
        }

        return (uint(gl_FragCoord.x) & rtXMask) == 0;
    }
#endif

    void main()
    {
        // Gamma value to make the image brighter
        const float gamma = 2.2;

        // Read color from textures
        vec3 baseColor;
        if (numTexReads > 0)
        {
            vec4 aclwmColor = vec4(0, 0, 0, 1);
            for (uint iRead = 0; iRead < numTexReads; iRead++)
            {
                const uint sampId   = iRead % numSamplers;
                const uint texId    = iRead % numTextures;
                const vec4 texColor = texture(sampler2D(textures[texId], samplers[sampId]),
                                              texCoord);

                aclwmColor = mix(aclwmColor, texColor, texColor.w);
            }

            baseColor = aclwmColor.xyz;
        }
        else
        {
            // Use texture coordinates as color RG, use Z value as B
            baseColor = vec3(texCoord, gl_FragCoord.z);
        }

        // Callwlate attenuation from all lights
        float colorAtten = 1;
        float rayAtten   = 0;
        uint  hitRays    = 0;
        if (numLights > 0)
        {
            colorAtten = 0;
            for (uint i = 0; i < numLights; i++)
            {
                // Light positions are in view space
                const vec3 lightPos = lights[i].xyz;
                colorAtten += CalcLighting(lightPos, pos, normal);
            }
            if (numLights > 1)
            {
                colorAtten /= numLights;
            }
        }

        const vec3 litColor = baseColor * colorAtten;

        // Apply gamma correction
        outColor = vec4(pow(litColor, vec3(1 / gamma)) / numDraws, 1);

#if USE_ray_query
        if (ShouldTraceRay())
        {
            for (uint i = 0; i < numRays; i++)
            {
                const float t = IntersectRay(pos, vec3(0, 0, -1));
                if (t > 0 && t < 1000)
                {
                    rayAtten += t;
                    ++hitRays;
                }
            }
        }

        if (hitRays > 0)
        {
            rayAtten = (rayAtten / hitRays - 0.5) / (5 * numDraws);
        }
        outColor.b = rayAtten;
#endif
    }
)glsl");

// Vertex shader used for comparing images
static const char* const s_ErrorCountVertexShader = HS_(R"glsl(
    #version 460 core

    layout(location = 0) out vec2 outTexCoord;

    // Two triangles making up a quad which precisely covers the entire color attachment
    vec2 trianglePositions[6] = vec2[](
        vec2(-1,  1),
        vec2(-1, -1),
        vec2( 1, -1),
        vec2( 1, -1),
        vec2( 1,  1),
        vec2(-1,  1)
    );

    // Texture coordinates which map each pixel in the source images to one pixel
    // in the color attachment
    vec2 texCoords[6] = vec2[](
        vec2(0, 1),
        vec2(0, 0),
        vec2(1, 0),
        vec2(1, 0),
        vec2(1, 1),
        vec2(0, 1)
    );

    void main()
    {
        gl_Position = vec4(trianglePositions[gl_VertexIndex], 0, 1);
        outTexCoord = texCoords[gl_VertexIndex];
    }
)glsl");

// Fragment shader used for comparing images
static const char* const s_ErrorCountFragmentShader = HS_(R"glsl(
    #version 460 core

    layout(location = 0) in  vec2 texCoord;
    layout(location = 0) out vec4 outColor;

    layout(set = 0, binding = 0) uniform sampler   samplero;
    layout(set = 0, binding = 1) uniform texture2D textures[2];

    float CompareComponent(float a, float b)
    {
        // We use 16-bit UNORM as error counter
        const float error = 1.0 / 65536.0;

        return (a == b) ? 0 : error;
    }

    void main()
    {
        const vec4 img1Color = texture(sampler2D(textures[0], samplero), texCoord);
        const vec4 img2Color = texture(sampler2D(textures[1], samplero), texCoord);

        if (img1Color == img2Color)
        {
            discard;
        }

        outColor.r = CompareComponent(img1Color.r, img2Color.r);
        outColor.g = CompareComponent(img1Color.g, img2Color.g);
        outColor.b = CompareComponent(img1Color.b, img2Color.b);
        outColor.a = CompareComponent(img1Color.a, img2Color.a);
    }
)glsl");

VkFusion::Graphics::Graphics()
: Subtest("Graphics", 16)
{
}

VkFusion::QueueCounts VkFusion::Graphics::GetRequiredQueues() const
{
    QueueCounts counts = { 1, 0, 0 };
    return counts;
}

VkFusion::ExtensionList VkFusion::Graphics::GetRequiredExtensions() const
{
    if (m_RaysPerPixel)
    {
        static const char* const extensions[] =
        {
            "VK_KHR_deferred_host_operations", // required by VK_KHR_acceleration_structure
            "VK_KHR_acceleration_structure",   // required by VK_KHR_ray_query
            "VK_KHR_ray_query",                // Raytracing extension
            "VK_EXT_blend_operation_advanced"  // XOR blending
        };

        ExtensionList list = { extensions, static_cast<UINT32>(NUMELEMS(extensions)) };
        return list;
    }
    else
    {
        static const char* const extensions[] =
        {
            "VK_EXT_blend_operation_advanced"  // XOR blending
        };

        ExtensionList list = { extensions, static_cast<UINT32>(NUMELEMS(extensions)) };
        return list;
    }
}

RC VkFusion::Graphics::Setup()
{
    if (m_DrawsPerFrame == 0)
    {
        Printf(Tee::PriError, "DrawsPerFrame is 0 but must be at least 1\n");
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_GeometryType > geomTessellation)
    {
        Printf(Tee::PriError, "Invalid value %u for GeometryType testarg\n", m_GeometryType);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_TexSize == 0)
    {
        Printf(Tee::PriError, "Invalid value 0 for TexSize testarg\n");
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_SurfaceWidth < 64 || m_SurfaceHeight < 64)
    {
        Printf(Tee::PriError, "Invalid surface dimensions %ux%u, each dimension must be at least 64\n",
               m_SurfaceWidth, m_SurfaceHeight);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_SurfaceBits != 0 && m_SurfaceBits != 32 && m_SurfaceBits != 64)
    {
        Printf(Tee::PriError, "Invalid SurfaceBits %u, can be 0, 32 or 64\n", m_SurfaceBits);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_NumVertices < 32 || m_NumVertices > 4 * 1024 * 1024)
    {
        Printf(Tee::PriError, "NumVertices %u is out of range [32, %u]\n",
               m_NumVertices, 4 * 1024 * 1024);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if (m_NumLights > maxLights)
    {
        Printf(Tee::PriError, "NumLights %u exceeds maximum %u\n", m_NumLights, maxLights);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    constexpr UINT32 minTLASWidth = 2;
    if (m_RTTLASWidth < minTLASWidth)
    {
        Printf(Tee::PriError, "RTTLASWidth %u is too small, must be at least %u\n",
               m_RTTLASWidth, minTLASWidth);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    if ((m_RTTLASWidth & 1) != 0)
    {
        Printf(Tee::PriError, "RTTLASWidth %u is not an even number\n", m_RTTLASWidth);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }
    constexpr UINT32 maxRTXMask = 255;
    if (m_RTXMask > maxRTXMask)
    {
        Printf(Tee::PriError, "RTXMask is %u but should be in range from 0 to %u inclusive\n",
               m_RTXMask, maxRTXMask);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }

    m_VtxPerRib = static_cast<UINT32>(sqrt(m_NumVertices / 2));
    VerbosePrintf("Graphics: Using %u vertices per torus rib\n", m_VtxPerRib);

    // Get raytracing properties from physical device
    if (m_RaysPerPixel)
    {
        VkPhysicalDeviceAccelerationStructurePropertiesKHR asProperties = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR };
        VkPhysicalDeviceProperties2KHR props2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR };
        props2.pNext = &asProperties;
        m_pVulkanInst->GetPhysicalDeviceProperties2KHR(m_pVulkanDev->GetPhysicalDevice()->GetVkPhysicalDevice(),
                                                       &props2);
        m_ASProperties = asProperties;
    }

    m_Random.SeedRandom(m_RandomSeed ^ 0x75392CA2u); // Unique seed for this subtest

    RC rc;

    // Setup command buffer pool
    m_CmdPool = VulkanCmdPool(m_pVulkanDev);
    MASSERT(m_Queues.size() == 1);
    CHECK_VK_TO_RC(m_CmdPool.InitCmdPool(m_Queues[0].family, m_Queues[0].idx));

    // Create auxiliary/temporary command buffer for setup functions
    VulkanCmdBuffer auxCmdBuf(m_pVulkanDev);
    CHECK_VK_TO_RC(auxCmdBuf.AllocateCmdBuffer(&m_CmdPool));

    m_Jobs.resize(m_NumJobs);

    CHECK_RC(SetupSwapChain());
    CHECK_RC(SetupDepthImages(auxCmdBuf));
    CHECK_RC(SetupGoldenImages(auxCmdBuf));
    CHECK_RC(SetupGeometry(auxCmdBuf));
    CHECK_RC(SetupRTGeometry(auxCmdBuf));
    CHECK_RC(SetupRenderPasses());
    CHECK_RC(SetupFrameBuffers());
    CHECK_RC(SetupSamplers());
    CHECK_RC(SetupTextures(auxCmdBuf));
    CHECK_RC(SetupPipeline(auxCmdBuf));
    CHECK_RC(SetupTransforms(auxCmdBuf));
    CHECK_RC(SetupErrorCounter(auxCmdBuf));

    m_StatsQuery = VulkanQuery(m_pVulkanDev);
    CHECK_VK_TO_RC(m_StatsQuery.Init(VK_QUERY_TYPE_PIPELINE_STATISTICS,
                                     static_cast<UINT32>(m_Jobs.size()) * m_DrawsPerFrame,
                                     VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_ILWOCATIONS_BIT));

    for (UINT32 jobId = 0; jobId < m_Jobs.size(); jobId++)
    {
        CHECK_RC(SetupJob(auxCmdBuf, jobId));
    }

    return RC::OK;
}

RC VkFusion::Graphics::Cleanup()
{
    StickyRC rc;

    m_Jobs.clear();
    m_CmdPool.DestroyCmdPool();
    m_DrawPipeline.Cleanup();
    m_ErrorCountPipeline.Cleanup();
    m_FrameBuffers.clear();
    m_ErrorCountFrameBuffer.Cleanup();
    m_DrawRenderPass.Cleanup();
    m_ClearRenderPass.Cleanup();
    m_ErrorCountRenderPass.Cleanup();
    m_RT.builder.Cleanup();
    m_VertexBuf.Cleanup();
    m_IndexBuf.Cleanup();
    m_UniformDataBuf.Cleanup();
    rc = m_DrawDescriptorInfo.Cleanup();
    rc = m_ErrorCountDescriptorInfo.Cleanup();
    m_ErrorCountSampler.Cleanup();
    m_Samplers.clear();
    m_Textures.clear();
    m_ErrorCountImage.Cleanup();
    m_StatsQuery.Cleanup();
    m_DepthImages.clear();
    m_pSwapChain.reset(nullptr);
    m_PresentFence.Cleanup();
    return rc;
}

RC VkFusion::Graphics::SetupSwapChain()
{
    MASSERT(m_Queues.size() == 1);
    RC rc;

    static const struct
    {
        VkFormat    format;
        const char* name;
        UINT32      bits;
    } formats[] =
    {
        { VK_FORMAT_R16G16B16A16_UNORM,       "R16G16B16A16_UNORM",  64 },
        { VK_FORMAT_R16G16B16A16_SFLOAT,      "R16G16B16A16_SFLOAT", 64 },
        { VK_FORMAT_A2R10G10B10_UNORM_PACK32, "A2R10G10B10_UNORM",   32 },
    };

    vector<VkFormat> requestedFormats;
    const UINT32 mask = m_SurfaceBits ? m_SurfaceBits : (32u | 64u);
    for (const auto& fmt : formats)
    {
        if (mask & fmt.bits)
        {
            requestedFormats.push_back(fmt.format);
        }
    }

#ifdef VULKAN_STANDALONE_KHR
    if (!m_bModsSwapChain)
    {
        m_PresentFence = VulkanFence(m_pVulkanDev);
        CHECK_VK_TO_RC(m_PresentFence.CreateFence());

        unique_ptr<SwapChainKHR> pSwapChain = make_unique<SwapChainKHR>(m_pVulkanInst, m_pVulkanDev);
        pSwapChain->SetPreferredFormats(move(requestedFormats));
        pSwapChain->SetImageUsage(VK_IMAGE_USAGE_SAMPLED_BIT);
        CHECK_VK_TO_RC(pSwapChain->Init(m_HInstance,
                                        m_HWindow,
                                        SwapChain::MULTI_IMAGE_MODE,
                                        m_PresentFence.GetFence(),
                                        m_Queues[0].family,
                                        m_Queues[0].idx));
        m_pSwapChain = move(pSwapChain);

        const UINT32 swapChainWidth  = m_pSwapChain->GetSwapChainExtent().width;
        const UINT32 swapChainHeight = m_pSwapChain->GetSwapChainExtent().height;

        if ((swapChainWidth != m_SurfaceWidth) || (swapChainHeight != m_SurfaceHeight))
        {
            VerbosePrintf("Graphics: Adjusting surface dimensions from %ux%u to %ux%u to match swapchain\n",
                          m_SurfaceWidth, m_SurfaceHeight,
                          swapChainWidth, swapChainHeight);
            m_SurfaceWidth  = swapChainWidth;
            m_SurfaceHeight = swapChainHeight;
        }

        for (Job& job : m_Jobs)
        {
            job.swapSema = VulkanSemaphore(m_pVulkanDev);
            CHECK_VK_TO_RC(job.swapSema.CreateBinarySemaphore());

            job.waitSema = VulkanSemaphore(m_pVulkanDev);
            CHECK_VK_TO_RC(job.waitSema.CreateBinarySemaphore());
        }
    }
    else
#endif
    {
        unique_ptr<SwapChainMods> pSwapChain = make_unique<SwapChainMods>(m_pVulkanInst, m_pVulkanDev);
        pSwapChain->SetPreferredFormats(move(requestedFormats));
        pSwapChain->SetImageUsage(VK_IMAGE_USAGE_SAMPLED_BIT);
        CHECK_VK_TO_RC(pSwapChain->Init(m_SurfaceWidth,
                                        m_SurfaceHeight,
                                        SwapChain::SINGLE_IMAGE_MODE,
                                        m_Queues[0].family,
                                        m_Queues[0].idx));
        m_pSwapChain = move(pSwapChain);
    }

    const VkFormat format    = m_pSwapChain->GetSwapChainImage(0)->GetFormat();
    const char*    formatStr = nullptr;
    UINT32         bits      = 0;
    for (const auto& fmt : formats)
    {
        if (format == fmt.format)
        {
            formatStr = fmt.name;
            bits      = fmt.bits;
            break;
        }
    }
    string storage;
    if (formatStr == nullptr)
    {
        const ColorUtils::Format cFormat = VkUtil::ColorUtilsFormat(format);

        storage   = ColorUtils::FormatToString(cFormat);
        formatStr = storage.c_str();
        bits      = ColorUtils::PixelBytes(cFormat) * 8;
    }
    if (m_DrawsPerFrame == defaultDrawsPerFrame)
    {
        m_DrawsPerFrame = (bits == 64) ? 256 : 4;
        VerbosePrintf("Graphics: Using DrawsPerFrame %u\n", m_DrawsPerFrame);
    }
    VerbosePrintf("Graphics: Using render target format %s\n", formatStr);

    return RC::OK;
}

RC VkFusion::Graphics::SetupDepthImages(VulkanCmdBuffer& auxCmdBuf)
{
    m_DepthImages.resize(m_pSwapChain->GetNumImages());

    for (VulkanImage& depthImage : m_DepthImages)
    {
        depthImage = VulkanImage(m_pVulkanDev);
        RC rc;
        CHECK_VK_TO_RC(AllocateImage(&depthImage,
                                     VK_FORMAT_D24_UNORM_S8_UINT,
                                     m_SurfaceWidth,
                                     m_SurfaceHeight,
                                     1, // mipmapLevels
                                     VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |
                                         VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
                                     VK_IMAGE_TILING_OPTIMAL,
                                     VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));
        CHECK_VK_TO_RC(depthImage.SetImageLayout(&auxCmdBuf,
                                                 depthImage.GetImageAspectFlags(),
                                                 VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                                 VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
                                                 VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT));
    }

    return RC::OK;
}

RC VkFusion::Graphics::SetupGoldenImages(VulkanCmdBuffer& auxCmdBuf)
{
    RC rc;

    for (Job& job : m_Jobs)
    {
        job.goldenImage = VulkanImage(m_pVulkanDev);

        CHECK_VK_TO_RC(AllocateImage(&job.goldenImage,
                                     m_pSwapChain->GetSurfaceFormat(),
                                     m_SurfaceWidth,
                                     m_SurfaceHeight,
                                     1, // mipmapLevels
                                     VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,
                                     VK_IMAGE_TILING_OPTIMAL,
                                     VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));
    }

    return RC::OK;
}

RC VkFusion::Graphics::SetupGeometry(VulkanCmdBuffer& auxCmdBuf)
{
    if (m_GeometryType != geomVertexBuffer)
    {
        return RC::OK;
    }

    UINT32 numVertices = 0;
    return GenerateTorus(auxCmdBuf,
                         m_VtxPerRib,
                         static_cast<float>(m_MajorR),
                         static_cast<float>(m_MinorR),
                         m_TorusMajor,
                         &numVertices,
                         &m_NumIndices,
                         &m_VertexBuf,
                         &m_IndexBuf);
}

RC VkFusion::Graphics::SetupRTGeometry(VulkanCmdBuffer& auxCmdBuf)
{
    if (!m_RaysPerPixel)
    {
        return RC::OK;
    }

    RC rc;
    VulkanBuffer vertexBuf;
    VulkanBuffer indexBuf;
    UINT32       numVertices = 0;

    if (m_RTGeometryType == geomTorus)
    {
        // Generate mini-torus geometry for raytracing
        constexpr float minorR = 0.45f;
        constexpr float majorR = 1.0f - minorR;
        static_assert(minorR > 0.01f && minorR <= 0.5f, "minorR must be less than 0.5");
        CHECK_RC(GenerateTorus(auxCmdBuf,
                               m_RT.numVertices,
                               majorR,
                               minorR,
                               true, // major-first, but does order really matter for BLAS?
                               &numVertices,
                               &m_RT.numIndices,
                               &vertexBuf,
                               &indexBuf));
    }
    else
    {
        // Generate mini-lwbes for raytracing
        MASSERT(m_RTGeometryType == geomLwbe);
        CHECK_RC(GenerateLwbe(auxCmdBuf,
                              &numVertices,
                              &m_RT.numIndices,
                              &vertexBuf,
                              &indexBuf));
    }

    MASSERT(m_Queues.size() > 0);
    MASSERT(m_Queues[0].caps & VK_QUEUE_COMPUTE_BIT);
    m_RT.builder.Setup(m_pVulkanDev, m_Queues[0].idx, m_Queues[0].family);

    // Build bottom-level acceleration structure, which contains just a single
    // object consisting of triangles
    vector<VulkanRaytracingBuilder::BlasInput> blas(1);
    VulkanRaytracingBuilder::BlasInput& geoms = blas.back();

    geoms.geometry.emplace_back();
    VkAccelerationStructureGeometryKHR& geom = geoms.geometry.back();
    geom.sType        = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
    geom.pNext        = nullptr;
    geom.flags        = VK_GEOMETRY_OPAQUE_BIT_KHR;
    geom.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;

    // Geometry is made out of rectangles, so every rectangle has two triangles, 3 vertices each
    MASSERT((m_RT.numIndices % 6) == 0);

    VkAccelerationStructureGeometryTrianglesDataKHR& triangles = geom.geometry.triangles;
    triangles.sType                     = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
    triangles.pNext                     = nullptr;
    triangles.vertexFormat              = VK_FORMAT_R32G32B32_SFLOAT;
    triangles.vertexData.deviceAddress  = vertexBuf.GetBufferDeviceAddress();
    triangles.vertexStride              = sizeof(Vertex);
    triangles.maxVertex                 = numVertices - 1;
    triangles.indexType                 = VK_INDEX_TYPE_UINT32;
    triangles.indexData.deviceAddress   = indexBuf.GetBufferDeviceAddress();
    triangles.transformData.hostAddress = nullptr;

    geoms.buildOffsetInfo.emplace_back();
    VkAccelerationStructureBuildRangeInfoKHR& buildOffsetInfo = geoms.buildOffsetInfo.back();

    // Geometry is made out of triangles, so 3 indices per triangle
    MASSERT((m_RT.numIndices % 3) == 0);

    buildOffsetInfo.primitiveCount  = m_RT.numIndices / 3;
    buildOffsetInfo.primitiveOffset = 0;
    buildOffsetInfo.firstVertex     = 0;
    buildOffsetInfo.transformOffset = 0;

    CHECK_VK_TO_RC(m_RT.builder.BuildBlas(blas,
                                          VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR |
                                          VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR));

    // Build top-level acceleration structure, which contains many copies of the object
    // laid out behind the viewer.  Rays are traced by the shader from the point drawn by
    // the fragment shader back towards the viewer.
    const float posScale = 2.0f / m_RTTLASWidth;
    const float objScale = (m_RTGeometryType == geomTorus ? 1.0f : 0.9f) / m_RTTLASWidth;
    vector<VulkanRaytracingBuilder::Instance> tlas;

    const mat4 rotMat   = lwmath::quat_2_mat(quat(vec3(-1, 0, 0), static_cast<float>(deg2rad(90))));
    const mat4 scaleMat = lwmath::scale_mat4(vec3(objScale, objScale, objScale));

    for (UINT32 z = 0; z < 1; z++)
    {
        const float shiftOffs = z * posScale / 10;
        const float zOffs     = -(static_cast<float>(z) * posScale + 4.0f);
        for (UINT32 y = 0; y < m_RTTLASWidth; y++)
        {
            const float yOffs = (static_cast<float>(y) - m_RTTLASWidth / 2.0f) * posScale + posScale / 2.0f + shiftOffs;
            for (UINT32 x = 0; x < m_RTTLASWidth; x++)
            {
                const float xOffs = (static_cast<float>(x) - m_RTTLASWidth / 2.0f) * posScale + posScale / 2.0f + shiftOffs;

                tlas.emplace_back();
                VulkanRaytracingBuilder::Instance& inst = tlas.back();

                inst.flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;

                inst.transform = lwmath::translation_mat4(xOffs, yOffs, zOffs) * scaleMat * rotMat;
            }
        }
    }

    CHECK_VK_TO_RC(m_RT.builder.BuildTlas(tlas));

    return RC::OK;
}

RC VkFusion::Graphics::GenerateTorus
(
    VulkanCmdBuffer& auxCmdBuf,
    UINT32           vtxPerRib,
    float            majorR,
    float            minorR,
    bool             torusMajor,
    UINT32*          pNumVertices,
    UINT32*          pNumIndices,
    VulkanBuffer*    pVertexBuf,
    VulkanBuffer*    pIndexBuf
)
{
    // In this function we compute the torus geometry.
    //
    // A torus is a very popular 3D shape, it is a single surface
    // which encloses a volume which has a hole in it.  I'm sure you
    // can find a lot of intersting info about it on the Web.
    //
    // We've chosen this shape, because other stress tests, such as
    // Furmark, GPU-Z and finally GLStressZ, have had great success with it.
    //
    // Essentially, a torus is a ring or a donut (doughnut?).
    // We generate it by creating vertical 2-D cycles and spreading
    // them evenly around the center of the torus, then connecting
    // vertices from these circles to form faces.

    if (vtxPerRib < 4u)
    {
        Printf(Tee::PriError, "NumVertices is %u but must be at least 4\n", vtxPerRib);
        return RC::BAD_COMMAND_LINE_ARGUMENT;
    }

    const UINT32 numRibs      = vtxPerRib * 2;
    // One extra row and column of vertices for texturing to work correctly
    const UINT32 numRows      = numRibs + 1;
    const UINT32 vtxPerRow    = vtxPerRib + 1;
    const UINT32 numVertices  = vtxPerRib * numRibs;
    *pNumVertices             = numVertices;
    const UINT32 numFaces     = numVertices;
    const UINT32 numTriangles = numFaces * 2;
    const UINT32 numIndices   = numTriangles * 3;
    const UINT32 vbSize       = numRows * vtxPerRow * sizeof(Vertex);
    const UINT32 ibSize       = numIndices * sizeof(UINT32);
    *pNumIndices              = numIndices;

    VulkanBuffer hostVtxBuf(m_pVulkanDev);
    VulkanBuffer hostIdxBuf(m_pVulkanDev);

    RC rc;

    CHECK_VK_TO_RC(hostVtxBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                           vbSize,
                                           VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                           | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    CHECK_VK_TO_RC(hostIdxBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                           ibSize,
                                           VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                           | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    // Fill out vertex buffer
    {
        VulkanBufferView<Vertex> vtxView(hostVtxBuf);
        CHECK_VK_TO_RC(vtxView.Map());

        // Callwlate positions and colors of all vertices
        auto vtxIter = vtxView.begin();
        for (UINT32 iRib = 0; iRib <= numRibs; iRib++)
        {
            const double ribAngle = static_cast<double>(iRib < numRibs ? iRib : 0) * 2.0 * lw_pi
                                    / static_cast<double>(numRibs);
            const quat ribRotation = quat(vec3(0, -1, 0), static_cast<float>(ribAngle));
            for (UINT32 iVtx = 0; iVtx <= vtxPerRib; iVtx++)
            {
                // Create circle ("rib") on the torus
                const double vtxAngle = static_cast<double>(iVtx < vtxPerRib ? iVtx : 0) * 2.0 * lw_pi
                                        / static_cast<double>(vtxPerRib);
                const quat vtxRotation        = quat(vec3(-1, 0, 0), static_cast<float>(vtxAngle));
                const vec3 pointOnMinorCircle = lwmath::rotate_by(vec3(0, 0, -minorR), vtxRotation);

                // Move that circle into its place on the torus
                const vec3 pointOnMovedCircle = pointOnMinorCircle + vec3(0, 0, majorR);
                const vec3 finalVtx           = lwmath::rotate_by(pointOnMovedCircle, ribRotation);

                // Callwlate normal
                const vec3 normal = lwmath::rotate_by(lwmath::rotate_by(vec3(0, 0, -1), vtxRotation),
                                                      ribRotation);

                // Callwlate texture coordinates
                const vec2 texCoord(2.0f * iRib / static_cast<float>(numRibs),
                                    iVtx / static_cast<float>(vtxPerRib));

                vtxIter->pos      = finalVtx;
                vtxIter->normal   = normal;
                vtxIter->texCoord = texCoord;
                ++vtxIter;
            }
        }
        MASSERT(vtxIter == vtxView.end());
    }

    // Assemble vertices into faces, fill out index buffer
    {
        VulkanBufferView<UINT32> idxView(hostIdxBuf);
        CHECK_VK_TO_RC(idxView.Map());

        auto idxIter = idxView.begin();

        if (torusMajor)
        {
            for (UINT32 iFace = 0; iFace < vtxPerRib; iFace++)
            {
                const UINT32 nextFace = iFace + 1;
                for (UINT32 iRib = 0; iRib < numRibs; iRib++)
                {
                    const UINT32 lwrRow  = iRib * vtxPerRow;
                    const UINT32 nextRow = lwrRow + vtxPerRow;
                    *(idxIter++) = lwrRow  + iFace;
                    *(idxIter++) = nextRow + iFace;
                    *(idxIter++) = lwrRow  + nextFace;
                    *(idxIter++) = lwrRow  + nextFace;
                    *(idxIter++) = nextRow + iFace;
                    *(idxIter++) = nextRow + nextFace;
                }
            }
        }
        else
        {
            for (UINT32 iRib = 0; iRib < numRibs; iRib++)
            {
                const UINT32 lwrRow  = iRib * vtxPerRow;
                const UINT32 nextRow = lwrRow + vtxPerRow;
                for (UINT32 iFace = 0; iFace < vtxPerRib; iFace++)
                {
                    const UINT32 nextFace = iFace + 1;
                    *(idxIter++) = lwrRow  + iFace;
                    *(idxIter++) = nextRow + iFace;
                    *(idxIter++) = lwrRow  + nextFace;
                    *(idxIter++) = lwrRow  + nextFace;
                    *(idxIter++) = nextRow + iFace;
                    *(idxIter++) = nextRow + nextFace;
                }
            }
        }
        MASSERT(idxIter == idxView.end());
    }

    const UINT32 extraUsage = m_RaysPerPixel ? VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT : 0;

    *pVertexBuf = VulkanBuffer(m_pVulkanDev);
    CHECK_VK_TO_RC(pVertexBuf->CreateBuffer(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
                                            | VK_BUFFER_USAGE_TRANSFER_DST_BIT
                                            | extraUsage,
                                            vbSize,
                                            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    *pIndexBuf = VulkanBuffer(m_pVulkanDev);
    CHECK_VK_TO_RC(pIndexBuf->CreateBuffer(VK_BUFFER_USAGE_INDEX_BUFFER_BIT
                                           | VK_BUFFER_USAGE_TRANSFER_DST_BIT
                                           | extraUsage,
                                           ibSize,
                                           VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    CHECK_VK_TO_RC(VkUtil::CopyBuffer(&auxCmdBuf,
                                      &hostVtxBuf,
                                      pVertexBuf,
                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                      VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
                                      VK_PIPELINE_STAGE_TRANSFER_BIT,
                                      VK_PIPELINE_STAGE_VERTEX_INPUT_BIT));

    CHECK_VK_TO_RC(VkUtil::CopyBuffer(&auxCmdBuf,
                                      &hostIdxBuf,
                                      pIndexBuf,
                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                      VK_ACCESS_INDEX_READ_BIT,
                                      VK_PIPELINE_STAGE_TRANSFER_BIT,
                                      VK_PIPELINE_STAGE_VERTEX_INPUT_BIT));

    return RC::OK;
}

RC VkFusion::Graphics::GenerateLwbe
(
    VulkanCmdBuffer& auxCmdBuf,
    UINT32*          pNumVertices,
    UINT32*          pNumIndices,
    VulkanBuffer*    pVertexBuf,
    VulkanBuffer*    pIndexBuf
)
{
    static constexpr UINT32 numVertices  = 8;
    static constexpr UINT32 numTriangles = 6 * 2;
    static constexpr UINT32 numIndices   = numTriangles * 3;
    const UINT32            vbSize       = numVertices * sizeof(Vertex);
    const UINT32            ibSize       = numIndices  * sizeof(UINT32);
    *pNumVertices                        = numVertices;
    *pNumIndices                         = numIndices;

    VulkanBuffer hostVtxBuf(m_pVulkanDev);
    VulkanBuffer hostIdxBuf(m_pVulkanDev);

    RC rc;

    CHECK_VK_TO_RC(hostVtxBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                           vbSize,
                                           VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                           | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    CHECK_VK_TO_RC(hostIdxBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                           ibSize,
                                           VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                           | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    // Fill out vertex buffer
    {
        VulkanBufferView<Vertex> vtxView(hostVtxBuf);
        CHECK_VK_TO_RC(vtxView.Map());

        auto vtxIter = vtxView.begin();

        // Outer array: vertices of a lwbe (axis-aligned)
        // Inner array: 3 coordinates (x, y, z), for each coord choose near (min) or far (max) value
        static const int selectCoord[numVertices][3] =
        {
            { 0, 0, 0 },
            { 1, 0, 0 },
            { 1, 1, 0 },
            { 0, 1, 0 },
            { 0, 0, 1 },
            { 1, 0, 1 },
            { 1, 1, 1 },
            { 0, 1, 1 }
        };

        // Near (min) and far (max) coordinates of the AABB lwbe
        const vec3 coord[2] = { vec3(-1, -1, -1), vec3(1, 1, 1) };

        for (const auto& select : selectCoord)
        {
            vtxIter->pos = vec3(coord[select[0]].x,
                                coord[select[1]].y,
                                coord[select[2]].z);
            // We use this only for RT so for now we don't need normal or color
            vtxIter->normal   = vec3(0, 0, 0);
            vtxIter->texCoord = vec2(0, 0);
            ++vtxIter;
        }

        MASSERT(vtxIter == vtxView.end());
    }

    // Assemble vertices into faces, fill out index buffer
    {
        VulkanBufferView<UINT32> idxView(hostIdxBuf);
        CHECK_VK_TO_RC(idxView.Map());

        auto idxIter = idxView.begin();

        // Select vertices for each triangle in each face of the lwbe
        static const UINT32 faceIndicesCCW[numIndices] =
        {
            0, 1, 3,
            3, 1, 2,
            2, 1, 6,
            6, 1, 5,
            5, 1, 4,
            4, 1, 0,
            4, 0, 3,
            3, 7, 4,
            4, 7, 5,
            5, 7, 6,
            6, 7, 3,
            3, 2, 6
        };

        for (UINT32 idx : faceIndicesCCW)
        {
            *idxIter = idx;
            ++idxIter;
        }

        MASSERT(idxIter == idxView.end());
    }

    *pVertexBuf = VulkanBuffer(m_pVulkanDev);
    CHECK_VK_TO_RC(pVertexBuf->CreateBuffer(VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
                                            | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                                            vbSize,
                                            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    *pIndexBuf = VulkanBuffer(m_pVulkanDev);
    CHECK_VK_TO_RC(pIndexBuf->CreateBuffer(VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
                                           | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                                           ibSize,
                                           VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    CHECK_VK_TO_RC(VkUtil::CopyBuffer(&auxCmdBuf,
                                      &hostVtxBuf,
                                      pVertexBuf,
                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                      VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
                                      VK_PIPELINE_STAGE_TRANSFER_BIT,
                                      VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR));

    CHECK_VK_TO_RC(VkUtil::CopyBuffer(&auxCmdBuf,
                                      &hostIdxBuf,
                                      pIndexBuf,
                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                      VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
                                      VK_PIPELINE_STAGE_TRANSFER_BIT,
                                      VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR));

    return RC::OK;
}

RC VkFusion::Graphics::SetupRenderPasses()
{
    RC rc;

    CHECK_RC(SetupDrawRenderPass(&m_DrawRenderPass, VK_ATTACHMENT_LOAD_OP_LOAD));

    CHECK_RC(SetupDrawRenderPass(&m_ClearRenderPass, VK_ATTACHMENT_LOAD_OP_CLEAR));

    return RC::OK;
}

RC VkFusion::Graphics::SetupDrawRenderPass(VulkanRenderPass* pRenderPass, VkAttachmentLoadOp loadOp)
{
    *pRenderPass = VulkanRenderPass(m_pVulkanDev);

    VkAttachmentDescription attDesc = { };
    attDesc.format         = m_pSwapChain->GetSurfaceFormat();
    attDesc.samples        = VK_SAMPLE_COUNT_1_BIT;
    attDesc.loadOp         = loadOp;
    attDesc.storeOp        = VK_ATTACHMENT_STORE_OP_STORE;
    attDesc.stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attDesc.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attDesc.initialLayout  = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    attDesc.finalLayout    = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    pRenderPass->PushAttachmentDescription(VkUtil::AttachmentType::COLOR, &attDesc);

    attDesc.format         = m_DepthImages[0].GetFormat();
    attDesc.loadOp         = loadOp;
    attDesc.storeOp        = VK_ATTACHMENT_STORE_OP_STORE;
    attDesc.stencilLoadOp  = loadOp;
    attDesc.stencilStoreOp = VK_ATTACHMENT_STORE_OP_STORE;
    attDesc.initialLayout  = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    attDesc.finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    pRenderPass->PushAttachmentDescription(VkUtil::AttachmentType::DEPTH, &attDesc);

    VkAttachmentReference colorRef = { };
    colorRef.attachment = 0;
    colorRef.layout     = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthRef = { };
    depthRef.attachment = 1;
    depthRef.layout     = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpass    = { };
    subpass.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount    = 1;
    subpass.pColorAttachments       = &colorRef;
    subpass.pDepthStencilAttachment = &depthRef;
    pRenderPass->PushSubpassDescription(&subpass);

    RC rc;
    CHECK_VK_TO_RC(pRenderPass->CreateRenderPass());

    return RC::OK;
}

RC VkFusion::Graphics::SetupFrameBuffers()
{
    VerbosePrintf("Graphics: Swapchain has %u images\n",
                  static_cast<UINT32>(m_pSwapChain->GetNumImages()));

    m_FrameBuffers.resize(m_pSwapChain->GetNumImages());

    for (UINT32 i = 0; i < m_FrameBuffers.size(); i++)
    {
        VulkanFrameBuffer& framebuffer = m_FrameBuffers[i];

        framebuffer = VulkanFrameBuffer(m_pVulkanDev);

        vector<VkImageView> attachments =
        {
            m_pSwapChain->GetImageView(i),
            m_DepthImages[i].GetImageView()
        };

        MASSERT(m_DrawRenderPass.GetAttachmentType(0) == VkUtil::AttachmentType::COLOR);
        MASSERT(m_DrawRenderPass.GetAttachmentType(1) == VkUtil::AttachmentType::DEPTH);
        MASSERT(m_pSwapChain->GetSwapChainExtent().width  == m_DepthImages[i].GetWidth());
        MASSERT(m_pSwapChain->GetSwapChainExtent().height == m_DepthImages[i].GetHeight());

        framebuffer.SetWidth(m_pSwapChain->GetSwapChainExtent().width);
        framebuffer.SetHeight(m_pSwapChain->GetSwapChainExtent().height);

        RC rc;
        CHECK_VK_TO_RC(framebuffer.CreateFrameBuffer(attachments, m_DrawRenderPass.GetRenderPass()));
    }

    return RC::OK;
}

RC VkFusion::Graphics::SetupSamplers()
{
    RC rc;

    VulkanPhysicalDevice& physDev = *m_pVulkanDev->GetPhysicalDevice();

    // Note: need at least 1 sampler for array in fragment shader, even if the shader won't use it
    const UINT32 numSamplers = min(physDev.GetLimits().maxSamplerAllocationCount,
                               min(physDev.GetLimits().maxPerStageDescriptorSamplers,
                               max(m_NumTexReads, 1u)));

    VerbosePrintf("Graphics samplers: actual=%u, requested=%u, maxSamplerAllocationCount=%u, "
                  "maxPerStageDescriptorSamplers=%u\n",
                  numSamplers,
                  m_NumTexReads,
                  physDev.GetLimits().maxSamplerAllocationCount,
                  physDev.GetLimits().maxPerStageDescriptorSamplers);

    m_Samplers.reserve(numSamplers);

    while (m_Samplers.size() < numSamplers)
    {
        constexpr VkFilter             filter      = VK_FILTER_LINEAR;
        constexpr VkSamplerAddressMode addressMode = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        constexpr VkSamplerMipmapMode  mipmapMode  = VK_SAMPLER_MIPMAP_MODE_LINEAR;

        VkBool32 anisotropyEnable = VK_FALSE;
        float    maxAnisotropy    = 0;
        if (physDev.GetFeatures2().features.samplerAnisotropy)
        {
            anisotropyEnable = VK_TRUE;
            maxAnisotropy    = physDev.GetLimits().maxSamplerAnisotropy;
        }

        VkSamplerCreateInfo info = { VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO };
        info.magFilter        = filter;
        info.minFilter        = filter;
        info.addressModeU     = addressMode;
        info.addressModeV     = addressMode;
        info.addressModeW     = addressMode;
        info.mipmapMode       = mipmapMode;
        info.mipLodBias       = static_cast<float>(m_MipLodBias);
        info.minLod           = 0;
        info.maxLod           = 16;
        info.anisotropyEnable = anisotropyEnable;
        info.maxAnisotropy    = maxAnisotropy;

        m_Samplers.emplace_back(m_pVulkanDev);
        CHECK_VK_TO_RC(m_Samplers.back().CreateSampler(info));
    }

    return RC::OK;
}

RC VkFusion::Graphics::SetupTextures(VulkanCmdBuffer& auxCmdBuf)
{
    RC rc;

    VulkanPhysicalDevice& physDev = *m_pVulkanDev->GetPhysicalDevice();

    // Note: need at least 1 texture for array in fragment shader, even if the shader won't use it
    const UINT32 origNumTextures = m_NumTextures;
    m_NumTextures = min(physDev.GetLimits().maxPerStageDescriptorSampledImages,
                    min(physDev.GetLimits().maxMemoryAllocationCount,
                    max(1u,
                    min(m_NumTexReads, m_NumTextures))));

    const UINT32 mipmapLevels = 1 + static_cast<UINT32>(floor(log2(m_TexSize)));

    VerbosePrintf("Graphics textures: actual=%u, requested=%u, dimensions=%ux%u, mipmap levels=%u, maxPerStageDescriptorSampledImages=%u, "
                  "maxMemoryAllocationCount=%u\n",
                  m_NumTextures,
                  origNumTextures,
                  m_TexSize,
                  m_TexSize,
                  mipmapLevels,
                  physDev.GetLimits().maxPerStageDescriptorSampledImages,
                  physDev.GetLimits().maxMemoryAllocationCount);

    m_Textures.reserve(m_NumTextures);
    UINT64 totalSize = 0;

    while (m_Textures.size() < m_NumTextures)
    {
        m_Textures.emplace_back(m_pVulkanDev);
        VulkanImage& tex = m_Textures.back();

        CHECK_VK_TO_RC(AllocateImage(&tex,
                                     VK_FORMAT_R8G8B8A8_UNORM,
                                     m_TexSize,
                                     m_TexSize,
                                     mipmapLevels,
                                     VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,
                                     VK_IMAGE_TILING_OPTIMAL,
                                     VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

        CHECK_VK_TO_RC(tex.SetImageLayout(&auxCmdBuf,
                                          VK_IMAGE_ASPECT_COLOR_BIT,
                                          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                          VK_ACCESS_TRANSFER_WRITE_BIT,
                                          VK_PIPELINE_STAGE_TRANSFER_BIT));

        if (!tex.IsSamplingSupported())
        {
            Printf(Tee::PriError, "Texture format is not supported\n");
            return RC::MODS_VK_ERROR_FORMAT_NOT_SUPPORTED;
        }

        totalSize += tex.GetDeviceMemorySize();
    }

    VulkanBuffer patternBuf(m_pVulkanDev);
    CHECK_VK_TO_RC(patternBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                           totalSize,
                                           VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                           | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    CHECK_VK_TO_RC(auxCmdBuf.BeginCmdBuffer());

    PatternClass::PatternSets patternSets = PatternClass::PATTERNSET_ALL;
    PatternClass patternClass;
    patternClass.SelectPatternSet(patternSets);
    patternClass.FillRandomPattern(m_Random.GetRandom());
    patternClass.ResetFillIndex();
    patternClass.ResetCheckIndex();
    vector<UINT32> patternIds;
    CHECK_RC(patternClass.GetSelectedPatterns(&patternIds));

    {
        VulkanBufferView<UINT32> view(patternBuf);
        CHECK_VK_TO_RC(view.Map());

        vector<VkBufferImageCopy> regions;
        regions.reserve(mipmapLevels);

        UINT64 offset = 0;
        for (VulkanImage& tex : m_Textures)
        {
            const UINT64 size = tex.GetDeviceMemorySize();

            // 4 bytes per pixel, also matches buffer view above
            constexpr UINT32 bpp = 4;

            regions.clear();
            UINT64 mipOffset = offset;

            UINT32 height = m_TexSize;
            for (UINT32 mipLevel = 0; mipLevel < mipmapLevels; mipLevel++)
            {
                MASSERT(height > 0);

                const UINT32 width = height;
                const UINT32 pitch = width * bpp;

                // Randomly choose pattern index
                const UINT32 idx = m_Random.GetRandom(0u, static_cast<UINT32>(patternIds.size() - 1));

                UINT32* const mipPtr = view.begin() + mipOffset / sizeof(UINT32);
                CHECK_RC(patternClass.FillMemoryWithPattern(mipPtr,
                                                            pitch,
                                                            height,
                                                            pitch,
                                                            32,
                                                            patternIds[idx],
                                                            nullptr));

                if (m_DebugMipMaps)
                {
                    DebugFillMipMap(mipPtr, width * height, mipLevel);
                }

                VkBufferImageCopy region = { };
                region.bufferOffset                = mipOffset;
                region.bufferRowLength             = width;
                region.bufferImageHeight           = height;
                region.imageSubresource.aspectMask = tex.GetImageAspectFlags();
                region.imageSubresource.mipLevel   = mipLevel;
                region.imageSubresource.layerCount = 1;
                region.imageExtent.width           = width;
                region.imageExtent.height          = height;
                region.imageExtent.depth           = 1;

                regions.push_back(region);

                mipOffset += static_cast<UINT64>(pitch) * height;
                height >>= 1;
            }

            m_pVulkanDev->CmdCopyBufferToImage(auxCmdBuf.GetCmdBuffer(),
                                               patternBuf.GetBuffer(),
                                               tex.GetImage(),
                                               tex.GetImageLayout(),
                                               mipmapLevels,
                                               regions.data());

            CHECK_VK_TO_RC(tex.SetImageLayout(&auxCmdBuf,
                                              VK_IMAGE_ASPECT_COLOR_BIT,
                                              VK_IMAGE_LAYOUT_GENERAL,
                                              VK_ACCESS_SHADER_READ_BIT,
                                              VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT));

            offset += size;
        }
    }

    CHECK_VK_TO_RC(auxCmdBuf.EndCmdBuffer());
    CHECK_VK_TO_RC(auxCmdBuf.ExelwteCmdBuffer(true, true));

    return RC::OK;
}

void VkFusion::Graphics::DebugFillMipMap(UINT32* pFirstPixel, UINT32 numPixels, UINT32 mipLevel)
{
    static const UINT32 colors[] =
    {
        0xFFFF0000u,
        0xFF00FF00u,
        0xFF0000FFu,
        0xFFFFFF00u,
        0xFF00FFFFu,
        0xFFFF00FFu,
        0xFF401010u,
        0xFF104010u,
        0xFF101040u
    };

    const UINT32 color = colors[mipLevel % NUMELEMS(colors)];

    UINT32* const pEnd = pFirstPixel + numPixels;
    for ( ; pFirstPixel < pEnd; pFirstPixel++)
    {
        *pFirstPixel = color;
    }
}

RC VkFusion::Graphics::SetupPipeline(VulkanCmdBuffer& auxCmdBuf)
{
    RC rc;

    // Fragment shader needs at least one sampler and one texture
    MASSERT(m_NumTextures > 0);
    MASSERT(!m_Samplers.empty());
    const UINT32 numSamplers = static_cast<UINT32>(m_Samplers.size());

    ////////////////////////////////////////////////////////////////////////////
    // Vertex shader

    VBBindingAttributeDesc vbBinding;
    const char*            vertexShaderSource = nullptr;

    switch (m_GeometryType)
    {
        case geomVertexBuffer:
        {
            vertexShaderSource = s_VertexShader;
            {
                VkVertexInputBindingDescription desc = { };
                desc.binding   = 0;
                desc.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
                desc.stride    = sizeof(Vertex);
                vbBinding.m_BindingDesc.push_back(desc);
            }
            {
                VkVertexInputAttributeDescription desc = { };
                desc.binding  = 0;
                desc.location = 0;
                desc.format   = VK_FORMAT_R32G32B32_SFLOAT;
                desc.offset   = offsetof(Vertex, pos);
                vbBinding.m_AttributesDesc.push_back(desc);
            }
            {
                VkVertexInputAttributeDescription desc = { };
                desc.binding  = 0;
                desc.location = 1;
                desc.format   = VK_FORMAT_R32G32B32_SFLOAT;
                desc.offset   = offsetof(Vertex, normal);
                vbBinding.m_AttributesDesc.push_back(desc);
            }
            {
                VkVertexInputAttributeDescription desc = { };
                desc.binding  = 0;
                desc.location = 2;
                desc.format   = VK_FORMAT_R32G32_SFLOAT;
                desc.offset   = offsetof(Vertex, texCoord);
                vbBinding.m_AttributesDesc.push_back(desc);
            }
        }
        break;

        case geomTessellation:
            vertexShaderSource = s_TessellatedVertexShader;
            break;

        default:
            MASSERT(!"Missing handling of new geometry mode");
    }

    vector<VkPipelineShaderStageCreateInfo> stages;

    VulkanShader vertexShader(m_pVulkanDev);
    CHECK_VK_TO_RC(vertexShader.CreateShader(VK_SHADER_STAGE_VERTEX_BIT,
                                             vertexShaderSource,
                                             "main",
                                             m_ShaderReplacement));
    stages.push_back(vertexShader.GetShaderStageInfo());

    ////////////////////////////////////////////////////////////////////////////
    // Tessellation shaders

    VulkanShader tessControlShader(m_pVulkanDev);
    VulkanShader tessEvaluationShader(m_pVulkanDev);

    // Specialization constants for tessellation control shader
    // Note: VulkanShader holds pointer to these structs/arrays, so they must
    // remain here in this scope rather than being inside the if scope below!
    struct ControlSpecialization
    {
        UINT32 numRibs;
        UINT32 vtxPerRib;
        UINT32 torusMajor;
    };
    ControlSpecialization controlConstants = { };
    controlConstants.numRibs    = m_VtxPerRib * 2;
    controlConstants.vtxPerRib  = m_VtxPerRib;
    controlConstants.torusMajor = m_TorusMajor ? 1 : 0;
    const VkSpecializationMapEntry controlMapEntries[] =
    {
        { 0, offsetof(ControlSpecialization, numRibs),    sizeof(controlConstants.numRibs)    },
        { 1, offsetof(ControlSpecialization, vtxPerRib),  sizeof(controlConstants.vtxPerRib)  },
        { 2, offsetof(ControlSpecialization, torusMajor), sizeof(controlConstants.torusMajor) },
    };

    VkSpecializationInfo controlSpecInfo = { };
    controlSpecInfo.pMapEntries   = &controlMapEntries[0];
    controlSpecInfo.mapEntryCount = static_cast<UINT32>(NUMELEMS(controlMapEntries));
    controlSpecInfo.pData         = &controlConstants;
    controlSpecInfo.dataSize      = sizeof(controlConstants);

    // Specialization constants for tessellation evaluation shader
    struct EvaluationSpecialization
    {
        float  majorR;
        float  minorR;
        UINT32 torusMajor;
    };
    EvaluationSpecialization evaluationConstants = { };
    evaluationConstants.majorR     = static_cast<float>(m_MajorR);
    evaluationConstants.minorR     = static_cast<float>(m_MinorR);
    evaluationConstants.torusMajor = m_TorusMajor ? 1 : 0;
    const VkSpecializationMapEntry evaluationMapEntries[] =
    {
        { 0, offsetof(EvaluationSpecialization, majorR),     sizeof(evaluationConstants.majorR)     },
        { 1, offsetof(EvaluationSpecialization, minorR),     sizeof(evaluationConstants.minorR)     },
        { 2, offsetof(EvaluationSpecialization, torusMajor), sizeof(evaluationConstants.torusMajor) },
    };

    VkSpecializationInfo evaluationSpecInfo = { };
    evaluationSpecInfo.pMapEntries   = &evaluationMapEntries[0];
    evaluationSpecInfo.mapEntryCount = static_cast<UINT32>(NUMELEMS(evaluationMapEntries));
    evaluationSpecInfo.pData         = &evaluationConstants;
    evaluationSpecInfo.dataSize      = sizeof(evaluationConstants);

    if (m_GeometryType == geomTessellation)
    {
        CHECK_VK_TO_RC(tessControlShader.CreateShader(VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
                                                      s_TessellationControlShader,
                                                      "main",
                                                      m_ShaderReplacement,
                                                      &controlSpecInfo));
        stages.push_back(tessControlShader.GetShaderStageInfo());

        CHECK_VK_TO_RC(tessEvaluationShader.CreateShader(VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
                                                         s_TessellationEvaluationShader,
                                                         "main",
                                                         m_ShaderReplacement,
                                                         &evaluationSpecInfo));
        stages.push_back(tessEvaluationShader.GetShaderStageInfo());
    }

    ////////////////////////////////////////////////////////////////////////////
    // Fragment shader

    // When using UNORM output type, we divide by the number of draws to avoid saturating
    // the output.  For SFLOAT this is not needed, because SFLOAT values can go beyond
    // 1.0 at the expense of mantissa precision.
    const VkFormat swapChainFormat = m_pSwapChain->GetSwapChainImage(0)->GetFormat();
    const UINT32   numDraws        = (swapChainFormat == VK_FORMAT_R16G16B16A16_SFLOAT)
                                     ? 1u : m_DrawsPerFrame;

    // Specialization constants for fragment shader
    struct ShaderSpecialization
    {
        UINT32 numTexReads;
        UINT32 numSamplers;
        UINT32 numTextures;
        UINT32 numDraws;
        UINT32 numLights;
        UINT32 numRays;
        UINT32 rtXMask;
    };
    ShaderSpecialization shaderConstants = { };
    shaderConstants.numTexReads = m_NumTexReads;
    shaderConstants.numSamplers = numSamplers;
    shaderConstants.numTextures = m_NumTextures;
    shaderConstants.numDraws    = numDraws;
    shaderConstants.numLights   = m_NumLights;
    shaderConstants.numRays     = m_RaysPerPixel;
    shaderConstants.rtXMask     = m_RaysPerPixel ? m_RTXMask : 0;
    const VkSpecializationMapEntry constantMapEntries[] =
    {
        { 0, offsetof(ShaderSpecialization, numTexReads), sizeof(shaderConstants.numTexReads) },
        { 1, offsetof(ShaderSpecialization, numSamplers), sizeof(shaderConstants.numSamplers) },
        { 2, offsetof(ShaderSpecialization, numTextures), sizeof(shaderConstants.numTextures) },
        { 3, offsetof(ShaderSpecialization, numDraws),    sizeof(shaderConstants.numDraws)    },
        { 4, offsetof(ShaderSpecialization, numLights),   sizeof(shaderConstants.numLights)   },
        { 5, offsetof(ShaderSpecialization, numRays),     sizeof(shaderConstants.numRays)     },
        { 6, offsetof(ShaderSpecialization, rtXMask),     sizeof(shaderConstants.rtXMask)     },
    };

    VkSpecializationInfo specInfo = { };
    specInfo.pMapEntries   = &constantMapEntries[0];
    specInfo.mapEntryCount = static_cast<UINT32>(NUMELEMS(constantMapEntries));
    specInfo.pData         = &shaderConstants;
    specInfo.dataSize      = sizeof(shaderConstants);

    // Conditionally enable ray tracing in fragment shader
    const char* fragmentShaderSrc = s_FragmentShader;
    string fragmentCopy;
    if (!m_RaysPerPixel)
    {
        fragmentCopy = fragmentShaderSrc;

        {
            const char rayQueryExt[] = "#extension GL_EXT_ray_query : ";
            const size_t pos = fragmentCopy.find(rayQueryExt);
            MASSERT(fragmentCopy.find("require", pos) == pos + sizeof(rayQueryExt) - 1);

            const char disable[] = "disable";
            memcpy(&fragmentCopy[pos + sizeof(rayQueryExt) - 1], disable, sizeof(disable) - 1);
        }

        {
            const char useRayQuery[] = "#define USE_ray_query ";
            const size_t pos = fragmentCopy.find(useRayQuery);
            MASSERT(fragmentCopy.find("1", pos) == pos + sizeof(useRayQuery) - 1);

            fragmentCopy[pos + sizeof(useRayQuery) - 1] = '0';
        }

        fragmentShaderSrc = fragmentCopy.c_str();
    }

    VulkanShader fragmentShader(m_pVulkanDev);
    CHECK_VK_TO_RC(fragmentShader.CreateShader(VK_SHADER_STAGE_FRAGMENT_BIT,
                                               fragmentShaderSrc,
                                               "main",
                                               m_ShaderReplacement,
                                               &specInfo));
    stages.push_back(fragmentShader.GetShaderStageInfo());

    ////////////////////////////////////////////////////////////////////////////
    // Create descriptor set layouts and descriptor sets

    VkShaderStageFlags uniformBufferTarget = VK_SHADER_STAGE_FRAGMENT_BIT;
    switch (m_GeometryType)
    {
        case geomVertexBuffer:
            uniformBufferTarget |= VK_SHADER_STAGE_VERTEX_BIT;
            break;

        case geomTessellation:
            uniformBufferTarget |= VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
            break;

        default:
            MASSERT(!"Missing handling of new geometry mode");
    }
    const VkDescriptorSetLayoutBinding bindings[] =
    {
        {
            0,                                  // binding
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,  // descriptorType
            1,                                  // descriptorCount
            uniformBufferTarget,                // stageFlags
            nullptr                             // pImmutableSamplers
        },
        {
            1,                                  // binding
            VK_DESCRIPTOR_TYPE_SAMPLER,         // descriptorType
            numSamplers,                        // descriptorCount
            VK_SHADER_STAGE_FRAGMENT_BIT,       // stageFlags
            nullptr                             // pImmutableSamplers
        },
        {
            2,                                  // binding
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,   // descriptorType
            m_NumTextures,                      // descriptorCount
            VK_SHADER_STAGE_FRAGMENT_BIT,       // stageFlags
            nullptr                             // pImmutableSamplers
        },
        {
            3,                                              // binding
            VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,  // descriptorType
            1,                                              // descriptorCount
            VK_SHADER_STAGE_FRAGMENT_BIT,                   // stageFlags
            nullptr                                         // pImmutableSamplers
        },
    };
    m_DrawDescriptorInfo = DescriptorInfo(m_pVulkanDev);
    UINT32 numBindings = static_cast<UINT32>(NUMELEMS(bindings));
    if (!m_RaysPerPixel)
    {
        --numBindings;
    }
    CHECK_VK_TO_RC(m_DrawDescriptorInfo.CreateDescriptorSetLayout(0, numBindings, bindings));

    vector<VkDescriptorPoolSize> descPoolSizes =
    {
        { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,             1             },
        { VK_DESCRIPTOR_TYPE_SAMPLER,                    numSamplers   },
        { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,              m_NumTextures },
        { VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, 1             },
    };
    if (!m_RaysPerPixel)
    {
        descPoolSizes.resize(descPoolSizes.size() - 1);
    }
    CHECK_VK_TO_RC(m_DrawDescriptorInfo.CreateDescriptorPool(m_NumJobs * m_DrawsPerFrame, descPoolSizes));

    for (UINT32 i = 0; i < m_NumJobs * m_DrawsPerFrame; i++)
    {
        CHECK_VK_TO_RC(m_DrawDescriptorInfo.AllocateDescriptorSets(i, 1, 0));
    }

    ////////////////////////////////////////////////////////////////////////////
    // Setup pipeline

    VkViewport viewport = { };
    viewport.width    = static_cast<float>(m_SurfaceWidth);
    viewport.height   = static_cast<float>(m_SurfaceHeight);
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    VkRect2D scissor = { };
    scissor.extent.width  = m_SurfaceWidth;
    scissor.extent.height = m_SurfaceHeight;

    m_DrawPipeline = VulkanPipeline(m_pVulkanDev);

    switch (m_GeometryType)
    {
        case geomVertexBuffer:
            m_DrawPipeline.SetInputAssemblyTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_FALSE);
            break;

        case geomTessellation:
            m_DrawPipeline.SetTessellationState(4); // patch control points = 4 for one quad
            m_DrawPipeline.SetInputAssemblyTopology(VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, VK_FALSE);
            break;

        default:
            MASSERT(!"Missing handling of new geometry mode");
    }

    VkPipelineViewportStateCreateInfo vpInfo = { VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO };
    vpInfo.viewportCount = 1;
    vpInfo.pViewports    = &viewport;
    vpInfo.scissorCount  = 1;
    vpInfo.pScissors     = &scissor;

    m_DrawPipeline.SetViewPortAndScissorState(&vpInfo);

    const VkLwllModeFlags lwllMode = m_Lwll ? VK_LWLL_MODE_BACK_BIT : VK_LWLL_MODE_NONE;
    m_DrawPipeline.SetRasterizerState(VK_TRUE,                         // depthClampEnable
                                      VK_FALSE,                        // rasterizerDiscardEnable
                                      VK_POLYGON_MODE_FILL,            // polygonMode
                                      lwllMode,                        // lwllMode
                                      VK_FRONT_FACE_COUNTER_CLOCKWISE, // frontFace
                                      VK_FALSE,                        // depthBiasEnable
                                      0.0f,                            // depthBiasConstantFactor
                                      0.0f,                            // depthBiasClamp
                                      0.0f,                            // depthBiasSlopeFactor
                                      1.0f);                           // lineWidth

    VkPipelineDepthStencilStateCreateInfo dsInfo = { VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO };
    dsInfo.depthTestEnable  = VK_TRUE;
    dsInfo.depthWriteEnable = VK_TRUE;
    dsInfo.depthCompareOp   = VK_COMPARE_OP_GREATER;
    dsInfo.back.writeMask   = 0xFFU;
    dsInfo.back.compareOp   = VK_COMPARE_OP_GREATER;
    dsInfo.back.reference   = 0;
    dsInfo.back.compareMask = 0xFFU;
    dsInfo.back.failOp      = VK_STENCIL_OP_KEEP;
    dsInfo.back.depthFailOp = VK_STENCIL_OP_KEEP;
    dsInfo.back.passOp      = VK_STENCIL_OP_INCREMENT_AND_CLAMP;
    dsInfo.front            = dsInfo.back;

    m_DrawPipeline.SetDepthStencilState(&dsInfo);

    // Configure color and alpha channel blending in such a way that subsequent draws
    // are simply added together.
    VkPipelineColorBlendAttachmentState blendState = { };
    blendState.colorWriteMask      = 0b1111; // All channels - ABGR
    blendState.blendEnable         = VK_TRUE;
    blendState.colorBlendOp        = VK_BLEND_OP_ADD;
    blendState.alphaBlendOp        = VK_BLEND_OP_ADD;
    blendState.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;

    float blendConstants[4] = { 1, 1, 1, 1 };

    m_DrawPipeline.SetColorBlendState(blendState, VK_FALSE, VK_LOGIC_OP_NO_OP, blendConstants);

    CHECK_VK_TO_RC(m_DrawPipeline.SetupGraphicsPipeline(&vbBinding,
                                                        m_DrawDescriptorInfo.GetDescriptorSetLayout(0),
                                                        stages,
                                                        m_DrawRenderPass.GetRenderPass(),
                                                        0, // subpass
                                                        VK_SAMPLE_COUNT_1_BIT));

    return RC::OK;
}

RC VkFusion::Graphics::SetupTransforms(VulkanCmdBuffer& auxCmdBuf)
{
    RC rc;

    VulkanPhysicalDevice& physDev = *m_pVulkanDev->GetPhysicalDevice();
    m_UniformDataSize = Utility::AlignUp(static_cast<UINT32>(sizeof(UniformData)),
                                         physDev.GetLimits().minUniformBufferOffsetAlignment);
    const UINT32 uniformBufSize = m_DrawsPerFrame * m_UniformDataSize;

    VulkanBuffer hostUniformDataBuf(m_pVulkanDev);
    CHECK_VK_TO_RC(hostUniformDataBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                                                   uniformBufSize,
                                                   VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                                   | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT));

    {
        VulkanBufferView<UINT08> uniformView(hostUniformDataBuf);
        CHECK_VK_TO_RC(uniformView.Map());

        for (UINT32 iDraw = 0; iDraw < m_DrawsPerFrame; iDraw++)
        {
            UniformData& uniform = *reinterpret_cast<UniformData*>(
                                   uniformView.begin() + iDraw * m_UniformDataSize);

            // Model matrix moves the object's geometry from model space coordinates
            // to world space coordinates.
            // Model, world and view coordinate systems look like so:
            //  - X goes from left to right
            //  - Y goes from bottom to top
            //  - Z goes forward
            // This means that we use a left-handed coordinate system, which is different
            // than in OpenGL.
            //
            // Also note that matrices are physically laid out as column-major, meaning
            // that float offsets 0, 1, 2, 3 within the matrix's array are the first column,
            // not the first row.
            //
            // Last but not least, we treat vectors as columns, so multiplications
            // are performing operations from right to left, such as:
            //   v2 = Mat2 * Mat1 * v1
            // This applies transform Mat1 to vector v1, and after that transform Mat2
            // (in this example, v1, v2 are 4-element column vectors and Mat1, Mat2 are
            // 4x4 matrices).

            const double torusR  = m_MajorR + m_MinorR;
            const double zOffset = 2.0 + torusR;
            const double farP    = zOffset + torusR + 0.0625;
            const double nearP   = (m_DrawsPerFrame < farP) ? 0.5 : (farP / (m_DrawsPerFrame * 1.0625));

            // In order to avoid clearing Z buffer for every draw, we apply depth bias to subsequent
            // draw calls using the projection matrix.  The depth bias is 1/m_DrawsPerFrame, so that
            // we completely fill the range of Z from 0 to 1 with subsequent draws.  The value
            // of depth bias is simply added to proj[2][2] component in projection matrix, which
            // results in this value being added to final Z after perspective division.
            const double depthBias = static_cast<double>(iDraw) / m_DrawsPerFrame;

            const float rotateAngleX  = static_cast<float>(deg2rad(m_Rotation + m_RotationStep * iDraw));
            const quat  torusRotQ     = quat(vec3(-1, 0, 0), rotateAngleX);
            const mat4  torusRotation = lwmath::quat_2_mat(torusRotQ);
            const mat4  model         = lwmath::translation_mat4(0.0f, 0.0f, static_cast<float>(zOffset))
                                        * torusRotation;

            // Form the view matrix, which transforms data from world space coordinates
            // to view space coordinates.  However for now we just use identity matrix,
            // meaning the camera is already placed in [0, 0, 0].
            mat4 view;
            view.identity();

            // Form the projection matrix.
            //
            // The values for the projection matrix are derived from:
            //   https://en.wikipedia.org/wiki/Intercept_theorem
            //
            // In Vulkan screen space, the X coordinates go from -1 (left) to 1 (right)
            // and Y coordinates go from -1 (top) to 1 (bottom).  So [0, 0] is the middle
            // of the screen.  We have to scale width and height according to the tangent
            // of half of the viewing angle and for width we also need to apply apect ratio.
            // Note that our Y coordinates go from bottom to top, so we need to ilwert
            // (negate) the Y coordinate.
            //
            // The only trick here is that we linearly scale 1/Z from 1/far to 1/near
            // such that 1/far is 0 and 1/near is 1.  This is for two reasons:
            //  - To reduce issues with float accuracy.  Float accuracy is highest
            //    between 0 and 1 and also accuracy increases closer to 0.  This is typically
            //    leveraged to reduce "Z fighting" for farther objects.
            //  - To clear the depth buffer with depth value 0, 0 must correspond to the far plane.
            //    We can then use VK_COMPARE_OP_GREATER for Z test.
            const float aspect = static_cast<float>(m_SurfaceWidth) / m_SurfaceHeight;
            const float fovTan = tanf(deg2rad(static_cast<float>(m_Fov)) * 0.5f);

            mat4 proj;
            proj.a00 = 1.0f / (aspect * fovTan);
            proj.a10 = 0;
            proj.a20 = 0;
            proj.a30 = 0;

            proj.a01 = 0;
            proj.a11 = -1.0f / fovTan;
            proj.a21 = 0;
            proj.a31 = 0;

            proj.a02 = 0;
            proj.a12 = 0;
            proj.a22 = static_cast<float>(depthBias - nearP / (farP - nearP));
            proj.a32 = 1;

            proj.a03 = 0;
            proj.a13 = 0;
            proj.a23 = static_cast<float>((farP * nearP) / (farP - nearP));
            proj.a33 = 0;

            uniform.modelView     = view * model;
            uniform.modelViewProj = proj * uniform.modelView;

            // Fill out light positions
            for (UINT32 i = 0; i < m_NumLights; i++)
            {
                // Light position is in view space coordinates
                const vec3  startPos   = vec3(-5, 5, -5);
                const float drawAngle  = iDraw * 90.0f / m_DrawsPerFrame;
                const float lightAngle = i * 180.f / m_NumLights;
                const float angle      = static_cast<float>(deg2rad(drawAngle + lightAngle));
                const quat  rotQ       = quat(vec3(0, 0, -1), angle);
                const vec3  pos        = lwmath::rotate_by(startPos, rotQ);

                uniform.lights[i] = vec4(pos, 0);
            }
        }
    }

    m_UniformDataBuf = VulkanBuffer(m_pVulkanDev);
    CHECK_VK_TO_RC(m_UniformDataBuf.CreateBuffer(VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
                                                 | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                                                 uniformBufSize,
                                                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    CHECK_VK_TO_RC(VkUtil::CopyBuffer(&auxCmdBuf,
                                      &hostUniformDataBuf,
                                      &m_UniformDataBuf,
                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                      VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
                                      VK_PIPELINE_STAGE_TRANSFER_BIT,
                                      VK_PIPELINE_STAGE_VERTEX_INPUT_BIT));

    return RC::OK;
}

RC VkFusion::Graphics::SetupErrorCounter(VulkanCmdBuffer& auxCmdBuf)
{
    RC rc;

    ////////////////////////////////////////////////////////////////////////////
    // Allocate error counter surface

    m_ErrorCountImage = VulkanImage(m_pVulkanDev);

    CHECK_VK_TO_RC(AllocateImage(&m_ErrorCountImage,
                                 VK_FORMAT_R16G16B16A16_UNORM,
                                 m_SurfaceWidth,
                                 m_SurfaceHeight,
                                 1, // mipmapLevels
                                 VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
                                    VK_IMAGE_USAGE_TRANSFER_SRC_BIT  |
                                    VK_IMAGE_USAGE_TRANSFER_DST_BIT,
                                 VK_IMAGE_TILING_OPTIMAL,
                                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));

    ////////////////////////////////////////////////////////////////////////////
    // Create render pass for comparing result vs. golden and writing error counters

    m_ErrorCountRenderPass = VulkanRenderPass(m_pVulkanDev);

    VkAttachmentDescription attDesc = { };
    attDesc.format         = m_ErrorCountImage.GetFormat();
    attDesc.samples        = VK_SAMPLE_COUNT_1_BIT;
    attDesc.loadOp         = VK_ATTACHMENT_LOAD_OP_LOAD;
    attDesc.storeOp        = VK_ATTACHMENT_STORE_OP_STORE;
    attDesc.stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    attDesc.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    attDesc.initialLayout  = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    attDesc.finalLayout    = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    m_ErrorCountRenderPass.PushAttachmentDescription(VkUtil::AttachmentType::COLOR, &attDesc);

    VkAttachmentReference colorRef = { };
    colorRef.attachment = 0;
    colorRef.layout     = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpass = { };
    subpass.pipelineBindPoint    = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments    = &colorRef;
    m_ErrorCountRenderPass.PushSubpassDescription(&subpass);

    CHECK_VK_TO_RC(m_ErrorCountRenderPass.CreateRenderPass());

    ////////////////////////////////////////////////////////////////////////////
    // Create framebuffer object for comparing result vs. golden

    m_ErrorCountFrameBuffer = VulkanFrameBuffer(m_pVulkanDev);

    vector<VkImageView> attachments = { m_ErrorCountImage.GetImageView() };

    MASSERT(m_ErrorCountRenderPass.GetAttachmentType(0) == VkUtil::AttachmentType::COLOR);

    m_ErrorCountFrameBuffer.SetWidth(m_SurfaceWidth);
    m_ErrorCountFrameBuffer.SetHeight(m_SurfaceHeight);

    CHECK_VK_TO_RC(m_ErrorCountFrameBuffer.CreateFrameBuffer(attachments,
                                                             m_ErrorCountRenderPass.GetRenderPass()));

    ////////////////////////////////////////////////////////////////////////////
    // Set up vertex shader

    VBBindingAttributeDesc vbBinding;

    vector<VkPipelineShaderStageCreateInfo> stages;

    VulkanShader vertexShader(m_pVulkanDev);
    CHECK_VK_TO_RC(vertexShader.CreateShader(VK_SHADER_STAGE_VERTEX_BIT,
                                             s_ErrorCountVertexShader,
                                             "main",
                                             m_ShaderReplacement));
    stages.push_back(vertexShader.GetShaderStageInfo());

    ////////////////////////////////////////////////////////////////////////////
    // Set up fragment shader

    VulkanShader fragmentShader(m_pVulkanDev);
    CHECK_VK_TO_RC(fragmentShader.CreateShader(VK_SHADER_STAGE_FRAGMENT_BIT,
                                               s_ErrorCountFragmentShader,
                                               "main",
                                               m_ShaderReplacement));
    stages.push_back(fragmentShader.GetShaderStageInfo());

    ////////////////////////////////////////////////////////////////////////////
    // Create descriptor set layouts and descriptor sets

    const VkDescriptorSetLayoutBinding bindings[] =
    {
        {
            0,                                  // binding
            VK_DESCRIPTOR_TYPE_SAMPLER,         // descriptorType
            1,                                  // descriptorCount
            VK_SHADER_STAGE_FRAGMENT_BIT,       // stageFlags
            nullptr                             // pImmutableSamplers
        },
        {
            1,                                  // binding
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,   // descriptorType
            2,                                  // descriptorCount
            VK_SHADER_STAGE_FRAGMENT_BIT,       // stageFlags
            nullptr                             // pImmutableSamplers
        },
    };
    m_ErrorCountDescriptorInfo = DescriptorInfo(m_pVulkanDev);
    constexpr UINT32 numBindings = static_cast<UINT32>(NUMELEMS(bindings));
    CHECK_VK_TO_RC(m_ErrorCountDescriptorInfo.CreateDescriptorSetLayout(0, numBindings, bindings));

    vector<VkDescriptorPoolSize> descPoolSizes =
    {
        { VK_DESCRIPTOR_TYPE_SAMPLER,        1 },
        { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,  2 },
    };
    descPoolSizes.resize(numBindings);
    CHECK_VK_TO_RC(m_ErrorCountDescriptorInfo.CreateDescriptorPool(m_NumJobs, descPoolSizes));

    for (UINT32 i = 0; i < m_NumJobs; i++)
    {
        CHECK_VK_TO_RC(m_ErrorCountDescriptorInfo.AllocateDescriptorSets(i, 1, 0));
    }

    ////////////////////////////////////////////////////////////////////////////
    // Create pipeline

    VkViewport viewport = { };
    viewport.width    = static_cast<float>(m_SurfaceWidth);
    viewport.height   = static_cast<float>(m_SurfaceHeight);
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    VkRect2D scissor = { };
    scissor.extent.width  = m_SurfaceWidth;
    scissor.extent.height = m_SurfaceHeight;

    m_ErrorCountPipeline = VulkanPipeline(m_pVulkanDev);

    m_ErrorCountPipeline.SetInputAssemblyTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_FALSE);

    VkPipelineViewportStateCreateInfo vpInfo = { VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO };
    vpInfo.viewportCount = 1;
    vpInfo.pViewports    = &viewport;
    vpInfo.scissorCount  = 1;
    vpInfo.pScissors     = &scissor;

    m_ErrorCountPipeline.SetViewPortAndScissorState(&vpInfo);

    m_ErrorCountPipeline.SetRasterizerState(VK_FALSE,                // depthClampEnable
                                            VK_FALSE,                // rasterizerDiscardEnable
                                            VK_POLYGON_MODE_FILL,    // polygonMode
                                            VK_LWLL_MODE_NONE,       // lwllMode
                                            VK_FRONT_FACE_CLOCKWISE, // frontFace
                                            VK_FALSE,                // depthBiasEnable
                                            0.0f,                    // depthBiasConstantFactor
                                            0.0f,                    // depthBiasClamp
                                            0.0f,                    // depthBiasSlopeFactor
                                            1.0f);                   // lineWidth

    VkPipelineDepthStencilStateCreateInfo dsInfo = { VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO };
    dsInfo.depthTestEnable  = VK_FALSE;
    dsInfo.depthWriteEnable = VK_FALSE;

    m_ErrorCountPipeline.SetDepthStencilState(&dsInfo);

    // Configure color and alpha channel blending in such a way that subsequent draws
    // are simply added together.
    VkPipelineColorBlendAttachmentState blendState = { };
    blendState.colorWriteMask      = 0b1111; // All channels - ABGR
    blendState.blendEnable         = VK_TRUE;
    blendState.colorBlendOp        = VK_BLEND_OP_ADD;
    blendState.alphaBlendOp        = VK_BLEND_OP_ADD;
    blendState.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    blendState.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;

    float blendConstants[4] = { 1, 1, 1, 1 };

    m_ErrorCountPipeline.SetColorBlendState(blendState, VK_FALSE, VK_LOGIC_OP_NO_OP, blendConstants);

    CHECK_VK_TO_RC(m_ErrorCountPipeline.SetupGraphicsPipeline(&vbBinding,
                                                              m_ErrorCountDescriptorInfo.GetDescriptorSetLayout(0),
                                                              stages,
                                                              m_ErrorCountRenderPass.GetRenderPass(),
                                                              0, // subpass
                                                              VK_SAMPLE_COUNT_1_BIT));

    ////////////////////////////////////////////////////////////////////////////
    // Create sampler

    VkSamplerCreateInfo samplerInfo = { VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO };
    samplerInfo.magFilter        = VK_FILTER_NEAREST;
    samplerInfo.minFilter        = VK_FILTER_NEAREST;
    samplerInfo.addressModeU     = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeV     = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeW     = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.mipmapMode       = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    samplerInfo.mipLodBias       = 0;
    samplerInfo.minLod           = 0;
    samplerInfo.maxLod           = 0;
    samplerInfo.anisotropyEnable = VK_FALSE;
    samplerInfo.maxAnisotropy    = 0;

    m_ErrorCountSampler = VulkanSampler(m_pVulkanDev);
    CHECK_VK_TO_RC(m_ErrorCountSampler.CreateSampler(samplerInfo));

    ////////////////////////////////////////////////////////////////////////////
    // Set sampler in descriptor sets

    for (UINT32 i = 0; i < m_NumJobs; i++)
    {
        const auto& allDescSets = m_ErrorCountDescriptorInfo.GetAllDescriptorSets();

        VkDescriptorImageInfo samplerInfo = { };
        samplerInfo.sampler     = m_ErrorCountSampler;
        samplerInfo.imageView   = VK_NULL_HANDLE;
        samplerInfo.imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        VkWriteDescriptorSet updateDescSet =
        {
            VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            nullptr,
            allDescSets[i],
            0,
            0,
            1,
            VK_DESCRIPTOR_TYPE_SAMPLER,
            &samplerInfo
        };

        m_ErrorCountDescriptorInfo.UpdateDescriptorSets(&updateDescSet, 1);
    }

    return RC::OK;
}

RC VkFusion::Graphics::SetupJob(VulkanCmdBuffer& auxCmdBuf, UINT32 jobId)
{
    Job& job = m_Jobs[jobId];

    if (m_DumpPng)
    {
        RC rc;
        CHECK_VK_TO_RC(AllocateImage(&job.dumpImage,
                                     m_pSwapChain->GetSwapChainImage(0)->GetFormat(),
                                     m_SurfaceWidth,
                                     m_SurfaceHeight,
                                     1, // mipmapLevels
                                     VK_IMAGE_USAGE_SAMPLED_BIT // not used, but required by validation layers
                                     | VK_IMAGE_USAGE_TRANSFER_DST_BIT,
                                     VK_IMAGE_TILING_LINEAR,
                                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
                                     | VK_MEMORY_PROPERTY_HOST_CACHED_BIT));
        CHECK_VK_TO_RC(job.dumpImage.SetImageLayout(&auxCmdBuf,
                                                    VK_IMAGE_ASPECT_COLOR_BIT,
                                                    VK_IMAGE_LAYOUT_GENERAL,
                                                    VK_ACCESS_HOST_READ_BIT,
                                                    VK_PIPELINE_STAGE_HOST_BIT));
    }

    UpdateDescriptorSets(jobId);

    return RC::OK;
}

void VkFusion::Graphics::UpdateDescriptorSets(UINT32 jobId)
{
    for (UINT32 iDraw = 0; iDraw < m_DrawsPerFrame; iDraw++)
    {
        const auto& allDescSets = m_DrawDescriptorInfo.GetAllDescriptorSets();
        const UINT32 descId = jobId * m_DrawsPerFrame + iDraw;

        VkDescriptorBufferInfo uniformInfo = { };
        uniformInfo.buffer = m_UniformDataBuf.GetBuffer();
        uniformInfo.offset = iDraw * m_UniformDataSize;
        uniformInfo.range  = m_UniformDataSize;

        vector<VkDescriptorImageInfo> samplerInfos;
        samplerInfos.reserve(m_Samplers.size());
        for (const VulkanSampler& sampler : m_Samplers)
        {
            VkDescriptorImageInfo imageInfo = { };
            imageInfo.sampler     = sampler;
            imageInfo.imageView   = VK_NULL_HANDLE;
            imageInfo.imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
            samplerInfos.push_back(imageInfo);
        }

        vector<VkDescriptorImageInfo> textureInfos;
        textureInfos.reserve(m_NumTextures);
        MASSERT(m_Textures.size() == m_NumTextures);
        for (const VulkanImage& tex : m_Textures)
        {
            VkDescriptorImageInfo imageInfo = { };
            imageInfo.sampler     = VK_NULL_HANDLE;
            imageInfo.imageView   = tex.GetImageView();
            imageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
            textureInfos.push_back(imageInfo);
        }

        VkWriteDescriptorSetAccelerationStructureKHR asInfo = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR };
        asInfo.accelerationStructureCount = 1;
        asInfo.pAccelerationStructures    = &m_RT.builder.GetAccelerationStructure();

        VkWriteDescriptorSet updateDescSets[] =
        {
            {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                nullptr,
                allDescSets[descId],
                0,
                0,
                1,
                VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                nullptr,
                &uniformInfo
            },
            {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                nullptr,
                allDescSets[descId],
                1,
                0,
                static_cast<UINT32>(m_Samplers.size()),
                VK_DESCRIPTOR_TYPE_SAMPLER,
                samplerInfos.data()
            },
            {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                nullptr,
                allDescSets[descId],
                2,
                0,
                static_cast<UINT32>(m_NumTextures),
                VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                textureInfos.data()
            },
            {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                &asInfo,
                allDescSets[descId],
                3,
                0,
                1,
                VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR
            }
        };

        UINT32 numDesc = static_cast<UINT32>(NUMELEMS(updateDescSets));

        if (!m_RaysPerPixel)
        {
            --numDesc;
        }

        m_DrawDescriptorInfo.UpdateDescriptorSets(&updateDescSets[0], numDesc);
    }
}

RC VkFusion::Graphics::FillCmdBuffer(VulkanCmdBuffer& cmdBuf, UINT32 jobId, UINT32 iDraw)
{
    m_pVulkanDev->CmdBindPipeline(cmdBuf.GetCmdBuffer(),
                                  VK_PIPELINE_BIND_POINT_GRAPHICS,
                                  m_DrawPipeline.GetPipeline());

    if (m_GeometryType == geomVertexBuffer)
    {
        const VkBuffer     vb       = m_VertexBuf.GetBuffer();
        const VkDeviceSize vbOffset = 0;
        m_pVulkanDev->CmdBindVertexBuffers(cmdBuf.GetCmdBuffer(),
                                           0,
                                           1,
                                           &vb,
                                           &vbOffset);
        m_pVulkanDev->CmdBindIndexBuffer(cmdBuf.GetCmdBuffer(),
                                         m_IndexBuf.GetBuffer(),
                                         0,
                                         VK_INDEX_TYPE_UINT32);
    }

    const VkDescriptorSet descSet = m_DrawDescriptorInfo.GetDescriptorSet(jobId * m_DrawsPerFrame + iDraw);
    m_pVulkanDev->CmdBindDescriptorSets(cmdBuf.GetCmdBuffer(),
                                        VK_PIPELINE_BIND_POINT_GRAPHICS,
                                        m_DrawPipeline.GetPipelineLayout(),
                                        0,
                                        1,
                                        &descSet,
                                        0,
                                        nullptr);

    if (m_GeometryType == geomVertexBuffer)
    {
        m_pVulkanDev->CmdDrawIndexed(cmdBuf.GetCmdBuffer(),
                                     m_NumIndices,  // indexCount
                                     1,             // instanceCount
                                     0,             // firstVertex
                                     0,             // vertexOffset
                                     0);            // firstInstance
    }
    else
    {
        m_pVulkanDev->CmdDraw(cmdBuf.GetCmdBuffer(),
                              4,  // vertexCount set to 4 for one quad patch
                              1,  // instanceCount
                              0,  // firstVertex
                              0); // firstInstance
    }

    return RC::OK;
}

void VkFusion::Graphics::PreRun()
{
    for (Job& job : m_Jobs)
    {
        job.numChecks = 0;
    }
    m_LastJobId        = ~0U;
    m_LastSwapChainIdx = ~0U;
    m_TotalDraws       = 0;
    m_DrawsPerSecond   = 0;
    m_TotalPixels      = 0;
}

RC VkFusion::Graphics::Execute
(
    UINT32            jobId,
    VulkanCmdBuffer** pCmdBufs,
    UINT32            numCmdBufs,
    VkSemaphore*      pJobWaitSema,
    VkSemaphore*      pPresentSema
)
{
    MASSERT(numCmdBufs == 1);

    Job& job = m_Jobs[jobId];

    const UINT32 swapChainIdx = m_pSwapChain->GetNextSwapChainImage(job.waitSema.GetSemaphore());
    VulkanFrameBuffer& framebuffer = m_FrameBuffers[swapChainIdx];

    VulkanImage* const pColorAtt = m_pSwapChain->GetSwapChainImage(swapChainIdx);
    MASSERT(pColorAtt);

    RC rc;
    CHECK_VK_TO_RC(pColorAtt->SetImageLayout(pCmdBufs[0],
                                             VK_IMAGE_ASPECT_COLOR_BIT,
                                             VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                                             VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
                                             VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT));

    constexpr UINT32 clearColor = 0xFF000000u;

    VkClearValue clearValues[2];
    clearValues[0].color.float32[0] = ((clearColor >> 16) & 0xFF) * (1.0f / 255.0f); // Red
    clearValues[0].color.float32[1] = ((clearColor >>  8) & 0xFF) * (1.0f / 255.0f); // Green
    clearValues[0].color.float32[2] = ((clearColor >>  0) & 0xFF) * (1.0f / 255.0f); // Blue
    clearValues[0].color.float32[3] = ((clearColor >> 24) & 0xFF) * (1.0f / 255.0f); // Alpha
    clearValues[1].depthStencil     = { 0.0f, 0 };

    m_StatsQuery.CmdReset(pCmdBufs[0], jobId * m_DrawsPerFrame, m_DrawsPerFrame);

    for (UINT32 iDraw = 0; iDraw < m_DrawsPerFrame; iDraw++)
    {
        const UINT32 queryIdx = jobId * m_DrawsPerFrame + iDraw;

        const bool clear = iDraw == 0;
        VulkanRenderPass& renderPass = clear ? m_ClearRenderPass : m_DrawRenderPass;

        VkRenderPassBeginInfo renderPassInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO };
        renderPassInfo.renderPass               = renderPass.GetRenderPass();
        renderPassInfo.renderArea.extent.width  = framebuffer.GetWidth();
        renderPassInfo.renderArea.extent.height = framebuffer.GetHeight();
        renderPassInfo.clearValueCount          = static_cast<UINT32>(NUMELEMS(clearValues));
        renderPassInfo.pClearValues             = &clearValues[0];
        renderPassInfo.framebuffer              = framebuffer.GetVkFrameBuffer();

        m_pVulkanDev->CmdBeginRenderPass(pCmdBufs[0]->GetCmdBuffer(),
                                         &renderPassInfo,
                                         VK_SUBPASS_CONTENTS_INLINE);

        m_StatsQuery.CmdBegin(pCmdBufs[0], queryIdx, 0);

        CHECK_RC(FillCmdBuffer(*pCmdBufs[0], jobId, iDraw));

        m_StatsQuery.CmdEnd(pCmdBufs[0], queryIdx);

        m_pVulkanDev->CmdEndRenderPass(pCmdBufs[0]->GetCmdBuffer());
    }

    m_StatsQuery.CmdCopyResults(pCmdBufs[0],
                                jobId * m_DrawsPerFrame,
                                m_DrawsPerFrame,
                                VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WAIT_BIT);

    CHECK_RC(CheckResults(*pCmdBufs[0], *pColorAtt, jobId));

    if (m_DumpPng)
    {
        CHECK_RC(CopyOutputImage(*pCmdBufs[0], *pColorAtt, job.dumpImage));
    }

    CHECK_VK_TO_RC(pColorAtt->SetImageLayout(pCmdBufs[0],
                                             VK_IMAGE_ASPECT_COLOR_BIT,
                                             VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
                                             VK_ACCESS_MEMORY_READ_BIT,
                                             VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT));

    m_LastJobId        = jobId;
    m_LastSwapChainIdx = swapChainIdx;
    *pJobWaitSema      = job.waitSema.GetSemaphore();
    *pPresentSema      = job.swapSema.GetSemaphore();
    m_TotalDraws      += m_DrawsPerFrame;

    return RC::OK;
}

RC VkFusion::Graphics::Present(VkSemaphore presentSema)
{
    RC rc;
    // The last arg is false because we don't want MODS to wait on anything.
    // On windows that arg is ignored.
    CHECK_VK_TO_RC(m_pSwapChain->PresentImage(m_LastSwapChainIdx,
                                              presentSema,
                                              VK_NULL_HANDLE,
                                              false));
    return RC::OK;
}

RC VkFusion::Graphics::CheckFrame(UINT32 jobId, UINT64 frameId, bool finalFrame)
{
    Job& job = m_Jobs[jobId];

    if (job.numChecks)
    {
        const UINT64* pStats = static_cast<const UINT64*>(m_StatsQuery.GetResultsPtr());
        const UINT64* const pEnd = pStats + m_DrawsPerFrame;
        for (; pStats < pEnd; ++pStats)
        {
            m_TotalPixels += *pStats;
        }
    }

    if (!finalFrame || !m_Check || (jobId != m_LastJobId))
    {
        return RC::OK;
    }

    VerbosePrintf("Graphics: Checking for errors at job %u frame %llu\n", jobId, frameId);

    RC rc;

    // Create auxiliary/temporary command buffer
    VulkanCmdBuffer auxCmdBuf(m_pVulkanDev);
    CHECK_VK_TO_RC(auxCmdBuf.AllocateCmdBuffer(&m_CmdPool));

    // Create host-readable buffer
    VulkanBuffer hostBuf(m_pVulkanDev);
    CHECK_VK_TO_RC(hostBuf.CreateBuffer(VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                                        m_SurfaceWidth * m_SurfaceHeight *
                                            static_cast<UINT32>(sizeof(UINT64)),
                                        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                                            VK_MEMORY_PROPERTY_HOST_CACHED_BIT));

    CHECK_VK_TO_RC(auxCmdBuf.BeginCmdBuffer());

    CHECK_VK_TO_RC(m_ErrorCountImage.SetImageLayout(&auxCmdBuf,
                                                    VK_IMAGE_ASPECT_COLOR_BIT,
                                                    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                                    VK_ACCESS_TRANSFER_READ_BIT,
                                                    VK_PIPELINE_STAGE_TRANSFER_BIT));

    VkBufferImageCopy copyRegion = { };
    copyRegion.bufferOffset                = 0;
    copyRegion.bufferRowLength             = m_SurfaceWidth;
    copyRegion.bufferImageHeight           = m_SurfaceHeight;
    copyRegion.imageSubresource.aspectMask = m_ErrorCountImage.GetImageAspectFlags();
    copyRegion.imageSubresource.layerCount = 1;
    copyRegion.imageExtent.width           = m_ErrorCountImage.GetWidth();
    copyRegion.imageExtent.height          = m_ErrorCountImage.GetHeight();
    copyRegion.imageExtent.depth           = 1;

    m_pVulkanDev->CmdCopyImageToBuffer(auxCmdBuf.GetCmdBuffer(),
                                       m_ErrorCountImage.GetImage(),
                                       m_ErrorCountImage.GetImageLayout(),
                                       hostBuf.GetBuffer(),
                                       1,
                                       &copyRegion);

    CHECK_VK_TO_RC(m_ErrorCountImage.SetImageLayout(&auxCmdBuf,
                                                    VK_IMAGE_ASPECT_COLOR_BIT,
                                                    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                                                    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
                                                    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT));

    CHECK_VK_TO_RC(auxCmdBuf.EndCmdBuffer());
    CHECK_VK_TO_RC(auxCmdBuf.ExelwteCmdBuffer(true, false));

    // Check error numbers
    struct Errors
    {
        UINT16 r;
        UINT16 g;
        UINT16 b;
        UINT16 a;
    };
    static_assert(sizeof(Errors) == sizeof(UINT64), "Unexpected size of struct Errors");
    MASSERT(m_ErrorCountImage.GetFormat() == VK_FORMAT_R16G16B16A16_UNORM);
    UINT64 totalRed   = 0;
    UINT64 totalGreen = 0;
    UINT64 totalBlue  = 0;
    UINT64 totalAlpha = 0;
    UINT16 maxRed     = 0;
    UINT16 maxGreen   = 0;
    UINT16 maxBlue    = 0;
    UINT16 maxAlpha   = 0;
    VulkanBufferView<Errors> view(hostBuf);
    CHECK_VK_TO_RC(view.Map());
    for (const Errors& pixelErrors : view)
    {
        totalRed   += pixelErrors.r;
        totalGreen += pixelErrors.g;
        totalBlue  += pixelErrors.b;
        totalAlpha += pixelErrors.a;
        maxRed     = max(maxRed,   pixelErrors.r);
        maxGreen   = max(maxGreen, pixelErrors.g);
        maxBlue    = max(maxBlue,  pixelErrors.b);
        maxAlpha   = max(maxAlpha, pixelErrors.a);
    }

    if (totalRed || totalGreen || totalBlue || totalAlpha)
    {
        Printf(Tee::PriError, "VkFusion.Graphics found pixel miscompares: red=%llu, green=%llu, blue=%llu, alpha=%llu\n",
               totalRed, totalGreen, totalBlue, totalAlpha);

        // Make the errors visible in the image
        const UINT16 maxColor = max(maxRed, max(maxGreen, maxBlue));
        for (Errors& pixelErrors : view)
        {
            if (pixelErrors.r || pixelErrors.g || pixelErrors.b)
            {
                const UINT16 r = (pixelErrors.r * 0xFFFFU) / maxColor;
                const UINT16 g = (pixelErrors.g * 0xFFFFU) / maxColor;
                const UINT16 b = (pixelErrors.b * 0xFFFFU) / maxColor;
                if (totalAlpha)
                {
                    pixelErrors.r = max(r, b);
                    pixelErrors.g = g;
                    pixelErrors.b = (pixelErrors.a * 0xFFFFU) / maxAlpha;
                }
                else
                {
                    pixelErrors.r = r;
                    pixelErrors.g = g;
                    pixelErrors.b = b;
                }
                pixelErrors.a = 0xFFFFU;
            }
            else if (pixelErrors.a)
            {
                pixelErrors.b = (pixelErrors.a * 0xFFFFU) / maxAlpha;
                pixelErrors.a = 0xFFFFU;
            }
        }
        const char* const key = totalAlpha ? "red=max(red,blue), green=green, blue=alpha"
                                           : "red=red, green=green, blue=blue";

        static int dumpIdx = 0;
        const string errorFilename = Utility::StrPrintf("vkfusion_gfx_errors_%04d.png", dumpIdx);
        Printf(Tee::PriNormal, "Dumping %s with %s\n", errorFilename.c_str(), key);

        const RC dumpRc = ImageFile::WritePng(errorFilename.c_str(),
                                              ColorUtils::RF16_GF16_BF16_AF16,
                                              view.data(),
                                              m_SurfaceWidth,
                                              m_SurfaceHeight,
                                              m_SurfaceWidth * sizeof(UINT64),
                                              false,
                                              false);
        if (dumpRc != RC::OK)
        {
            Printf(Tee::PriError, "Failed to dump errors to PNG\n");
        }

        return RC::GOLDEN_VALUE_MISCOMPARE;
    }

    return RC::OK;
}

RC VkFusion::Graphics::CheckResults(VulkanCmdBuffer& cmdBuf, VulkanImage& srcImg, UINT32 jobId)
{
    RC rc;
    Job& job = m_Jobs[jobId];

    if (job.numChecks == 0)
    {
        if (jobId == 0)
        {
            CHECK_VK_TO_RC(m_ErrorCountImage.SetImageLayout(&cmdBuf,
                                                            VK_IMAGE_ASPECT_COLOR_BIT,
                                                            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                                            VK_ACCESS_TRANSFER_WRITE_BIT,
                                                            VK_PIPELINE_STAGE_TRANSFER_BIT));

            // Clear to black, i.e. all 0s
            VkClearColorValue clearColor;
            memset(&clearColor, 0, sizeof(clearColor));

            VkImageSubresourceRange range = { };
            range.aspectMask = m_ErrorCountImage.GetImageAspectFlags();
            range.levelCount = 1;
            range.layerCount = 1;

            m_pVulkanDev->CmdClearColorImage(cmdBuf.GetCmdBuffer(),
                                             m_ErrorCountImage.GetImage(),
                                             m_ErrorCountImage.GetImageLayout(),
                                             &clearColor,
                                             1,
                                             &range);

            CHECK_VK_TO_RC(m_ErrorCountImage.SetImageLayout(&cmdBuf,
                                                            VK_IMAGE_ASPECT_COLOR_BIT,
                                                            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                                                            VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
                                                            VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT));
        }

        CHECK_VK_TO_RC(srcImg.SetImageLayout(&cmdBuf,
                                             VK_IMAGE_ASPECT_COLOR_BIT,
                                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                             VK_ACCESS_TRANSFER_READ_BIT,
                                             VK_PIPELINE_STAGE_TRANSFER_BIT));

        CHECK_VK_TO_RC(job.goldenImage.SetImageLayout(&cmdBuf,
                                                      VK_IMAGE_ASPECT_COLOR_BIT,
                                                      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                                      VK_ACCESS_TRANSFER_WRITE_BIT,
                                                      VK_PIPELINE_STAGE_TRANSFER_BIT));

        VkImageCopy copyRegion = { };
        copyRegion.srcSubresource.aspectMask = srcImg.GetImageAspectFlags();
        copyRegion.srcSubresource.layerCount = 1;
        copyRegion.dstSubresource.aspectMask = job.goldenImage.GetImageAspectFlags();
        copyRegion.dstSubresource.layerCount = 1;
        copyRegion.extent.width              = srcImg.GetWidth();
        copyRegion.extent.height             = srcImg.GetHeight();
        copyRegion.extent.depth              = 1;

        m_pVulkanDev->CmdCopyImage(cmdBuf.GetCmdBuffer(),
                                   srcImg.GetImage(),
                                   srcImg.GetImageLayout(),
                                   job.goldenImage.GetImage(),
                                   job.goldenImage.GetImageLayout(),
                                   1,
                                   &copyRegion);

        CHECK_VK_TO_RC(job.goldenImage.SetImageLayout(&cmdBuf,
                                                      VK_IMAGE_ASPECT_COLOR_BIT,
                                                      VK_IMAGE_LAYOUT_GENERAL,
                                                      VK_ACCESS_SHADER_READ_BIT,
                                                      VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT));
    }
    else if (m_Check)
    {
        CHECK_VK_TO_RC(srcImg.SetImageLayout(&cmdBuf,
                                             VK_IMAGE_ASPECT_COLOR_BIT,
                                             VK_IMAGE_LAYOUT_GENERAL,
                                             VK_ACCESS_SHADER_READ_BIT,
                                             VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT));

        VkRenderPassBeginInfo renderPassInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO };
        renderPassInfo.renderPass               = m_ErrorCountRenderPass.GetRenderPass();
        renderPassInfo.renderArea.extent.width  = m_ErrorCountImage.GetWidth();
        renderPassInfo.renderArea.extent.height = m_ErrorCountImage.GetHeight();
        renderPassInfo.framebuffer              = m_ErrorCountFrameBuffer.GetVkFrameBuffer();

        m_pVulkanDev->CmdBeginRenderPass(cmdBuf.GetCmdBuffer(),
                                         &renderPassInfo,
                                         VK_SUBPASS_CONTENTS_INLINE);

        m_pVulkanDev->CmdBindPipeline(cmdBuf.GetCmdBuffer(),
                                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                                      m_ErrorCountPipeline.GetPipeline());

        VkDescriptorImageInfo textureInfos[2] = { };
        textureInfos[0].sampler     = VK_NULL_HANDLE;
        textureInfos[0].imageView   = srcImg.GetImageView();
        textureInfos[0].imageLayout = VK_IMAGE_LAYOUT_GENERAL;
        textureInfos[1].sampler     = VK_NULL_HANDLE;
        textureInfos[1].imageView   = job.goldenImage.GetImageView();
        textureInfos[1].imageLayout = VK_IMAGE_LAYOUT_GENERAL;

        const VkDescriptorSet descSet = m_ErrorCountDescriptorInfo.GetDescriptorSet(jobId);

        VkWriteDescriptorSet updateDescSet =
        {
            VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            nullptr,
            descSet,
            1,
            0,
            2,
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            textureInfos
        };

        m_ErrorCountDescriptorInfo.UpdateDescriptorSets(&updateDescSet, 1);

        m_pVulkanDev->CmdBindDescriptorSets(cmdBuf.GetCmdBuffer(),
                                            VK_PIPELINE_BIND_POINT_GRAPHICS,
                                            m_ErrorCountPipeline.GetPipelineLayout(),
                                            0,
                                            1,
                                            &descSet,
                                            0,
                                            nullptr);

        m_pVulkanDev->CmdDraw(cmdBuf.GetCmdBuffer(),
                              6,  // vertexCount - two triangles covering entire image
                              1,  // instanceCount
                              0,  // firstVertex
                              0); // firstInstance

        m_pVulkanDev->CmdEndRenderPass(cmdBuf.GetCmdBuffer());
    }

    ++job.numChecks;

    return RC::OK;
}

RC VkFusion::Graphics::CopyOutputImage
(
    VulkanCmdBuffer& cmdBuf,
    VulkanImage&     srcImg,
    VulkanImage&     dstImg
)
{
    RC rc;

    CHECK_VK_TO_RC(srcImg.SetImageLayout(&cmdBuf,
                                         VK_IMAGE_ASPECT_COLOR_BIT,
                                         VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                         VK_ACCESS_TRANSFER_READ_BIT,
                                         VK_PIPELINE_STAGE_TRANSFER_BIT));

    CHECK_VK_TO_RC(dstImg.SetImageLayout(&cmdBuf,
                                         VK_IMAGE_ASPECT_COLOR_BIT,
                                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                         VK_ACCESS_TRANSFER_WRITE_BIT,
                                         VK_PIPELINE_STAGE_TRANSFER_BIT));

    VkImageCopy copyRegion = { };
    copyRegion.srcSubresource.aspectMask = srcImg.GetImageAspectFlags();
    copyRegion.srcSubresource.layerCount = 1;
    copyRegion.dstSubresource.aspectMask = dstImg.GetImageAspectFlags();
    copyRegion.dstSubresource.layerCount = 1;
    copyRegion.extent.width              = srcImg.GetWidth();
    copyRegion.extent.height             = srcImg.GetHeight();
    copyRegion.extent.depth              = 1;

    m_pVulkanDev->CmdCopyImage(cmdBuf.GetCmdBuffer(),
                               srcImg.GetImage(),
                               srcImg.GetImageLayout(),
                               dstImg.GetImage(),
                               dstImg.GetImageLayout(),
                               1,
                               &copyRegion);

    CHECK_VK_TO_RC(dstImg.SetImageLayout(&cmdBuf,
                                         VK_IMAGE_ASPECT_COLOR_BIT,
                                         VK_IMAGE_LAYOUT_GENERAL,
                                         VK_ACCESS_HOST_READ_BIT,
                                         VK_PIPELINE_STAGE_HOST_BIT));

    return RC::OK;
}

RC VkFusion::Graphics::Dump(UINT32 jobId, UINT64 frameId)
{
    RC rc;
    VulkanImage& dumpImage = m_Jobs[jobId].dumpImage;

    const string filename = Utility::StrPrintf("vkfusion_gfx%llu.png", frameId);
    VerbosePrintf("Graphics: Dumping %s\n", filename.c_str());

    const VkDeviceSize size = dumpImage.GetPitch() * dumpImage.GetHeight();
    void* ptr = nullptr;
    CHECK_VK_TO_RC(dumpImage.Map(size, 0, &ptr));
    DEFER { dumpImage.Unmap(); };

    // Make the image visible/usable
    if (dumpImage.GetFormat() == VK_FORMAT_R16G16B16A16_SFLOAT)
    {
        ColwertSignedFloatToUser(ptr, size);
    }

    CHECK_RC(ImageFile::WritePng(filename.c_str(),
                                 VkUtil::ColorUtilsFormat(dumpImage.GetFormat()),
                                 ptr,
                                 dumpImage.GetWidth(),
                                 dumpImage.GetHeight(),
                                 static_cast<UINT32>(dumpImage.GetPitch()),
                                 false,
                                 false));

    return RC::OK;
}

void VkFusion::Graphics::ColwertSignedFloatToUser(void* ptr, UINT64 numBytes)
{
    UINT16*       pComp = static_cast<UINT16*>(ptr);
    UINT16* const pEnd  = pComp + (numBytes / sizeof(*pComp));

    VerbosePrintf("Colwerting FP16 to usable UINT16\n");

    for (UINT32 i = 1; pComp < pEnd; pComp++, i++)
    {
        // This function is used to colwert FP16 RGBA image to 16-bit PNG
        // (16 bits per component).  Technically components in PNG are UNORM.
        // We could map FP16 directly to UNORM, but then that is useless if
        // the user wants to see the actual image.  The purpose of this function
        // is to make the image usable for inspection.
        //
        // Each component is signed FP16.  FP16 description:
        // https://en.wikipedia.org/wiki/Half-precision_floating-point_format
        // To summarize:
        //  1 bit sign (most significant, assuming little endian)
        //  5 bits of exponent
        // 10 bits of mantissa
        //
        // We will be dumping this to 16-bit PNG.  For the user to be able to
        // view the PNG, we have to normalize the numbers, because on 10-bit
        // monitors on MacOS the topmost 10 bits of each component are displayed
        // (no idea how it works on Windows or Linux) and on most common 8-bit
        // monitors the topmost 8 bits of each components are displayed.
        //
        // So we simply swap sign+exponent with mantissa in place, so that the
        // 10 bits of mantissa end up being most significant bits.  If the user
        // wants to do raw bitwise comparison (somehow?) it is still possible,
        // so the colwersion is lossless.
        const UINT16 origValue  = *pComp;
        const UINT16 expAndSign = origValue >> 10;
        const UINT16 finalValue = (origValue << 6) | expAndSign;

        // We flip all bits of the alpha channel, because at the moment the
        // alpha component stays at 1 and is not very usable, so mantissa
        // ends up at 0 and thus the user would view this as fully transparent.
        // In the future when we use the alpha channel for RT we will probably
        // split it out to a separate image.
        const bool   isAlpha = !(i & 3);
        const UINT16 mask    = isAlpha ? 0xFFFFu : 0u;

        *pComp = finalValue ^ mask;
    }
}

void VkFusion::Graphics::UpdateAndPrintStats(UINT64 elapsedMs)
{
    m_DrawsPerSecond  = elapsedMs ? (m_TotalDraws  * 1000.0 / elapsedMs) : 0.0;
    m_PixelsPerSecond = elapsedMs ? (m_TotalPixels * 1000.0 / elapsedMs) : 0.0;

    VerbosePrintf("Graphics: Drew %llu toruses in %llu ms, %.1f Draws-Per-Second\n",
                  m_TotalDraws, elapsedMs, m_DrawsPerSecond);
    VerbosePrintf("Graphics: Drew %llu M pixels in %llu ms, %.1f M Pixels-Per-Second\n",
                  m_TotalPixels / 1_MB, elapsedMs, m_PixelsPerSecond / 1_MB);

    if (m_RaysPerPixel)
    {
        const INT32  maskBits      = Utility::CountBits(m_RTXMask);
        const UINT64 totalRays     = (m_TotalPixels * m_RaysPerPixel) >> maskBits;
        const double raysPerSecond = (m_PixelsPerSecond * m_RaysPerPixel) / (1 << maskBits);

        VerbosePrintf("Graphics: Traced %llu M rays in %llu ms, %.1f M Rays-Per-Second\n",
                      totalRays / 1_MB, elapsedMs, raysPerSecond / 1_MB);
    }
}
