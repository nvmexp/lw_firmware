/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2005-2019 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#ifndef INCLUDED_BUFBUILD_H
#define INCLUDED_BUFBUILD_H

#include "bufmgr.h"
#include "core/include/massert.h"
#include "core/include/rc.h"
#include "core/include/script.h"
#include <string>
#include <vector>
#include <map>

enum FragListProperties
{
    FRAGLIST_MIN_LENGTH,
    FRAGLIST_MAX_LENGTH,
    FRAGLIST_MIN_SIZE,
    FRAGLIST_MAX_SIZE,
    FRAGLIST_MIN_OFFSET,
    FRAGLIST_MAX_OFFSET,
    FRAGLIST_DATAWIDTH,
    FRAGLIST_ALIGN,
    FRAGLIST_IS_SHUFFLE
};

class BufBuild
{
public:
    typedef vector<BufferMgr::AllocInfo> Allocs;
    typedef MemoryFragment::FRAGLIST  Frags;
    typedef vector<UINT08> V_UINT08;
    typedef vector<UINT16> V_UINT16;
    typedef vector<UINT32> V_UINT32;
    typedef vector<UINT64> V_UINT64;

    typedef struct
    {
        UINT32 numMin;
        UINT32 numMax;
        UINT32 sizeMin;
        UINT32 sizeMax;
        UINT32 offsetMin;
        UINT32 offsetMax;
        UINT32 dataWidth;
        UINT32 align;
        UINT32 boundaryMask;
        UINT32 isShuffle;
        UINT32 setProperties;
    }PriPara;

    BufBuild();
    ~BufBuild();

    //! \Set some setting
    RC SetAttr(UINT32 HwMaxFragments,
               UINT32 HwMinDataWidth,
               UINT32 HwMaxFragSize,
               UINT32 AddrBits,
               Memory::Attrib MemAttr,
               UINT32 BoundaryMask = 0);

    //! \Create bufmgr object with totalbytes memory.
    //! \If totalBytes is zero, don't alloc any memory but still create bufmgr object
    //! \return the index of bufmgr object
    RC CreateBufMgrs(vector <UINT64>* pvIndexReturned,
                     UINT32 NumBuffer,
                     UINT32 TotalBytes,
                     Controller *pCtrl = nullptr);

    /*
     * GenerateFragmentList -   Generate frag list
     * Index                    Indicate which bufmgr object  will be
     *                              used to generate fraglist.
     * Key                      Flag the generated fraglist. If the Key value exits,
     *                              New generated fraglist will overwrite old fraglist structure
     *                              if not present, will create a new fraglist structure.
     *                              By default, Key is set to zero. Users can set multiple key values
     *                              to hold multiple fraglists in one bufmgr.
     * ppFragList               Return a frageList pointer into *ppFragList
     * pPara                    Contain the parameters from internal code.Its'value is null by default
     */
    //! \brief: Users can mark or get any time's fraglist generated by this function
    //  with Index and Key. The "Index" and "Key" will respond to only fraglist.
    //  If user want to generate fraglist twice marking with the same Index and Key ,
    //  then the  latter fraglist will overwirte prevoius fraglist.
    //  Attention, each fraglist with the same Index will use the same buffer range,i.e BufMgr object.
    //  So, the fraglists with the same Index can't be used simultaneously as dma read operation
    RC GenerateFragmentList(UINT64 BufferIndex,
                            UINT32 TotalBytes,
                            Frags **ppFragList,
                            UINT32 Key = 0,
                            UINT32 PrintMask = 0);

    /*
     * GetFragList  - Get fraglist users previously generated with GenerateFragmentList function
     * Index          Indicate which bufmgr object
     * Key            Indicate which fraglist in the 'Index' bufmgr object
     * ppFragList     Return a frageList pointer into *ppFragList
     */
    RC GetFragList(UINT64 BufferIndex, Frags **ppFragList, UINT32 Key = 0);

    // if pFragList exists, return the Buffer Index it associated, otherwiase 0
    UINT64 FindFragmentList(Frags *pFragList, UINT32 *pNumOfFrags = NULL);

    RC SetFragListProperty(UINT64 BufferIndex,
                           UINT32 Property,
                           UINT32 Value);

    RC FillPattern(UINT64 BufferIndex, V_UINT08 *pPattern);
    RC FillPattern(UINT64 BufferIndex, V_UINT16 *pPattern);
    RC FillPattern(UINT64 BufferIndex, V_UINT32 *pPattern);

    //! \ Transfer custom size vector or off vector from user's inputs
    RC SetLwstomProperties(V_UINT32 *pvBufSize, V_UINT32 *pvBufOff);

    RC PrintTestInfo();
    RC PrintProperties();
    bool IsPrint(UINT32 val);
    RC PrintNode();

    // Clear memory
    RC Clear(UINT64 BufferIndex = 0);

protected:

    //! \ The size value probably need calwlation. Don't overwrite the new value to p_SizeMin or pSizeMax
    //! \ in case any issue happens in multiple processs elwiroment

    //! \brief:
    // sizeMode is comprised of size-fix, sizeAvg, sizeNumRnd and sizeCstm
    // 1. With the value of m_vCstmSize, we can determine size custom mode.
    // 2. sizeMin == sizeMax, numMin = numMax = 0;  we can dertermine it's size-Fix mode,
    //      we calwlate the numMin and numMax value with TotalByte/sizeMin(sizeMax);
    // 3. numMin == numMax,  SizeMin = SizeMax = 0; this case is sizeAvg mode,
    //      we transfer sizeMax = 0 into bufMgr->CallwlateFragSizes and the function will
    //      average mode
    // 4. For random mode, we don't need to have special manipulation and directly transfer parameters
    //      into bufMgr class
    // In fact, there is another default case in enet and ahci that sizeMax 's value is TotalBytes,
    // So we leave sizeMax == 0 and let code fill its value with TotalBytes dynamically.
    // This function's intention is to prepare proper parameters well to feed them to bufMgr class.
    // Also, set sizeMax to ~0 is a safe value.

    RC GenerateFragListProperties(PriPara* pPriPara,
                                  BufferMgr* pBufMgr,
                                  Allocs *pAllocInfo,
                                  UINT32 TotalBytes);

    RC ValidateSizeNum(BufferMgr *pBufMgr,
                       UINT32 TotalBytes,
                       UINT32 DataWidth,
                       UINT32 &SizeMin,
                       UINT32 &SizeMax,
                       UINT32 &NumMin,
                       UINT32 &NumMax,
                       UINT32 &Align);

    RC ValidateAlign(UINT32 &Align);

    RC GetBufferMgr(UINT64 BufferIndex, BufferMgr **ppBufMgr);

    //! \ Transfer NumMin and NumMax since its'value probably needs to be changed
    RC GenerateNumFrags(BufferMgr *pBufMgr,
                        UINT32 TotalBytes,
                        UINT32 DataWidth,
                        Allocs *pAllocList,
                        UINT32 NumMin,
                        UINT32 NumMax);

    //! \ Transfer SizeMin and SizeMax since its'value probably needs to be changed
    RC GenerateFragSizes(BufferMgr *pBufMgr,
                    UINT32 TotalBytes,
                    UINT32 DataWidth,
                    Allocs *pAllocList,
                    UINT32 SizeMin,
                    UINT32 SizeMax);

    //! \ Transfer Align
    RC GenerateOffsets(BufferMgr* pBufMgr,
                       UINT32 TotalBytes,
                       UINT32 DataWidth,
                       Allocs* pAllocList,
                       UINT32 Align);

    RC ValidateIndex(UINT64 BufferIndex);
    bool IsKeyPresent(UINT64 BufferIndex, UINT32 Key);
    RC ValidateKey(UINT64 BufferIndex, UINT32 Key);
    RC UpdateLwstomProperties(Allocs *pAllocInfo);
    RC PrintParameters();
    RC PrintLwstomProperties();
    RC PrintPriParams(UINT64 Index);

public:
    //! \Parameters from user input or internal default initialization
    UINT32 p_SizeMin;
    UINT32 p_SizeMax;
    UINT32 p_NumMin;
    UINT32 p_NumMax;
    UINT32 p_OffMin;
    UINT32 p_OffMax;
    UINT32 p_OffStep;
    UINT32 p_DataWidth;
    UINT32 p_Align;
    bool   p_IsShuffle;
    V_UINT32 m_vCstmSize;
    V_UINT32 m_vCstmOff;

protected:
    // public parameters going private for now

    UINT32 m_LwstomLength;
    UINT32 m_LwstomSizeLength;
    UINT32 m_LwstomOffsetLength;
    UINT32 m_AddrBits;
    Memory::Attrib m_MemAttr;
    UINT32 m_HwMaxFragments;
    UINT32 m_HwMinDataWidth;
    UINT32 m_MaxFragSize;
    UINT32 m_BoundaryMask;

    typedef map<UINT32, Frags> FragsMap;

    typedef struct
    {
        FragsMap FragListMap; //save fraglist. By BufferIndex and Key, we can get it.
        Allocs   AllocInfo;    // We would save custom setting or generated size or offset info
                                // into this structure. Once the code determines size or offset's calwlation
                                // can be skipped, the prevoius setting in this structure will be used.
                                // BufMgr class will directly use this structure.
        UINT32   TotalBytes;    // save totalbytes
        //bool     IsAlloc;       // if there's already buffer allocated
        PriPara  BufParam;
    } BufNode, *PBufNode;

    typedef map<UINT64,BufNode> Nodes;
    Nodes m_BufNodeMap;     // Each bufmgr object has a BufNode which holds
                            // some info. The map structure uses the virtual address
                            // as the Key value
};

#endif //INCLUDED_BUFBUILD_H

