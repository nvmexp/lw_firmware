#!/usr/bin/elw python3
# LWIDIA_COPYRIGHT_BEGIN
#
# Copyright 2019 by LWPU Corporation.  All rights reserved.  All
# information contained herein is proprietary and confidential to LWPU
# Corporation.  Any use, reproduction, or disclosure without the written
# permission of LWPU Corporation is prohibited.
#
# LWIDIA_COPYRIGHT_END
import argparse
import datetime
import json
import os
import re
import sys

######################################################################
# Parse the argument list, and return a namespace with the following
# members:
# - prog: The name of the program, from argv[0]
# - className: The argument of the -c/--class flag
# - inFile: The input file, as an open io.TextIOWrapper object
# - outFile: The output file, as an open io.TextIOWrapper object
#
def ParseArgs(argv):
    # Filter for the -c/--className arg, to make sure it's a valid
    # identifier
    #
    def IdentifierType(string):
        if not re.fullmatch(r"[a-zA-Z][a-zA-Z0-9_]*", string):
            msg = "\"{}\" is not a valid identifier".format(string)
            raise argparse.ArgumentTypeError(msg)
        return string

    # Parse the args
    #
    parser = argparse.ArgumentParser(
            prog = os.path.basename(os.path.normpath(argv[0])))
    parser.add_argument("-c", "--class",
            dest = "className", type = IdentifierType,
            help = "The name of the class.  Defaults to output filename, or \"MuccProgram\" if output is stdout.")
    parser.add_argument("inFile", nargs = "?", default = "-",
            type = argparse.FileType("r", encoding = "utf-8", errors = "ignore"),
            help = "The input filename, or \"-\" for stdin.  Defaults to \"-\".")
    parser.add_argument("outFile", nargs = "?", default = "-",
            type = argparse.FileType("w", encoding = "utf-8"),
            help = "The output filename, or \"-\" for stdout.  Defaults to \"-\".")
    args = parser.parse_args(argv[1:])

    # Set arg.prog, and set arg.className to the default value if the
    # user did not pass -c or --class
    #
    args.prog = parser.prog
    if not args.className:
        className = ""
        if args.outFile.name != "<stdout>":
            className = os.path.basename(os.path.normpath(args.outFile.name))
            while os.path.splitext(className)[1]:
                className = os.path.splitext(className)[0]
            className = re.sub(r'[^a-zA-Z0-9_]', "_", className)
            className = re.sub(r'^[^a-zA-Z]*', "", className)
        if className == "":
            className = "MuccProgram"
        className = className[0].upper() + className[1:]
        args.className = className
    return args

######################################################################
# Colwenience function to print to the output .js file
# - args: The command-line args returned from ParseArgs()
# - indent: The indentation level.  The actual indentation is 4*indent.
# - string: The string to print, after indentation.  Trailing
#       whitespace is automatically removed.
#
def Print(args, indent, string):
    fullString = (" " * (4 * indent)) + string
    print(fullString.rstrip(), file = args.outFile)

######################################################################
# Print the copyright and documentation to the .js file
# - args: The command-line args returned from ParseArgs()
#
def PrintHeader(args, argv):
    year = datetime.date.today().year
    Print(args, 0, "/*")
    Print(args, 0, " * LWIDIA_COPYRIGHT_BEGIN")
    Print(args, 0, " *")
    Print(args, 0, " * Copyright {} by LWPU Corporation.  All rights reserved.  All".format(year))
    Print(args, 0, " * information contained herein is proprietary and confidential to LWPU")
    Print(args, 0, " * Corporation.  Any use, reproduction, or disclosure without the written")
    Print(args, 0, " * permission of LWPU Corporation is prohibited.")
    Print(args, 0, " *")
    Print(args, 0, " * LWIDIA_COPYRIGHT_END")
    Print(args, 0, " */")
    Print(args, 0, "")
    Print(args, 0, "// This file was generated by the following command:")
    Print(args, 0, "// {}".format(" ".join([args.prog] + argv[1:])))
    Print(args, 0, "")
    Print(args, 0, "//-------------------------------------------------------------------")
    Print(args, 0, "// This class runs a compiled Mucc memory-test program on the GPU.")
    Print(args, 0, "// Typical usage:")
    Print(args, 0, "//     pgm = new {}(); // Takes optional GpuSubdevice arg,".format(args.className))
    Print(args, 0, "//               {}    // defaults to GpuSubdevice(0, 0)".format(" " * len(args.className)))
    Print(args, 0, "//     pgm.Run(); // Run the program on the GPU")
    Print(args, 0, "//     pgm.Poll(); // Wait for the program to finish.")
    Print(args, 0, "//                 // Takes optional timeoutMs arg")
    Print(args, 0, "//     results = {};")
    Print(args, 0, "//     pgm.GetResults(results); // Get error info")
    Print(args, 0, "//")
    Print(args, 0, "// The results object filled by GetResults() has these fields:")
    Print(args, 0, "//     results.laneErrors             // Array of lane errors")
    Print(args, 0, "//     results.laneErrors[i].fbpa     // Number starting at 0")
    Print(args, 0, "//     results.laneErrors[i].subp     // Numbered from 0 to 1")
    Print(args, 0, "//     results.laneErrors[i].type     // \"DQ\", \"ECC\", or \"DBI\"")
    Print(args, 0, "//     results.laneErrors[i].laneNum  // 0-127 for DQ errors, 0-15 for ECC & DBI")
    Print(args, 0, "//     results.laneErrors[i].errCount // Errors on lane, maxxes out at 255")
    Print(args, 0, "//     results.firstErrors            // Array of first error on each fbpa+subp")
    Print(args, 0, "//     results.firstErrors[i].fbpa    // Number starting at 0")
    Print(args, 0, "//     results.firstErrors[i].subp:   // Numbered from 0 to 1")
    Print(args, 0, "//     results.firstErrors[i].rank    // For 8-high HBM, same as as StackID")
    Print(args, 0, "//     results.firstErrors[i].bank")
    Print(args, 0, "//     results.firstErrors[i].column  // Always even in HBM2")
    Print(args, 0, "//     results.firstErrors[i].row")
    Print(args, 0, "//     results.firstErrors[i].pseudoChannel")
    Print(args, 0, "//     results.firstErrors[i].ecc     // The expected ECC data")
    Print(args, 0, "//     results.firstErrors[i].dbi     // The expected DBI data")
    Print(args, 0, "//     results.firstErrors[i].dq      // Expected DQ data (array of 8 dwords)")
    Print(args, 0, "//")

######################################################################
# Print the constructor of the class in the .js file
# - args: The command-line args returned from ParseArgs()
#
def PrintConstructor(args):
    Print(args, 0, "function {}(gpu)".format(args.className))
    Print(args, 0, "{")
    Print(args, 1, "if (typeof(gpu) === \"undefined\")")
    Print(args, 1, "{")
    Print(args, 2, "gpu = new GpuSubdevice(0, 0);")
    Print(args, 1, "}")
    Print(args, 1, "this.gpu = gpu;")
    Print(args, 1, "this.fbpaMask = gpu.FbpaMask;")
    Print(args, 1, "this.subpCount = 2;")
    Print(args, 0, "}")

######################################################################
# Print the Run() method to the .js file
# - args: The command-line args returned from ParseArgs()
# - program: The parsed JSON program
#
def PrintRunMethod(args, program):
    Print(args, 0, "{}.prototype.Run = function()".format(args.className))
    Print(args, 0, "{")
    Print(args, 1, "let regs = this.gpu.Regs;")

    threads = program["threads"]
    if (len(threads) == 1):
        Print(args, 1, "")
        Print(args, 1, "for (let subp = 0; subp < this.subpCount; ++subp)")
        Print(args, 1, "{")
        PrintThread(args, 2, threads[0], True)
        Print(args, 1, "}")
    else:
        Print(args, 1, "let ucontrollers = [];")
        for thread in threads:
            mask = thread["mask"]
            bits = []
            lwrrentBit = 0
            while mask != 0:
                if (mask & 0x1) != 0:
                    bits.append(str(lwrrentBit))
                    lwrrentBit += 1
                    mask >>= 1
            Print(args, 1, "")
            Print(args, 1, "ucontrollers = [{}];".format(", ".join(bits)))
            Print(args, 1, "for (let ii = 0; ii < ucontrollers.length; ++ii)")
            Print(args, 1, "{")
            Print(args, 2, "let fbpa = Math.floor(ucontrollers[ii] / this.subpCount);")
            Print(args, 2, "let subp = ucontrollers[ii] % this.subpCount;")
            Print(args, 2, "if ((fbpa & this.fbpaMask) != 0)")
            Print(args, 2, "{")
            PrintThread(args, 3, thread, False)
            Print(args, 2, "}")
            Print(args, 1, "}")
    Print(args, 1, "return RC.OK;")
    Print(args, 0, "}")

######################################################################
# Print one thread to the .js file.  Called from PrintRunMethod().
# - args: The command-line args returned from ParseArgs()
# - indent: The indentation level to print the code at
# - thread: One thread from the parsed JSON program
# - broadcast: If true, broadcast to "subp".  If false, just write to
#         "fbpa" and "subp".  It is up to the caller to set the
#         "fbpa" and/or "subp" variables.
#
def PrintThread(args, indent, thread, broadcast):
    # Registers
    #
    if broadcast:
        trainingPatternPtr = "RegHalConst.PFB_FBPA_TRAINING_PATTERN_PTR, subp"
        trainingDpCntd = "RegHalConst.PFB_FBPA_TRAINING_DP_CNTD, subp"
        trainingDp = "RegHalConst.PFB_FBPA_TRAINING_DP, subp"
        ucData = "RegHalConst.PFB_FBPA_UC_DATA, subp"
        ucCtl = "RegHalConst.PFB_FBPA_UC_CTL, subp"
    else:
        trainingPatternPtr = "RegHalConst.PFB_FBPA_0_TRAINING_PATTERN_PTR, [fbpa, subp]"
        trainingDpCntd = "RegHalConst.PFB_FBPA_0_TRAINING_DP_CNTD, [fbpa, subp]"
        trainingDp = "RegHalConst.PFB_FBPA_0_TRAINING_DP, [fbpa, subp]"
        ucData = "RegHalConst.PFB_FBPA_0_UC_DATA, [fbpa, subp]"
        ucCtl = "RegHalConst.PFB_FBPA_0_UC_Ctl, [fbpa, subp]"

    # Write patram
    #
    patram = thread["patram"]
    for entry in range(len(patram)):
        source = patram[entry]["source"]
        dq     = patram[entry]["dq"]
        ecc    = patram[entry]["ecc"]
        dbi    = patram[entry]["dbi"]
        for sourceLine in source:
            Print(args, indent, "// {}".format(sourceLine))
        for word in range(len(dq)):
            Print(args, indent, "regs.Write32({},".format(trainingPatternPtr))
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_TRAINING_PATTERN_PTR_DP, 0x{:02x}) |".format(entry * 8 + word))
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_TRAINING_PATTERN_PTR_ACT_ADR_ENABLED));")
            Print(args, indent, "regs.Write32({},".format(trainingDpCntd))
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_TRAINING_DP_CNTD_SEL_CHAR_ENGINE) |")
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_TRAINING_DP_CNTD_EDC, 0x{:x}) |".format((ecc[0] >> (4*word)) & 0xf))
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_TRAINING_DP_CNTD_DBI, 0x{:x}));".format((dbi[0] >> (4*word)) & 0xf))
            Print(args, indent, "regs.Write32({}, 0x{:08x});".format(trainingDp, dq[word]))
        Print(args, indent, "")

    # Write code
    #
    code = thread["code"]
    labels = thread["labels"]
    for addr in range(len(code)):
        source = code[addr]["source"]
        data   = code[addr]["data"]
        for sourceLine in source:
            Print(args, indent, "// {}".format(sourceLine))
        for word in data:
            Print(args, indent, "regs.Write32({}, {})".format(ucData, word))
        Print(args, indent, "regs.Write32({},".format(ucCtl))
        Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_UC_CTL_LOAD_ENABLE_TRUE) |")
        if addr < len(code) - 1:
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_UC_CTL_LOAD_ADDR, 0x{:02x}));".format(addr))
            Print(args, indent, "")
        else:
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_UC_CTL_LOAD_ADDR, 0x{:02x}) |".format(addr))
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_UC_CTL_ENABLE_TRUE) |")
            Print(args, indent, "    regs.FieldValue(RegHalConst.PFB_FBPA_UC_CTL_START_ADDR, 0x{:02x}));".format(labels["start"]))

######################################################################
# Print Poll() method to the .js file
# - args: The command-line args returned from ParseArgs()
#
def PrintPollMethod(args):
    Print(args, 0, "{}.prototype.Poll = function(timeoutMs)".format(args.className))
    Print(args, 0, "{")
    Print(args, 1, "let timeoutTicks = 0x7fffffff;")
    Print(args, 1, "let sleepMsPerLoop = 250;")
    Print(args, 1, "let regs = this.gpu.Regs;")
    Print(args, 1, "")
    Print(args, 1, "if (typeof(timeoutMs) !== \"undefined\" && timeoutMs >= 0)")
    Print(args, 1, "{")
    Print(args, 2, "timeoutTicks = timeoutMs / sleepMsPerLoop;")
    Print(args, 1, "}")
    Print(args, 1, "")
    Print(args, 1, "for (let fbpa = 0; fbpa < 32; ++fbpa)")
    Print(args, 1, "{")
    Print(args, 2, "if (((1 << fbpa) & this.fbpaMask) != 0)")
    Print(args, 2, "{")
    Print(args, 3, "for (let subp = 0; subp < this.subpCount; ++subp)")
    Print(args, 3, "{")
    Print(args, 4, "if (!regs.Test32(RegHalConst.PFB_FBPA_0_UC_CTL_ENABLE_FALSE, [fbpa, subp]))")
    Print(args, 4, "{")
    Print(args, 5, "if (timeoutTicks <= 0)")
    Print(args, 5, "{")
    Print(args, 6, "return RC.TIMEOUT_ERROR;")
    Print(args, 5, "}")
    Print(args, 5, "Sleep(sleepMsPerLoop);")
    Print(args, 4, "}")
    Print(args, 3, "}")
    Print(args, 2, "}")
    Print(args, 1, "}")
    Print(args, 1, "return RC.OK;")
    Print(args, 0, "}")

######################################################################
# Print GetResults() method to the .js file
#
# For an explanation of this process, see section 8.3 of
# //hw/doc/gpu/ampere/ampere/design/IAS/FB/FBPA_incr_uArch_ga100.docx
#
# - args: The command-line args returned from ParseArgs()
#
def PrintGetResultsMethod(args):
    Print(args, 0, "{}.prototype.GetResults = function(results)".format(args.className))
    Print(args, 0, "{")
    Print(args, 1, "let regs = this.gpu.Regs;")
    Print(args, 1, "results.laneErrors = []")
    Print(args, 1, "results.firstErrors = []")
    Print(args, 1, "")
    Print(args, 1, "for (let fbpa = 0; fbpa < 32; ++fbpa)")
    Print(args, 1, "{")
    Print(args, 2, "if (((1 << fbpa) & this.fbpaMask) != 0)")
    Print(args, 2, "{")
    Print(args, 3, "for (let subp = 0; subp < this.subpCount; ++subp)")
    Print(args, 3, "{")
    Print(args, 4, "let initialSubpErrCount = results.laneErrors.length;")
    PrintLaneError(args, 0, "DQ",   0)
    PrintLaneError(args, 1, "DQ",  16)
    PrintLaneError(args, 2, "DQ",  32)
    PrintLaneError(args, 3, "DQ",  48)
    PrintLaneError(args, 4, "DQ",  64)
    PrintLaneError(args, 5, "DQ",  80)
    PrintLaneError(args, 6, "DQ",  96)
    PrintLaneError(args, 7, "DQ", 112)
    PrintLaneError(args, 8, "DBI",  0)
    PrintLaneError(args, 9, "ECC",  0)
    Print(args, 4, "if (initialSubpErrCount != results.laneErrors.length)")
    Print(args, 4, "{")
    Print(args, 5, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_1ST_ERR_ADDR, [fbpa, subp]);")
    Print(args, 5, "let addr0 = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 0, subp]);")
    Print(args, 5, "let addr1 = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 1, subp]);")
    Print(args, 5, "let addr2 = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 2, subp]);")
    Print(args, 5, "let addr3 = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 3, subp]);")
    Print(args, 5, "let dq = [];")
    Print(args, 5, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_1ST_ERR_DQ_L, [fbpa, subp]);")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 0, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 1, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 2, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 3, subp]));")
    Print(args, 5, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_1ST_ERR_DQ_U, [fbpa, subp]);")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 0, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 1, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 2, subp]));")
    Print(args, 5, "dq.push(regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 3, subp]));")
    Print(args, 5, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_1ST_ERR_ECC, [fbpa, subp]);")
    Print(args, 5, "let ecc = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 0, subp]);")
    Print(args, 5, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_1ST_ERR_DBI, [fbpa, subp]);")
    Print(args, 5, "let dbi = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, 0, subp]);")
    Print(args, 5, "results.firstErrors.push({")
    Print(args, 6, "fbpa: fbpa,")
    Print(args, 6, "subp: subp,")
    Print(args, 6, "rank: addr0 & 0x1,")
    Print(args, 6, "bank: addr1 & 0xf,")
    Print(args, 6, "column: addr2 & 0xfff,")
    Print(args, 6, "row: (addr2 >> 12) & 0x7fff,")
    Print(args, 6, "pseudoChannel: addr3 & 0x1,")
    Print(args, 6, "ecc: ecc,")
    Print(args, 6, "dbi: dbi,")
    Print(args, 6, "dq: dq")
    Print(args, 5, "});")
    Print(args, 4, "}")
    Print(args, 3, "}")
    Print(args, 2, "}")
    Print(args, 1, "}")
    Print(args, 1, "return RC.OK;")
    Print(args, 0, "}")

######################################################################
# Print code to get 16 lane errors to the .js file.  Called by
# GetResults().
# - args: The command-line args returned from ParseArgs()
# - selectNum: The ERRCNT_WIDE number to pass to the DEBUG_CTRL_SELECT register
# - errType: One of "DQ", "ECC", or "DBI"
# - laneNum: The lowest of the 16 lane numbers selected by selectNum
#
def PrintLaneError(args, selectNum, errType, laneNum):
    Print(args, 4, "regs.Write32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_CTRL_SELECT_HBM_CHAR_ERRCNT_WIDE{}, [fbpa, subp]);".format(selectNum))
    Print(args, 4, "for (let ii = 0; ii < 4; ++ii)")
    Print(args, 4, "{")
    Print(args, 5, "let val = regs.Read32(RegHalConst.PFB_FBPA_0_TRAINING_DEBUG_DQx, [fbpa, ii, subp]);")
    Print(args, 5, "for (let jj = 0; jj < 4; ++jj)")
    Print(args, 5, "{")
    Print(args, 6, "let errCount = (val >> (8 * jj)) & 0xff;")
    Print(args, 6, "if (errCount != 0)")
    Print(args, 6, "{")
    Print(args, 7, "results.laneErrors.push({")
    Print(args, 8, "fbpa: fbpa,")
    Print(args, 8, "subp: subp,")
    Print(args, 8, "type: \"{}\",".format(errType))
    Print(args, 8, "laneNum: {} + 4*ii + jj,".format(laneNum))
    Print(args, 8, "errCount: errCount")
    Print(args, 7, "});")
    Print(args, 6, "}")
    Print(args, 5, "}")
    Print(args, 4, "}")

######################################################################
# Main program
#
def main(argv):
    args = ParseArgs(argv)
    program = json.load(args.inFile)

    PrintHeader(args, argv)
    PrintConstructor(args)
    Print(args, 0, "")
    PrintRunMethod(args, program)
    Print(args, 0, "")
    PrintPollMethod(args)
    Print(args, 0, "")
    PrintGetResultsMethod(args)
    return 0

######################################################################
# Entry point: call main(), and print any thrown error messages
#
if __name__ == "__main__":
    try:
        sys.exit(main(sys.argv))
    except Exception as err:
        if str(err):
            print(err)
        sys.exit(1)
