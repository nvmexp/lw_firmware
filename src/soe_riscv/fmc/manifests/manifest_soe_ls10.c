/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2020-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#include "lwriscv/manifest_ls10.h"

// PMP-related defines

#define PMPADDR_NAPOT(START, NAPOT) (((START) >> 2) | ((NAPOT) >> 3))

#define PMPADDR_IMEM(NAPOT) PMPADDR_NAPOT(LW_RISCV_AMAP_IMEM_START, (NAPOT))
#define PMPADDR_DMEM(NAPOT) PMPADDR_NAPOT(LW_RISCV_AMAP_DMEM_START, (NAPOT))

const PKC_VERIFICATION_MANIFEST manifest = {
    // Decrytpted part of manifest
    .stage1RSA3KSigProd     = {0, },
    .stage1RSA3KSigDebug    = {0, },
    .magicNumberStage1      = 0x42,
    .bUseDevKey             = TRUE,
    .manifestEncParams      = {
        // MK TODO: check endiannes and if we care about that field on non-fsp
        .encryptionDerivationString = "",
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8, 0x8c},

        .authTag            = {0, },
    },

    // Encrypted part of manifest (stage 1)
    .version               = 0x01,
    .ucodeId               = 0x04,  // See https://confluence.lwpu.com/display/GFS/Ucode+ID+Assignment
    .ucodeVersion          = 0x00,  // Post-QS signed
    .bRelaxedVersionCheck  = TRUE,  // Allow >= check for ucode version in BR revocation
    .engineIdMask          = ENGINE_TO_ENGINE_ID_MASK(SOE),    // Base 1
    // This field will be patched during build
    .itcmSizeIn256Bytes    = (LWRISCV_APP_IMEM_LIMIT) / 256,    // NA, incorrect value will not work on boot
    // This field will be patched during build
    .dtcmSizeIn256Bytes    = (LWRISCV_APP_DMEM_LIMIT) / 256,    // NA, incorrect value will not work on boot
    .fmcHashPadInfoBitMask = 0x00000000,            // LSB determines if PDI is pre-pended to the FMC before hashing
    .fmcEncParams          = {
        // NOT AUTOGENERATED! also must be !=0
        // MK TODO: check endiannes
        .encryptionDerivationString = "",
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8, 0x8c},
        .authTag            = {0, },
    },
    // Need a checklist that says this cannot be 0
    // This field will be patched by siggen
    .digest                = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // NA, patched by siggen when signing
                               0x00000000, 0x00000000, 0x00000000, 0x00000000,
                               0x00000000, 0x00000000, 0x00000000, 0x00000000 },
    .secretMask            = {
        .scpSecretMask     = 0x0,                       // SCP 'secret' instrlwtion is not allowed
        .scpSecretMaskLock = 0xFFFFFFFFFFFFFFFFULL,     // This mask is locked and cannot be changed
    },
    .debugAccessControl    = {
        .dbgctl =
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STOP,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RUN,    _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STEP,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_J,      _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_EMASK,  _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RREG,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WREG,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RDM,    _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WDM,    _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RSTAT,  _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_IBRKPT, _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RCSR,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WCSR,   _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RPC,    _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RFREG,  _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WFREG,  _ENABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _START_IN_ICD,     _FALSE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _SINGLE_STEP_MODE, _DISABLE),
        .dbgctlLock = 0,
    },
    .bDICE = FALSE,
    .bKDF  = FALSE,                     // SOE Steady State does not use fuse keys
    .bCertCA = FALSE,
    .bAttester = FALSE,

    .mspm  = {
        .mplm  = (LW_RISCV_CSR_MSPM_MPLM_LEVEL2),
        .msecm = LW_RISCV_CSR_MSPM_MSECM_SEC
    },

    .kdfConstant = { 0 },   // SOE does not use KDF (for decrypt fuse key)

    .deviceMap.deviceMap = {
        DEVICEMAP(_MMODE,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_RISCV_CTL,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PIC,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_TIMER,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HOSTIF,         _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DMA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        // PMB must be unlocked so someone can write LOCKPMB (and then disable/lock it)
        DEVICEMAP(_PMB,            _ENABLE,  _ENABLE,  _UNLOCKED) |
        DEVICEMAP(_DIO,            _ENABLE,  _ENABLE,  _LOCKED  ),

        DEVICEMAP(_KEY,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DEBUG,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SHA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_KMEM,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_BROM,           _ENABLE,  _DISABLE, _LOCKED  ) | // BROM enforced
        DEVICEMAP(_ROM_PATCH,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_IOPMP,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_NOACCESS,       _DISABLE, _DISABLE, _LOCKED  ), // Empty Group

        DEVICEMAP(_SCP,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FBIF,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FALCON_ONLY,    _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PRGN_CTL,       _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP0, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP1, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP2, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP3, _ENABLE,  _ENABLE,  _LOCKED  ),

        DEVICEMAP(_PLM,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HUB_DIO,        _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_RESET,          _ENABLE,  _ENABLE,  _LOCKED  ),
    },

    .corePmp = {
        .cfg = {
            [0] = // PMP entry 0..7 -> pmpcfg0
            PMP_ENTRY(_DENIED,    _DENIED,    _DENIED,    _NAPOT, _UNLOCK, 0) | // IMEM SK, access blocked for S/U *MUST BE UNLOCKED as unlock enables M access*
            PMP_ENTRY(_DENIED,    _DENIED,    _DENIED,    _NAPOT, _UNLOCK, 1) | // DMEM SK, access blocked for S/U *MUST BE UNLOCKED as unlock enables M access*
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK,   2) , // LOCALIO, RW
            [1] = 0, // PMP entry 8..15 -> pmpcfg2 -> filled by SK based on partition policies
            [2] = 0, // PMP entry 16..23 -> extpmp0 -> filled by SK based on partition policies
            [3] = 0, // PMP entry 24-31 -> extpmp2
        },
        .addr = {
            // PMPADDR
            PMPADDR_IMEM(SEPKERN_IMEM_LIMIT - 1), // PMPADDR(0) - SK IMEM
            PMPADDR_DMEM(SEPKERN_DMEM_LIMIT - 1), // PMPADDR(1) - SK DMEM
            PMPADDR_NAPOT(LW_RISCV_AMAP_INTIO_START, (LW_RISCV_AMAP_INTIO_SIZE - 1)), // PMPADDR(2) - LOCALIO
        },
    },

    // IO_PMP_MODE - NAPOT for all entries as that's the only mode we support
    .ioPmpMode = 0xffffffffffffffff,

    .ioPmp.entry = {
    },

    .numberOfValidPairs      = 3,

    .registerPair.entries    = {
        [0] = {
            .addr    = LW_PRGNLCL_RISCV_BR_PRIV_LOCKDOWN,
            .andMask = 0,
            .orMask  = DRF_DEF(_PRGNLCL, _RISCV_BR_PRIV_LOCKDOWN, _LOCK, _UNLOCKED),
        },
        [1] = {
            .addr    = LW_PRGNLCL_FALCON_LOCKPMB,
            .andMask = 0,
            .orMask  = 0,
        },
        [2] = {
            .addr    = LW_PRGNLCL_RISCV_TRACECTL,
            .andMask = 0,
            .orMask  = DRF_DEF(_PRGNLCL, _RISCV_TRACECTL, _MODE, _REDUCED)      |
                       DRF_DEF(_PRGNLCL, _RISCV_TRACECTL, _MMODE_ENABLE, _TRUE) |
                       DRF_DEF(_PRGNLCL, _RISCV_TRACECTL, _SMODE_ENABLE, _TRUE) |
                       DRF_DEF(_PRGNLCL, _RISCV_TRACECTL, _UMODE_ENABLE, _TRUE),
        },
    },
};

