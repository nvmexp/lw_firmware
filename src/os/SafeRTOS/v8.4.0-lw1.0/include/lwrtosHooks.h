/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file    lwrtosHooks.h
 * @brief   TODO: Document.
 */

#ifndef LWRTOS_HOOKS_H
#define LWRTOS_HOOKS_H

/* ------------------------ System Includes --------------------------------- */
#include "lwtypes.h"

/* ------------------------ RTOS Includes ----------------------------------- */
#include "lwrtos.h"

/* ------------------------ Application Includes ---------------------------- */
/* ------------------------ Forward Definitions ----------------------------- */
/* ------------------------ Macros and Defines ------------------------------ */
/* ------------------------ Types Definitions ------------------------------- */
/* ------------------------ Function Prototypes ----------------------------- */
void  lwrtosHookTimerTick(LwU32 ticksNow);
void  lwrtosHookError(void *pxTask, LwS32 xErrorCode);
void  lwrtosHookIdle(void);
LwS32 lwrtosHookIV0Handler(void);

/*
 * Returns value that is added to time to program systick interrupt in mtimecmp.
 */
LwU64 lwrtosHookGetTimerPeriod(void);

/*
 * Syscall handler, runs at kernel context.
 * Must modify PC or will re-enter syscall on return.
 *
 * It *must* implement syscalls from portSyscall.h, others are optional.
 * Context (kernel or user) pointer is passed via tp register.
 *
 */
void lwrtosHookSyscall(LwU64 arg0,
                       LwU64 arg1,
                       LwU64 arg2,
                       LwU64 arg3,
                       LwU64 arg4,
                       LwU64 arg5,
                       LwU64 arg6,
                       LwU64 num);

/*
 * External interrupt handler. Called when RISC-V receives external interrupt.
 * Runs on kernel context with interrupts disabled.
 * Must handle all interrupt registers (PRIV and CSR), or it will reenter it.
 * It should not touch mstatus.*ie (it will be re-enabled on return).
 */
void lwrtosRiscvExtIrqHook(void);

/*
 * Software interrupt handler. Called when RISC-V receives software interrupt.
 * Runs on kernel context with interrupts disabled.
 * Must handle all interrupt registers (PRIV and CSR), or it will reenter it.
 * It should not touch mstatus.*ie (it will be re-enabled on return).
 */
void lwrtosRiscvSwIrqHook(void);

/*
 * Exception handler. Called when exception is generated by RISC-V core.
 * Context passed in pCtx may be kernel or task.
 * Remaining arguments are copies of machine registers (they may no longer have
 * valid information).
 */
void lwrtosRiscvExceptionHook(LwrtosTaskHandle pCtx,
                              LwU64 cause,
                              LwU64 cause2,
                              LwU64 trapVal);

/*
 * Hook to setup mapping for pxLwrrentTCB.
 * May be called directly from assembly.
 */
void lwrtosHookConfigMpuForTask(void);

/*
 * Maps a task's memory for access by the kernel.
 */
void lwrtosHookTaskMap(struct TaskMpuInfo *pMpuInfo);

/*
 * Unmaps a task's memory.
 */
void lwrtosHookTaskUnmap(struct TaskMpuInfo *pMpuInfo);

#if defined(ODP_ENABLED) && defined(DMA_SUSPENSION)
/*
 * Hook to unpin current task stack and pin new task stack.
 */
void lwrtosHookPinTaskStack(void);
#endif // defined(ODP_ENABLED) && defined(DMA_SUSPENSION)

#if defined(INSTRUMENTATION) || defined(USTREAMER)
/*
 * Instrumentation hooks.
 */
void lwrtosHookInstrumentationBegin(void);
void lwrtosHookInstrumentationEnd(void);
void lwrtosHookOdpInstrumentationEvent(LwBool bIsCodeMiss, LwBool bIsBegin);
#endif // INSTRUMENTATION || USTREAMER

#if defined(IS_SSP_ENABLED) && defined(IS_SSP_ENABLED_PER_TASK)
void lwrtosHookSetTaskStackCanary(void);
#endif // defined(IS_SSP_ENABLED) && defined(IS_SSP_ENABLED_PER_TASK)

#ifdef DYNAMIC_FLCN_PRIV_LEVEL
void lwrtosHookPrivLevelSet(void);
#endif // DYNAMIC_FLCN_PRIV_LEVEL

#ifdef PMU_RTOS
/*!
 * Secure syscall timer hook, for setting timer values from kernel-mode.
 * Only allowed on PMU right now.
 */
FLCN_STATUS lwrtosHookSyscallSetSelwreKernelTimestamp(LwU64 timeDataId);

/*!
 * Secure syscall timer hook, for setting mclk from kernel-mode.
 * Only allowed on PMU right now.
 */
FLCN_STATUS lwrtosHookSyscallSetSelwreKernelVbiosMclk(LwU64 mclkkHz);

/*!
 * Secure syscall timer hook, for querying mclk from kernel-mode.
 * Only allowed on PMU right now.
 */
LwU64       lwrtosHookSyscallGetSelwreKernelVbiosMclk(void);
#endif // PMU_RTOS

#endif /* LWRTOS_HOOKS_H */
