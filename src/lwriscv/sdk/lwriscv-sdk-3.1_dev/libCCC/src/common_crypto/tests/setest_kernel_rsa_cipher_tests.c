/*
 * Copyright (c) 2016-2021, LWPU CORPORATION. All rights reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <crypto_system_config.h>
#include <tests/setest_kernel_tests.h>

#if KERNEL_TEST_MODE

#if MODULE_TRACE
#define LOCAL_TRACE MODULE_TRACE
#else
#define LOCAL_TRACE 0
#endif

#if HAVE_RSA_CIPHER

/* Don't define static yet => would need to call all
 * When enabling all test cases => this can now be defined static =>
 * all funs are called.
 */
#define __STATIC__ static

/* VERIFIED */
/*  openssl rsautl -raw -encrypt -pubin -inkey public_key.pem */
__STATIC__ status_t TEST_rsa_cipher_symmetric(crypto_context_t *c,
					      te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */
	static unsigned char data[RSA512_BYTE_SIZE];
	static unsigned char dst[RSA512_BYTE_SIZE];

	static unsigned char correct[64] = {
		0xd2, 0x36, 0xb6, 0xe6, 0xff, 0xea, 0x05, 0x5d, 0x87, 0xc6, 0xa6, 0xf3, 0x7e, 0x07, 0xdf, 0x3c,
		0xd1, 0x6f, 0x74, 0x74, 0x7e, 0x2e, 0x9f, 0xe8, 0x10, 0x1c, 0xec, 0x7e, 0xd4, 0xa8, 0xa1, 0x6d,
		0x12, 0x4a, 0x0d, 0x50, 0x0b, 0xd5, 0x52, 0x15, 0x30, 0x01, 0xb1, 0x3b, 0x67, 0x90, 0x5a, 0xc6,
		0x1f, 0x02, 0xc2, 0x5e, 0xa4, 0xd4, 0xa9, 0x80, 0xa0, 0x63, 0xfc, 0x84, 0x53, 0x38, 0xbe, 0xf0
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// RSA keys now big endian by default! (set flag only if LE keys)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA512_BYTE_SIZE,
		.k_keyslot = 3U,	/* This is RSA keyslot 3 out of 0..3 */

		/* both exponent and modulus are in big endian,
		 * as specified by the flags.
		 */
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // RSA modulus (512 bits == 64 bytes) */
			       { 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
				 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1 }
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	// (symmetric) data to cipher: 00FFFFFFFFFF...FF00 (total 64 bytes; first and last bytes
	// zeroed).
	//
	se_util_mem_set(data, 0xFF, sizeof_u32(data));
	data[0]  = '\000';
	data[63] = '\000';

	se_util_mem_set(dst, 0, sizeof_u32(dst));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	/* pass the above the key params as well */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA cipher result (fake symmetric key):", dst, sizeof_u32(dst));

	VERIFY_ARRAY_VALUE(dst, correct, sizeof_u32(correct));
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if HAVE_RSA_PKCS1V15_CIPHER
/* openssl rsautl -pkcs -encrypt -pubin -inkey public_key.pem
 *
 * PKCS1v1.5 padding includes a random component => can not verify
 * with a "precomputed fixed value"; the only way is to verify a generated value
 * by an external program. Of course, deciphering with this program would be ok,
 * but since it is in the same code it may contain self cancelling bugs...
 *
 * The included "correct value" has the RANDOM VALUE FIXED TO ALL 0x01 bytes =>
 * for TESTING ONLY => must NOT have such trickery in production version...
 */
__STATIC__ status_t TEST_rsa_padding_cipher(crypto_context_t *c,
					    te_crypto_algo_t algo, engine_id_t eid, uint32_t data_size)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	uint32_t i = 0U;

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */
	static unsigned char data[RSA512_BYTE_SIZE];
	static unsigned char dst[RSA512_BYTE_SIZE];

#ifdef FIXED_PS_VALUE
	/* Only result of 50 byte PKCS1v1.5 padded RSA encryption is lwrrently
	 * verified => need to implement a better way (do a dynamic verification with openssl)
	 *
	 * In this value the RANDOM component has been jammed to always set 0x01 byte!!!
	 */
	static unsigned char correct50_PS_value_0x1[] = {
		0x48, 0xa3, 0xb4, 0x4d, 0xe0, 0x3e, 0xca, 0x09, 0x22, 0x7e, 0x8c, 0x84, 0x14, 0x85, 0x76, 0x1b,
		0x37, 0xce, 0x59, 0xcb, 0x35, 0xc2, 0x1a, 0xd8, 0x9c, 0x63, 0xf0, 0x27, 0xa5, 0x7d, 0x39, 0xa5,
		0x7c, 0x57, 0xbd, 0x03, 0x78, 0x91, 0x94, 0x81, 0x97, 0xcc, 0x5e, 0xdb, 0xf7, 0x75, 0xd8, 0x75,
		0x70, 0x68, 0x9b, 0xb4, 0xd9, 0x59, 0x34, 0x78, 0x70, 0xa5, 0xcf, 0x79, 0x36, 0xfc, 0xe4, 0x62,
	};
#endif // FIXED_PS_VALUE

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// RSA keys now big endian by default! (set flag only if you import LE keys)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA512_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise; key length
			       // must be multiple of 512 bits)
			       //
			       // RSA modulus
			       { 0xe1, 0x2c, 0xc5, 0x7e, 0x85, 0x8b, 0xb6, 0xe6,
				 0xe2, 0x98, 0x62, 0xda, 0xfe, 0x2f, 0xfd, 0xb6,
				 0x73, 0x5e, 0xdc, 0x63, 0x8b, 0x57, 0x6d, 0x82,
				 0xbc, 0x88, 0x53, 0xe2, 0xed, 0xda, 0xd3, 0x47,
				 0xf4, 0x79, 0xd4, 0x69, 0x94, 0x7b, 0x95, 0x7c,
				 0xc7, 0xa0, 0x45, 0x1f, 0xda, 0x96, 0x10, 0x95,
				 0x33, 0xbf, 0xe3, 0xe4, 0xc8, 0x10, 0xd2, 0x34,
				 0x72, 0x2f, 0x2b, 0xee, 0xf2, 0x19, 0xf6, 0x8b }
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	if (data_size > sizeof_u32(data)) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	/* Fill data with some byte sequence (just non-identical bytes) */
	for (i = 0; i < sizeof_u32(data); i++) {
		data[i] = BYTE_VALUE(i);
	}

	se_util_mem_set(dst, 0, sizeof_u32(dst));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = data_size;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA padding cipher result:", dst, sizeof_u32(dst));

#ifdef FIXED_PS_VALUE
	if (data_size == 50) {
		VERIFY_ARRAY_VALUE(dst, correct50_PS_value_0x1, 50);
	}
#else
	// need to implement (or rather just test) decipher with private key, better than this...
	LOG_ERROR("%s: WARNING => result data correctness not verified for data size: %u\n", __func__, data_size);
#endif

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_RSA_PKCS1V15_CIPHER */


__STATIC__ status_t TEST_rsa_cipher_decipher(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// First bit must be zero to make this positive
	static unsigned char data[RSA512_BYTE_SIZE] = {
		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	};

	static unsigned char dst[RSA512_BYTE_SIZE];

	static unsigned char correct[] = {
		0x23, 0xc6, 0x1b, 0x8a, 0x6b, 0x3e, 0x09, 0x7b, 0xb8, 0xbf, 0x38, 0xc2, 0xa3, 0xe9, 0x0f, 0xf4,
		0x50, 0xec, 0x6b, 0x7b, 0x53, 0x75, 0xe9, 0xd3, 0x0e, 0x82, 0xa3, 0xc9, 0x4b, 0xee, 0x0e, 0x17,
		0x80, 0x2e, 0xc7, 0xdf, 0x4f, 0x43, 0x41, 0xca, 0xd5, 0x97, 0x96, 0xad, 0x70, 0xcb, 0x0a, 0x1d,
		0xc2, 0x01, 0xc8, 0x88, 0xa4, 0x8f, 0x2c, 0xd4, 0x1e, 0x72, 0x55, 0x74, 0x5b, 0x68, 0xe5, 0x84,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PRIVATE,
		// RSA keys now big endian by default! (set flag only if LE keys)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA512_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_priv = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
				.modulus  =
				// Stripped leading 0x00 out of the modulus
				// (it would be too long otherwise; modulus length
				// must be multiple of 512 bits)
				//
				// RSA modulus
				{ 0xe1, 0x2c, 0xc5, 0x7e, 0x85, 0x8b, 0xb6, 0xe6,
				  0xe2, 0x98, 0x62, 0xda, 0xfe, 0x2f, 0xfd, 0xb6,
				  0x73, 0x5e, 0xdc, 0x63, 0x8b, 0x57, 0x6d, 0x82,
				  0xbc, 0x88, 0x53, 0xe2, 0xed, 0xda, 0xd3, 0x47,
				  0xf4, 0x79, 0xd4, 0x69, 0x94, 0x7b, 0x95, 0x7c,
				  0xc7, 0xa0, 0x45, 0x1f, 0xda, 0x96, 0x10, 0x95,
				  0x33, 0xbf, 0xe3, 0xe4, 0xc8, 0x10, 0xd2, 0x34,
				  0x72, 0x2f, 0x2b, 0xee, 0xf2, 0x19, 0xf6, 0x8b
				},

				.priv_exponent = {
				0xcd, 0xd2, 0x1e, 0xb3, 0x87, 0x5e, 0x2d, 0xd0,
				0xdd, 0x4e, 0x6d, 0x0d, 0xbf, 0x4a, 0x1e, 0x9e,
				0xa6, 0xd6, 0x0e, 0x9c, 0xee, 0xc0, 0xfb, 0x58,
				0x84, 0xfc, 0x17, 0xb1, 0x55, 0xb8, 0xaf, 0x65,
				0x5f, 0x1b, 0x1e, 0x33, 0x91, 0x1f, 0x66, 0x6f,
				0x9b, 0xa9, 0x46, 0x4e, 0x7e, 0x5f, 0x37, 0xbe,
				0x4e, 0x3e, 0xee, 0xa6, 0x2e, 0x1f, 0x40, 0xb5,
				0x92, 0xce, 0x77, 0x06, 0x3a, 0x5d, 0x40, 0x01
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	/* Encrypt data with a public key, place result to dst */

	se_util_mem_set(dst, 0, sizeof_u32(dst));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data, dst);

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA cipher result:", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct, sizeof_u32(correct));

	LOG_INFO("Deciphering previous result with private key\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DECRYPT, algo);

	/* Then decipher dst with a private key, put result again to dst */

	se_util_mem_set((uint8_t *)&arg, 0, sizeof_u32(arg));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DECRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(dst);
	arg.ca_data.src = dst;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] decipher (COMBINED OPERATION) src %p data, result %p\n",
		 algo, data, dst);

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] decipher (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA decipher result:", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, data, sizeof_u32(data));

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_rsa_cipher(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	static unsigned char data[RSA512_BYTE_SIZE];
	static unsigned char dst[RSA512_BYTE_SIZE];

	static unsigned char correct[] = {
		0x23, 0xc6, 0x1b, 0x8a, 0x6b, 0x3e, 0x09, 0x7b, 0xb8, 0xbf, 0x38, 0xc2, 0xa3, 0xe9, 0x0f, 0xf4,
		0x50, 0xec, 0x6b, 0x7b, 0x53, 0x75, 0xe9, 0xd3, 0x0e, 0x82, 0xa3, 0xc9, 0x4b, 0xee, 0x0e, 0x17,
		0x80, 0x2e, 0xc7, 0xdf, 0x4f, 0x43, 0x41, 0xca, 0xd5, 0x97, 0x96, 0xad, 0x70, 0xcb, 0x0a, 0x1d,
		0xc2, 0x01, 0xc8, 0x88, 0xa4, 0x8f, 0x2c, 0xd4, 0x1e, 0x72, 0x55, 0x74, 0x5b, 0x68, 0xe5, 0x84,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// RSA keys now big endian by default! (set flag only if LE keys)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA512_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise; modulus length
			       // must be multiple of 512 bits)
			       //
			       // RSA modulus
			       { 0xe1, 0x2c, 0xc5, 0x7e, 0x85, 0x8b, 0xb6, 0xe6,
				 0xe2, 0x98, 0x62, 0xda, 0xfe, 0x2f, 0xfd, 0xb6,
				 0x73, 0x5e, 0xdc, 0x63, 0x8b, 0x57, 0x6d, 0x82,
				 0xbc, 0x88, 0x53, 0xe2, 0xed, 0xda, 0xd3, 0x47,
				 0xf4, 0x79, 0xd4, 0x69, 0x94, 0x7b, 0x95, 0x7c,
				 0xc7, 0xa0, 0x45, 0x1f, 0xda, 0x96, 0x10, 0x95,
				 0x33, 0xbf, 0xe3, 0xe4, 0xc8, 0x10, 0xd2, 0x34,
				 0x72, 0x2f, 0x2b, 0xee, 0xf2, 0x19, 0xf6, 0x8b }
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	// data to cipher: 00FFFFFFFFFF...FFFF (total 64 bytes;
	// MSB zeroed (to make non-negative))
	se_util_mem_set(data, 0xFF, sizeof_u32(data));
	data[0] = '\000';

	se_util_mem_set(dst, 0, sizeof_u32(dst));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA cipher result:", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct, sizeof_u32(correct));
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

static te_args_key_data_t rsa512_akey = {
	.k_key_type  = KEY_TYPE_RSA_PRIVATE,
	// RSA keys now big endian by default! (set flag only if LE keys)
	.k_flags     = KEY_FLAG_PLAIN,
	.k_byte_size = RSA512_BYTE_SIZE,
	.k_keyslot = 3U,
	.k_rsa_priv = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			.modulus  =
			{ 0xe1, 0x2c, 0xc5, 0x7e, 0x85, 0x8b, 0xb6, 0xe6,
			  0xe2, 0x98, 0x62, 0xda, 0xfe, 0x2f, 0xfd, 0xb6,
			  0x73, 0x5e, 0xdc, 0x63, 0x8b, 0x57, 0x6d, 0x82,
			  0xbc, 0x88, 0x53, 0xe2, 0xed, 0xda, 0xd3, 0x47,
			  0xf4, 0x79, 0xd4, 0x69, 0x94, 0x7b, 0x95, 0x7c,
			  0xc7, 0xa0, 0x45, 0x1f, 0xda, 0x96, 0x10, 0x95,
			  0x33, 0xbf, 0xe3, 0xe4, 0xc8, 0x10, 0xd2, 0x34,
			  0x72, 0x2f, 0x2b, 0xee, 0xf2, 0x19, 0xf6, 0x8b
			},

			.priv_exponent = {
			0xcd, 0xd2, 0x1e, 0xb3, 0x87, 0x5e, 0x2d, 0xd0,
			0xdd, 0x4e, 0x6d, 0x0d, 0xbf, 0x4a, 0x1e, 0x9e,
			0xa6, 0xd6, 0x0e, 0x9c, 0xee, 0xc0, 0xfb, 0x58,
			0x84, 0xfc, 0x17, 0xb1, 0x55, 0xb8, 0xaf, 0x65,
			0x5f, 0x1b, 0x1e, 0x33, 0x91, 0x1f, 0x66, 0x6f,
			0x9b, 0xa9, 0x46, 0x4e, 0x7e, 0x5f, 0x37, 0xbe,
			0x4e, 0x3e, 0xee, 0xa6, 0x2e, 0x1f, 0x40, 0xb5,
			0x92, 0xce, 0x77, 0x06, 0x3a, 0x5d, 0x40, 0x01
		},
	},
};

#if HAVE_RSA_OAEP
static te_args_key_data_t rsa2048_akey = {
	.k_key_type  = KEY_TYPE_RSA_PRIVATE,
	// RSA keys now big endian by default! (set flag only if LE keys)
	.k_flags     = KEY_FLAG_PLAIN,
	.k_byte_size = RSA2048_BYTE_SIZE,
	.k_keyslot = 3U,

	// By default RSA key material is in BIG ENDIAN byte order
	//
	.k_rsa_priv = {
		.pub_exponent = {
			0x00, 0x01, 0x00, 0x01
		},

		// Stripped leading 0x00 out of the modulus
		// (it would be too long otherwise; modulus length
		// must be multiple of 512 bits)
		//
		// RSA modulus
		.modulus  = {
			0xb2, 0xfd, 0x44, 0xf3, 0xe6, 0xc5, 0x70, 0xf1,
			0x22, 0x11, 0x28, 0xfe, 0x94, 0xc5, 0xe1, 0x8f,
			0x36, 0xa9, 0x28, 0xfb, 0x2e, 0xa2, 0x9b, 0x97,
			0xc3, 0x5e, 0x72, 0x49, 0xd4, 0x97, 0xd1, 0xe6,
			0x35, 0x4b, 0x8c, 0x44, 0xa3, 0x21, 0x3a, 0xe2,
			0xd3, 0xff, 0x05, 0xf1, 0xf3, 0x0b, 0x5b, 0xee,
			0xf1, 0x87, 0x8b, 0x82, 0x88, 0x70, 0xb7, 0x7f,
			0xef, 0x9f, 0xa2, 0x42, 0xd5, 0xe8, 0x7f, 0x8d,
			0x78, 0x49, 0x93, 0xfd, 0xcb, 0x9b, 0xc1, 0x22,
			0x2b, 0x7f, 0xc2, 0x20, 0x24, 0xda, 0x53, 0x6d,
			0x76, 0xb3, 0x67, 0xb3, 0x53, 0x2a, 0x7c, 0xf4,
			0x53, 0x89, 0x88, 0xb5, 0xbd, 0xf8, 0xb0, 0xa2,
			0x00, 0x30, 0x6a, 0x55, 0x37, 0xfb, 0xb6, 0x3c,
			0xb6, 0x6b, 0x2a, 0xb4, 0x7d, 0x6d, 0xe3, 0xe0,
			0xdd, 0x8f, 0x19, 0x99, 0xcb, 0x54, 0x46, 0x43,
			0x61, 0x40, 0x54, 0x82, 0x5b, 0x76, 0x9f, 0x33,
			0x49, 0x11, 0x55, 0xfb, 0x9f, 0x46, 0x6d, 0x57,
			0x1e, 0x6c, 0x44, 0xf1, 0xac, 0x9e, 0xdb, 0x2d,
			0x69, 0xcb, 0xea, 0x42, 0x43, 0x68, 0xca, 0x48,
			0x4a, 0x3c, 0x8f, 0x84, 0x6b, 0xf8, 0x7e, 0x23,
			0xd8, 0xfc, 0xcd, 0xb4, 0xbe, 0x77, 0xab, 0x97,
			0xd1, 0x3c, 0xef, 0x58, 0x0c, 0x1a, 0xf2, 0x2d,
			0x8d, 0x16, 0x66, 0xe5, 0xcc, 0xb0, 0x3e, 0x74,
			0xde, 0x48, 0x3b, 0x0f, 0xc3, 0x1b, 0xfb, 0xfc,
			0xb5, 0x21, 0x86, 0x51, 0xf4, 0xf7, 0x94, 0xa1,
			0x24, 0xe6, 0xeb, 0x20, 0x21, 0x40, 0x42, 0xde,
			0x30, 0x7c, 0xe3, 0x0d, 0x7a, 0xab, 0xa4, 0x9e,
			0x67, 0xec, 0x18, 0x0c, 0x04, 0x87, 0x40, 0x61,
			0xe6, 0xaa, 0x0f, 0x53, 0x51, 0x0f, 0xf6, 0x26,
			0xd7, 0x9c, 0x80, 0xca, 0x4b, 0x4c, 0xb9, 0xf1,
			0xa9, 0x37, 0xee, 0xdb, 0xa3, 0x8b, 0x12, 0x60,
			0x56, 0x12, 0xb5, 0xe4, 0xd4, 0x13, 0xca, 0x1d,
		},

		.priv_exponent={
			0x0A, 0xE9, 0xDE, 0x76, 0x70, 0xAF, 0xC1, 0x3F,
			0x32, 0xB0, 0x91, 0x2B, 0x54, 0xAE, 0xEC, 0x1D,
			0xEB, 0x5B, 0x4D, 0x20, 0x63, 0xAB, 0x8E, 0x89,
			0x26, 0x64, 0x6F, 0xDB, 0x88, 0x96, 0xE9, 0x39,
			0x7C, 0x2E, 0x6B, 0x13, 0x14, 0x4F, 0x46, 0x63,
			0xE6, 0x41, 0x3A, 0x7F, 0x92, 0x2E, 0x33, 0x20,
			0xD2, 0xA1, 0x4D, 0x24, 0x5C, 0x65, 0x63, 0x0A,
			0xED, 0xF5, 0x71, 0xD3, 0x59, 0x6F, 0x9F, 0xB7,
			0x64, 0x8A, 0x37, 0xF7, 0xD5, 0x9E, 0x5D, 0x9C,
			0x53, 0xC2, 0xAA, 0x77, 0x83, 0x47, 0xBC, 0xA6,
			0x84, 0x02, 0x54, 0x64, 0x5E, 0xC1, 0xCC, 0x74,
			0xA9, 0x53, 0x4D, 0x7E, 0xA7, 0x62, 0xAE, 0x82,
			0x72, 0x38, 0x81, 0x83, 0x48, 0xB2, 0x94, 0x5E,
			0x07, 0x51, 0x69, 0x7D, 0x2F, 0xD8, 0xAF, 0x78,
			0x5A, 0x8A, 0x0B, 0x29, 0x91, 0x78, 0x46, 0x00,
			0x7D, 0xC1, 0x8A, 0x65, 0x98, 0x66, 0x17, 0x36,
			0xD3, 0x31, 0x1D, 0xFF, 0x65, 0x91, 0x23, 0xAE,
			0x84, 0x7C, 0x1C, 0x45, 0x6E, 0xB5, 0xBD, 0x34,
			0x1C, 0xCD, 0xD2, 0x7A, 0xD7, 0x34, 0x9D, 0x9F,
			0x72, 0x3A, 0xFB, 0x87, 0x48, 0x4F, 0xB3, 0x1F,
			0xE9, 0x0A, 0x98, 0x53, 0x1C, 0xDC, 0xC8, 0xD6,
			0xE7, 0x69, 0x69, 0x37, 0xEA, 0x14, 0xA6, 0x5A,
			0xCF, 0x1E, 0xBC, 0x9A, 0x37, 0xF6, 0xFA, 0xD6,
			0xD1, 0x69, 0x7F, 0xCE, 0x9B, 0xE5, 0x06, 0xF9,
			0xD1, 0xC8, 0xD2, 0x5E, 0xB6, 0xA4, 0x65, 0x99,
			0xA3, 0x7F, 0xCF, 0xA1, 0x0B, 0x76, 0x1C, 0x12,
			0xC3, 0x1A, 0x30, 0x72, 0xC0, 0x51, 0xD2, 0xCE,
			0xB9, 0x30, 0x32, 0x71, 0x69, 0xE8, 0x14, 0x4D,
			0x05, 0xAB, 0x66, 0x5E, 0xAC, 0xD5, 0x71, 0xA2,
			0x98, 0xE2, 0x2F, 0x6B, 0xC4, 0x46, 0x5F, 0xF1,
			0x21, 0x15, 0xDB, 0xC5, 0x5D, 0x81, 0x71, 0xA7,
			0x2C, 0xF6, 0xBC, 0x59, 0x8D, 0x5E, 0x72, 0x11,
		},
	},
};

static te_args_key_data_t rsa4096_akey = {
	.k_key_type  = KEY_TYPE_RSA_PRIVATE,
	// RSA keys now big endian by default! (set flag only if LE keys)
	.k_flags     = KEY_FLAG_PLAIN,
	.k_byte_size = RSA4096_BYTE_SIZE,
	.k_keyslot = 3U,

	// By default RSA key material is in BIG ENDIAN byte order
	//
	.k_rsa_priv = {
		.pub_exponent = {
			0x00, 0x01, 0x00, 0x01
		},

		// Stripped leading 0x00 out of the modulus
		// (it would be too long otherwise; modulus length
		// must be multiple of 512 bits)
		//
		// RSA modulus
		.modulus  = {
			0xC1, 0xBB, 0x5F, 0x6C, 0x7C, 0x13, 0xC4, 0xF8, 0x22, 0xB7, 0x38, 0xA9, 0xF3, 0x38, 0x9B, 0xA0, 0xDF, 0x22, 0x31, 0x87, 0x9B, 0xF0, 0x1F, 0x84, 0x62, 0xE2, 0x20, 0xFE, 0x13, 0x40, 0xF7, 0xCB, 0x85, 0x71, 0xE6, 0x25, 0x8D, 0x7B, 0x4D, 0x40, 0x8D, 0xA7, 0x63, 0xFB, 0x3C, 0x7F, 0xD5, 0x77, 0xA1, 0x35, 0xA4, 0xDB, 0x5E, 0x41, 0xA5, 0xE2, 0x3D, 0x14, 0x3D, 0xF4, 0x52, 0x0C, 0x22, 0x62, 0x4C, 0xB0, 0xB2, 0xAF, 0x6A, 0x7A, 0x22, 0x63, 0xB2, 0x7A, 0x0D, 0x77, 0x95, 0x0C, 0xB7, 0xEC, 0xDC, 0x5E, 0x68, 0xC9, 0xAB, 0x34, 0x49, 0x3B, 0x00, 0xFB, 0xF4, 0xCC, 0x98, 0xAA, 0xA0, 0xD0, 0x52, 0x46, 0x30, 0x61, 0x89, 0x2A, 0x4C, 0xFA, 0x45, 0x0F, 0x73, 0xB0, 0xC2, 0xBB, 0xBE, 0x92, 0x71, 0x44, 0xD8, 0x43, 0x1E, 0x6D, 0x6C, 0xDA, 0x74, 0x68, 0xC8, 0x89, 0xDE, 0xB3, 0x96, 0x6D, 0x08, 0xC0, 0x18, 0xAA, 0xE9, 0x03, 0x90, 0x01, 0x4E, 0xEF, 0xB7, 0x95, 0xE9, 0x8D, 0x03, 0x0D, 0x00, 0x2D, 0xB7, 0x46, 0x35, 0x06, 0x4E, 0x12, 0xDB, 0x1E, 0xDC, 0x90, 0x20, 0x43, 0xDB, 0x5E, 0x9F, 0x23, 0x80, 0x64, 0xA8, 0x25, 0x43, 0xDF, 0x67, 0x99, 0x9D, 0x94, 0x9A, 0x06, 0xC1, 0x08, 0x1B, 0x25, 0x86, 0xBA, 0xCF, 0xD9, 0x97, 0xA5, 0x87, 0x73, 0xEE, 0x3A, 0x6F, 0x1C, 0x24, 0x8C, 0xF2, 0xB0, 0x63, 0x22, 0x70, 0x4D, 0x55, 0xFC, 0xF9, 0x34, 0xDE, 0x46, 0xF6, 0xEB, 0x4D, 0xC0, 0xD4, 0x53, 0xE6, 0x65, 0x82, 0x45, 0x04, 0x0D, 0xB0, 0x08, 0x68, 0x53, 0xB1, 0x4C, 0x0E, 0x00, 0x82, 0x9C, 0xB0, 0x56, 0x36, 0xAA, 0x19, 0x73, 0x0B, 0x31, 0x3B, 0xAC, 0x73, 0xB2, 0x20, 0x89, 0x53, 0x97, 0xB9, 0xBD, 0x14, 0xC2, 0xBE, 0x2B, 0x4A, 0x80, 0x50, 0xE6, 0xDA, 0x15, 0x9C, 0x09, 0xCB, 0xA1, 0x00, 0x58, 0xE7, 0xD1, 0x3D, 0x0B, 0x3C, 0x2A, 0x51, 0x77, 0x08, 0x63, 0x86, 0x7C, 0x57, 0xBD, 0xD3, 0x92, 0x9E, 0xE6, 0xEC, 0xFA, 0xE9, 0x78, 0xA0, 0xFD, 0xC2, 0xE9, 0xC8, 0xB4, 0xC9, 0x37, 0xA9, 0x74, 0x42, 0x9F, 0xAB, 0x61, 0x05, 0xCA, 0x6F, 0xE8, 0xF3, 0xAF, 0x1C, 0xE5, 0xA5, 0x81, 0x7D, 0x53, 0x1E, 0x82, 0xF6, 0x88, 0xFB, 0xCC, 0xCC, 0x37, 0x3D, 0xF6, 0xA0, 0x01, 0x84, 0x4B, 0x83, 0x27, 0x04, 0xCB, 0x33, 0x94, 0x0A, 0xD6, 0x6B, 0x97, 0xA6, 0x0F, 0x3D, 0xAF, 0xEC, 0xED, 0x5B, 0x15, 0x5C, 0x05, 0x3E, 0xF5, 0x1E, 0xDB, 0xCF, 0x57, 0x0F, 0xAF, 0x93, 0x80, 0xFC, 0xF7, 0x96, 0xA9, 0x49, 0xF3, 0x5E, 0xCF, 0xE5, 0x82, 0xBC, 0x41, 0xD2, 0x0A, 0xBA, 0x84, 0x52, 0xEA, 0x8E, 0xFA, 0xA6, 0xBC, 0x2B, 0xE1, 0x38, 0x56, 0x90, 0x34, 0xCD, 0x38, 0x86, 0x69, 0x54, 0x8A, 0xF1, 0x5B, 0xBE, 0x64, 0xBD, 0xA4, 0x7B, 0x74, 0x26, 0xEE, 0x09, 0xF8, 0x2F, 0xF3, 0x1D, 0xBF, 0x4B, 0x04, 0x4C, 0xEF, 0x55, 0x5C, 0x7A, 0xA7, 0x56, 0x20, 0xF9, 0x59, 0x21, 0xFE, 0xD1, 0x74, 0x32, 0xCD, 0xC0, 0xD5, 0xF0, 0x56, 0x2C, 0x70, 0x1E, 0xAD, 0xAB, 0x60, 0x67, 0xC5, 0xF5, 0xEE, 0x7D, 0x52, 0xCD, 0x5D, 0xCC, 0x81, 0x3E, 0x52, 0x27, 0xDA, 0x65, 0x61, 0x4B, 0xE1, 0x8E, 0x2B, 0xF5, 0x3F, 0x3D, 0xCD, 0x47, 0x53, 0x6A, 0x02, 0xCB, 0xA6, 0x65, 0x07, 0x98, 0x2D, 0x9D, 0x56, 0x00, 0xAF, 0xCD, 0xFF, 0x84, 0xFA, 0x79, 0xFE, 0x36, 0xF4, 0x38, 0x44, 0xE6, 0x52, 0x13, 0x90, 0x07, 0x1E, 0xAA, 0x00, 0x3D, 0x7F, 0x11, 0x1F, 0x42, 0xD6, 0x13, 0x22, 0x68, 0xB5, 0x52, 0x45, 0xFF, 0xB3, 0xD7, 0xE7, 0x3C, 0xEB, 0x6A, 0x72, 0x1E, 0xEA, 0x7C, 0x44, 0x3A, 0x31,
		},

		.priv_exponent={
			0x42, 0xFA, 0x86, 0xF9, 0x38, 0xC4, 0x94, 0xFA, 0xBC, 0xF5, 0xDF, 0x8F, 0x52, 0x59, 0xA5, 0xE4, 0xAE, 0x80, 0x61, 0xE3, 0x62, 0x94, 0x58, 0x31, 0x2B, 0x06, 0xC7, 0x25, 0x50, 0x7E, 0xCB, 0xAC, 0xFF, 0x8B, 0xEB, 0x67, 0xDC, 0x4C, 0x5E, 0xDF, 0x0C, 0x9A, 0x6C, 0xC4, 0xB5, 0x9B, 0xF4, 0xAF, 0x91, 0x7A, 0xBC, 0x6E, 0x63, 0x5E, 0x0A, 0xFD, 0xF6, 0xE4, 0x02, 0xAF, 0x6F, 0x96, 0x66, 0x64, 0xD9, 0xE2, 0xD5, 0x44, 0x34, 0x69, 0xD9, 0x6D, 0xE2, 0x8C, 0xB4, 0x0F, 0x3D, 0xE6, 0xD1, 0xC8, 0x00, 0x40, 0x5B, 0xB6, 0x2D, 0x8C, 0xBC, 0x2C, 0xBC, 0x20, 0x5F, 0xF8, 0x44, 0x67, 0xE9, 0x85, 0x5C, 0x8C, 0x8B, 0xB9, 0x8C, 0xF4, 0xA4, 0xFC, 0x79, 0xD7, 0xE7, 0xC5, 0x9A, 0xED, 0xD1, 0xEB, 0x4B, 0x61, 0xE3, 0xEB, 0x00, 0xA0, 0x10, 0x5C, 0x4E, 0x96, 0xD3, 0x8E, 0x67, 0x02, 0x6B, 0xE5, 0x72, 0x7B, 0x07, 0x8C, 0x3F, 0x57, 0x4D, 0xF8, 0x45, 0xD4, 0x37, 0x02, 0x8B, 0x66, 0x87, 0x41, 0x7D, 0x68, 0x50, 0xCE, 0xE3, 0x12, 0x34, 0xF7, 0xEB, 0xED, 0xF5, 0x8F, 0x96, 0xB8, 0x1F, 0x25, 0xCD, 0x9B, 0x36, 0x8E, 0x96, 0x5B, 0x9B, 0xE5, 0xA7, 0x29, 0xC3, 0x03, 0x57, 0x65, 0x32, 0x63, 0x9D, 0x0F, 0x12, 0x4F, 0x90, 0x00, 0xC8, 0x9F, 0x1F, 0xFF, 0x82, 0xC3, 0x8D, 0x1A, 0x8B, 0xC0, 0x77, 0x3F, 0x68, 0x66, 0xC5, 0xB0, 0xD7, 0x23, 0xC8, 0xFC, 0xF0, 0x44, 0x54, 0xA5, 0xF1, 0x91, 0xD3, 0x56, 0xD6, 0x77, 0x0D, 0xDC, 0xD2, 0x93, 0xF0, 0xE2, 0x57, 0x3F, 0x68, 0x32, 0xC5, 0x3C, 0x83, 0xEB, 0xAC, 0x43, 0x82, 0x4E, 0xB8, 0xD1, 0xBF, 0x72, 0xDC, 0x10, 0xB9, 0x47, 0x42, 0x5C, 0x78, 0x1C, 0x22, 0xC9, 0x2E, 0x5E, 0x4D, 0xE5, 0x25, 0xB2, 0xCB, 0x45, 0xA4, 0xEC, 0x87, 0xAF, 0x78, 0xA8, 0x09, 0x8A, 0x06, 0xBC, 0x9C, 0xD6, 0x1B, 0x35, 0xD2, 0x93, 0xCE, 0xD3, 0x6B, 0xEB, 0x3D, 0x96, 0x67, 0xBF, 0x23, 0xED, 0xC4, 0xEF, 0xA9, 0x99, 0xC7, 0x10, 0xBA, 0xA7, 0xB3, 0xAD, 0x48, 0x98, 0xE1, 0x62, 0xAD, 0x4C, 0x47, 0xD8, 0xB0, 0xE4, 0x8C, 0x05, 0x5B, 0x30, 0x18, 0xE8, 0x15, 0xB0, 0xD2, 0x5B, 0x13, 0x36, 0x68, 0x8D, 0xC7, 0x82, 0x52, 0x46, 0x2C, 0x92, 0x11, 0x3D, 0x3C, 0x66, 0xC2, 0x74, 0x0B, 0xBE, 0x6E, 0x31, 0xE4, 0x13, 0xA2, 0x20, 0x2F, 0x19, 0xFA, 0x35, 0x7F, 0x4B, 0xEC, 0xE4, 0x3F, 0x89, 0xBB, 0x3B, 0x60, 0xFD, 0x81, 0x7C, 0xD8, 0xCB, 0xF7, 0x7C, 0x62, 0x94, 0x13, 0xFA, 0xE0, 0x3F, 0x53, 0x2B, 0x96, 0x94, 0x1E, 0x48, 0xC1, 0xE0, 0x3C, 0x3D, 0x0B, 0x65, 0x3D, 0x42, 0x78, 0x3A, 0xD6, 0x47, 0x66, 0x22, 0xA1, 0x0B, 0xF5, 0x16, 0xAD, 0x5A, 0xD7, 0x62, 0x2C, 0x41, 0x70, 0x3B, 0x23, 0x46, 0x1E, 0x77, 0xF8, 0x13, 0xDE, 0x62, 0x7B, 0xCB, 0xE1, 0x3E, 0xE1, 0x0B, 0x25, 0xDA, 0xA2, 0x45, 0x4F, 0x38, 0x1B, 0x9F, 0xD2, 0xB5, 0xC3, 0xF9, 0x37, 0xDF, 0x13, 0xC3, 0xE8, 0xD4, 0x01, 0xEF, 0x37, 0x20, 0xCC, 0x8E, 0xF0, 0x62, 0xBE, 0xCD, 0xFA, 0xFA, 0x30, 0x40, 0x8C, 0xC3, 0x09, 0x37, 0xA8, 0x29, 0x95, 0x0F, 0x7A, 0xDC, 0x91, 0xC1, 0xC2, 0x70, 0x72, 0x1E, 0x62, 0x6F, 0xA7, 0x4C, 0x06, 0x36, 0x03, 0x71, 0xC8, 0xA3, 0xEE, 0x88, 0x0A, 0x78, 0xCC, 0x71, 0x97, 0x91, 0xE2, 0xD6, 0x6D, 0xB4, 0xDF, 0x3B, 0x18, 0xF6, 0x30, 0x83, 0xB8, 0x96, 0x52, 0xBB, 0x99, 0xB4, 0x3D, 0xE0, 0x7A, 0x76, 0xE8, 0xDA, 0x52, 0x9E, 0x5B, 0x4A, 0x14, 0x52, 0x16, 0x15, 0x0A, 0xB7, 0xC2, 0x03, 0xAB, 0x34, 0x8A, 0x14, 0x8A, 0xA7, 0x60, 0x01,
		},
	},
};
#endif /* HAVE_RSA_OAEP */

__STATIC__ status_t TEST_rsa_pad_cipher_decipher(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						 te_args_key_data_t *akey, uint32_t dlen)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	uint32_t result_len = 0U;

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// First bit must be zero to make this positive
	static unsigned char data[RSA4096_BYTE_SIZE];
	static unsigned char dst[RSA4096_BYTE_SIZE];

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	if (dlen > akey->k_byte_size) {
		CCC_ERROR_WITH_ECODE(ERR_TOO_BIG,
				     LOG_ERROR("Data too long (%u) for RSA cipher\n", dlen));
	}

	(void)se_util_mem_set(data, 0, sizeof_u32(data));

	uint32_t inx = 0U;
	uint8_t val = (uint8_t)dlen;
	for (inx = 0U; inx < dlen; inx++) {
		data[inx] = val--;
	}

	/* Encrypt data with a public key, place result to dst */

	se_util_mem_set(dst, 0, sizeof_u32(dst));

	LOG_INFO("XXX Changing RSA key type to PUBLIC (%u bit RSA key)\n",
		 (akey->k_byte_size * 8U));
	akey->k_key_type  = KEY_TYPE_RSA_PUBLIC;

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Pass the key params
	arg.ca_set_key.kdata = akey;

	arg.ca_data.src_size = dlen;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) src %p data, result %p\n",
		 algo, data, dst);

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	result_len = arg.ca_data.dst_size;

	LOG_INFO("RSA[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u (result size %u bytes)\n",
		 algo, ret, arg.ca_handle, result_len);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA cipher result:", dst, result_len);

	TRAP_ASSERT(result_len == akey->k_byte_size);

	LOG_INFO("Deciphering previous result with private key\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DECRYPT, algo);

	/* Then decipher dst with a private key, put result again to dst */

	se_util_mem_set((uint8_t *)&arg, 0, sizeof_u32(arg));

	LOG_INFO("XXX Changing RSA key type to PRIVATE\n");
	akey->k_key_type  = KEY_TYPE_RSA_PRIVATE;

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DECRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Pass the key params
	arg.ca_set_key.kdata = akey;

	arg.ca_data.src_size = result_len;
	arg.ca_data.src = dst;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("RSA[0x%x] decipher (COMBINED OPERATION) src %p data, result %p\n",
		 algo, data, dst);

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("RSA[0x%x] decipher (COMBINED OPERATION) ret %d, attached handle: %u (result size %u bytes)\n",
		 algo, ret, arg.ca_handle, arg.ca_data.dst_size);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA decipher result:", dst, arg.ca_data.dst_size);

	TRAP_ASSERT(dlen == arg.ca_data.dst_size);

	VERIFY_ARRAY_VALUE(dst, data, arg.ca_data.dst_size);

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if HAVE_RSA_OAEP
// openssl generated OAEP ciphered blob
__STATIC__ status_t TEST_rsa2048_oaep_decipher(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	te_args_key_data_t *akey = &rsa2048_akey;

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	static const unsigned char orig[] = {
		0x71, 0x70, 0x6F, 0x6E, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60, 0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
	};

	static unsigned char data[] = {
		0x9a, 0xe2, 0xc5, 0x3e, 0xf4, 0xbd, 0x94, 0x6f, 0x87, 0x0c, 0xdd, 0xcd, 0x13, 0xfb, 0x9f, 0x4e, 0x9c, 0x16, 0xae, 0x76, 0xba, 0x72, 0x8b, 0xd7, 0x02, 0x20, 0x62, 0x2d, 0x76, 0xa0,
		0x62, 0x18, 0xdf, 0xc0, 0x2d, 0xfa, 0x4d, 0xbb, 0x81, 0xf5, 0x47, 0x3b, 0x5e, 0x58, 0xb1, 0xa5, 0xf2, 0x0d, 0x00, 0xcc, 0x5d, 0xbe, 0x43, 0xcf, 0x85, 0x4c, 0xb0, 0x8e, 0xbd, 0xfa,
		0xfb, 0xff, 0xd2, 0xa8, 0xbf, 0x23, 0xd8, 0x2b, 0x25, 0xa3, 0xbe, 0x7f, 0x8d, 0x08, 0x5d, 0x6f, 0xa3, 0xa9, 0xb2, 0x36, 0xc3, 0xad, 0xfc, 0xea, 0x07, 0x9f, 0x20, 0x48, 0xc4, 0xf6,
		0xb4, 0x1f, 0x3e, 0x51, 0x76, 0x38, 0x9f, 0x6a, 0x7e, 0xbd, 0xa7, 0x42, 0xc2, 0xb0, 0x14, 0x7f, 0xb1, 0x0c, 0x8d, 0x72, 0x7f, 0x44, 0x6a, 0xac, 0xb5, 0x33, 0x88, 0x71, 0x22, 0x14,
		0xf3, 0xab, 0xbe, 0x7a, 0x52, 0x8f, 0x2a, 0xba, 0xc0, 0x16, 0xa3, 0xf1, 0xbc, 0x51, 0x75, 0xfe, 0xe0, 0xbd, 0x8a, 0xab, 0x4e, 0x8b, 0x6b, 0x5d, 0xf6, 0x12, 0xb1, 0x1b, 0xa5, 0x69,
		0x58, 0xad, 0x35, 0xb7, 0x9e, 0xd8, 0x3a, 0x10, 0x91, 0x36, 0xf0, 0x21, 0x7a, 0xa0, 0xd5, 0x56, 0xa4, 0xe3, 0xa8, 0x5f, 0xc0, 0x1b, 0xe0, 0x79, 0xf6, 0xe5, 0x53, 0xf5, 0x58, 0xa2,
		0xac, 0x26, 0x5e, 0x83, 0x09, 0xcb, 0x89, 0x80, 0x0d, 0x3d, 0x5d, 0xf0, 0x0b, 0x06, 0x92, 0x79, 0xd7, 0x6c, 0xf6, 0x35, 0xf0, 0x90, 0xea, 0xbb, 0x00, 0xbb, 0x07, 0x49, 0xc9, 0x93,
		0x1b, 0xa1, 0xb6, 0x0c, 0xae, 0x50, 0x3e, 0xca, 0x23, 0xd6, 0x87, 0x59, 0x20, 0x1c, 0x42, 0xcb, 0xa5, 0x49, 0x1b, 0x80, 0x92, 0x50, 0x42, 0x87, 0x0f, 0x45, 0x55, 0x0d, 0xf2, 0xc6,
		0x62, 0x19, 0xbb, 0xd6, 0x36, 0xbf, 0x56, 0xc1, 0x16, 0xbf, 0x7c, 0x12, 0x73, 0xce, 0xd0, 0xcb,
	};
	static unsigned char dst[RSA2048_BYTE_SIZE];

	LOG_INFO("Deciphering openssl input with RSA2048-OAEP\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DECRYPT, algo);

	/* Then decipher data with a private key, put result to dst */

	LOG_INFO("XXX Changing RSA key type to PRIVATE\n");
	akey->k_key_type  = KEY_TYPE_RSA_PRIVATE;

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DECRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Pass the key params
	arg.ca_set_key.kdata = akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("RSA[0x%x] decipher (COMBINED OPERATION) ret %d, attached handle: %u (result size %u bytes)\n",
		 algo, ret, arg.ca_handle, arg.ca_data.dst_size);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RSA decipher result:", dst, arg.ca_data.dst_size);

	TRAP_ASSERT(sizeof_u32(orig) == arg.ca_data.dst_size);

	VERIFY_ARRAY_VALUE(dst, orig, sizeof_u32(orig));

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_RSA_OAEP */

status_t run_rsa_cipher_tests(crypto_context_t *crypto_ctx, engine_id_t engine_id);

status_t run_rsa_cipher_tests(crypto_context_t *crypto_ctx, engine_id_t engine_id)
{
	status_t ret = NO_ERROR;

#if HAVE_RSA_OAEP
	/* Decipher openssl generated data OAEP encrypted blob */
#if HAVE_SHA1
	TEST_ERRCHK(TEST_rsa2048_oaep_decipher, engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1);

	/* OAEP tests with RSA-512 and SHA-1 */
	{
		/* RSA cipher/decipher with various data lengths; using OAEP padding
		 *
		 * Loop from 0 to max(data_length_for_RSA512) and then check how
		 * CCC handles too long data input
		 *
		 * "too long input size" callwlated with: RSA_SIZE - (2 * DIGEST_LENGTH) - 1
		 */
		uint32_t too_long_input_size = (64U - (2U * 20U) - 1U);
		uint32_t inx = 0U;

		for (inx = 0U; inx < too_long_input_size; inx++) {
			LOG_ERROR("RSA-512 OAEP padding cipher decipher test: data length %u\n", inx);
			TEST_ERRCHK(TEST_rsa_pad_cipher_decipher, engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1, &rsa512_akey, inx);
		}

		LOG_ERROR("Expect failure => RSA padding cipher decipher test: data length %u\n",
			  too_long_input_size);

		/* 23 bytes is too long for RSA encryption using OAEP padding.
		 * Test that this gets trapped correctly.
		 */
		TEST_EXPECT_RET(TEST_rsa_pad_cipher_decipher, ERR_TOO_BIG,
				engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1, &rsa512_akey, too_long_input_size);
	}
#endif /* HAVE_SHA1 */

	/* OAEP tests with RSA-2048 and SHA-256 */
	{
		/* RSA cipher/decipher with various data lengths; using OAEP padding
		 *
		 * Loop from 0 to max(data_length_for_RSA2048) and then check how
		 * CCC handles too long data input
		 */
		uint32_t too_long_input_size = (256U - (2U * 32U) - 1U);
		uint32_t inx = 0U;

		for (inx = 0U; inx < too_long_input_size; inx++) {
			LOG_ERROR("RSA-2048 OAEP padding cipher decipher test: data length %u\n", inx);
			TEST_ERRCHK(TEST_rsa_pad_cipher_decipher, engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256,
				    &rsa2048_akey, inx);
		}

		LOG_ERROR("Expect failure => RSA padding cipher decipher test: data length %u\n",
			  too_long_input_size);

		/* 191 bytes is too long for RSA encryption using OAEP padding with SHA-256 and RSA-2048.
		 * Test that this gets trapped correctly.
		 */
		TEST_EXPECT_RET(TEST_rsa_pad_cipher_decipher, ERR_TOO_BIG,
				engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256, &rsa2048_akey, too_long_input_size);
	}

	/* OAEP tests with RSA-4096 and SHA-512
	 *
	 * Do not run with SE == PKA0, it would select PKA1 anyway.
	 */
	if (CCC_ENGINE_PKA1_PKA == engine_id) {
		/* RSA cipher/decipher with various data lengths; using OAEP padding
		 *
		 * Loop from 0 to max(data_length_for_RSA4096) and then check how
		 * CCC handles too long data input
		 */
		uint32_t too_long_input_size = (512U - (2U * 64U) - 1U);
		uint32_t inx = 0U;

		for (inx = 0U; inx < too_long_input_size; inx++) {
			LOG_ERROR("RSA-4096 OAEP padding cipher decipher test: data length %u\n", inx);
			TEST_ERRCHK(TEST_rsa_pad_cipher_decipher, engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512,
				    &rsa4096_akey, inx);
		}

		LOG_ERROR("Expect failure => RSA padding cipher decipher test: data length %u\n",
			  too_long_input_size);

		/* 383 bytes is too long for RSA encryption using OAEP padding (with RSA-4096 / SHA-512 digest).
		 * Test that this gets trapped correctly.
		 */
		TEST_EXPECT_RET(TEST_rsa_pad_cipher_decipher, ERR_TOO_BIG,
				engine_id, TE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512, &rsa4096_akey, too_long_input_size);
	}
#endif /* HAVE_RSA_OAEP */

	/* other RSA cipher tests
	 */
	TEST_ERRCHK(TEST_rsa_cipher, engine_id, TE_ALG_MODEXP);

#if HAVE_RSA_PKCS1V15_CIPHER
	// 50 data bytes to 512 bit RSA key, pad with PKCS#1v1_5
	TEST_ERRCHK(TEST_rsa_padding_cipher, engine_id, TE_ALG_RSAES_PKCS1_V1_5, 50);
#endif

	// Nopad modular exponentiation cipher/decipher (data size == modulus size)
	TEST_ERRCHK(TEST_rsa_cipher_decipher, engine_id, TE_ALG_MODEXP);		// do not select anything

	// Next two use symmetric pubkey modulus (hand made ;-))
	LOG_INFO("TESTING with symmetric modulus, exponent 65537\n");
	TEST_ERRCHK(TEST_rsa_cipher_symmetric, engine_id, TE_ALG_MODEXP);

#if HAVE_RSA_PKCS1V15_CIPHER
	/* PKCS#1v1_5 padding encrypt/decrypt */
	{
		/* RSA cipher/decipher with various data lengths; using PKCS#1v1.5 padding
		 *
		 * Loop from 0 to max(data_length_for_RSA512) and then check how
		 * CCC handles too long data input
		 */
		uint32_t too_long_input_size = 54U;
		uint32_t inx = 0U;

		for (inx = 0U; inx < too_long_input_size; inx++) {
			LOG_ERROR("RSA padding cipher decipher test: data length %u\n", inx);
			TEST_ERRCHK(TEST_rsa_pad_cipher_decipher, engine_id, TE_ALG_RSAES_PKCS1_V1_5,
				    &rsa512_akey, inx);
		}

		LOG_ERROR("Expect failure => RSA padding cipher decipher test: data length %u\n",
			  too_long_input_size);

		/* 54 bytes is too long for RSA encryption using PKCS#1v1.5 padding.
		 * Test that this gets trapped correctly.
		 */
		TEST_EXPECT_RET(TEST_rsa_pad_cipher_decipher, ERR_TOO_BIG,
				engine_id, TE_ALG_RSAES_PKCS1_V1_5, &rsa512_akey, too_long_input_size);
	}
#endif /* HAVE_RSA_PKCS1V15_CIPHER */

	if (CFALSE) {
	fail:
		LOG_ERROR("[ ***ERROR: SE RSA CIPHER TEST CASE FAILED! (err 0x%x) ]\n",ret);
		// On failure must return error code
		if (NO_ERROR == ret) {
			ret = SE_ERROR(ERR_GENERIC);
		}
	}
	return ret;
}
#endif /* HAVE_RSA_CIPHER */
#endif /* KERNEL_TEST_MODE */
