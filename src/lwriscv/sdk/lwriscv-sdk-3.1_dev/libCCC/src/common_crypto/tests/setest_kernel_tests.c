/*
 * Copyright (c) 2016-2021, LWPU CORPORATION. All rights reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* XXX TODO => Should move tests from this file to other files.
 *
 * Since adding algorithm restrictions => becomes hard to
 * update => split test in groups into separate files for
 * maintenance reasons.
 */

#include <crypto_system_config.h>
#include <tests/setest_kernel_tests.h>
#include <tegra_pka1_ks_rw.h>

#define CCC_TESTS_VERSION_STRING "setest_kernel_tests: version 2.0"

/* Defined nonzero to run the kernel mode crypto tests
 */
#if KERNEL_TEST_MODE

#if MODULE_TRACE
#define LOCAL_TRACE MODULE_TRACE
#else
#define LOCAL_TRACE 0
#endif

#define AES_KEYSLOT 2U

#if (TEST_N_PAGE_DIGEST == 205U) && !defined(TEST_N_PAGE_DIGEST_RESULT)
/* sha256 out of 205*4096 zero bytes
 *
 * This is a sample result vector used for 205 pages of zeros.
 */
const uint8_t pages_205_sha256[] = {
	0xcc, 0xf2, 0x4e, 0xbb, 0xb0, 0x96, 0xa8, 0xc4, 0xc6, 0x5c, 0x65, 0x08, 0xe3, 0xa1, 0x14, 0xb9,
	0x41, 0x89, 0x84, 0xcc, 0x55, 0x41, 0x91, 0xab, 0x15, 0xe6, 0xb8, 0x97, 0xdc, 0x52, 0x6b, 0x54,
};
#define TEST_N_PAGE_DIGEST_RESULT pages_205_sha256
#endif /* (TEST_N_PAGE_DIGEST == 205U) && !defined(TEST_N_PAGE_DIGEST_RESULT) */

#ifndef TEST_N_PAGE_DIGEST_RESULT
#define TEST_N_PAGE_DIGEST_RESULT NULL
#endif

#define reverse_buffer(buf,len) se_util_reverse_list(buf,buf,len)

status_t TEST_kernel_ops(void);

/************************/

struct {
	engine_id_t eid;
	const char  *ename;
} eid2name[] = {
	{ CCC_ENGINE_NONE, "CCC_ENGINE_NONE" },
	{ CCC_ENGINE_ANY,"CCC_ENGINE_ANY" },

	/* Primary SE accelerator */
	{ CCC_ENGINE_SE0_AES0,"CCC_ENGINE_SE0_AES0" },
	{ CCC_ENGINE_SE0_AES1,"CCC_ENGINE_SE0_AES1" },
	{ CCC_ENGINE_SE0_PKA0,"CCC_ENGINE_SE0_PKA0" },
	{ CCC_ENGINE_SE0_SHA,"CCC_ENGINE_SE0_SHA" },

	/* Secondary SE accelerator (only in selected SoCs) */
	{ CCC_ENGINE_SE1_AES0,"CCC_ENGINE_SE1_AES0" },
	{ CCC_ENGINE_SE1_AES1,"CCC_ENGINE_SE1_AES1" },
	{ CCC_ENGINE_SE1_PKA0,"CCC_ENGINE_SE1_PKA0" },
	{ CCC_ENGINE_SE1_SHA,"CCC_ENGINE_SE1_SHA" },

	/* Elliptic core units*/
	{ CCC_ENGINE_PKA1_PKA,"CCC_ENGINE_PKA1_PKA" },
	{ CCC_ENGINE_RNG1, "CCC_ENGINE_RNG1" },

	/* Software implementation (not using HW acceleration at all) */
	{ CCC_ENGINE_SOFT,"CCC_ENGINE_SOFT" },

	// terminate loop
	{ CCC_ENGINE_NONE, NULL },
};

const char *eid_name(engine_id_t eid)
{
	uint32_t i = 0U;

	while(eid2name[i].ename) {
		if (eid2name[i].eid == eid)
			return eid2name[i].ename;
		i++;
	}

	return "No such engine";
}

/* Don't define static yet => would need to call all
 * When enabling all test cases => this can now be defined static =>
 * all funs are called.
 */
#define __STATIC__ static

#if !defined(SETEST_KERNEL_TEST_FILE_SPLIT)
/* Temporary C file include */
#include <tests/setest_ed25519_tests.c>
#endif /* !defined(SETEST_KERNEL_TEST_FILE_SPLIT) */

#if !defined(SETEST_KERNEL_TEST_FILE_SPLIT)
/* Incluing C source files here to avoid subsystem missed them in it's
 * build makefile.
 * When you do update the build makefile, define SETEST_KERNEL_TEST_FILE_SPLIT
 * to avoid confusing complier on building these files.
 */
#include <tests/setest_kernel_mac_tests.c>
#include <tests/setest_kernel_aes_cipher_tests.c>
#include <tests/setest_kernel_class_init_tests.c>
#include <tests/setest_kernel_srs_tests.c>
#include <tests/setest_kernel_api_tests.c>
#include <tests/setest_aes_kdf_tests.c>
#endif /* !defined(SETEST_KERNEL_TEST_FILE_SPLIT) */

/***********************************************/

#if HAVE_SE_RSA || CCC_WITH_RSA

/*
// private exponent for pss sig
0x43,0x8f,0x19,0x83,0xb1,0x27,0x4e,0xee,
0x98,0xba,0xcb,0x54,0xa0,0x77,0x11,0x6d,
0xd4,0x25,0x31,0x8c,0xb0,0x01,0xcf,0xe6,
0x80,0x83,0x14,0x40,0x67,0x39,0x33,0x67,
0x03,0x1e,0xa0,0x8b,0xd1,0x1d,0xfd,0x80,
0xa4,0xb9,0xe7,0x57,0x5e,0xc8,0x8e,0x79,
0x71,0xd5,0x6b,0x09,0xe9,0x2b,0x41,0xa0,
0x33,0x64,0xc9,0x66,0x33,0xa1,0xb1,0x55,
0x07,0x55,0x98,0x53,0x10,0xe6,0xc0,0x39,
0x6d,0x61,0xd9,0xe8,0x16,0x52,0x28,0xe4,
0x2b,0xda,0x27,0x01,0xaf,0x21,0x4a,0xe8,
0x55,0x1d,0x0b,0xd1,0x1c,0xdc,0xfd,0xb3,
0x0b,0xa6,0x5c,0xcc,0x6e,0x77,0xb8,0xe0,
0xd1,0x4e,0x0a,0xd7,0x7a,0x5e,0x18,0xc3,
0xfb,0xe9,0xa1,0x9c,0xc3,0x9c,0xd4,0x4a,
0x7e,0x70,0x72,0x11,0x18,0x24,0x56,0x24,
0xdf,0xf8,0xba,0xac,0x5b,0x54,0xd3,0xc4,
0x65,0x69,0xc8,0x79,0x94,0x16,0x88,0x9a,
0x68,0x1c,0xbc,0xd4,0xca,0xec,0x5e,0x07,
0x4a,0xc9,0x54,0x7a,0x4b,0xdb,0x19,0x88,
0xf6,0xbe,0x50,0x9d,0x9e,0x9d,0x88,0x5b,
0x4a,0x23,0x86,0x2b,0xa9,0xa6,0x6c,0x70,
0x7d,0xe1,0x11,0xba,0xbf,0x03,0x2e,0xf1,
0x46,0x7e,0x1b,0xed,0x06,0x11,0x57,0xad,
0x4a,0xcb,0xe5,0xb1,0x11,0x05,0x0a,0x30,
0xb1,0x73,0x79,0xcd,0x7a,0x04,0xcc,0x70,
0xe9,0x95,0xe4,0x27,0xc2,0xd5,0x2d,0x92,
0x44,0xdf,0xb4,0x94,0xa8,0x73,0xa1,0x4a,
0xc3,0xcc,0xc4,0x0e,0x8d,0xa1,0x6a,0xc2,
0xd8,0x03,0x7f,0xfa,0xa7,0x76,0x0d,0xad,
0x87,0x88,0xa0,0x77,0xaf,0x3b,0x23,0xd1,
0x66,0x0b,0x31,0x2b,0xaf,0xef,0xd5,0x41
*/

#if HAVE_SHA1
__STATIC__ status_t TEST_rsa_pss_verify_sha1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// This is a RSA-PSS signature, created with cmd:
	// echo -n "HelloWorld" |
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sign pss-privkey.p8 -out HelloWorld.sig
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	static uint8_t sig[] = {
		0x53,0x3a,0xb9,0x5b,0x14,0x4c,0x04,0x7c,
		0x1c,0x92,0x20,0x35,0xbc,0x6e,0x2c,0x13,
		0xc3,0x5b,0xf9,0xd3,0x35,0xa4,0x7f,0x6f,
		0xb0,0x75,0x16,0xa1,0xbf,0xdd,0x5b,0x0d,
		0x40,0x5d,0x7e,0xce,0xa9,0x2e,0x9e,0xc9,
		0xa2,0x5b,0x53,0x5a,0xe9,0x05,0x0a,0x28,
		0x4e,0x0e,0xf0,0xd5,0xa5,0x57,0x38,0x94,
		0x88,0xb3,0x0a,0x13,0xb8,0x39,0xdd,0x09,
		0xa6,0xad,0x4a,0xe3,0x29,0xff,0x6d,0x17,
		0x60,0x7f,0xba,0xd9,0xc3,0x02,0x68,0xf6,
		0x57,0xf2,0x69,0xb5,0x08,0x9d,0x6d,0xfd,
		0x69,0xfd,0x8c,0xfa,0x0a,0x97,0x3b,0xe0,
		0xef,0x99,0x82,0x19,0x56,0x49,0x99,0xc7,
		0x13,0x69,0x40,0x10,0xa8,0x7a,0x7e,0x64,
		0x26,0x5d,0xeb,0x78,0xcb,0x5d,0xe2,0x61,
		0x4f,0x8d,0x05,0xae,0x90,0x01,0x66,0xa6,
		0x2e,0x93,0xec,0xfd,0x3f,0x0b,0xe1,0x10,
		0xb5,0xed,0x38,0xfe,0x1f,0x7a,0x46,0xe7,
		0x5c,0x8a,0x9b,0x86,0x02,0x50,0xbf,0xdb,
		0x5f,0x66,0x9e,0x4e,0xe2,0x47,0x8c,0x6b,
		0x25,0x6d,0x50,0xcd,0xe3,0xa3,0x85,0xe7,
		0xc2,0x3f,0x77,0x43,0x78,0xfe,0x76,0x4e,
		0xb3,0x6c,0x13,0x90,0x34,0x67,0xd0,0x0e,
		0xf2,0xa1,0x64,0x2a,0xce,0xec,0x7f,0x56,
		0xee,0x6f,0xe2,0x8f,0x3d,0xac,0x8e,0xe6,
		0xee,0xf3,0xb9,0x81,0x5b,0x6e,0x8b,0x20,
		0xf6,0x1e,0xd8,0x61,0x1f,0x6d,0xee,0x7b,
		0x72,0x88,0x37,0x3a,0x93,0x4c,0x54,0x6d,
		0x67,0x9c,0xf4,0x7c,0xb7,0x68,0xb6,0x48,
		0xff,0x30,0xdf,0x64,0xf2,0x22,0x0e,0x73,
		0x28,0xa8,0x8d,0xe3,0xcb,0xd0,0x99,0x9d,
		0xde,0xeb,0x98,0xcd,0xd7,0x8a,0x63,0x37,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA2048_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leaving 0x00 out of the 2048 bit modulus
			       // (it would be too long otherwise; modulus length
			       // must be multiple of 512 bits)
			       //
			       // RSA modulus
			       {
				       0xa5,0xd0,0xd7,0x3e,0x0e,0x2d,0xfb,0x43,
				       0x51,0x99,0xea,0x40,0x1e,0x2d,0x89,0xe4,
				       0xa2,0x3e,0xfc,0x51,0x3d,0x0e,0x83,0xa7,
				       0xe0,0xa5,0x41,0x04,0x1e,0x14,0xc5,0xa7,
				       0x5c,0x61,0x36,0x44,0xb3,0x08,0x05,0x5b,
				       0x14,0xde,0x01,0x0c,0x32,0x3c,0x9a,0x91,
				       0x00,0x50,0xa8,0x1d,0xcc,0x9f,0x8f,0x35,
				       0xb7,0xc2,0x75,0x08,0x32,0x8b,0x10,0x3a,
				       0x86,0xf9,0xd7,0x78,0xa3,0x9d,0x74,0x10,
				       0xc6,0x24,0xb1,0x7f,0xa5,0xbf,0x5f,0xc2,
				       0xd7,0x15,0xa3,0x1d,0xe0,0x15,0x6b,0x1b,
				       0x0e,0x38,0xba,0x34,0xbc,0x95,0x47,0x94,
				       0x40,0x70,0xac,0x99,0x1f,0x0b,0x8e,0x56,
				       0x93,0x36,0x2b,0x6d,0x04,0xe7,0x95,0x1a,
				       0x37,0xda,0x16,0x57,0x99,0xee,0x03,0x68,
				       0x16,0x31,0xaa,0xc3,0xb7,0x92,0x75,0x53,
				       0xfc,0xf6,0x20,0x55,0x44,0xf8,0xd4,0x8d,
				       0x78,0x15,0xc7,0x1a,0xb6,0xde,0x6c,0xe8,
				       0x49,0x5d,0xaf,0xa8,0x4e,0x6f,0x7c,0xe2,
				       0x6a,0x4c,0xd5,0xe7,0x8c,0x8f,0x0b,0x5d,
				       0x3a,0x09,0xd6,0xb3,0x44,0xab,0xe0,0x35,
				       0x52,0x7c,0x66,0x85,0xa4,0x40,0xd7,0x20,
				       0xec,0x24,0x05,0x06,0xd9,0x84,0x51,0x5a,
				       0xd2,0x38,0xd5,0x1d,0xea,0x70,0x2a,0x21,
				       0xe6,0x82,0xfd,0xa4,0x46,0x1c,0x4f,0x59,
				       0x6e,0x29,0x3d,0xae,0xb8,0x8e,0xee,0x77,
				       0x1f,0x15,0x33,0xcf,0x94,0x1d,0x87,0x3c,
				       0x37,0xc5,0x89,0xe8,0x7d,0x85,0xb3,0xbc,
				       0xe8,0x62,0x6a,0x84,0x7f,0xfe,0x9a,0x85,
				       0x3f,0x39,0xe8,0xaa,0x16,0xa6,0x8f,0x87,
				       0x7f,0xcb,0xc1,0xd6,0xf2,0xec,0x2b,0xa7,
				       0xdd,0x49,0x98,0x7b,0x6f,0xdd,0x69,0x6d
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// No init flags passed (e.g. RSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init rsa flags.
	// Also the input can be passed through a MD function (same as MGF1 digest)
	// by setting a flag. By default, input is treated as a digest to be handled

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig);
	arg.ca_data.src_signature = sig;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p data\n",
		   algo, data);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("RSA PSS signature check: OK\n");

	LOG_INFO("Check signature of data; SE driver callwlates the digest of the data\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Digest the input first\n");
	arg.ca_init.rsa.flags = INIT_FLAG_RSA_DIGEST_INPUT;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = (const uint8_t *)data;	// Char string to byte vector

	arg.ca_data.src_signature_size = sizeof_u32(sig);
	arg.ca_data.src_signature = sig;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p data\n",
		   algo, data);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("RSA PSS signature check: OK\n");

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR != ret) {
		LOG_INFO("RSA PSS signature check: failed\n");
	}
	return ret;
}

/* Test that the long (4096 bit) RSA keys work and that the SE driver
 * is properly selecting an engine that can handle these keys, no matter
 * which engine is suggested by the caller.
 */
__STATIC__ status_t TEST_rsa4096_pss_verify_sha1_saltlen(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	// XXX This signature has sLen == hLen (created by above openssl cmd)
	static uint8_t sig_saltlen[] = {
		0x4c, 0xf6, 0x65, 0xfd, 0x28, 0x3e, 0xfb, 0x94, 0x6b, 0x25, 0xa8, 0x7c, 0x20, 0x5e, 0x4e, 0xbd,
		0xd4, 0x92, 0xcf, 0x19, 0x52, 0xb7, 0xe6, 0xc9, 0x79, 0xec, 0x6b, 0x7f, 0xb0, 0x5d, 0x0c, 0x64,
		0x96, 0xb7, 0xca, 0xa7, 0x96, 0x75, 0xb5, 0x14, 0x38, 0x8d, 0xb1, 0x2f, 0x88, 0xbd, 0x68, 0xf4,
		0x18, 0x94, 0x1d, 0x66, 0xc5, 0xa7, 0xe2, 0x0e, 0xe0, 0x14, 0x99, 0x2f, 0xbd, 0xd8, 0x0e, 0x9e,
		0x29, 0xf1, 0x00, 0x55, 0x19, 0x25, 0x1f, 0x59, 0x53, 0x83, 0xf2, 0x28, 0x8b, 0x2a, 0xd0, 0xe8,
		0xb7, 0x9c, 0x1a, 0x90, 0x96, 0x34, 0xab, 0x48, 0x10, 0x53, 0x19, 0x33, 0xe1, 0xa2, 0xd1, 0xf8,
		0xe9, 0xd5, 0xb4, 0x49, 0xf6, 0xa3, 0x94, 0xa5, 0x02, 0x7b, 0x0c, 0x22, 0x45, 0x09, 0x42, 0xee,
		0xb8, 0xca, 0xc7, 0x0c, 0xa6, 0x55, 0x6f, 0x5d, 0xc8, 0xdf, 0x67, 0xdd, 0xcd, 0x70, 0xc3, 0xcf,
		0x5f, 0xc5, 0xad, 0xcd, 0xd0, 0x54, 0xfd, 0x0d, 0x57, 0x19, 0xb1, 0x01, 0x4f, 0xb7, 0xd6, 0xc1,
		0x60, 0x74, 0xf1, 0x79, 0x52, 0x6f, 0x02, 0x9d, 0x7e, 0x8d, 0x55, 0xd0, 0xeb, 0x35, 0x46, 0xb7,
		0x26, 0x3e, 0x12, 0x17, 0xda, 0x85, 0x13, 0x3a, 0x94, 0xfc, 0xc2, 0x07, 0xa8, 0xb8, 0x8c, 0x21,
		0x60, 0x3b, 0xb7, 0x16, 0x2f, 0xcc, 0x1e, 0xaa, 0x0f, 0xaa, 0x69, 0xec, 0x12, 0x9c, 0xf0, 0x9a,
		0x7a, 0x3d, 0x1f, 0xc1, 0x5b, 0x95, 0xb0, 0x7d, 0x45, 0x4b, 0x56, 0x66, 0xca, 0x3d, 0x9e, 0x29,
		0x1f, 0x97, 0xf7, 0x76, 0xa0, 0x79, 0x07, 0x64, 0x0f, 0x85, 0xe9, 0x3a, 0x1b, 0xeb, 0x61, 0x02,
		0x19, 0x40, 0xfa, 0xdc, 0x3e, 0x6f, 0xb6, 0x6e, 0x4c, 0xd4, 0xdf, 0xac, 0x0e, 0xa1, 0x6c, 0xb1,
		0x9d, 0x49, 0x25, 0x6e, 0x1c, 0xde, 0x22, 0xab, 0x8b, 0x72, 0x83, 0x79, 0xcc, 0xb5, 0xeb, 0x5e,
		0x63, 0x27, 0x55, 0x5b, 0x17, 0xdd, 0x29, 0xdf, 0xce, 0xc3, 0x3c, 0xc2, 0xd7, 0x64, 0x64, 0x53,
		0xfc, 0xfc, 0xf7, 0x6e, 0xd3, 0x03, 0x4b, 0x63, 0x39, 0xe9, 0x16, 0x24, 0x95, 0x64, 0x0a, 0x09,
		0x94, 0x61, 0xe3, 0xe0, 0x67, 0xa9, 0x71, 0x6e, 0xc9, 0xef, 0x64, 0xce, 0xe0, 0x74, 0xca, 0x7d,
		0xa9, 0xfc, 0x83, 0xe3, 0x1e, 0xa5, 0x60, 0xce, 0x45, 0x0d, 0xd2, 0xf3, 0xc7, 0x93, 0x81, 0xf7,
		0x7d, 0x5c, 0x76, 0x62, 0xcb, 0x6e, 0x09, 0xf3, 0xcc, 0x8c, 0xc3, 0x2d, 0xd5, 0x5a, 0x4e, 0xe1,
		0x24, 0x1e, 0x16, 0xa0, 0xc3, 0xb3, 0x55, 0x52, 0x55, 0xf4, 0x7c, 0x42, 0xa5, 0xf2, 0xbe, 0x79,
		0xd8, 0x78, 0x40, 0x01, 0x2b, 0xb2, 0x36, 0xb1, 0x50, 0xec, 0x65, 0xbe, 0x33, 0x86, 0x09, 0xa2,
		0xc0, 0x1f, 0x7d, 0xe1, 0xf7, 0x8b, 0x70, 0x3b, 0x82, 0x90, 0x4c, 0xb4, 0xaa, 0x40, 0x41, 0x44,
		0xc2, 0x0d, 0xeb, 0x4c, 0x46, 0x4d, 0x96, 0xc7, 0xf6, 0x02, 0xc6, 0xd4, 0xa2, 0xa5, 0xfa, 0x0e,
		0xd2, 0xad, 0x0c, 0xe9, 0xb2, 0xd3, 0xa0, 0x2d, 0x03, 0x78, 0x24, 0xb0, 0xce, 0x07, 0xc9, 0x5a,
		0x1c, 0x3f, 0xdd, 0x10, 0x9d, 0xc9, 0xea, 0x5b, 0xa1, 0x9b, 0xc7, 0xf6, 0x31, 0x91, 0xf3, 0x22,
		0xdf, 0xe2, 0x5b, 0x6e, 0x67, 0x1b, 0x37, 0xc9, 0x42, 0xe4, 0x1e, 0x8d, 0x33, 0x83, 0x63, 0xe1,
		0xd9, 0xad, 0x63, 0xae, 0xe6, 0xd9, 0xd5, 0x72, 0xb9, 0x44, 0xf5, 0x7b, 0x15, 0xcb, 0x81, 0x6b,
		0xad, 0x6d, 0xc6, 0x81, 0x4e, 0x4e, 0x36, 0xcb, 0x2c, 0xb0, 0x0a, 0xfc, 0x7b, 0xac, 0x80, 0x0a,
		0x04, 0xee, 0x69, 0xd6, 0xcc, 0x6b, 0x41, 0x33, 0xa6, 0x7a, 0x0a, 0x21, 0x64, 0xfe, 0x7d, 0xfa,
		0x45, 0x93, 0x43, 0x8f, 0x6b, 0x11, 0x7d, 0x5d, 0x51, 0x38, 0x1d, 0xf3, 0x86, 0x2b, 0x1c, 0xb3,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA4096_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise)
			       //
			       // RSA 4096 bit modulus (file: se/rsa4096-privkey.pem)
			       {
				       0xab, 0x0d, 0x09, 0xec, 0x4e, 0xb9, 0x11, 0x06,
				       0x5e, 0x6f, 0xc9, 0x53, 0xa7, 0xa3, 0xc8, 0xf6,
				       0x2f, 0xc7, 0x5f, 0x82, 0x47, 0x25, 0x9c, 0xf8,
				       0x98, 0x16, 0x98, 0x22, 0x89, 0x96, 0x14, 0xbd,
				       0xc6, 0xc6, 0x28, 0xea, 0x73, 0x2c, 0x20, 0x2e,
				       0xa3, 0x2e, 0x72, 0x8a, 0xc5, 0xec, 0xfc, 0x01,
				       0x45, 0xb3, 0xc5, 0xb3, 0x90, 0xf2, 0x19, 0x62,
				       0x41, 0x5f, 0x4c, 0x80, 0x78, 0x04, 0x07, 0x75,
				       0xcf, 0x7d, 0x44, 0x25, 0xd5, 0xce, 0x40, 0x26,
				       0x2c, 0xd3, 0xb9, 0x93, 0xd1, 0x13, 0xc1, 0xc7,
				       0xf3, 0xd5, 0xea, 0x2d, 0x59, 0x73, 0x96, 0x9f,
				       0x06, 0x30, 0x42, 0x67, 0xa1, 0xdf, 0xda, 0x9c,
				       0x38, 0x88, 0x70, 0xe0, 0x55, 0xf9, 0x88, 0x4f,
				       0x37, 0x01, 0x2d, 0x6d, 0x89, 0x26, 0x2c, 0x7f,
				       0x6e, 0xe4, 0x95, 0x2c, 0x65, 0x8f, 0x21, 0xf3,
				       0x2d, 0x20, 0x39, 0xeb, 0xe4, 0xf9, 0x06, 0x45,
				       0x81, 0xae, 0x54, 0xd4, 0x52, 0x07, 0x18, 0x17,
				       0x51, 0x48, 0x86, 0x46, 0x66, 0xdf, 0x15, 0x7f,
				       0x79, 0xac, 0x5c, 0xd1, 0x1c, 0x51, 0xd7, 0x41,
				       0x14, 0x22, 0x4f, 0xb8, 0x9c, 0x36, 0xca, 0xb9,
				       0x8a, 0x27, 0x11, 0xa3, 0x5b, 0xed, 0x5e, 0x72,
				       0x8d, 0xb8, 0xcb, 0x28, 0xf3, 0x28, 0x5f, 0x62,
				       0xda, 0x66, 0x24, 0x60, 0x92, 0x9d, 0xaa, 0x41,
				       0x8a, 0x4a, 0x8f, 0xa7, 0xf7, 0x69, 0x69, 0x84,
				       0x01, 0x6c, 0xe1, 0xea, 0x7c, 0x83, 0xb4, 0x03,
				       0x6b, 0xc9, 0xd9, 0xa6, 0x93, 0xe5, 0xb9, 0x81,
				       0x46, 0x29, 0xc2, 0x4c, 0x42, 0xe1, 0x6c, 0xa4,
				       0xa1, 0xe3, 0x08, 0xc1, 0x8f, 0x6a, 0x59, 0xb9,
				       0x10, 0x75, 0x6a, 0x8a, 0xeb, 0x62, 0x17, 0x32,
				       0xf9, 0x29, 0x99, 0xfa, 0xbd, 0x1a, 0xc0, 0x73,
				       0x4d, 0x0f, 0x9a, 0x6e, 0x28, 0x2c, 0xba, 0x36,
				       0xe6, 0x2e, 0xb9, 0x05, 0x45, 0x90, 0xa7, 0x2c,
				       0x21, 0x07, 0x0b, 0x0d, 0xe5, 0xf4, 0x33, 0x06,
				       0xfe, 0x3a, 0x1d, 0x9d, 0xb4, 0xac, 0x7e, 0xd9,
				       0xc9, 0xa4, 0xa7, 0xc0, 0x34, 0xb1, 0x0f, 0xa6,
				       0xa5, 0x23, 0x52, 0x8d, 0xec, 0xad, 0x53, 0x27,
				       0x6e, 0xe3, 0x71, 0xab, 0x2c, 0x92, 0xcd, 0x9b,
				       0xdf, 0x06, 0x86, 0x2c, 0x36, 0x99, 0x2e, 0xe3,
				       0xdf, 0xfa, 0xe0, 0x68, 0x26, 0xed, 0x60, 0xb1,
				       0x0d, 0x06, 0x66, 0x8d, 0xd0, 0x35, 0x25, 0x9d,
				       0x73, 0x90, 0xc6, 0x58, 0x4b, 0xd3, 0x5d, 0xd5,
				       0xb6, 0x9b, 0x3d, 0xdf, 0x99, 0x3f, 0xbc, 0xd8,
				       0x64, 0xfd, 0x6c, 0x38, 0xc0, 0x89, 0xe1, 0x48,
				       0xec, 0x83, 0x96, 0xf2, 0x2f, 0x73, 0xba, 0x75,
				       0x79, 0x30, 0x3c, 0x2e, 0x7a, 0x23, 0x66, 0x5f,
				       0xdb, 0x97, 0xb6, 0x04, 0xd1, 0x67, 0xbb, 0xf4,
				       0xb6, 0x7a, 0x5d, 0xe5, 0x2c, 0x21, 0xfa, 0x45,
				       0x9a, 0x5b, 0xf0, 0x34, 0x59, 0xc6, 0x7b, 0x24,
				       0x3e, 0xb4, 0xd2, 0xcf, 0x4c, 0xca, 0xed, 0x21,
				       0x10, 0x30, 0x21, 0x39, 0x90, 0x9f, 0x72, 0x9d,
				       0x70, 0xbf, 0x15, 0xc2, 0x81, 0x31, 0xc8, 0xa7,
				       0xc5, 0xb9, 0x3d, 0xc1, 0xe4, 0xab, 0xc1, 0xae,
				       0x18, 0x8f, 0x7b, 0xa7, 0x36, 0xa0, 0x45, 0x7a,
				       0x2f, 0x69, 0xb0, 0xe8, 0x91, 0xe0, 0xdd, 0xf3,
				       0x1a, 0x46, 0x33, 0x25, 0x27, 0x17, 0xa9, 0xc8,
				       0x2b, 0x06, 0x60, 0x21, 0x00, 0xf2, 0x7b, 0x5a,
				       0x75, 0xa0, 0x0e, 0xab, 0x9b, 0x72, 0x27, 0x93,
				       0x71, 0x27, 0x2e, 0x6e, 0x85, 0x97, 0x41, 0x09,
				       0xcb, 0xcb, 0x02, 0x1c, 0x53, 0x03, 0xc6, 0x3a,
				       0x26, 0xbc, 0x6c, 0x0e, 0xa0, 0x5b, 0xa5, 0xa3,
				       0xda, 0x6d, 0xcd, 0xac, 0xf8, 0xfb, 0x1c, 0x45,
				       0x3a, 0x2d, 0x05, 0xe6, 0xd9, 0xd3, 0x08, 0x34,
				       0xa3, 0x79, 0xb5, 0xa1, 0x0a, 0x44, 0x73, 0x64,
				       0xf2, 0xc6, 0x63, 0x51, 0x7c, 0x86, 0xfd, 0x9f,
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p\n",
		   algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA 4096 PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA 4096 PSS signature check: INVALID\n");
	}

	return ret;
}
#endif /* HAVE_SHA1 */

#ifdef TEST_PKA1_RSA_KSLOT
#if HAVE_SHA1
/* Test that the long (4096 bit) RSA keys work and that the SE driver
 * is properly selecting an engine that can handle these keys, no matter
 * which engine is suggested by the caller.
 */
__STATIC__ status_t TEST_rsa4096_pss_verify_sha1_saltlen_kslot(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	// XXX This signature has sLen == hLen (created by above openssl cmd)
	static uint8_t sig_saltlen[] = {
		0x4c, 0xf6, 0x65, 0xfd, 0x28, 0x3e, 0xfb, 0x94, 0x6b, 0x25, 0xa8, 0x7c, 0x20, 0x5e, 0x4e, 0xbd,
		0xd4, 0x92, 0xcf, 0x19, 0x52, 0xb7, 0xe6, 0xc9, 0x79, 0xec, 0x6b, 0x7f, 0xb0, 0x5d, 0x0c, 0x64,
		0x96, 0xb7, 0xca, 0xa7, 0x96, 0x75, 0xb5, 0x14, 0x38, 0x8d, 0xb1, 0x2f, 0x88, 0xbd, 0x68, 0xf4,
		0x18, 0x94, 0x1d, 0x66, 0xc5, 0xa7, 0xe2, 0x0e, 0xe0, 0x14, 0x99, 0x2f, 0xbd, 0xd8, 0x0e, 0x9e,
		0x29, 0xf1, 0x00, 0x55, 0x19, 0x25, 0x1f, 0x59, 0x53, 0x83, 0xf2, 0x28, 0x8b, 0x2a, 0xd0, 0xe8,
		0xb7, 0x9c, 0x1a, 0x90, 0x96, 0x34, 0xab, 0x48, 0x10, 0x53, 0x19, 0x33, 0xe1, 0xa2, 0xd1, 0xf8,
		0xe9, 0xd5, 0xb4, 0x49, 0xf6, 0xa3, 0x94, 0xa5, 0x02, 0x7b, 0x0c, 0x22, 0x45, 0x09, 0x42, 0xee,
		0xb8, 0xca, 0xc7, 0x0c, 0xa6, 0x55, 0x6f, 0x5d, 0xc8, 0xdf, 0x67, 0xdd, 0xcd, 0x70, 0xc3, 0xcf,
		0x5f, 0xc5, 0xad, 0xcd, 0xd0, 0x54, 0xfd, 0x0d, 0x57, 0x19, 0xb1, 0x01, 0x4f, 0xb7, 0xd6, 0xc1,
		0x60, 0x74, 0xf1, 0x79, 0x52, 0x6f, 0x02, 0x9d, 0x7e, 0x8d, 0x55, 0xd0, 0xeb, 0x35, 0x46, 0xb7,
		0x26, 0x3e, 0x12, 0x17, 0xda, 0x85, 0x13, 0x3a, 0x94, 0xfc, 0xc2, 0x07, 0xa8, 0xb8, 0x8c, 0x21,
		0x60, 0x3b, 0xb7, 0x16, 0x2f, 0xcc, 0x1e, 0xaa, 0x0f, 0xaa, 0x69, 0xec, 0x12, 0x9c, 0xf0, 0x9a,
		0x7a, 0x3d, 0x1f, 0xc1, 0x5b, 0x95, 0xb0, 0x7d, 0x45, 0x4b, 0x56, 0x66, 0xca, 0x3d, 0x9e, 0x29,
		0x1f, 0x97, 0xf7, 0x76, 0xa0, 0x79, 0x07, 0x64, 0x0f, 0x85, 0xe9, 0x3a, 0x1b, 0xeb, 0x61, 0x02,
		0x19, 0x40, 0xfa, 0xdc, 0x3e, 0x6f, 0xb6, 0x6e, 0x4c, 0xd4, 0xdf, 0xac, 0x0e, 0xa1, 0x6c, 0xb1,
		0x9d, 0x49, 0x25, 0x6e, 0x1c, 0xde, 0x22, 0xab, 0x8b, 0x72, 0x83, 0x79, 0xcc, 0xb5, 0xeb, 0x5e,
		0x63, 0x27, 0x55, 0x5b, 0x17, 0xdd, 0x29, 0xdf, 0xce, 0xc3, 0x3c, 0xc2, 0xd7, 0x64, 0x64, 0x53,
		0xfc, 0xfc, 0xf7, 0x6e, 0xd3, 0x03, 0x4b, 0x63, 0x39, 0xe9, 0x16, 0x24, 0x95, 0x64, 0x0a, 0x09,
		0x94, 0x61, 0xe3, 0xe0, 0x67, 0xa9, 0x71, 0x6e, 0xc9, 0xef, 0x64, 0xce, 0xe0, 0x74, 0xca, 0x7d,
		0xa9, 0xfc, 0x83, 0xe3, 0x1e, 0xa5, 0x60, 0xce, 0x45, 0x0d, 0xd2, 0xf3, 0xc7, 0x93, 0x81, 0xf7,
		0x7d, 0x5c, 0x76, 0x62, 0xcb, 0x6e, 0x09, 0xf3, 0xcc, 0x8c, 0xc3, 0x2d, 0xd5, 0x5a, 0x4e, 0xe1,
		0x24, 0x1e, 0x16, 0xa0, 0xc3, 0xb3, 0x55, 0x52, 0x55, 0xf4, 0x7c, 0x42, 0xa5, 0xf2, 0xbe, 0x79,
		0xd8, 0x78, 0x40, 0x01, 0x2b, 0xb2, 0x36, 0xb1, 0x50, 0xec, 0x65, 0xbe, 0x33, 0x86, 0x09, 0xa2,
		0xc0, 0x1f, 0x7d, 0xe1, 0xf7, 0x8b, 0x70, 0x3b, 0x82, 0x90, 0x4c, 0xb4, 0xaa, 0x40, 0x41, 0x44,
		0xc2, 0x0d, 0xeb, 0x4c, 0x46, 0x4d, 0x96, 0xc7, 0xf6, 0x02, 0xc6, 0xd4, 0xa2, 0xa5, 0xfa, 0x0e,
		0xd2, 0xad, 0x0c, 0xe9, 0xb2, 0xd3, 0xa0, 0x2d, 0x03, 0x78, 0x24, 0xb0, 0xce, 0x07, 0xc9, 0x5a,
		0x1c, 0x3f, 0xdd, 0x10, 0x9d, 0xc9, 0xea, 0x5b, 0xa1, 0x9b, 0xc7, 0xf6, 0x31, 0x91, 0xf3, 0x22,
		0xdf, 0xe2, 0x5b, 0x6e, 0x67, 0x1b, 0x37, 0xc9, 0x42, 0xe4, 0x1e, 0x8d, 0x33, 0x83, 0x63, 0xe1,
		0xd9, 0xad, 0x63, 0xae, 0xe6, 0xd9, 0xd5, 0x72, 0xb9, 0x44, 0xf5, 0x7b, 0x15, 0xcb, 0x81, 0x6b,
		0xad, 0x6d, 0xc6, 0x81, 0x4e, 0x4e, 0x36, 0xcb, 0x2c, 0xb0, 0x0a, 0xfc, 0x7b, 0xac, 0x80, 0x0a,
		0x04, 0xee, 0x69, 0xd6, 0xcc, 0x6b, 0x41, 0x33, 0xa6, 0x7a, 0x0a, 0x21, 0x64, 0xfe, 0x7d, 0xfa,
		0x45, 0x93, 0x43, 0x8f, 0x6b, 0x11, 0x7d, 0x5d, 0x51, 0x38, 0x1d, 0xf3, 0x86, 0x2b, 0x1c, 0xb3,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// Write plain key to PKA1 keyslot and leave it there
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_FORCE_KEYSLOT |
					KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_byte_size = RSA4096_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise)
			       //
			       // RSA 4096 bit modulus (file: se/rsa4096-privkey.pem)
			       {
				       0xab, 0x0d, 0x09, 0xec, 0x4e, 0xb9, 0x11, 0x06,
				       0x5e, 0x6f, 0xc9, 0x53, 0xa7, 0xa3, 0xc8, 0xf6,
				       0x2f, 0xc7, 0x5f, 0x82, 0x47, 0x25, 0x9c, 0xf8,
				       0x98, 0x16, 0x98, 0x22, 0x89, 0x96, 0x14, 0xbd,
				       0xc6, 0xc6, 0x28, 0xea, 0x73, 0x2c, 0x20, 0x2e,
				       0xa3, 0x2e, 0x72, 0x8a, 0xc5, 0xec, 0xfc, 0x01,
				       0x45, 0xb3, 0xc5, 0xb3, 0x90, 0xf2, 0x19, 0x62,
				       0x41, 0x5f, 0x4c, 0x80, 0x78, 0x04, 0x07, 0x75,
				       0xcf, 0x7d, 0x44, 0x25, 0xd5, 0xce, 0x40, 0x26,
				       0x2c, 0xd3, 0xb9, 0x93, 0xd1, 0x13, 0xc1, 0xc7,
				       0xf3, 0xd5, 0xea, 0x2d, 0x59, 0x73, 0x96, 0x9f,
				       0x06, 0x30, 0x42, 0x67, 0xa1, 0xdf, 0xda, 0x9c,
				       0x38, 0x88, 0x70, 0xe0, 0x55, 0xf9, 0x88, 0x4f,
				       0x37, 0x01, 0x2d, 0x6d, 0x89, 0x26, 0x2c, 0x7f,
				       0x6e, 0xe4, 0x95, 0x2c, 0x65, 0x8f, 0x21, 0xf3,
				       0x2d, 0x20, 0x39, 0xeb, 0xe4, 0xf9, 0x06, 0x45,
				       0x81, 0xae, 0x54, 0xd4, 0x52, 0x07, 0x18, 0x17,
				       0x51, 0x48, 0x86, 0x46, 0x66, 0xdf, 0x15, 0x7f,
				       0x79, 0xac, 0x5c, 0xd1, 0x1c, 0x51, 0xd7, 0x41,
				       0x14, 0x22, 0x4f, 0xb8, 0x9c, 0x36, 0xca, 0xb9,
				       0x8a, 0x27, 0x11, 0xa3, 0x5b, 0xed, 0x5e, 0x72,
				       0x8d, 0xb8, 0xcb, 0x28, 0xf3, 0x28, 0x5f, 0x62,
				       0xda, 0x66, 0x24, 0x60, 0x92, 0x9d, 0xaa, 0x41,
				       0x8a, 0x4a, 0x8f, 0xa7, 0xf7, 0x69, 0x69, 0x84,
				       0x01, 0x6c, 0xe1, 0xea, 0x7c, 0x83, 0xb4, 0x03,
				       0x6b, 0xc9, 0xd9, 0xa6, 0x93, 0xe5, 0xb9, 0x81,
				       0x46, 0x29, 0xc2, 0x4c, 0x42, 0xe1, 0x6c, 0xa4,
				       0xa1, 0xe3, 0x08, 0xc1, 0x8f, 0x6a, 0x59, 0xb9,
				       0x10, 0x75, 0x6a, 0x8a, 0xeb, 0x62, 0x17, 0x32,
				       0xf9, 0x29, 0x99, 0xfa, 0xbd, 0x1a, 0xc0, 0x73,
				       0x4d, 0x0f, 0x9a, 0x6e, 0x28, 0x2c, 0xba, 0x36,
				       0xe6, 0x2e, 0xb9, 0x05, 0x45, 0x90, 0xa7, 0x2c,
				       0x21, 0x07, 0x0b, 0x0d, 0xe5, 0xf4, 0x33, 0x06,
				       0xfe, 0x3a, 0x1d, 0x9d, 0xb4, 0xac, 0x7e, 0xd9,
				       0xc9, 0xa4, 0xa7, 0xc0, 0x34, 0xb1, 0x0f, 0xa6,
				       0xa5, 0x23, 0x52, 0x8d, 0xec, 0xad, 0x53, 0x27,
				       0x6e, 0xe3, 0x71, 0xab, 0x2c, 0x92, 0xcd, 0x9b,
				       0xdf, 0x06, 0x86, 0x2c, 0x36, 0x99, 0x2e, 0xe3,
				       0xdf, 0xfa, 0xe0, 0x68, 0x26, 0xed, 0x60, 0xb1,
				       0x0d, 0x06, 0x66, 0x8d, 0xd0, 0x35, 0x25, 0x9d,
				       0x73, 0x90, 0xc6, 0x58, 0x4b, 0xd3, 0x5d, 0xd5,
				       0xb6, 0x9b, 0x3d, 0xdf, 0x99, 0x3f, 0xbc, 0xd8,
				       0x64, 0xfd, 0x6c, 0x38, 0xc0, 0x89, 0xe1, 0x48,
				       0xec, 0x83, 0x96, 0xf2, 0x2f, 0x73, 0xba, 0x75,
				       0x79, 0x30, 0x3c, 0x2e, 0x7a, 0x23, 0x66, 0x5f,
				       0xdb, 0x97, 0xb6, 0x04, 0xd1, 0x67, 0xbb, 0xf4,
				       0xb6, 0x7a, 0x5d, 0xe5, 0x2c, 0x21, 0xfa, 0x45,
				       0x9a, 0x5b, 0xf0, 0x34, 0x59, 0xc6, 0x7b, 0x24,
				       0x3e, 0xb4, 0xd2, 0xcf, 0x4c, 0xca, 0xed, 0x21,
				       0x10, 0x30, 0x21, 0x39, 0x90, 0x9f, 0x72, 0x9d,
				       0x70, 0xbf, 0x15, 0xc2, 0x81, 0x31, 0xc8, 0xa7,
				       0xc5, 0xb9, 0x3d, 0xc1, 0xe4, 0xab, 0xc1, 0xae,
				       0x18, 0x8f, 0x7b, 0xa7, 0x36, 0xa0, 0x45, 0x7a,
				       0x2f, 0x69, 0xb0, 0xe8, 0x91, 0xe0, 0xdd, 0xf3,
				       0x1a, 0x46, 0x33, 0x25, 0x27, 0x17, 0xa9, 0xc8,
				       0x2b, 0x06, 0x60, 0x21, 0x00, 0xf2, 0x7b, 0x5a,
				       0x75, 0xa0, 0x0e, 0xab, 0x9b, 0x72, 0x27, 0x93,
				       0x71, 0x27, 0x2e, 0x6e, 0x85, 0x97, 0x41, 0x09,
				       0xcb, 0xcb, 0x02, 0x1c, 0x53, 0x03, 0xc6, 0x3a,
				       0x26, 0xbc, 0x6c, 0x0e, 0xa0, 0x5b, 0xa5, 0xa3,
				       0xda, 0x6d, 0xcd, 0xac, 0xf8, 0xfb, 0x1c, 0x45,
				       0x3a, 0x2d, 0x05, 0xe6, 0xd9, 0xd3, 0x08, 0x34,
				       0xa3, 0x79, 0xb5, 0xa1, 0x0a, 0x44, 0x73, 0x64,
				       0xf2, 0xc6, 0x63, 0x51, 0x7c, 0x86, 0xfd, 0x9f,
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p\n",
		   algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA 4096 PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA 4096 PSS signature check: INVALID\n");
	}

	return ret;
}

/* Test that the long (4096 bit) RSA keys work and that the SE driver
 * is properly selecting an engine that can handle these keys, no matter
 * which engine is suggested by the caller.
 */
__STATIC__ status_t TEST_rsa4096_pss_verify_sha1_saltlen_key3(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	// XXX This signature has sLen == hLen (created by above openssl cmd)
	static uint8_t sig_saltlen[] = {
		0x4c, 0xf6, 0x65, 0xfd, 0x28, 0x3e, 0xfb, 0x94, 0x6b, 0x25, 0xa8, 0x7c, 0x20, 0x5e, 0x4e, 0xbd,
		0xd4, 0x92, 0xcf, 0x19, 0x52, 0xb7, 0xe6, 0xc9, 0x79, 0xec, 0x6b, 0x7f, 0xb0, 0x5d, 0x0c, 0x64,
		0x96, 0xb7, 0xca, 0xa7, 0x96, 0x75, 0xb5, 0x14, 0x38, 0x8d, 0xb1, 0x2f, 0x88, 0xbd, 0x68, 0xf4,
		0x18, 0x94, 0x1d, 0x66, 0xc5, 0xa7, 0xe2, 0x0e, 0xe0, 0x14, 0x99, 0x2f, 0xbd, 0xd8, 0x0e, 0x9e,
		0x29, 0xf1, 0x00, 0x55, 0x19, 0x25, 0x1f, 0x59, 0x53, 0x83, 0xf2, 0x28, 0x8b, 0x2a, 0xd0, 0xe8,
		0xb7, 0x9c, 0x1a, 0x90, 0x96, 0x34, 0xab, 0x48, 0x10, 0x53, 0x19, 0x33, 0xe1, 0xa2, 0xd1, 0xf8,
		0xe9, 0xd5, 0xb4, 0x49, 0xf6, 0xa3, 0x94, 0xa5, 0x02, 0x7b, 0x0c, 0x22, 0x45, 0x09, 0x42, 0xee,
		0xb8, 0xca, 0xc7, 0x0c, 0xa6, 0x55, 0x6f, 0x5d, 0xc8, 0xdf, 0x67, 0xdd, 0xcd, 0x70, 0xc3, 0xcf,
		0x5f, 0xc5, 0xad, 0xcd, 0xd0, 0x54, 0xfd, 0x0d, 0x57, 0x19, 0xb1, 0x01, 0x4f, 0xb7, 0xd6, 0xc1,
		0x60, 0x74, 0xf1, 0x79, 0x52, 0x6f, 0x02, 0x9d, 0x7e, 0x8d, 0x55, 0xd0, 0xeb, 0x35, 0x46, 0xb7,
		0x26, 0x3e, 0x12, 0x17, 0xda, 0x85, 0x13, 0x3a, 0x94, 0xfc, 0xc2, 0x07, 0xa8, 0xb8, 0x8c, 0x21,
		0x60, 0x3b, 0xb7, 0x16, 0x2f, 0xcc, 0x1e, 0xaa, 0x0f, 0xaa, 0x69, 0xec, 0x12, 0x9c, 0xf0, 0x9a,
		0x7a, 0x3d, 0x1f, 0xc1, 0x5b, 0x95, 0xb0, 0x7d, 0x45, 0x4b, 0x56, 0x66, 0xca, 0x3d, 0x9e, 0x29,
		0x1f, 0x97, 0xf7, 0x76, 0xa0, 0x79, 0x07, 0x64, 0x0f, 0x85, 0xe9, 0x3a, 0x1b, 0xeb, 0x61, 0x02,
		0x19, 0x40, 0xfa, 0xdc, 0x3e, 0x6f, 0xb6, 0x6e, 0x4c, 0xd4, 0xdf, 0xac, 0x0e, 0xa1, 0x6c, 0xb1,
		0x9d, 0x49, 0x25, 0x6e, 0x1c, 0xde, 0x22, 0xab, 0x8b, 0x72, 0x83, 0x79, 0xcc, 0xb5, 0xeb, 0x5e,
		0x63, 0x27, 0x55, 0x5b, 0x17, 0xdd, 0x29, 0xdf, 0xce, 0xc3, 0x3c, 0xc2, 0xd7, 0x64, 0x64, 0x53,
		0xfc, 0xfc, 0xf7, 0x6e, 0xd3, 0x03, 0x4b, 0x63, 0x39, 0xe9, 0x16, 0x24, 0x95, 0x64, 0x0a, 0x09,
		0x94, 0x61, 0xe3, 0xe0, 0x67, 0xa9, 0x71, 0x6e, 0xc9, 0xef, 0x64, 0xce, 0xe0, 0x74, 0xca, 0x7d,
		0xa9, 0xfc, 0x83, 0xe3, 0x1e, 0xa5, 0x60, 0xce, 0x45, 0x0d, 0xd2, 0xf3, 0xc7, 0x93, 0x81, 0xf7,
		0x7d, 0x5c, 0x76, 0x62, 0xcb, 0x6e, 0x09, 0xf3, 0xcc, 0x8c, 0xc3, 0x2d, 0xd5, 0x5a, 0x4e, 0xe1,
		0x24, 0x1e, 0x16, 0xa0, 0xc3, 0xb3, 0x55, 0x52, 0x55, 0xf4, 0x7c, 0x42, 0xa5, 0xf2, 0xbe, 0x79,
		0xd8, 0x78, 0x40, 0x01, 0x2b, 0xb2, 0x36, 0xb1, 0x50, 0xec, 0x65, 0xbe, 0x33, 0x86, 0x09, 0xa2,
		0xc0, 0x1f, 0x7d, 0xe1, 0xf7, 0x8b, 0x70, 0x3b, 0x82, 0x90, 0x4c, 0xb4, 0xaa, 0x40, 0x41, 0x44,
		0xc2, 0x0d, 0xeb, 0x4c, 0x46, 0x4d, 0x96, 0xc7, 0xf6, 0x02, 0xc6, 0xd4, 0xa2, 0xa5, 0xfa, 0x0e,
		0xd2, 0xad, 0x0c, 0xe9, 0xb2, 0xd3, 0xa0, 0x2d, 0x03, 0x78, 0x24, 0xb0, 0xce, 0x07, 0xc9, 0x5a,
		0x1c, 0x3f, 0xdd, 0x10, 0x9d, 0xc9, 0xea, 0x5b, 0xa1, 0x9b, 0xc7, 0xf6, 0x31, 0x91, 0xf3, 0x22,
		0xdf, 0xe2, 0x5b, 0x6e, 0x67, 0x1b, 0x37, 0xc9, 0x42, 0xe4, 0x1e, 0x8d, 0x33, 0x83, 0x63, 0xe1,
		0xd9, 0xad, 0x63, 0xae, 0xe6, 0xd9, 0xd5, 0x72, 0xb9, 0x44, 0xf5, 0x7b, 0x15, 0xcb, 0x81, 0x6b,
		0xad, 0x6d, 0xc6, 0x81, 0x4e, 0x4e, 0x36, 0xcb, 0x2c, 0xb0, 0x0a, 0xfc, 0x7b, 0xac, 0x80, 0x0a,
		0x04, 0xee, 0x69, 0xd6, 0xcc, 0x6b, 0x41, 0x33, 0xa6, 0x7a, 0x0a, 0x21, 0x64, 0xfe, 0x7d, 0xfa,
		0x45, 0x93, 0x43, 0x8f, 0x6b, 0x11, 0x7d, 0x5d, 0x51, 0x38, 0x1d, 0xf3, 0x86, 0x2b, 0x1c, 0xb3,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// Write plain key to PKA1 keyslot and erase key slot when done
		// (i.e. do not "leave_key_to_keyslot")
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY |
		// XXXX Check if the next RSA does not break after adding this!!
					KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_byte_size = RSA4096_BYTE_SIZE,
		.k_keyslot = 3U,
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p\n",
		   algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA 4096 PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA 4096 PSS signature check: INVALID\n");
	}

	return ret;
}

__STATIC__ status_t TEST_rsa4096_pss_verify_sha1_saltlen_set_key2(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Use keyslot 2 for this test */
	uint32_t keyslot = 2U;

	// char data[] = "HelloWorld";
	// No null termination, no LF

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	// XXX This signature has sLen == hLen (created by above openssl cmd)
	static uint8_t sig_saltlen[] = {
		0x4c, 0xf6, 0x65, 0xfd, 0x28, 0x3e, 0xfb, 0x94, 0x6b, 0x25, 0xa8, 0x7c, 0x20, 0x5e, 0x4e, 0xbd,
		0xd4, 0x92, 0xcf, 0x19, 0x52, 0xb7, 0xe6, 0xc9, 0x79, 0xec, 0x6b, 0x7f, 0xb0, 0x5d, 0x0c, 0x64,
		0x96, 0xb7, 0xca, 0xa7, 0x96, 0x75, 0xb5, 0x14, 0x38, 0x8d, 0xb1, 0x2f, 0x88, 0xbd, 0x68, 0xf4,
		0x18, 0x94, 0x1d, 0x66, 0xc5, 0xa7, 0xe2, 0x0e, 0xe0, 0x14, 0x99, 0x2f, 0xbd, 0xd8, 0x0e, 0x9e,
		0x29, 0xf1, 0x00, 0x55, 0x19, 0x25, 0x1f, 0x59, 0x53, 0x83, 0xf2, 0x28, 0x8b, 0x2a, 0xd0, 0xe8,
		0xb7, 0x9c, 0x1a, 0x90, 0x96, 0x34, 0xab, 0x48, 0x10, 0x53, 0x19, 0x33, 0xe1, 0xa2, 0xd1, 0xf8,
		0xe9, 0xd5, 0xb4, 0x49, 0xf6, 0xa3, 0x94, 0xa5, 0x02, 0x7b, 0x0c, 0x22, 0x45, 0x09, 0x42, 0xee,
		0xb8, 0xca, 0xc7, 0x0c, 0xa6, 0x55, 0x6f, 0x5d, 0xc8, 0xdf, 0x67, 0xdd, 0xcd, 0x70, 0xc3, 0xcf,
		0x5f, 0xc5, 0xad, 0xcd, 0xd0, 0x54, 0xfd, 0x0d, 0x57, 0x19, 0xb1, 0x01, 0x4f, 0xb7, 0xd6, 0xc1,
		0x60, 0x74, 0xf1, 0x79, 0x52, 0x6f, 0x02, 0x9d, 0x7e, 0x8d, 0x55, 0xd0, 0xeb, 0x35, 0x46, 0xb7,
		0x26, 0x3e, 0x12, 0x17, 0xda, 0x85, 0x13, 0x3a, 0x94, 0xfc, 0xc2, 0x07, 0xa8, 0xb8, 0x8c, 0x21,
		0x60, 0x3b, 0xb7, 0x16, 0x2f, 0xcc, 0x1e, 0xaa, 0x0f, 0xaa, 0x69, 0xec, 0x12, 0x9c, 0xf0, 0x9a,
		0x7a, 0x3d, 0x1f, 0xc1, 0x5b, 0x95, 0xb0, 0x7d, 0x45, 0x4b, 0x56, 0x66, 0xca, 0x3d, 0x9e, 0x29,
		0x1f, 0x97, 0xf7, 0x76, 0xa0, 0x79, 0x07, 0x64, 0x0f, 0x85, 0xe9, 0x3a, 0x1b, 0xeb, 0x61, 0x02,
		0x19, 0x40, 0xfa, 0xdc, 0x3e, 0x6f, 0xb6, 0x6e, 0x4c, 0xd4, 0xdf, 0xac, 0x0e, 0xa1, 0x6c, 0xb1,
		0x9d, 0x49, 0x25, 0x6e, 0x1c, 0xde, 0x22, 0xab, 0x8b, 0x72, 0x83, 0x79, 0xcc, 0xb5, 0xeb, 0x5e,
		0x63, 0x27, 0x55, 0x5b, 0x17, 0xdd, 0x29, 0xdf, 0xce, 0xc3, 0x3c, 0xc2, 0xd7, 0x64, 0x64, 0x53,
		0xfc, 0xfc, 0xf7, 0x6e, 0xd3, 0x03, 0x4b, 0x63, 0x39, 0xe9, 0x16, 0x24, 0x95, 0x64, 0x0a, 0x09,
		0x94, 0x61, 0xe3, 0xe0, 0x67, 0xa9, 0x71, 0x6e, 0xc9, 0xef, 0x64, 0xce, 0xe0, 0x74, 0xca, 0x7d,
		0xa9, 0xfc, 0x83, 0xe3, 0x1e, 0xa5, 0x60, 0xce, 0x45, 0x0d, 0xd2, 0xf3, 0xc7, 0x93, 0x81, 0xf7,
		0x7d, 0x5c, 0x76, 0x62, 0xcb, 0x6e, 0x09, 0xf3, 0xcc, 0x8c, 0xc3, 0x2d, 0xd5, 0x5a, 0x4e, 0xe1,
		0x24, 0x1e, 0x16, 0xa0, 0xc3, 0xb3, 0x55, 0x52, 0x55, 0xf4, 0x7c, 0x42, 0xa5, 0xf2, 0xbe, 0x79,
		0xd8, 0x78, 0x40, 0x01, 0x2b, 0xb2, 0x36, 0xb1, 0x50, 0xec, 0x65, 0xbe, 0x33, 0x86, 0x09, 0xa2,
		0xc0, 0x1f, 0x7d, 0xe1, 0xf7, 0x8b, 0x70, 0x3b, 0x82, 0x90, 0x4c, 0xb4, 0xaa, 0x40, 0x41, 0x44,
		0xc2, 0x0d, 0xeb, 0x4c, 0x46, 0x4d, 0x96, 0xc7, 0xf6, 0x02, 0xc6, 0xd4, 0xa2, 0xa5, 0xfa, 0x0e,
		0xd2, 0xad, 0x0c, 0xe9, 0xb2, 0xd3, 0xa0, 0x2d, 0x03, 0x78, 0x24, 0xb0, 0xce, 0x07, 0xc9, 0x5a,
		0x1c, 0x3f, 0xdd, 0x10, 0x9d, 0xc9, 0xea, 0x5b, 0xa1, 0x9b, 0xc7, 0xf6, 0x31, 0x91, 0xf3, 0x22,
		0xdf, 0xe2, 0x5b, 0x6e, 0x67, 0x1b, 0x37, 0xc9, 0x42, 0xe4, 0x1e, 0x8d, 0x33, 0x83, 0x63, 0xe1,
		0xd9, 0xad, 0x63, 0xae, 0xe6, 0xd9, 0xd5, 0x72, 0xb9, 0x44, 0xf5, 0x7b, 0x15, 0xcb, 0x81, 0x6b,
		0xad, 0x6d, 0xc6, 0x81, 0x4e, 0x4e, 0x36, 0xcb, 0x2c, 0xb0, 0x0a, 0xfc, 0x7b, 0xac, 0x80, 0x0a,
		0x04, 0xee, 0x69, 0xd6, 0xcc, 0x6b, 0x41, 0x33, 0xa6, 0x7a, 0x0a, 0x21, 0x64, 0xfe, 0x7d, 0xfa,
		0x45, 0x93, 0x43, 0x8f, 0x6b, 0x11, 0x7d, 0x5d, 0x51, 0x38, 0x1d, 0xf3, 0x86, 0x2b, 0x1c, 0xb3,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		// Write plain key to PKA1 keyslot and erase key slot when done
		// (i.e. do not "leave_key_to_keyslot")
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY |
		// XXXX Check if the next RSA does not break after adding this!!
					KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_byte_size = RSA4096_BYTE_SIZE,
		// Set this in code from a variable: .k_keyslot = 2,
	};

	uint8_t pub_exponent[4] = { 0x00, 0x01, 0x00, 0x01 };

	uint8_t modulus[512] = {
		0xab, 0x0d, 0x09, 0xec, 0x4e, 0xb9, 0x11, 0x06,
		0x5e, 0x6f, 0xc9, 0x53, 0xa7, 0xa3, 0xc8, 0xf6,
		0x2f, 0xc7, 0x5f, 0x82, 0x47, 0x25, 0x9c, 0xf8,
		0x98, 0x16, 0x98, 0x22, 0x89, 0x96, 0x14, 0xbd,
		0xc6, 0xc6, 0x28, 0xea, 0x73, 0x2c, 0x20, 0x2e,
		0xa3, 0x2e, 0x72, 0x8a, 0xc5, 0xec, 0xfc, 0x01,
		0x45, 0xb3, 0xc5, 0xb3, 0x90, 0xf2, 0x19, 0x62,
		0x41, 0x5f, 0x4c, 0x80, 0x78, 0x04, 0x07, 0x75,
		0xcf, 0x7d, 0x44, 0x25, 0xd5, 0xce, 0x40, 0x26,
		0x2c, 0xd3, 0xb9, 0x93, 0xd1, 0x13, 0xc1, 0xc7,
		0xf3, 0xd5, 0xea, 0x2d, 0x59, 0x73, 0x96, 0x9f,
		0x06, 0x30, 0x42, 0x67, 0xa1, 0xdf, 0xda, 0x9c,
		0x38, 0x88, 0x70, 0xe0, 0x55, 0xf9, 0x88, 0x4f,
		0x37, 0x01, 0x2d, 0x6d, 0x89, 0x26, 0x2c, 0x7f,
		0x6e, 0xe4, 0x95, 0x2c, 0x65, 0x8f, 0x21, 0xf3,
		0x2d, 0x20, 0x39, 0xeb, 0xe4, 0xf9, 0x06, 0x45,
		0x81, 0xae, 0x54, 0xd4, 0x52, 0x07, 0x18, 0x17,
		0x51, 0x48, 0x86, 0x46, 0x66, 0xdf, 0x15, 0x7f,
		0x79, 0xac, 0x5c, 0xd1, 0x1c, 0x51, 0xd7, 0x41,
		0x14, 0x22, 0x4f, 0xb8, 0x9c, 0x36, 0xca, 0xb9,
		0x8a, 0x27, 0x11, 0xa3, 0x5b, 0xed, 0x5e, 0x72,
		0x8d, 0xb8, 0xcb, 0x28, 0xf3, 0x28, 0x5f, 0x62,
		0xda, 0x66, 0x24, 0x60, 0x92, 0x9d, 0xaa, 0x41,
		0x8a, 0x4a, 0x8f, 0xa7, 0xf7, 0x69, 0x69, 0x84,
		0x01, 0x6c, 0xe1, 0xea, 0x7c, 0x83, 0xb4, 0x03,
		0x6b, 0xc9, 0xd9, 0xa6, 0x93, 0xe5, 0xb9, 0x81,
		0x46, 0x29, 0xc2, 0x4c, 0x42, 0xe1, 0x6c, 0xa4,
		0xa1, 0xe3, 0x08, 0xc1, 0x8f, 0x6a, 0x59, 0xb9,
		0x10, 0x75, 0x6a, 0x8a, 0xeb, 0x62, 0x17, 0x32,
		0xf9, 0x29, 0x99, 0xfa, 0xbd, 0x1a, 0xc0, 0x73,
		0x4d, 0x0f, 0x9a, 0x6e, 0x28, 0x2c, 0xba, 0x36,
		0xe6, 0x2e, 0xb9, 0x05, 0x45, 0x90, 0xa7, 0x2c,
		0x21, 0x07, 0x0b, 0x0d, 0xe5, 0xf4, 0x33, 0x06,
		0xfe, 0x3a, 0x1d, 0x9d, 0xb4, 0xac, 0x7e, 0xd9,
		0xc9, 0xa4, 0xa7, 0xc0, 0x34, 0xb1, 0x0f, 0xa6,
		0xa5, 0x23, 0x52, 0x8d, 0xec, 0xad, 0x53, 0x27,
		0x6e, 0xe3, 0x71, 0xab, 0x2c, 0x92, 0xcd, 0x9b,
		0xdf, 0x06, 0x86, 0x2c, 0x36, 0x99, 0x2e, 0xe3,
		0xdf, 0xfa, 0xe0, 0x68, 0x26, 0xed, 0x60, 0xb1,
		0x0d, 0x06, 0x66, 0x8d, 0xd0, 0x35, 0x25, 0x9d,
		0x73, 0x90, 0xc6, 0x58, 0x4b, 0xd3, 0x5d, 0xd5,
		0xb6, 0x9b, 0x3d, 0xdf, 0x99, 0x3f, 0xbc, 0xd8,
		0x64, 0xfd, 0x6c, 0x38, 0xc0, 0x89, 0xe1, 0x48,
		0xec, 0x83, 0x96, 0xf2, 0x2f, 0x73, 0xba, 0x75,
		0x79, 0x30, 0x3c, 0x2e, 0x7a, 0x23, 0x66, 0x5f,
		0xdb, 0x97, 0xb6, 0x04, 0xd1, 0x67, 0xbb, 0xf4,
		0xb6, 0x7a, 0x5d, 0xe5, 0x2c, 0x21, 0xfa, 0x45,
		0x9a, 0x5b, 0xf0, 0x34, 0x59, 0xc6, 0x7b, 0x24,
		0x3e, 0xb4, 0xd2, 0xcf, 0x4c, 0xca, 0xed, 0x21,
		0x10, 0x30, 0x21, 0x39, 0x90, 0x9f, 0x72, 0x9d,
		0x70, 0xbf, 0x15, 0xc2, 0x81, 0x31, 0xc8, 0xa7,
		0xc5, 0xb9, 0x3d, 0xc1, 0xe4, 0xab, 0xc1, 0xae,
		0x18, 0x8f, 0x7b, 0xa7, 0x36, 0xa0, 0x45, 0x7a,
		0x2f, 0x69, 0xb0, 0xe8, 0x91, 0xe0, 0xdd, 0xf3,
		0x1a, 0x46, 0x33, 0x25, 0x27, 0x17, 0xa9, 0xc8,
		0x2b, 0x06, 0x60, 0x21, 0x00, 0xf2, 0x7b, 0x5a,
		0x75, 0xa0, 0x0e, 0xab, 0x9b, 0x72, 0x27, 0x93,
		0x71, 0x27, 0x2e, 0x6e, 0x85, 0x97, 0x41, 0x09,
		0xcb, 0xcb, 0x02, 0x1c, 0x53, 0x03, 0xc6, 0x3a,
		0x26, 0xbc, 0x6c, 0x0e, 0xa0, 0x5b, 0xa5, 0xa3,
		0xda, 0x6d, 0xcd, 0xac, 0xf8, 0xfb, 0x1c, 0x45,
		0x3a, 0x2d, 0x05, 0xe6, 0xd9, 0xd3, 0x08, 0x34,
		0xa3, 0x79, 0xb5, 0xa1, 0x0a, 0x44, 0x73, 0x64,
		0xf2, 0xc6, 0x63, 0x51, 0x7c, 0x86, 0xfd, 0x9f,
	};

	(void)algo;

	{
		bool key_is_big_endian = true;
		se_cdev_id_t dev_id = SE_CDEV_PKA1;

		/* Set dev RSA BE keyslot value.. First clear the keyslot
		 * (no real reason, just a demo) and then write the keyslot
		 */
		ret = se_clear_device_rsa_keyslot(dev_id, keyslot);
		LOG_ALWAYS("Cleared (ret=%d) dev %u keyslot %u before setting it\n", ret, dev_id, keyslot);
		CCC_ERROR_CHECK(ret,
				LOG_ERROR("Failed to write dev %u RSA keyslot value\n", dev_id));

		ret = se_set_device_rsa_keyslot(dev_id, keyslot,
						sizeof_u32(pub_exponent), sizeof_u32(modulus),
						pub_exponent, modulus,
						key_is_big_endian);
		CCC_ERROR_CHECK(ret,
				LOG_ERROR("Failed to write dev %u RSA keyslot value\n", dev_id));

		LOG_ALWAYS("Set (ret=%d) dev %u keyslot %u; now attempt using it\n", ret, dev_id, keyslot);
	}

	/* Do the RSA operation with the public key set above */

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	/* Set used keyslot here */
	akey.k_keyslot = keyslot;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p\n",
		   algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA 4096 PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA 4096 PSS signature check: INVALID\n");
	}

	return ret;
}
#endif /* HAVE_SHA1 */

/* RSA pubkey for 3072 bit rsa verify test below.
 * Moved here so the key can be used in another test
 * for passing pubkey in a keyslot.
 */

/* The following values must be in the SAME ENDIAN
 * (as specified in the key set function parameters)
 * when passed to se_set_device_rsa_keyslot_montgomery().
 *
 * Big endian RSA values are used in this example.
 *
 * The values are extracted from the previous test case
 * (TEST_rsa3072_pss_verify_sha256_saltlen), the
 * montgomery values are callwlated with PKA1.
 */
static uint8_t R3072_pub_exponent[] = { 0x00, 0x01, 0x00, 0x01 };

/* RSA 3072 bit modulus (file: test-keys/rsa3072-privkey.pem) */
static uint8_t R3072_modulus[] = {
	0xCD, 0x8E, 0xD6, 0x88, 0x82, 0x86, 0xC7, 0x95,
	0xC6, 0x4D, 0x58, 0x7F, 0x08, 0x96, 0xB2, 0xE0,
	0x31, 0xC3, 0x11, 0x27, 0x23, 0x50, 0x8A, 0xD4,
	0x55, 0x78, 0x3F, 0x95, 0x91, 0xF8, 0x6F, 0x77,
	0x58, 0x89, 0xD3, 0xC1, 0xF5, 0xA6, 0xAE, 0x1A,
	0xF1, 0x77, 0xE3, 0x10, 0x2D, 0xAD, 0xFC, 0x24,
	0x16, 0x84, 0x1E, 0x86, 0xCA, 0xD3, 0x8C, 0x31,
	0xD6, 0xA1, 0xCD, 0xE2, 0x78, 0xAE, 0xF7, 0x97,
	0x05, 0x45, 0xCD, 0x5B, 0x31, 0x34, 0x02, 0x10,
	0xCA, 0x93, 0xA5, 0x3C, 0x67, 0xBC, 0xED, 0xA8,
	0xEA, 0x51, 0xDB, 0x2E, 0x69, 0xA3, 0xA0, 0x2A,
	0xEA, 0x96, 0x8A, 0x4D, 0x46, 0x44, 0xD8, 0x21,
	0x2C, 0x7D, 0x6E, 0x38, 0xB8, 0x70, 0xEE, 0x5F,
	0x43, 0x8D, 0x5E, 0x27, 0x7D, 0xBF, 0x70, 0x1A,
	0x72, 0xEE, 0xAE, 0xC4, 0x49, 0xB8, 0xF1, 0xB1,
	0x8E, 0x54, 0x18, 0x24, 0x84, 0xA8, 0x17, 0x27,
	0xD6, 0xBC, 0x5B, 0x52, 0xB3, 0x65, 0x44, 0xD2,
	0xB1, 0x60, 0x7A, 0xB8, 0x08, 0xC2, 0x31, 0x95,
	0x9A, 0x2B, 0x4D, 0xEE, 0x85, 0x58, 0x6F, 0x1F,
	0x3A, 0x2F, 0xEC, 0x18, 0x91, 0xBC, 0x14, 0x6A,
	0x4A, 0xDB, 0xAC, 0x18, 0x50, 0x9C, 0x86, 0xE9,
	0x9D, 0x5F, 0x23, 0xE2, 0x87, 0x5A, 0x72, 0x4E,
	0xB7, 0x41, 0x79, 0xD2, 0x18, 0x2C, 0xBD, 0x38,
	0xD9, 0x91, 0xED, 0xF6, 0xFF, 0x75, 0xED, 0x28,
	0x58, 0xB2, 0xDD, 0x65, 0x49, 0xC1, 0xBB, 0x89,
	0x90, 0xB9, 0x73, 0x23, 0xE4, 0xE8, 0x91, 0x7B,
	0x90, 0xFF, 0xE5, 0x6C, 0x60, 0x1C, 0xEE, 0xEB,
	0xBA, 0xC9, 0xF2, 0xCE, 0x9E, 0xDF, 0xA5, 0x8A,
	0xCE, 0x18, 0x41, 0xEB, 0x22, 0x56, 0x8C, 0xDE,
	0xFC, 0x79, 0x8A, 0x00, 0x7F, 0x77, 0x53, 0x44,
	0xD4, 0xF1, 0x60, 0xCF, 0xD1, 0xB9, 0x8B, 0x66,
	0x2B, 0x1F, 0xD4, 0x6B, 0x33, 0x96, 0xCA, 0xCA,
	0x5D, 0x2C, 0xAB, 0x8D, 0xF1, 0xD4, 0x2D, 0xE0,
	0xA9, 0xAA, 0x0B, 0x69, 0xBA, 0x0D, 0x4F, 0x0E,
	0xD0, 0x3A, 0x70, 0x15, 0x5E, 0x00, 0xBB, 0xF9,
	0x68, 0xFF, 0x54, 0x0B, 0xFB, 0x2B, 0x80, 0x09,
	0x65, 0x91, 0xDA, 0x56, 0x98, 0x51, 0x54, 0x9A,
	0x48, 0x9D, 0x68, 0xD7, 0x7A, 0x74, 0xC6, 0x27,
	0x86, 0x84, 0x1F, 0xB6, 0xA2, 0x0B, 0x95, 0x36,
	0xB9, 0x44, 0x03, 0x98, 0xB9, 0x5A, 0x29, 0x23,
	0x9A, 0x2A, 0xFD, 0x76, 0x21, 0x32, 0x99, 0xDC,
	0x39, 0x49, 0xA2, 0x1E, 0x89, 0x22, 0xF0, 0xA1,
	0x19, 0x05, 0xE2, 0x0B, 0x8F, 0x92, 0x55, 0x25,
	0x58, 0x07, 0x65, 0xA1, 0x13, 0xF1, 0x41, 0x8B,
	0x31, 0xE9, 0xCD, 0x16, 0xC0, 0x99, 0x78, 0xCC,
	0xF9, 0x39, 0x95, 0x1A, 0xA2, 0xB9, 0x6D, 0x75,
	0x68, 0x4A, 0xBB, 0x9D, 0x03, 0x0A, 0x46, 0x81,
	0x4F, 0x53, 0x64, 0x49, 0x23, 0xEA, 0x79, 0xF7,
};

/* Pre-computed montgomery value M_PRIME,
 * this depends on the modulus value
 */
static uint8_t R3072_mont_m_prime[] = {
	0x7C, 0x70, 0x02, 0x1D, 0xD7, 0x5C, 0x14, 0x22,
	0xBB, 0x8A, 0x3C, 0x7B, 0x35, 0x4A, 0x9D, 0x2A,
	0xBD, 0xF8, 0x1C, 0x14, 0xC3, 0x77, 0xE0, 0xCC,
	0xB3, 0xAE, 0x5D, 0x4A, 0xF8, 0x5D, 0x47, 0x89,
	0xEF, 0x06, 0x9F, 0x80, 0xC7, 0x9D, 0x1B, 0x20,
	0xDD, 0x4C, 0xB1, 0x17, 0x51, 0xEA, 0x57, 0xEE,
	0x0D, 0xCC, 0xF5, 0x85, 0xE6, 0xBA, 0x5D, 0x48,
	0x50, 0xA7, 0x91, 0xD4, 0xAA, 0x51, 0x10, 0xEC,
	0xF4, 0xE7, 0x9B, 0xBB, 0x57, 0x2B, 0x7C, 0xA5,
	0x30, 0x0C, 0xF1, 0xE3, 0xAC, 0xB4, 0x9B, 0x65,
	0x2C, 0x9C, 0xAB, 0x0F, 0xE9, 0xBA, 0x0D, 0x43,
	0x1D, 0xDE, 0xB7, 0x7D, 0x3D, 0x57, 0x0A, 0x4C,
	0xEE, 0xD2, 0x0B, 0x17, 0x6F, 0x7A, 0xE1, 0x00,
	0x1A, 0x38, 0x1C, 0xB1, 0x6C, 0x97, 0xC4, 0xDA,
	0xCD, 0x51, 0x9D, 0x1C, 0x46, 0x0A, 0x51, 0x67,
	0xC3, 0xAA, 0xFF, 0xF6, 0xC1, 0x34, 0x22, 0x17,
	0xF1, 0x53, 0x62, 0x87, 0xB1, 0x63, 0xFC, 0x5A,
	0x5E, 0x50, 0x22, 0x2F, 0x4D, 0x2A, 0x79, 0x7A,
	0x0F, 0xBB, 0xF7, 0xBD, 0xF7, 0xF0, 0x63, 0xD8,
	0x8A, 0x60, 0xCC, 0xA1, 0xCB, 0x8C, 0x9E, 0x36,
	0x2B, 0x8E, 0x72, 0xCB, 0xE4, 0xB1, 0x79, 0x84,
	0x36, 0xA2, 0x19, 0x09, 0x4D, 0x85, 0xCE, 0xB4,
	0xD8, 0xA0, 0xC9, 0x78, 0x3A, 0x3E, 0xA5, 0xB2,
	0x27, 0x4E, 0x34, 0xB3, 0x9C, 0x4F, 0xBA, 0x24,
	0xDB, 0x1C, 0x48, 0xCE, 0xDC, 0x01, 0x0D, 0x95,
	0xFE, 0xBA, 0x3A, 0xD5, 0xAD, 0xFD, 0xB7, 0x6C,
	0x9D, 0xA4, 0x6C, 0xE8, 0x01, 0x55, 0x5F, 0xB1,
	0x34, 0xFD, 0x31, 0xFC, 0x31, 0x55, 0xEC, 0x6F,
	0xF9, 0x2B, 0xD2, 0x12, 0x0A, 0xBC, 0x3A, 0x61,
	0x7D, 0x84, 0x88, 0x9E, 0xBB, 0xD4, 0x1D, 0x77,
	0xE0, 0xBE, 0x48, 0x06, 0x2E, 0x5F, 0xC3, 0xB6,
	0x7E, 0x15, 0xFB, 0x8A, 0x39, 0xD8, 0x36, 0x76,
	0x02, 0xB5, 0x84, 0xDA, 0xAD, 0xAD, 0x29, 0xD1,
	0x89, 0x37, 0x22, 0x29, 0x2D, 0x2B, 0x59, 0xD4,
	0x12, 0xC8, 0x7B, 0x2E, 0x4E, 0x3E, 0x1A, 0x9D,
	0x20, 0xF2, 0xAB, 0xC4, 0xBC, 0xDC, 0x87, 0x7D,
	0x2B, 0x87, 0x06, 0x97, 0x65, 0x79, 0x9A, 0xA3,
	0x71, 0xD0, 0x2C, 0x38, 0xEE, 0x08, 0x8B, 0x91,
	0x97, 0x71, 0x54, 0x49, 0x7D, 0xDF, 0x79, 0xB3,
	0x00, 0x27, 0x08, 0xA2, 0xC3, 0x96, 0x81, 0xF4,
	0x0C, 0xDD, 0x74, 0xBF, 0x6A, 0x32, 0xEF, 0xDA,
	0xB6, 0x1F, 0x8F, 0x03, 0x31, 0x57, 0x51, 0x57,
	0xCF, 0xC9, 0x08, 0xF7, 0x97, 0x30, 0x39, 0x52,
	0x31, 0x32, 0x8F, 0xB8, 0x05, 0x60, 0xF8, 0x06,
	0x9F, 0x37, 0xE7, 0x72, 0xF1, 0xC1, 0x2B, 0xB7,
	0x58, 0x29, 0xEA, 0x5C, 0x41, 0x3B, 0x69, 0x0C,
	0xCA, 0x81, 0x5E, 0x52, 0xF9, 0x1A, 0x22, 0x63,
	0x33, 0x0B, 0x20, 0xFD, 0x47, 0x15, 0xE8, 0x39
};

/* Pre-computed montgomery value R_SQR,
 * this depends on the modulus value
 */
static uint8_t R3072_mont_r_sqr[] = {
	0xA5, 0x53, 0x16, 0x97, 0xDE, 0xB9, 0x63, 0xFB,
	0x78, 0xA4, 0x4B, 0xAC, 0x26, 0xC7, 0x28, 0xBC,
	0xDD, 0xA8, 0x78, 0x17, 0x0C, 0x5C, 0x58, 0x61,
	0x20, 0x64, 0x4F, 0x21, 0x8C, 0x94, 0xE9, 0x85,
	0x13, 0x52, 0xBB, 0x59, 0x94, 0x2C, 0x26, 0x4A,
	0x36, 0xED, 0xCC, 0xCD, 0x76, 0xB9, 0xCA, 0xED,
	0xE7, 0xD7, 0xE3, 0x0A, 0x76, 0x2C, 0xA0, 0x1E,
	0xBD, 0x6F, 0xDA, 0x23, 0xD1, 0x31, 0x30, 0x2B,
	0xE8, 0x38, 0xBE, 0xB6, 0xB2, 0x97, 0xBB, 0x54,
	0xC6, 0xA4, 0x21, 0xEE, 0xF9, 0x3F, 0x0B, 0xB2,
	0xDE, 0x1C, 0x53, 0x66, 0x1E, 0xFB, 0x9B, 0x5C,
	0xBB, 0x0C, 0xF4, 0xBC, 0x64, 0x15, 0x2E, 0xDC,
	0x51, 0xE3, 0x9B, 0xFF, 0xCB, 0x43, 0xCB, 0xA5,
	0x4D, 0x47, 0xC4, 0x7A, 0xEC, 0x91, 0x1C, 0x57,
	0x2F, 0xFB, 0x03, 0xB7, 0x3B, 0x64, 0x24, 0xA6,
	0xFE, 0xB0, 0x80, 0xD4, 0xDD, 0x95, 0x01, 0x1D,
	0xA1, 0x41, 0xC3, 0xCA, 0x12, 0x06, 0xAD, 0x0B,
	0x5B, 0x74, 0xD8, 0x26, 0x66, 0xDD, 0x02, 0xAB,
	0x3D, 0x1C, 0xB0, 0xA1, 0x13, 0xA4, 0xB6, 0x72,
	0x35, 0xF5, 0x99, 0x68, 0xB2, 0x63, 0x4E, 0xAB,
	0xE5, 0x83, 0x93, 0xC2, 0x62, 0x8B, 0xAB, 0x9E,
	0x1F, 0xDF, 0xA2, 0xF5, 0x44, 0x04, 0xF5, 0x48,
	0xC5, 0xB3, 0xBD, 0xF1, 0x6D, 0x7B, 0x57, 0xCC,
	0x62, 0x9E, 0x21, 0x22, 0x35, 0x56, 0x41, 0xFD,
	0x3C, 0xC3, 0x1B, 0xB2, 0xA1, 0x1A, 0x50, 0xB1,
	0xD6, 0xA7, 0x8F, 0xD0, 0x26, 0x89, 0xD8, 0xC2,
	0x71, 0xFE, 0xE2, 0xA1, 0xE2, 0x76, 0xEB, 0xE6,
	0x95, 0x68, 0x27, 0x36, 0x88, 0x13, 0xF3, 0xFC,
	0xC8, 0xD1, 0xD7, 0xB2, 0xCA, 0x5A, 0x22, 0x71,
	0xDF, 0x21, 0x72, 0x13, 0x27, 0x39, 0xAD, 0xB3,
	0xC7, 0x1A, 0x3C, 0x52, 0x4B, 0xC4, 0x6B, 0x92,
	0x21, 0x1F, 0x5E, 0x6B, 0xEE, 0x14, 0x1A, 0x9A,
	0xDF, 0x07, 0xB2, 0x1D, 0x2A, 0xF6, 0xB1, 0x13,
	0x77, 0x31, 0xA1, 0xB0, 0xAF, 0x11, 0xF5, 0xC2,
	0x05, 0x9C, 0x81, 0x35, 0xBE, 0x9B, 0x37, 0x88,
	0x3E, 0x6D, 0x17, 0x1F, 0x83, 0x90, 0xF6, 0x7F,
	0x99, 0xE2, 0xE5, 0x7C, 0x4F, 0x12, 0x50, 0xF5,
	0x8D, 0x48, 0xF2, 0x80, 0x80, 0x54, 0xA8, 0xA6,
	0xDF, 0xDE, 0x01, 0x4F, 0x1A, 0x53, 0xAE, 0x11,
	0xEB, 0x09, 0x88, 0x61, 0xF8, 0xFE, 0xBF, 0xEF,
	0x87, 0xDB, 0xEB, 0xBB, 0xA9, 0x4A, 0xBC, 0xFA,
	0x7B, 0x22, 0xD4, 0x5A, 0x5A, 0xB2, 0xCF, 0x72,
	0xF8, 0xC7, 0x0D, 0x84, 0x64, 0x0C, 0x9F, 0x0C,
	0x39, 0x1B, 0x7A, 0xDB, 0x77, 0xD1, 0xA6, 0x48,
	0xFD, 0xF0, 0x85, 0x09, 0xCB, 0x41, 0x13, 0x91,
	0x5B, 0x3B, 0x6A, 0x6E, 0xF2, 0x4F, 0xD1, 0x4D,
	0x58, 0x45, 0x7E, 0x92, 0x39, 0xCB, 0x55, 0xBF,
	0x1E, 0xCC, 0x2A, 0x4D, 0x8C, 0x22, 0x67, 0x06
};

/* Pre-load the RSA public key and the matching montgomery constants to
 * PKA1 keyslot and perform a RSA signature validation with the loaded
 * values.
 */
__STATIC__ status_t TEST_rsa3072_pss_verify_sha256_saltlen_oob_mont(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4
	};

	static uint8_t sig_saltlen[] = {
		0xa1, 0x94, 0xdf, 0x69, 0xc0, 0x62, 0x02, 0x9e, 0x8b, 0x19, 0x75, 0x29, 0x64, 0x84, 0xc9, 0xdd,
		0xcb, 0x38, 0xb7, 0xb1, 0x69, 0x39, 0x03, 0x82, 0xce, 0xfe, 0xa2, 0x5e, 0x46, 0x69, 0xb5, 0xe0,
		0x06, 0x5e, 0x14, 0xda, 0xc4, 0x33, 0xf9, 0x80, 0x50, 0xce, 0xc0, 0x03, 0xc8, 0x2c, 0x51, 0x20,
		0xec, 0x99, 0x87, 0x42, 0xb7, 0xea, 0x0f, 0x4f, 0x3b, 0x15, 0x79, 0xa2, 0x39, 0x79, 0x21, 0xe5,
		0xef, 0x4b, 0x1d, 0xc5, 0x3d, 0x57, 0x9d, 0x4d, 0x54, 0x05, 0x66, 0xf8, 0x94, 0x39, 0x65, 0xfa,
		0xfc, 0xc8, 0x08, 0x31, 0x45, 0xcf, 0x82, 0xe8, 0x04, 0xf1, 0x9a, 0xb4, 0x01, 0x37, 0x7b, 0x0d,
		0x00, 0xcc, 0xeb, 0x80, 0x62, 0x90, 0x11, 0x6d, 0x70, 0x27, 0x54, 0x4b, 0xae, 0x06, 0xc2, 0xb1,
		0xf4, 0xd0, 0x57, 0xc9, 0xc5, 0xb3, 0xf8, 0x8e, 0x17, 0x5c, 0x56, 0x6f, 0x08, 0x8c, 0xe2, 0x84,
		0xa3, 0x03, 0xec, 0x26, 0xdc, 0x6a, 0x35, 0x8e, 0x42, 0x2a, 0x9d, 0xe8, 0xf2, 0xfd, 0xb8, 0x66,
		0x7e, 0x41, 0x57, 0xaf, 0x41, 0xb9, 0x12, 0x29, 0x9f, 0x1f, 0x80, 0xd6, 0xee, 0xc8, 0xb6, 0x9c,
		0x75, 0x74, 0x14, 0xf5, 0x99, 0x4f, 0xed, 0xc1, 0x51, 0x6b, 0x6d, 0x50, 0xa9, 0x3d, 0x99, 0xe5,
		0x4c, 0xec, 0x4a, 0x0c, 0xdd, 0x09, 0xe7, 0x89, 0x57, 0xfc, 0x92, 0x68, 0x15, 0x80, 0xcd, 0xb1,
		0x8e, 0x6e, 0x6a, 0x57, 0x97, 0x75, 0x79, 0x60, 0x6d, 0xf1, 0x73, 0x1a, 0x0b, 0x7a, 0x67, 0x5c,
		0x67, 0x6c, 0x0b, 0x11, 0xe9, 0xc1, 0x31, 0x17, 0x33, 0x61, 0x7f, 0x96, 0x7b, 0x42, 0x9f, 0x4b,
		0xeb, 0x75, 0xf4, 0x1a, 0xe3, 0xdc, 0x30, 0x28, 0xa4, 0x68, 0xea, 0x61, 0x12, 0x17, 0x16, 0xf5,
		0x69, 0xd4, 0x29, 0xf9, 0x52, 0x7b, 0x9b, 0x08, 0xd3, 0xc8, 0x1f, 0x55, 0x2e, 0xc6, 0x53, 0xba,
		0xe4, 0xd3, 0x00, 0x44, 0xaf, 0x3f, 0x55, 0x4d, 0xdf, 0xd8, 0x27, 0x35, 0xb4, 0x82, 0xd4, 0xf2,
		0x17, 0x4e, 0x37, 0xf0, 0x74, 0x29, 0xa1, 0x56, 0x40, 0x16, 0xd9, 0x20, 0x84, 0x49, 0xc4, 0x1a,
		0x9c, 0x45, 0xab, 0x7f, 0x75, 0x8e, 0x0a, 0x97, 0x70, 0x7a, 0x19, 0x49, 0x0a, 0x5f, 0xbb, 0x66,
		0x43, 0xa8, 0xd1, 0x0f, 0xcc, 0x5c, 0x9f, 0x91, 0x92, 0xb4, 0xe7, 0xf1, 0xbd, 0x62, 0x26, 0x62,
		0x2c, 0xf6, 0xcf, 0x42, 0xf7, 0xe0, 0x54, 0xb2, 0x45, 0xc6, 0x7c, 0x64, 0xd1, 0xf1, 0xd0, 0x57,
		0x6b, 0x91, 0x21, 0x8e, 0x4f, 0xaf, 0x84, 0x5f, 0x0d, 0x58, 0x0d, 0x66, 0xc5, 0x71, 0xcc, 0xf2,
		0x46, 0x3f, 0x4b, 0xfe, 0x32, 0x27, 0x71, 0xb2, 0x4f, 0x14, 0x07, 0x40, 0x13, 0x5a, 0x61, 0x8b,
		0x4c, 0xab, 0x67, 0x5f, 0x08, 0xd7, 0xfd, 0xfd, 0x9b, 0xfe, 0x8d, 0x8f, 0x5e, 0x89, 0x71, 0x03,
	};

	/* Since KEY_FLAG_LEAVE_KEY_IN_KEYSLOT is not set in k_flags =>
	 * the PKA1 RSA keyslot will get erased when the operation
	 * is done.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
#if HAVE_READ_PKA1_RSA_KEYSLOT_PUBKEY
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY | KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
#else
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY,
#endif
		.k_byte_size = RSA3072_BYTE_SIZE,
		.k_keyslot = 3U,
	};

	bool key_big_endian = true;

	/* SE RSA0 does not require montgomery values so testing with PKA1 */
	eid = CCC_ENGINE_PKA1_PKA;
	LOG_ALWAYS("Always using PKA1 RSA engine for pre-loading montgomery values test case\n");

	algo = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256;
	LOG_ALWAYS("Test uses fixed key to perform RSA3072 RSA-PSS sig verify with SHA256 digest\n");

	/* Store the RSA pubkey and montgomery values matching that modulus
	 * to the PKA1 keyslot.
	 */
	ret = se_set_device_rsa_keyslot_montgomery(SE_CDEV_PKA1, akey.k_keyslot,
						   sizeof_u32(R3072_pub_exponent), akey.k_byte_size,
						   R3072_pub_exponent, R3072_modulus,
						   key_big_endian, R3072_mont_m_prime,
						   R3072_mont_r_sqr);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to set up PKA1 keyslot with montgomery values\n"));

	/* Then perform the operation as usual, but use the existing key from
	 * PKA1 keyslot #3
	 */
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, algo);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) src %p\n",
		 algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: INVALID\n");
	}

	return ret;
}

#endif /* TEST_PKA1_RSA_KSLOT */

#if HAVE_SHA1
__STATIC__ status_t TEST_rsa_pss_verify_sha1_keyslot(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint32_t keyslot = 3U;

	char data[10] = "HelloWorld";
	(void)data;

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// This is a RSA-PSS signature, created with cmd:
	// echo -n "HelloWorld" |
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sign pss-privkey.p8 -out HelloWorld.sig
	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	static uint8_t sig[] = {
		0x53,0x3a,0xb9,0x5b,0x14,0x4c,0x04,0x7c,
		0x1c,0x92,0x20,0x35,0xbc,0x6e,0x2c,0x13,
		0xc3,0x5b,0xf9,0xd3,0x35,0xa4,0x7f,0x6f,
		0xb0,0x75,0x16,0xa1,0xbf,0xdd,0x5b,0x0d,
		0x40,0x5d,0x7e,0xce,0xa9,0x2e,0x9e,0xc9,
		0xa2,0x5b,0x53,0x5a,0xe9,0x05,0x0a,0x28,
		0x4e,0x0e,0xf0,0xd5,0xa5,0x57,0x38,0x94,
		0x88,0xb3,0x0a,0x13,0xb8,0x39,0xdd,0x09,
		0xa6,0xad,0x4a,0xe3,0x29,0xff,0x6d,0x17,
		0x60,0x7f,0xba,0xd9,0xc3,0x02,0x68,0xf6,
		0x57,0xf2,0x69,0xb5,0x08,0x9d,0x6d,0xfd,
		0x69,0xfd,0x8c,0xfa,0x0a,0x97,0x3b,0xe0,
		0xef,0x99,0x82,0x19,0x56,0x49,0x99,0xc7,
		0x13,0x69,0x40,0x10,0xa8,0x7a,0x7e,0x64,
		0x26,0x5d,0xeb,0x78,0xcb,0x5d,0xe2,0x61,
		0x4f,0x8d,0x05,0xae,0x90,0x01,0x66,0xa6,
		0x2e,0x93,0xec,0xfd,0x3f,0x0b,0xe1,0x10,
		0xb5,0xed,0x38,0xfe,0x1f,0x7a,0x46,0xe7,
		0x5c,0x8a,0x9b,0x86,0x02,0x50,0xbf,0xdb,
		0x5f,0x66,0x9e,0x4e,0xe2,0x47,0x8c,0x6b,
		0x25,0x6d,0x50,0xcd,0xe3,0xa3,0x85,0xe7,
		0xc2,0x3f,0x77,0x43,0x78,0xfe,0x76,0x4e,
		0xb3,0x6c,0x13,0x90,0x34,0x67,0xd0,0x0e,
		0xf2,0xa1,0x64,0x2a,0xce,0xec,0x7f,0x56,
		0xee,0x6f,0xe2,0x8f,0x3d,0xac,0x8e,0xe6,
		0xee,0xf3,0xb9,0x81,0x5b,0x6e,0x8b,0x20,
		0xf6,0x1e,0xd8,0x61,0x1f,0x6d,0xee,0x7b,
		0x72,0x88,0x37,0x3a,0x93,0x4c,0x54,0x6d,
		0x67,0x9c,0xf4,0x7c,0xb7,0x68,0xb6,0x48,
		0xff,0x30,0xdf,0x64,0xf2,0x22,0x0e,0x73,
		0x28,0xa8,0x8d,0xe3,0xcb,0xd0,0x99,0x9d,
		0xde,0xeb,0x98,0xcd,0xd7,0x8a,0x63,0x37,
	};

	/* Default for rsa key and data is BIG ENDIAN
	 * Use pre-loaded keyslot key, erase kslot when done
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY,
		.k_byte_size = RSA2048_BYTE_SIZE,
		// .k_keyslot = keyslot,
	};

	uint8_t pub_exponent[4] = { 0x00, 0x01, 0x00, 0x01 };
	uint8_t modulus[256] = {
		0xa5,0xd0,0xd7,0x3e,0x0e,0x2d,0xfb,0x43,
		0x51,0x99,0xea,0x40,0x1e,0x2d,0x89,0xe4,
		0xa2,0x3e,0xfc,0x51,0x3d,0x0e,0x83,0xa7,
		0xe0,0xa5,0x41,0x04,0x1e,0x14,0xc5,0xa7,
		0x5c,0x61,0x36,0x44,0xb3,0x08,0x05,0x5b,
		0x14,0xde,0x01,0x0c,0x32,0x3c,0x9a,0x91,
		0x00,0x50,0xa8,0x1d,0xcc,0x9f,0x8f,0x35,
		0xb7,0xc2,0x75,0x08,0x32,0x8b,0x10,0x3a,
		0x86,0xf9,0xd7,0x78,0xa3,0x9d,0x74,0x10,
		0xc6,0x24,0xb1,0x7f,0xa5,0xbf,0x5f,0xc2,
		0xd7,0x15,0xa3,0x1d,0xe0,0x15,0x6b,0x1b,
		0x0e,0x38,0xba,0x34,0xbc,0x95,0x47,0x94,
		0x40,0x70,0xac,0x99,0x1f,0x0b,0x8e,0x56,
		0x93,0x36,0x2b,0x6d,0x04,0xe7,0x95,0x1a,
		0x37,0xda,0x16,0x57,0x99,0xee,0x03,0x68,
		0x16,0x31,0xaa,0xc3,0xb7,0x92,0x75,0x53,
		0xfc,0xf6,0x20,0x55,0x44,0xf8,0xd4,0x8d,
		0x78,0x15,0xc7,0x1a,0xb6,0xde,0x6c,0xe8,
		0x49,0x5d,0xaf,0xa8,0x4e,0x6f,0x7c,0xe2,
		0x6a,0x4c,0xd5,0xe7,0x8c,0x8f,0x0b,0x5d,
		0x3a,0x09,0xd6,0xb3,0x44,0xab,0xe0,0x35,
		0x52,0x7c,0x66,0x85,0xa4,0x40,0xd7,0x20,
		0xec,0x24,0x05,0x06,0xd9,0x84,0x51,0x5a,
		0xd2,0x38,0xd5,0x1d,0xea,0x70,0x2a,0x21,
		0xe6,0x82,0xfd,0xa4,0x46,0x1c,0x4f,0x59,
		0x6e,0x29,0x3d,0xae,0xb8,0x8e,0xee,0x77,
		0x1f,0x15,0x33,0xcf,0x94,0x1d,0x87,0x3c,
		0x37,0xc5,0x89,0xe8,0x7d,0x85,0xb3,0xbc,
		0xe8,0x62,0x6a,0x84,0x7f,0xfe,0x9a,0x85,
		0x3f,0x39,0xe8,0xaa,0x16,0xa6,0x8f,0x87,
		0x7f,0xcb,0xc1,0xd6,0xf2,0xec,0x2b,0xa7,
		0xdd,0x49,0x98,0x7b,0x6f,0xdd,0x69,0x6d
	};

	(void)algo;

	{
		/* Set PKA1 RSA BE keyslot value.. First clear the keyslot
		 * (no real reason, just a demo) and then write the keyslot
		 */
		bool key_is_big_endian = true;
		se_cdev_id_t dev_id;
		const engine_t *engine = NULL;

		/* In case the EID hinted RSA engine is not enabled we
		 * can not run the test with it.  So check if it is
		 * enabled, if not use an enabled engine.  If no such
		 * => fail test.
		 */
		ret = ccc_select_engine(&engine, CCC_ENGINE_CLASS_RSA, eid);
		CCC_ERROR_CHECK(ret);

		if (eid != engine->e_id) {
			LOG_ALWAYS("Suggested engine %s not enabled, setting keys to %s\n",
				   eid_name(eid), eid_name(engine->e_id));

			/* eid = engine->e_id;
			 *
			 * Setting the above would make sense, but do not do this for testing purposes
			 * so we set the keys to the device which should be used by the operation
			 * when the hinted engine does not exist in the system.
			 */
		}

		switch (engine->e_id) {
		case CCC_ENGINE_ANY:
		case CCC_ENGINE_SE0_PKA0:
			dev_id = SE_CDEV_SE0;
			break;

#if HAVE_SE1
		case CCC_ENGINE_SE1_PKA0:
			dev_id = SE_CDEV_SE1;
			break;
#endif

		case CCC_ENGINE_PKA1_PKA:
			dev_id = SE_CDEV_PKA1;
			break;

		default:
			ret = SE_ERROR(ERR_ILWALID_ARGS);
			break;
		}
		CCC_ERROR_CHECK(ret);

		ret = se_clear_device_rsa_keyslot(dev_id, keyslot);
		LOG_ALWAYS("Cleared (ret=%d) DEV %u keyslot %u before setting it\n", ret, dev_id, keyslot);
		CCC_ERROR_CHECK(ret,
				LOG_ERROR("Failed to write dev %u RSA  keyslot value\n", dev_id));

		ret = se_set_device_rsa_keyslot(dev_id, keyslot,
						sizeof_u32(pub_exponent), sizeof_u32(modulus),
						pub_exponent, modulus,
						key_is_big_endian);
		CCC_ERROR_CHECK(ret,
				LOG_ERROR("Failed to write dev %u RSA  keyslot value\n", dev_id));

		LOG_ALWAYS("Set (ret=%d) dev %u keyslot %u; now attempt using it\n", ret, dev_id, keyslot);
	}

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// No init flags passed (e.g. RSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init rsa flags.
	// Also the input can be passed through a MD function (same as MGF1 digest)
	// by setting a flag. By default, input is treated as a digest to be handled

	/* Set used keyslot here */
	akey.k_keyslot = keyslot;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig);
	arg.ca_data.src_signature = sig;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p data\n",
		   algo, data);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("RSA PSS signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR != ret) {
		LOG_INFO("RSA PSS signature check: failed\n");
	}
	return ret;
}
#endif /* HAVE_SHA1 */

__STATIC__ status_t TEST_rsa3072_pss_verify_sha256_saltlen(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF
	//
	// openssl sign =>
	//  echo -n "HelloWorld" | openssl dgst -sha256 -sigopt rsa_padding_mode:pss
	//    -sign rsa3072-privkey.pem -out HelloWorld-3072.sig
	//
	// openssl verify =>
	//  echo -n "HelloWorld" | openssl dgst -sha256 -sigopt rsa_padding_mode:pss
	//    -verify rsa3072-pubkey.pem -signature HelloWorld-3072.sig
	//
	// SHA-256 digest of data
	uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4
	};

	static uint8_t sig_saltlen[] = {
		0xa1, 0x94, 0xdf, 0x69, 0xc0, 0x62, 0x02, 0x9e, 0x8b, 0x19, 0x75, 0x29, 0x64, 0x84, 0xc9, 0xdd,
		0xcb, 0x38, 0xb7, 0xb1, 0x69, 0x39, 0x03, 0x82, 0xce, 0xfe, 0xa2, 0x5e, 0x46, 0x69, 0xb5, 0xe0,
		0x06, 0x5e, 0x14, 0xda, 0xc4, 0x33, 0xf9, 0x80, 0x50, 0xce, 0xc0, 0x03, 0xc8, 0x2c, 0x51, 0x20,
		0xec, 0x99, 0x87, 0x42, 0xb7, 0xea, 0x0f, 0x4f, 0x3b, 0x15, 0x79, 0xa2, 0x39, 0x79, 0x21, 0xe5,
		0xef, 0x4b, 0x1d, 0xc5, 0x3d, 0x57, 0x9d, 0x4d, 0x54, 0x05, 0x66, 0xf8, 0x94, 0x39, 0x65, 0xfa,
		0xfc, 0xc8, 0x08, 0x31, 0x45, 0xcf, 0x82, 0xe8, 0x04, 0xf1, 0x9a, 0xb4, 0x01, 0x37, 0x7b, 0x0d,
		0x00, 0xcc, 0xeb, 0x80, 0x62, 0x90, 0x11, 0x6d, 0x70, 0x27, 0x54, 0x4b, 0xae, 0x06, 0xc2, 0xb1,
		0xf4, 0xd0, 0x57, 0xc9, 0xc5, 0xb3, 0xf8, 0x8e, 0x17, 0x5c, 0x56, 0x6f, 0x08, 0x8c, 0xe2, 0x84,
		0xa3, 0x03, 0xec, 0x26, 0xdc, 0x6a, 0x35, 0x8e, 0x42, 0x2a, 0x9d, 0xe8, 0xf2, 0xfd, 0xb8, 0x66,
		0x7e, 0x41, 0x57, 0xaf, 0x41, 0xb9, 0x12, 0x29, 0x9f, 0x1f, 0x80, 0xd6, 0xee, 0xc8, 0xb6, 0x9c,
		0x75, 0x74, 0x14, 0xf5, 0x99, 0x4f, 0xed, 0xc1, 0x51, 0x6b, 0x6d, 0x50, 0xa9, 0x3d, 0x99, 0xe5,
		0x4c, 0xec, 0x4a, 0x0c, 0xdd, 0x09, 0xe7, 0x89, 0x57, 0xfc, 0x92, 0x68, 0x15, 0x80, 0xcd, 0xb1,
		0x8e, 0x6e, 0x6a, 0x57, 0x97, 0x75, 0x79, 0x60, 0x6d, 0xf1, 0x73, 0x1a, 0x0b, 0x7a, 0x67, 0x5c,
		0x67, 0x6c, 0x0b, 0x11, 0xe9, 0xc1, 0x31, 0x17, 0x33, 0x61, 0x7f, 0x96, 0x7b, 0x42, 0x9f, 0x4b,
		0xeb, 0x75, 0xf4, 0x1a, 0xe3, 0xdc, 0x30, 0x28, 0xa4, 0x68, 0xea, 0x61, 0x12, 0x17, 0x16, 0xf5,
		0x69, 0xd4, 0x29, 0xf9, 0x52, 0x7b, 0x9b, 0x08, 0xd3, 0xc8, 0x1f, 0x55, 0x2e, 0xc6, 0x53, 0xba,
		0xe4, 0xd3, 0x00, 0x44, 0xaf, 0x3f, 0x55, 0x4d, 0xdf, 0xd8, 0x27, 0x35, 0xb4, 0x82, 0xd4, 0xf2,
		0x17, 0x4e, 0x37, 0xf0, 0x74, 0x29, 0xa1, 0x56, 0x40, 0x16, 0xd9, 0x20, 0x84, 0x49, 0xc4, 0x1a,
		0x9c, 0x45, 0xab, 0x7f, 0x75, 0x8e, 0x0a, 0x97, 0x70, 0x7a, 0x19, 0x49, 0x0a, 0x5f, 0xbb, 0x66,
		0x43, 0xa8, 0xd1, 0x0f, 0xcc, 0x5c, 0x9f, 0x91, 0x92, 0xb4, 0xe7, 0xf1, 0xbd, 0x62, 0x26, 0x62,
		0x2c, 0xf6, 0xcf, 0x42, 0xf7, 0xe0, 0x54, 0xb2, 0x45, 0xc6, 0x7c, 0x64, 0xd1, 0xf1, 0xd0, 0x57,
		0x6b, 0x91, 0x21, 0x8e, 0x4f, 0xaf, 0x84, 0x5f, 0x0d, 0x58, 0x0d, 0x66, 0xc5, 0x71, 0xcc, 0xf2,
		0x46, 0x3f, 0x4b, 0xfe, 0x32, 0x27, 0x71, 0xb2, 0x4f, 0x14, 0x07, 0x40, 0x13, 0x5a, 0x61, 0x8b,
		0x4c, 0xab, 0x67, 0x5f, 0x08, 0xd7, 0xfd, 0xfd, 0x9b, 0xfe, 0x8d, 0x8f, 0x5e, 0x89, 0x71, 0x03,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA3072_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise)
			       //
			       // RSA 3072 bit modulus (file: test-keys/rsa3072-privkey.pem)
			       {
				       0xCD, 0x8E, 0xD6, 0x88, 0x82, 0x86, 0xC7, 0x95,
				       0xC6, 0x4D, 0x58, 0x7F, 0x08, 0x96, 0xB2, 0xE0,
				       0x31, 0xC3, 0x11, 0x27, 0x23, 0x50, 0x8A, 0xD4,
				       0x55, 0x78, 0x3F, 0x95, 0x91, 0xF8, 0x6F, 0x77,
				       0x58, 0x89, 0xD3, 0xC1, 0xF5, 0xA6, 0xAE, 0x1A,
				       0xF1, 0x77, 0xE3, 0x10, 0x2D, 0xAD, 0xFC, 0x24,
				       0x16, 0x84, 0x1E, 0x86, 0xCA, 0xD3, 0x8C, 0x31,
				       0xD6, 0xA1, 0xCD, 0xE2, 0x78, 0xAE, 0xF7, 0x97,
				       0x05, 0x45, 0xCD, 0x5B, 0x31, 0x34, 0x02, 0x10,
				       0xCA, 0x93, 0xA5, 0x3C, 0x67, 0xBC, 0xED, 0xA8,
				       0xEA, 0x51, 0xDB, 0x2E, 0x69, 0xA3, 0xA0, 0x2A,
				       0xEA, 0x96, 0x8A, 0x4D, 0x46, 0x44, 0xD8, 0x21,
				       0x2C, 0x7D, 0x6E, 0x38, 0xB8, 0x70, 0xEE, 0x5F,
				       0x43, 0x8D, 0x5E, 0x27, 0x7D, 0xBF, 0x70, 0x1A,
				       0x72, 0xEE, 0xAE, 0xC4, 0x49, 0xB8, 0xF1, 0xB1,
				       0x8E, 0x54, 0x18, 0x24, 0x84, 0xA8, 0x17, 0x27,
				       0xD6, 0xBC, 0x5B, 0x52, 0xB3, 0x65, 0x44, 0xD2,
				       0xB1, 0x60, 0x7A, 0xB8, 0x08, 0xC2, 0x31, 0x95,
				       0x9A, 0x2B, 0x4D, 0xEE, 0x85, 0x58, 0x6F, 0x1F,
				       0x3A, 0x2F, 0xEC, 0x18, 0x91, 0xBC, 0x14, 0x6A,
				       0x4A, 0xDB, 0xAC, 0x18, 0x50, 0x9C, 0x86, 0xE9,
				       0x9D, 0x5F, 0x23, 0xE2, 0x87, 0x5A, 0x72, 0x4E,
				       0xB7, 0x41, 0x79, 0xD2, 0x18, 0x2C, 0xBD, 0x38,
				       0xD9, 0x91, 0xED, 0xF6, 0xFF, 0x75, 0xED, 0x28,
				       0x58, 0xB2, 0xDD, 0x65, 0x49, 0xC1, 0xBB, 0x89,
				       0x90, 0xB9, 0x73, 0x23, 0xE4, 0xE8, 0x91, 0x7B,
				       0x90, 0xFF, 0xE5, 0x6C, 0x60, 0x1C, 0xEE, 0xEB,
				       0xBA, 0xC9, 0xF2, 0xCE, 0x9E, 0xDF, 0xA5, 0x8A,
				       0xCE, 0x18, 0x41, 0xEB, 0x22, 0x56, 0x8C, 0xDE,
				       0xFC, 0x79, 0x8A, 0x00, 0x7F, 0x77, 0x53, 0x44,
				       0xD4, 0xF1, 0x60, 0xCF, 0xD1, 0xB9, 0x8B, 0x66,
				       0x2B, 0x1F, 0xD4, 0x6B, 0x33, 0x96, 0xCA, 0xCA,
				       0x5D, 0x2C, 0xAB, 0x8D, 0xF1, 0xD4, 0x2D, 0xE0,
				       0xA9, 0xAA, 0x0B, 0x69, 0xBA, 0x0D, 0x4F, 0x0E,
				       0xD0, 0x3A, 0x70, 0x15, 0x5E, 0x00, 0xBB, 0xF9,
				       0x68, 0xFF, 0x54, 0x0B, 0xFB, 0x2B, 0x80, 0x09,
				       0x65, 0x91, 0xDA, 0x56, 0x98, 0x51, 0x54, 0x9A,
				       0x48, 0x9D, 0x68, 0xD7, 0x7A, 0x74, 0xC6, 0x27,
				       0x86, 0x84, 0x1F, 0xB6, 0xA2, 0x0B, 0x95, 0x36,
				       0xB9, 0x44, 0x03, 0x98, 0xB9, 0x5A, 0x29, 0x23,
				       0x9A, 0x2A, 0xFD, 0x76, 0x21, 0x32, 0x99, 0xDC,
				       0x39, 0x49, 0xA2, 0x1E, 0x89, 0x22, 0xF0, 0xA1,
				       0x19, 0x05, 0xE2, 0x0B, 0x8F, 0x92, 0x55, 0x25,
				       0x58, 0x07, 0x65, 0xA1, 0x13, 0xF1, 0x41, 0x8B,
				       0x31, 0xE9, 0xCD, 0x16, 0xC0, 0x99, 0x78, 0xCC,
				       0xF9, 0x39, 0x95, 0x1A, 0xA2, 0xB9, 0x6D, 0x75,
				       0x68, 0x4A, 0xBB, 0x9D, 0x03, 0x0A, 0x46, 0x81,
				       0x4F, 0x53, 0x64, 0x49, 0x23, 0xEA, 0x79, 0xF7,
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) src %p\n",
		 algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: INVALID\n");
	}

	return ret;
}

/* RSA-3072 test with little endian keys and little endian signature
 */
__STATIC__ status_t TEST_le_rsa3072_pss_verify_sha256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF
	//
	// openssl sign =>
	//  echo -n "HelloWorld" | openssl dgst -sha256 -sigopt rsa_padding_mode:pss
	//    -sign rsa3072-privkey.pem -out HelloWorld-3072.sig
	//
	// openssl verify =>
	//  echo -n "HelloWorld" | openssl dgst -sha256 -sigopt rsa_padding_mode:pss
	//    -verify rsa3072-pubkey.pem -signature HelloWorld-3072.sig
	//
	// SHA-256 digest of data
	//
	/* DIGEST in BIG ENDIAN */
	uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4
	};

	/* SIGNATURE in LITTLE ENDIAN */
	static uint8_t sig_saltlen[] = {
    0x03, 0x71, 0x89, 0x5e, 0x8f, 0x8d, 0xfe, 0x9b,
    0xfd, 0xfd, 0xd7, 0x08, 0x5f, 0x67, 0xab, 0x4c,
    0x8b, 0x61, 0x5a, 0x13, 0x40, 0x07, 0x14, 0x4f,
    0xb2, 0x71, 0x27, 0x32, 0xfe, 0x4b, 0x3f, 0x46,
    0xf2, 0xcc, 0x71, 0xc5, 0x66, 0x0d, 0x58, 0x0d,
    0x5f, 0x84, 0xaf, 0x4f, 0x8e, 0x21, 0x91, 0x6b,
    0x57, 0xd0, 0xf1, 0xd1, 0x64, 0x7c, 0xc6, 0x45,
    0xb2, 0x54, 0xe0, 0xf7, 0x42, 0xcf, 0xf6, 0x2c,
    0x62, 0x26, 0x62, 0xbd, 0xf1, 0xe7, 0xb4, 0x92,
    0x91, 0x9f, 0x5c, 0xcc, 0x0f, 0xd1, 0xa8, 0x43,
    0x66, 0xbb, 0x5f, 0x0a, 0x49, 0x19, 0x7a, 0x70,
    0x97, 0x0a, 0x8e, 0x75, 0x7f, 0xab, 0x45, 0x9c,
    0x1a, 0xc4, 0x49, 0x84, 0x20, 0xd9, 0x16, 0x40,
    0x56, 0xa1, 0x29, 0x74, 0xf0, 0x37, 0x4e, 0x17,
    0xf2, 0xd4, 0x82, 0xb4, 0x35, 0x27, 0xd8, 0xdf,
    0x4d, 0x55, 0x3f, 0xaf, 0x44, 0x00, 0xd3, 0xe4,
    0xba, 0x53, 0xc6, 0x2e, 0x55, 0x1f, 0xc8, 0xd3,
    0x08, 0x9b, 0x7b, 0x52, 0xf9, 0x29, 0xd4, 0x69,
    0xf5, 0x16, 0x17, 0x12, 0x61, 0xea, 0x68, 0xa4,
    0x28, 0x30, 0xdc, 0xe3, 0x1a, 0xf4, 0x75, 0xeb,
    0x4b, 0x9f, 0x42, 0x7b, 0x96, 0x7f, 0x61, 0x33,
    0x17, 0x31, 0xc1, 0xe9, 0x11, 0x0b, 0x6c, 0x67,
    0x5c, 0x67, 0x7a, 0x0b, 0x1a, 0x73, 0xf1, 0x6d,
    0x60, 0x79, 0x75, 0x97, 0x57, 0x6a, 0x6e, 0x8e,
    0xb1, 0xcd, 0x80, 0x15, 0x68, 0x92, 0xfc, 0x57,
    0x89, 0xe7, 0x09, 0xdd, 0x0c, 0x4a, 0xec, 0x4c,
    0xe5, 0x99, 0x3d, 0xa9, 0x50, 0x6d, 0x6b, 0x51,
    0xc1, 0xed, 0x4f, 0x99, 0xf5, 0x14, 0x74, 0x75,
    0x9c, 0xb6, 0xc8, 0xee, 0xd6, 0x80, 0x1f, 0x9f,
    0x29, 0x12, 0xb9, 0x41, 0xaf, 0x57, 0x41, 0x7e,
    0x66, 0xb8, 0xfd, 0xf2, 0xe8, 0x9d, 0x2a, 0x42,
    0x8e, 0x35, 0x6a, 0xdc, 0x26, 0xec, 0x03, 0xa3,
    0x84, 0xe2, 0x8c, 0x08, 0x6f, 0x56, 0x5c, 0x17,
    0x8e, 0xf8, 0xb3, 0xc5, 0xc9, 0x57, 0xd0, 0xf4,
    0xb1, 0xc2, 0x06, 0xae, 0x4b, 0x54, 0x27, 0x70,
    0x6d, 0x11, 0x90, 0x62, 0x80, 0xeb, 0xcc, 0x00,
    0x0d, 0x7b, 0x37, 0x01, 0xb4, 0x9a, 0xf1, 0x04,
    0xe8, 0x82, 0xcf, 0x45, 0x31, 0x08, 0xc8, 0xfc,
    0xfa, 0x65, 0x39, 0x94, 0xf8, 0x66, 0x05, 0x54,
    0x4d, 0x9d, 0x57, 0x3d, 0xc5, 0x1d, 0x4b, 0xef,
    0xe5, 0x21, 0x79, 0x39, 0xa2, 0x79, 0x15, 0x3b,
    0x4f, 0x0f, 0xea, 0xb7, 0x42, 0x87, 0x99, 0xec,
    0x20, 0x51, 0x2c, 0xc8, 0x03, 0xc0, 0xce, 0x50,
    0x80, 0xf9, 0x33, 0xc4, 0xda, 0x14, 0x5e, 0x06,
    0xe0, 0xb5, 0x69, 0x46, 0x5e, 0xa2, 0xfe, 0xce,
    0x82, 0x03, 0x39, 0x69, 0xb1, 0xb7, 0x38, 0xcb,
    0xdd, 0xc9, 0x84, 0x64, 0x29, 0x75, 0x19, 0x8b,
    0x9e, 0x02, 0x62, 0xc0, 0x69, 0xdf, 0x94, 0xa1,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_byte_size = RSA3072_BYTE_SIZE,
		.k_keyslot = 3U,

		// EXPONENT and MODULUS in LITTLE ENDIAN
		.k_rsa_pub = { .pub_exponent = { 0x01, 0x00, 0x01, 0x00 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise)
			       //
			       // RSA 3072 bit modulus (file: test-keys/rsa3072-privkey.pem)
			       {
    0xf7, 0x79, 0xea, 0x23, 0x49, 0x64, 0x53, 0x4f,
    0x81, 0x46, 0x0a, 0x03, 0x9d, 0xbb, 0x4a, 0x68,
    0x75, 0x6d, 0xb9, 0xa2, 0x1a, 0x95, 0x39, 0xf9,
    0xcc, 0x78, 0x99, 0xc0, 0x16, 0xcd, 0xe9, 0x31,
    0x8b, 0x41, 0xf1, 0x13, 0xa1, 0x65, 0x07, 0x58,
    0x25, 0x55, 0x92, 0x8f, 0x0b, 0xe2, 0x05, 0x19,
    0xa1, 0xf0, 0x22, 0x89, 0x1e, 0xa2, 0x49, 0x39,
    0xdc, 0x99, 0x32, 0x21, 0x76, 0xfd, 0x2a, 0x9a,
    0x23, 0x29, 0x5a, 0xb9, 0x98, 0x03, 0x44, 0xb9,
    0x36, 0x95, 0x0b, 0xa2, 0xb6, 0x1f, 0x84, 0x86,
    0x27, 0xc6, 0x74, 0x7a, 0xd7, 0x68, 0x9d, 0x48,
    0x9a, 0x54, 0x51, 0x98, 0x56, 0xda, 0x91, 0x65,
    0x09, 0x80, 0x2b, 0xfb, 0x0b, 0x54, 0xff, 0x68,
    0xf9, 0xbb, 0x00, 0x5e, 0x15, 0x70, 0x3a, 0xd0,
    0x0e, 0x4f, 0x0d, 0xba, 0x69, 0x0b, 0xaa, 0xa9,
    0xe0, 0x2d, 0xd4, 0xf1, 0x8d, 0xab, 0x2c, 0x5d,
    0xca, 0xca, 0x96, 0x33, 0x6b, 0xd4, 0x1f, 0x2b,
    0x66, 0x8b, 0xb9, 0xd1, 0xcf, 0x60, 0xf1, 0xd4,
    0x44, 0x53, 0x77, 0x7f, 0x00, 0x8a, 0x79, 0xfc,
    0xde, 0x8c, 0x56, 0x22, 0xeb, 0x41, 0x18, 0xce,
    0x8a, 0xa5, 0xdf, 0x9e, 0xce, 0xf2, 0xc9, 0xba,
    0xeb, 0xee, 0x1c, 0x60, 0x6c, 0xe5, 0xff, 0x90,
    0x7b, 0x91, 0xe8, 0xe4, 0x23, 0x73, 0xb9, 0x90,
    0x89, 0xbb, 0xc1, 0x49, 0x65, 0xdd, 0xb2, 0x58,
    0x28, 0xed, 0x75, 0xff, 0xf6, 0xed, 0x91, 0xd9,
    0x38, 0xbd, 0x2c, 0x18, 0xd2, 0x79, 0x41, 0xb7,
    0x4e, 0x72, 0x5a, 0x87, 0xe2, 0x23, 0x5f, 0x9d,
    0xe9, 0x86, 0x9c, 0x50, 0x18, 0xac, 0xdb, 0x4a,
    0x6a, 0x14, 0xbc, 0x91, 0x18, 0xec, 0x2f, 0x3a,
    0x1f, 0x6f, 0x58, 0x85, 0xee, 0x4d, 0x2b, 0x9a,
    0x95, 0x31, 0xc2, 0x08, 0xb8, 0x7a, 0x60, 0xb1,
    0xd2, 0x44, 0x65, 0xb3, 0x52, 0x5b, 0xbc, 0xd6,
    0x27, 0x17, 0xa8, 0x84, 0x24, 0x18, 0x54, 0x8e,
    0xb1, 0xf1, 0xb8, 0x49, 0xc4, 0xae, 0xee, 0x72,
    0x1a, 0x70, 0xbf, 0x7d, 0x27, 0x5e, 0x8d, 0x43,
    0x5f, 0xee, 0x70, 0xb8, 0x38, 0x6e, 0x7d, 0x2c,
    0x21, 0xd8, 0x44, 0x46, 0x4d, 0x8a, 0x96, 0xea,
    0x2a, 0xa0, 0xa3, 0x69, 0x2e, 0xdb, 0x51, 0xea,
    0xa8, 0xed, 0xbc, 0x67, 0x3c, 0xa5, 0x93, 0xca,
    0x10, 0x02, 0x34, 0x31, 0x5b, 0xcd, 0x45, 0x05,
    0x97, 0xf7, 0xae, 0x78, 0xe2, 0xcd, 0xa1, 0xd6,
    0x31, 0x8c, 0xd3, 0xca, 0x86, 0x1e, 0x84, 0x16,
    0x24, 0xfc, 0xad, 0x2d, 0x10, 0xe3, 0x77, 0xf1,
    0x1a, 0xae, 0xa6, 0xf5, 0xc1, 0xd3, 0x89, 0x58,
    0x77, 0x6f, 0xf8, 0x91, 0x95, 0x3f, 0x78, 0x55,
    0xd4, 0x8a, 0x50, 0x23, 0x27, 0x11, 0xc3, 0x31,
    0xe0, 0xb2, 0x96, 0x08, 0x7f, 0x58, 0x4d, 0xc6,
    0x95, 0xc7, 0x86, 0x82, 0x88, 0xd6, 0x8e, 0xcd,
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	/* SIGNATURE is in little endian byte order */
	arg.ca_init.rsa.flags =  INIT_FLAG_RSA_DATA_LITTLE_ENDIAN;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) src %p\n",
		 algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS (3072 bit key SHA-256 digest) VERIFY (COMBINED OPERATION) ret %d\n",
		 algo, ret);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA (3072 bit key SHA-256 digest) PSS signature check: INVALID\n");
	}

	return ret;
}

#if HAVE_SHA1
__STATIC__ status_t TEST_rsa_pss_verify_sha1_saltlen(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// char data[] = "HelloWorld";
	// No null termination, no LF

	// SHA-1 digest of data
	uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	//  openssl dgst -sha1 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sign pss-privkey.p8 -out HelloWorld-slen.sig
	// XXX This signature has sLen == hLen (created by above openssl cmd)
	static uint8_t sig_saltlen[] = {
		0x31,0x95,0x38,0x58,0x3d,0x0f,0xbb,0x88,0x2c,0xcd,0xfa,0xc0,0x17,0x0a,0x94,0x8c,
		0xde,0x4e,0x24,0xf9,0x5d,0x18,0x33,0xf8,0x2d,0x9e,0xc6,0xb1,0x9b,0x09,0xd7,0x42,
		0x7b,0xda,0x2f,0x3c,0x04,0xb9,0xf8,0x8b,0x79,0x4b,0x0a,0x51,0xe9,0xc7,0x70,0xb6,
		0x61,0xaa,0x17,0x4c,0xbc,0x0d,0xad,0x44,0xce,0x18,0x3c,0xed,0x13,0x7f,0xad,0xd8,
		0x7d,0x8d,0x66,0x3a,0x11,0x5d,0xd3,0x3b,0x3b,0xb4,0x52,0xcb,0xbb,0xf2,0x6d,0x02,
		0x4f,0x6a,0x8c,0x6d,0x76,0xbd,0x35,0xa2,0xe2,0x6d,0xac,0x9a,0xe6,0xb8,0xac,0x46,
		0xc1,0xe4,0xc0,0xfe,0x96,0x37,0xb3,0x89,0x0e,0xd0,0x52,0x6e,0x68,0x25,0x75,0x1d,
		0xa1,0x4b,0x56,0x63,0x5c,0x11,0x5b,0x87,0xea,0x60,0x23,0x9c,0x02,0x04,0xba,0xd1,
		0x34,0x1c,0xd9,0x21,0x71,0xe4,0xd4,0xe6,0xd9,0x11,0xd5,0x3e,0x5b,0xbc,0x9d,0x22,
		0xc9,0x82,0x84,0xea,0xac,0x0c,0xa7,0xdc,0x28,0x9c,0x37,0xab,0xbd,0x78,0x08,0x27,
		0x6d,0x7b,0xe3,0x4f,0xde,0xa4,0x5d,0x76,0xc3,0x32,0xf6,0x69,0x16,0xc1,0x6d,0xc6,
		0x36,0xdf,0x1d,0x89,0xa6,0x8e,0xee,0xfa,0x4a,0xe6,0x68,0xaf,0xf4,0xb5,0xfd,0x7d,
		0x3d,0xa3,0x3c,0x45,0xd7,0xea,0x3b,0x31,0x4e,0xac,0x61,0x86,0xbd,0x74,0x0f,0x96,
		0x50,0xf5,0x34,0x2a,0x57,0xa9,0xe9,0x65,0xfc,0x61,0x41,0x8b,0x71,0x3f,0xd1,0x7d,
		0x25,0x09,0x18,0xf8,0x14,0x48,0xf8,0x32,0x30,0x4e,0x19,0x12,0xe4,0x6d,0x2f,0x62,
		0xb7,0x3d,0x9f,0x26,0x3f,0x2b,0xf3,0x48,0x75,0xf5,0x0b,0xbf,0x6a,0xc9,0x35,0xcf,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA2048_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_pub = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
			       .modulus  =
			       // Stripped leading 0x00 out of the modulus
			       // (it would be too long otherwise)
			       // RSA modulus
			       {
				       0xa5,0xd0,0xd7,0x3e,0x0e,0x2d,0xfb,0x43,
				       0x51,0x99,0xea,0x40,0x1e,0x2d,0x89,0xe4,
				       0xa2,0x3e,0xfc,0x51,0x3d,0x0e,0x83,0xa7,
				       0xe0,0xa5,0x41,0x04,0x1e,0x14,0xc5,0xa7,
				       0x5c,0x61,0x36,0x44,0xb3,0x08,0x05,0x5b,
				       0x14,0xde,0x01,0x0c,0x32,0x3c,0x9a,0x91,
				       0x00,0x50,0xa8,0x1d,0xcc,0x9f,0x8f,0x35,
				       0xb7,0xc2,0x75,0x08,0x32,0x8b,0x10,0x3a,
				       0x86,0xf9,0xd7,0x78,0xa3,0x9d,0x74,0x10,
				       0xc6,0x24,0xb1,0x7f,0xa5,0xbf,0x5f,0xc2,
				       0xd7,0x15,0xa3,0x1d,0xe0,0x15,0x6b,0x1b,
				       0x0e,0x38,0xba,0x34,0xbc,0x95,0x47,0x94,
				       0x40,0x70,0xac,0x99,0x1f,0x0b,0x8e,0x56,
				       0x93,0x36,0x2b,0x6d,0x04,0xe7,0x95,0x1a,
				       0x37,0xda,0x16,0x57,0x99,0xee,0x03,0x68,
				       0x16,0x31,0xaa,0xc3,0xb7,0x92,0x75,0x53,
				       0xfc,0xf6,0x20,0x55,0x44,0xf8,0xd4,0x8d,
				       0x78,0x15,0xc7,0x1a,0xb6,0xde,0x6c,0xe8,
				       0x49,0x5d,0xaf,0xa8,0x4e,0x6f,0x7c,0xe2,
				       0x6a,0x4c,0xd5,0xe7,0x8c,0x8f,0x0b,0x5d,
				       0x3a,0x09,0xd6,0xb3,0x44,0xab,0xe0,0x35,
				       0x52,0x7c,0x66,0x85,0xa4,0x40,0xd7,0x20,
				       0xec,0x24,0x05,0x06,0xd9,0x84,0x51,0x5a,
				       0xd2,0x38,0xd5,0x1d,0xea,0x70,0x2a,0x21,
				       0xe6,0x82,0xfd,0xa4,0x46,0x1c,0x4f,0x59,
				       0x6e,0x29,0x3d,0xae,0xb8,0x8e,0xee,0x77,
				       0x1f,0x15,0x33,0xcf,0x94,0x1d,0x87,0x3c,
				       0x37,0xc5,0x89,0xe8,0x7d,0x85,0xb3,0xbc,
				       0xe8,0x62,0x6a,0x84,0x7f,0xfe,0x9a,0x85,
				       0x3f,0x39,0xe8,0xaa,0x16,0xa6,0x8f,0x87,
				       0x7f,0xcb,0xc1,0xd6,0xf2,0xec,0x2b,0xa7,
				       0xdd,0x49,0x98,0x7b,0x6f,0xdd,0x69,0x6d
			       },
		},
	};

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for RSA\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size = sizeof_u32(digest);
	arg.ca_data.src_digest = digest;
	arg.ca_data.src_signature_size = sizeof_u32(sig_saltlen);
	arg.ca_data.src_signature = sig_saltlen;

	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) src %p\n",
		   algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RSA[0x%x] PSS VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		   algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

fail:
	CRYPTO_CONTEXT_RESET(c);

	if (NO_ERROR == ret) {
		LOG_INFO("RSA PSS signature check: OK\n");
	} else {
		LOG_INFO("RSA PSS signature check: INVALID\n");
	}

	return ret;
}
#endif /* HAVE_SHA1 */
#endif /* HAVE_SE_RSA || CCC_WITH_RSA */

#ifdef TEST_DIGEST
#if TEST_N_PAGE_DIGEST

#if !defined(SHA_FROM_MEMORY)
#define SHA_FROM_MEMORY 0
#endif

__STATIC__ status_t TEST_n_page_digest(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid,
				       uint32_t pages, const uint8_t *correct)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint32_t dsize;
	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	if (0U == pages) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	dsize = pages * 4096U;

#if SHA_FROM_MEMORY
	// XXXXX DANGEROUS!!! digesting arbitrary memory content!!!
	//
	// XXXXX test may crash, but most systems using CCC have rather small heaps.
	// XXXXX The only generic way is to digest arbitrray memory (result
	// XXXXX  can not be verified, but e.g. the speed can be measured;
	// XXXXX  and this case is mainly added for that purpose).
	//
	const uint8_t *data = (const uint8_t *)&arg;

	(void)correct;
#else
	uint8_t *data = NULL;

	data = CMTAG_MEM_GET_BUFFER(NULL, CMTAG_ALIGNED_BUFFER, CACHE_LINE, dsize);
	if (NULL == data) {
		CCC_ERROR_WITH_ECODE(ERR_NO_MEMORY,
				     LOG_ERROR("Failed to allocate %u contig bytes\n", dsize));
	}
#endif

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = dsize;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init/dofinal return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;

	LOG_INFO("DIGEST(reset), hash_size == %u\n", hash_size);

	DUMP_HEX("DIGEST RESULT:", hash, hash_size);


#if SHA_FROM_MEMORY == 0
	// XXX TODO: should support NIST partial digests 512/224 and 512/256 !!!!

	switch (digest) {
	case TE_ALG_SHA256:
		TRAP_ASSERT(hash_size == 32);
		break;
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
#else
	LOG_ERROR("SHA of %u bytes was callwlated from arbitrary memory content\n",
		  dsize);

	switch (digest) {
	case TE_ALG_SHA256:
		TRAP_ASSERT(hash_size == 32);
		break;
	default:
		break;
	}
#endif

fail:
#if SHA_FROM_MEMORY == 0
	if (NULL != data) {
		CMTAG_MEM_RELEASE(NULL, CMTAG_ALIGNED_BUFFER, data);
	}
#endif
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_4Kdigest(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t *data = NULL;
	uint32_t dsize = 4096U;
	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	data = CMTAG_MEM_GET_BUFFER(NULL, CMTAG_ALIGNED_BUFFER, CACHE_LINE, dsize);
	if (NULL == data) {
		CCC_ERROR_WITH_ECODE(ERR_NO_MEMORY,
				     LOG_ERROR("Failed to allocate %u contig bytes\n", dsize));
	}

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = dsize;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init/dofinal return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);
	hash_size = arg.ca_data.dst_size;

	LOG_INFO("DIGEST(reset), hash_size == %u\n", hash_size);

	DUMP_HEX("DIGEST RESULT:", hash, hash_size);


	const uint8_t sha256[] = {
		0xad, 0x7f, 0xac, 0xb2, 0x58, 0x6f, 0xc6, 0xe9,
		0x66, 0xc0, 0x04, 0xd7, 0xd1, 0xd1, 0x6b, 0x02,
		0x4f, 0x58, 0x05, 0xff, 0x7c, 0xb4, 0x7c, 0x7a,
		0x85, 0xda, 0xbd, 0x8b, 0x48, 0x89, 0x2c, 0xa7,
	};

	const uint8_t *correct = NULL;

	// XXX TODO: should support NIST partial digests 512/224 and 512/256 !!!!

	switch (digest) {
	case TE_ALG_SHA256:
		correct = sha256;
		TRAP_ASSERT(hash_size == 32);
		break;
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
fail:
	if (NULL != data) {
		CMTAG_MEM_RELEASE(NULL, CMTAG_ALIGNED_BUFFER, data);
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* TEST_N_PAGE_DIGEST */

/* verified */
__STATIC__ status_t TEST_digest(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	unsigned char data[16] = "abcdefghijklmnop";
	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = op_INIT_DOFINAL;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 16;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init/dofinal return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;

	LOG_INFO("DIGEST(reset), hash_size == %u\n", hash_size);

	arg.ca_opcode = TE_OP_RESET;
	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(reset return): DIGEST: %u, ret %d\n", digest,ret);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DIGEST RESULT:", hash, hash_size);

	const uint8_t sha1[] = {
		0x14, 0xf3, 0x99, 0x52, 0x88, 0xac, 0xd1, 0x89,
		0xe6, 0xe5, 0x0a, 0x7a, 0xf4, 0x7e, 0xe7, 0x09,
		0x9a, 0xa6, 0x82, 0xb9, };

	const uint8_t sha224[] = {
		0x63, 0xd6, 0xe3, 0x65, 0x02, 0x59, 0xc7, 0x1e,
		0x25, 0x6b, 0x1f, 0x4b, 0x13, 0xf4, 0x5c, 0x15,
		0x8c, 0x4e, 0xa0, 0xdd, 0x59, 0x52, 0xb1, 0x87,
		0x83, 0xf8, 0xb1, 0x5a,
	};

	const uint8_t sha256[] = {
		0xf3, 0x9d, 0xac, 0x6c, 0xba, 0xba, 0x53, 0x5e,
		0x2c, 0x20, 0x7c, 0xd0, 0xcd, 0x8f, 0x15, 0x49,
		0x74, 0x22, 0x3c, 0x84, 0x8f, 0x72, 0x7f, 0x98,
		0xb3, 0x56, 0x4c, 0xea, 0x56, 0x9b, 0x41, 0xcf,
	};

	const uint8_t sha384[] = {
		0x96, 0xd3, 0xc1, 0xb5, 0x4b, 0x19, 0x38, 0x60,
		0x0a, 0xbe, 0x5b, 0x57, 0x23, 0x2e, 0x18, 0x5d,
		0xf1, 0xc5, 0x85, 0x6f, 0x74, 0x65, 0x6b, 0x8f,
		0x98, 0x37, 0xc5, 0x31, 0x7c, 0xf5, 0xb2, 0x2a,
		0xc3, 0x82, 0x26, 0xfa, 0xfc, 0x8c, 0x94, 0x6b,
		0x9d, 0x20, 0xac, 0xa1, 0xb0, 0xc5, 0x3a, 0x98,
	};

	const uint8_t sha512[] = {
		0xd0, 0xca, 0xdd, 0x68, 0x34, 0xfa, 0x0c, 0x15,
		0x7b, 0x36, 0xcc, 0xa3, 0x0e, 0xe8, 0xb0, 0xb1,
		0x43, 0x5d, 0x84, 0x1a, 0xa5, 0xb5, 0xac, 0x85,
		0x0c, 0x11, 0xae, 0x80, 0xa1, 0x44, 0x0f, 0x51,
		0x74, 0x3e, 0x98, 0xfb, 0x1f, 0x1e, 0x73, 0x76,
		0xc7, 0x0f, 0x2f, 0x65, 0x40, 0x4f, 0x08, 0x8c,
		0x28, 0xbc, 0xb4, 0xa5, 0x11, 0xdf, 0x2e, 0x64,
		0x11, 0x1f, 0x8f, 0x74, 0x24, 0x36, 0x4b, 0x60,
	};

	const uint8_t md5[] = {
		0x1d, 0x64, 0xdc, 0xe2, 0x39, 0xc4, 0x43, 0x7b,
		0x77, 0x36, 0x04, 0x1d, 0xb0, 0x89, 0xe1, 0xb9,
	};

#if CCC_WITH_SHA3
	const uint8_t sha3_224[] = {
		0xe2, 0xcd, 0x35, 0x22, 0xf5, 0x42, 0xd4, 0x91,
		0x06, 0x12, 0x5c, 0xf5, 0xf4, 0x61, 0x0f, 0xbc,
		0x4c, 0xa4, 0x5e, 0x1c, 0x8a, 0x77, 0xac, 0x2e,
		0x44, 0x23, 0x6f, 0x9b,
	};

	const uint8_t sha3_256[] = {
		0xc3, 0xfa, 0xd9, 0xc0, 0xcc, 0x98, 0x3f, 0x7e,
		0x2d, 0x13, 0x48, 0xbd, 0x3e, 0xfc, 0x56, 0xb2,
		0x63, 0x63, 0xa5, 0x44, 0xfc, 0xff, 0x58, 0xf7,
		0x28, 0x25, 0x5b, 0x8e, 0x1e, 0xc8, 0x2a, 0x42,
	};

	const uint8_t sha3_384[] = {
		0x13, 0x39, 0xca, 0x51, 0x6b, 0x27, 0xfe, 0xf1,
		0xc5, 0xcb, 0xc3, 0xc5, 0x4f, 0x26, 0xd2, 0x26,
		0xf5, 0x69, 0xb0, 0x2c, 0xc2, 0xa2, 0xaf, 0xd3,
		0xad, 0xb4, 0xef, 0x52, 0x82, 0xae, 0x72, 0x78,
		0xa6, 0xe4, 0x1e, 0x7c, 0xc4, 0xa1, 0x96, 0xcd,
		0x90, 0xaa, 0x8a, 0x04, 0x07, 0x62, 0x54, 0xde,
	};

	const uint8_t sha3_512[] = {
		0x1d, 0x0a, 0x86, 0x47, 0x3e, 0x91, 0x7f, 0x63,
		0x1e, 0xeb, 0xa6, 0xbb, 0x6b, 0x8d, 0x3b, 0xd9,
		0x6e, 0x32, 0x37, 0x19, 0xfe, 0x32, 0x74, 0xc8,
		0xcb, 0xa0, 0x4d, 0xd3, 0x2e, 0xc4, 0x90, 0x14,
		0x11, 0x4d, 0x03, 0x47, 0x37, 0xac, 0x7b, 0x3f,
		0x72, 0xec, 0x68, 0xf6, 0x04, 0x18, 0x68, 0x23,
		0xab, 0xeb, 0xd7, 0x0b, 0x0c, 0x51, 0x93, 0x76,
		0xc5, 0x0e, 0xf3, 0xe0, 0x5b, 0x67, 0x08, 0xf9,
	};
#endif /* CCC_WITH_SHA3 */

	const uint8_t whirlpool[] = {
		0x31, 0xb3, 0x53, 0xab, 0x9c, 0xd1, 0x81, 0xdc,
		0xad, 0x71, 0x61, 0xcc, 0x63, 0x40, 0x0f, 0xe1,
		0xd0, 0x61, 0x0d, 0x54, 0x15, 0xe6, 0x7b, 0xd7,
		0x16, 0x49, 0xbd, 0x77, 0x1a, 0xc9, 0xcf, 0x69,
		0x34, 0xee, 0x4f, 0x66, 0xe2, 0xbd, 0xa2, 0xb0,
		0xb0, 0x27, 0xc5, 0xb6, 0xca, 0x09, 0x9f, 0x15,
		0x53, 0xc2, 0x44, 0xd5, 0xa3, 0xc0, 0x1e, 0xd5,
		0x1c, 0xd7, 0x74, 0x49, 0x68, 0xe7, 0xfb, 0x2e,
	};

	const uint8_t *correct = NULL;

	// XXX TODO: should support NIST partial digests 512/224 and 512/256 !!!!

	switch (digest) {
	case TE_ALG_MD5:
		correct = md5;
		TRAP_ASSERT(hash_size == 16);
		break;
	case TE_ALG_SHA1:
		correct = sha1;
		TRAP_ASSERT(hash_size == 20);
		break;
	case TE_ALG_SHA224:
		correct = sha224;
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA256:
		correct = sha256;
		TRAP_ASSERT(hash_size == 32);
		break;
	case TE_ALG_SHA384:
		correct = sha384;
		TRAP_ASSERT(hash_size == 48);
		break;
	case TE_ALG_SHA512:
		correct = sha512;
		TRAP_ASSERT(hash_size == 64);
		break;
	case TE_ALG_WHIRLPOOL:
		correct = whirlpool;
		TRAP_ASSERT(hash_size == 64);
		break;
#if CCC_WITH_SHA3
	case TE_ALG_SHA3_224:
		correct = sha3_224;
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA3_256:
		correct = sha3_256;
		TRAP_ASSERT(hash_size == 32);
		break;
	case TE_ALG_SHA3_384:
		correct = sha3_384;
		TRAP_ASSERT(hash_size == 48);
		break;
	case TE_ALG_SHA3_512:
		correct = sha3_512;
		TRAP_ASSERT(hash_size == 64);
		break;
#endif /* CCC_WITH_SHA3 */
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if LONG_DIGEST_TEST
__STATIC__ status_t TEST_long_digest(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t data[] = {
		0xca, 0xa5, 0xcc, 0x5d, 0x0d, 0x87, 0x68, 0x0e, 0xaf, 0xc2, 0x94, 0x29, 0xba, 0xc5, 0x5c, 0x9e, 0x33, 0x16, 0x7d, 0x48, 0x57, 0x89, 0xc7, 0xc1, 0x24, 0xb5, 0xc5, 0x7a, 0x1b, 0xa8, 0xa0, 0x0b, 0x45, 0xda, 0x41, 0xc7, 0x74, 0x60, 0xb6, 0x94, 0xcb, 0x62, 0xd7, 0xfa, 0x80, 0xcf, 0x29, 0x79, 0xe1, 0x4f, 0x02, 0x20, 0x95, 0x7a, 0xee, 0x5b, 0x25, 0x47, 0x52, 0x0d, 0xbb, 0xc7, 0x4f, 0xde, 0x29, 0x13, 0xe9, 0xd7, 0x2c, 0x83, 0x69, 0x2c, 0xf2, 0x20, 0xff, 0x58, 0xdb, 0x5c, 0xac, 0x6f, 0x7d, 0x01, 0x5f, 0xb0, 0xea, 0x68, 0x5f, 0x5a, 0x35, 0xeb, 0xe8, 0xc2, 0x32, 0x9c, 0x19, 0xa1, 0x7e, 0x38, 0x0e, 0xb2, 0xbf, 0x56, 0x49, 0x7d, 0x2d, 0xe4, 0x56, 0x6d, 0x52, 0xd4, 0xae, 0x29, 0x0d, 0x13, 0xdd, 0x21, 0xdd, 0xbb, 0xe0, 0x67, 0x5c, 0x89, 0xd1, 0xc1, 0x0a, 0x91, 0xc6, 0xfc, 0x4c, 0x30, 0xf6, 0x83, 0xb5, 0x43, 0x1d, 0x30, 0x83, 0x96, 0x22, 0x61, 0x6d, 0xa0, 0xf7, 0x4f, 0x9c, 0x6d, 0xc2, 0x9b, 0xf7, 0xdb, 0x3a, 0x2a, 0xa3, 0x09, 0x53, 0x33, 0xca, 0x0d, 0x1d, 0x96, 0x9c, 0xe5, 0xe9, 0x70, 0x94, 0xb0, 0xaf, 0xec, 0xfd, 0x1f, 0xac, 0x5c, 0xb4, 0x26, 0x4f, 0x88, 0x2f, 0xf7, 0x56, 0x45, 0xbe, 0x30, 0x35, 0x4a, 0x11, 0x53, 0xb7, 0x40, 0xfb, 0x78, 0xe7, 0x18, 0x75, 0x3e, 0x31, 0xa1, 0xe6, 0x07, 0xc5, 0x5a, 0xa2, 0x65, 0x3c, 0x85, 0xb0, 0xcf, 0x7e, 0x7c, 0xd0, 0x99, 0xe3, 0x48, 0xbc, 0x23, 0x98, 0x70, 0xaf, 0x50, 0x45, 0x0f, 0x24, 0x39, 0xec, 0x29, 0xe0, 0x23, 0x15, 0x3f, 0x32, 0xaf, 0x28, 0x21, 0x7a, 0x51, 0x1a, 0x04, 0xe8, 0x03, 0x4b, 0xd4, 0x86, 0x3b, 0xaf, 0xcc, 0x79, 0x1a, 0x2d, 0x43, 0x84, 0xe6, 0x44, 0xc9, 0xcd, 0xba, 0xf4, 0x72, 0xe4, 0x7c, 0xdc, 0x72, 0x01, 0x10, 0xa0, 0xea, 0x8d, 0xcb, 0x8d, 0x02, 0xe4, 0x2b, 0x80, 0x38, 0x5a, 0xc5, 0x03, 0xf8, 0x7c, 0x7e, 0xba, 0x6c, 0x98, 0xfe, 0xfe, 0x95, 0x7f, 0x62, 0xc7, 0x9b, 0x89, 0x31, 0xcf, 0x61, 0xda, 0x92, 0xf4, 0x5d, 0xe4, 0xbc, 0xde, 0xa7, 0x2d, 0xad, 0xe3, 0x4f, 0x52, 0x1f, 0x27, 0xf4, 0x4d, 0xb8, 0x08, 0x92, 0xf3, 0x81, 0xb9, 0x9c, 0xc0, 0x99, 0x2c, 0x4b, 0xd7, 0x2b, 0x36, 0x35, 0x45, 0x9d, 0xee, 0x21, 0x86, 0x0a, 0x56, 0x1a, 0x4a, 0xf3, 0x3d, 0xc2, 0x79, 0x31, 0x63, 0xe9, 0x74, 0x2e, 0xdf, 0x5e, 0x9e, 0x55, 0xbe, 0x05, 0x1b, 0xc7, 0xed, 0x2a, 0xd7, 0x50, 0x59, 0x15, 0xca, 0x99, 0x54, 0xdf, 0x7b, 0x9f, 0x3b, 0x84, 0xc3, 0x63, 0x55, 0x38, 0xd4, 0xe4, 0xff, 0xff, 0x79, 0x4a, 0x06, 0x78, 0xa0, 0x64, 0x55, 0xf9, 0x15, 0x54, 0xd0, 0xe1, 0x90, 0x89, 0x7f, 0x2a, 0xf2, 0xee, 0xef, 0x3e, 0xcc, 0x61, 0xd5, 0x0c, 0x21, 0x67, 0xf5, 0x5a, 0x6d, 0x1e, 0x42, 0x5d, 0xe5, 0x73, 0x47, 0x87, 0x01, 0x94, 0xc5, 0xa0, 0x38, 0xa9, 0x9e, 0x18, 0x0a, 0xbf, 0xf1, 0x9c, 0x44, 0x04, 0x87, 0xe7, 0x80, 0x3a, 0x6e, 0xdb, 0xeb, 0x66, 0xe3, 0xd0, 0x4b, 0xc8, 0x76, 0x2c, 0x40, 0x10, 0x68, 0x33, 0xc9, 0xcf, 0x58, 0x21, 0x0b, 0x2c, 0x1e, 0x76, 0x4e, 0xd8, 0xf8, 0x92, 0x49, 0x44, 0xe4, 0x81, 0x9f, 0x11, 0x4c, 0x18, 0xa9, 0xc8, 0xe8, 0x41, 0x76, 0xcb, 0xe1, 0x93, 0x10, 0x8b, 0x32, 0x26, 0x01, 0xfc, 0x54, 0xa5, 0x16, 0x46, 0x1a, 0xa4, 0x63, 0xbe, 0xda, 0x34, 0x87, 0x14, 0xcd, 0xb5, 0x32, 0xcd, 0xb8, 0xec, 0xe4, 0xf4, 0xcc, 0x56, 0xf7, 0x0d, 0xcb, 0xbb, 0xdf, 0x4b, 0x6d, 0x05, 0xb1, 0x03, 0x02, 0x53, 0xe2, 0x5f, 0x58, 0x4a, 0x51, 0x57, 0xdf, 0xab, 0x88, 0xdd, 0x0b, 0x2b, 0x3f, 0x58, 0xfa, 0x7f, 0x22, 0x54, 0x57, 0xb6, 0xd5, 0x78, 0x7e, 0xcb, 0x34, 0xb8, 0xe1, 0x7b, 0xdf, 0xcc, 0xaa, 0x54, 0xf6, 0xe0, 0xa2, 0x0f, 0x21, 0x8d, 0x51, 0x1f, 0xd4, 0x08, 0x67, 0x8a, 0xd1, 0x99, 0x5a, 0xf8, 0xee, 0x4f, 0x51, 0x09, 0x18, 0xf3, 0x41, 0xec, 0x98, 0x3a, 0x55, 0x2e, 0x95, 0x3e, 0x94, 0xcf, 0xda, 0x2f, 0xbe, 0x9b, 0xda, 0x46, 0x76, 0xb7, 0xf1, 0xfb, 0xa6, 0x7b, 0xed, 0x78, 0x20, 0x7f, 0xcd, 0x4d, 0x81, 0xf9, 0xc9, 0x65, 0x5b, 0x46, 0x92, 0x39, 0x93, 0xc6, 0xda, 0x43, 0x07, 0xed, 0x17, 0xb6, 0x74, 0x97, 0x84, 0x6c, 0x98, 0x9c, 0x69, 0x20, 0x93, 0xa5, 0x9d, 0xdd, 0x93, 0x3e, 0x49, 0xb6, 0xb0, 0x2c, 0xee, 0xb8, 0x15, 0x00, 0xaa, 0x1d, 0x61, 0xec, 0xb7, 0xc2, 0x4d, 0xd6, 0x34, 0xdc, 0x8e, 0xab, 0x28, 0xe6, 0xfd, 0xf6, 0xc4, 0xde, 0xf5, 0xb1, 0xe8, 0xb0, 0xfc, 0x5a, 0xe9, 0xf3, 0xa6, 0x4a, 0x92, 0xd3, 0xb7, 0x43, 0x68, 0x4e, 0x88, 0x48, 0x32, 0xa4, 0xac, 0xb1, 0xb9, 0x08, 0xd2, 0x7e, 0xcd, 0x9c, 0xed, 0xec, 0x88, 0x9c, 0x93, 0x46, 0xd7, 0xd9, 0xa3, 0xfe, 0x35, 0x6a, 0x2b, 0xfc, 0xba, 0x9e, 0x89, 0x36, 0x55, 0x35, 0xd0, 0x81, 0x56, 0xcf, 0x6d, 0xa6, 0x2f, 0xa4, 0x0a, 0xb9, 0x7b, 0x76, 0xb2, 0xa6, 0x3f, 0xc4, 0x36, 0x0d, 0x70, 0x41, 0xd0, 0x50, 0xb6, 0x84, 0x07, 0xea, 0x70, 0x01, 0xd2, 0x02, 0xf8, 0x38, 0x00, 0x3f, 0x28, 0x2c, 0xd7, 0xdf, 0x1d, 0x17, 0xfc, 0x03, 0x3a, 0x5c, 0x93, 0x4d, 0x70, 0xbd, 0xa6, 0xad, 0xbd, 0xce, 0xcb, 0x78, 0xf3, 0xa9, 0x01, 0xbb, 0xbb, 0xe4, 0xdc, 0xce, 0xd9, 0xc0, 0xe2, 0x2c, 0xb2, 0xa3, 0x34, 0x81, 0x0b, 0xc9, 0x71, 0x05, 0x13, 0x36, 0xd7, 0x09, 0xa4, 0xef, 0xab, 0xcf, 0xc6, 0x69, 0xdb, 0x9f, 0x75, 0x42, 0xe3, 0x17, 0xa4, 0x2f, 0xed, 0xc3, 0x81, 0x36, 0x3c, 0xee, 0xfb, 0x1d, 0xca, 0xb7, 0x81, 0x22, 0x30, 0x67, 0x0d, 0xec, 0xc7, 0x01, 0x62, 0xc2, 0x0d, 0x1b, 0x92, 0xfb, 0x4a, 0xed, 0xc2, 0xb5, 0x73, 0xa8, 0x31, 0xca, 0x4e, 0x09, 0x77, 0x00, 0xd7, 0x2d, 0x0b, 0x80, 0xe3, 0xa7, 0x08, 0x8a, 0x03, 0xd0, 0x31, 0x66, 0xab, 0x5e, 0x32, 0x9e, 0x93, 0x38, 0x29, 0x6a, 0x5e, 0x89, 0x64, 0x6c, 0x7a, 0x13, 0x6c, 0x9d, 0x47, 0xc7, 0x43, 0x88, 0x7b, 0x92, 0xeb, 0xb6, 0xc5, 0x79, 0x27, 0x69, 0xb0, 0xe8, 0x86, 0x8d, 0xcb, 0x47, 0x9c, 0xeb, 0x07, 0xcf, 0x93, 0xa0, 0x60, 0x9c, 0xe3, 0xcd, 0xbf, 0x03, 0x5d, 0x91, 0x1f, 0x25, 0x6e, 0x34, 0xef, 0xc4, 0xa2, 0xa5, 0xb8, 0x56, 0x67, 0x27, 0x00, 0x58, 0x14, 0x47, 0x6e, 0xe5, 0x29, 0x11, 0x2f, 0x87, 0xd8, 0x83, 0x97, 0x4d, 0xc5, 0x42, 0x0c, 0x1e, 0x0b, 0x8c, 0x20, 0x4c, 0x7f, 0x6e, 0xfd, 0x6c, 0x38, 0x37, 0x06, 0x66, 0x4f, 0x2c, 0xbb, 0xc8, 0xe3, 0x7d, 0xdd, 0x60, 0x60, 0x78, 0xd3, 0x09, 0x01, 0xfd, 0x4d, 0xc5, 0x94, 0x32, 0x27, 0x0c, 0x7e, 0x77, 0x90, 0x64, 0xfe, 0x9d, 0x6b, 0x32, 0xb6, 0x52, 0xf5, 0xd0, 0x67, 0xe0, 0xa9, 0xdf, 0xfc, 0x18, 0x61, 0xdf, 0xca, 0x88, 0xbd, 0xfd, 0x16, 0xf5, 0xc8, 0x2b, 0xd7, 0x05, 0xd9, 0x76, 0xbe, 0x3b, 0xb8, 0x94, 0x74, 0x28, 0x02, 0xbd, 0x23, 0xe0, 0xcf, 0xbd, 0x37, 0xac, 0x91, 0x46, 0x66, 0xfe, 0x40, 0x8a, 0xed, 0xaa, 0xb4, 0x09, 0x1d, 0x52, 0x52, 0xa8, 0x17, 0x22, 0xea, 0x04, 0xd4, 0xbe, 0xe0, 0x05, 0x68, 0x79, 0x8a, 0xb6, 0x87, 0xc8, 0xda, 0x54, 0x48, 0xf6, 0x3d, 0xa5, 0x29, 0x19, 0xc2, 0x8a, 0x53, 0x44, 0x7f, 0xd8, 0x20, 0xfe, 0x31, 0x64, 0xdb, 0xf3, 0x22, 0x5d, 0xc7, 0xea, 0x50, 0xdf, 0x62, 0xf7, 0xcb, 0xc4, 0xea, 0xf2, 0x5f, 0xbe, 0x21, 0x27, 0x73, 0xa3, 0x4e, 0x4f, 0x31, 0x07, 0x84, 0xc0, 0xe7, 0x10, 0x26, 0xe0, 0xad, 0x86, 0xab, 0xdf, 0x49, 0x2a, 0x9f, 0xa6, 0x4f, 0x49, 0xea, 0x0a, 0x8d, 0x90, 0x55, 0x46, 0xa5, 0x22, 0x4a, 0xa8, 0xfc, 0xe8, 0xdb, 0x8a, 0xd3, 0x28, 0x07, 0x84, 0xb4, 0x5a, 0x38, 0xe0, 0x10, 0x37, 0x0f, 0x4e, 0x26, 0x12, 0x64, 0xd9, 0x26, 0x6b, 0x89, 0x1a, 0x97, 0xc2, 0xcf, 0xac, 0xf6, 0xa9, 0x4c, 0xe0, 0xa0, 0x1d, 0xdb, 0xb1, 0xf2, 0x16, 0x63, 0xfa, 0xae, 0x5d, 0x5d, 0xe6, 0xa0, 0x9e, 0x90, 0xa8, 0x82, 0xbe, 0x1f, 0x6d, 0x1e, 0x6e, 0xc6, 0x8f, 0xb2, 0x01, 0x61, 0x0c, 0x98, 0x7a, 0xae, 0x36, 0x26, 0xea, 0x53, 0xac, 0xd4, 0xf9, 0x23, 0x88, 0x9c, 0xc2, 0x9d, 0xda, 0xa7, 0xe4, 0xb5, 0x56, 0x25, 0xd5, 0xd8, 0x49, 0x7d, 0x7a, 0x2a, 0xd2, 0xa6, 0xf5, 0x12, 0x4e, 0xd4, 0xbf, 0xf8, 0x14, 0x58, 0xf6, 0x4d, 0x63, 0xc1, 0xf8, 0xcc, 0x98, 0x48, 0x30, 0x00, 0xa4, 0x6b, 0x30, 0x07, 0xbe, 0xd7, 0x00, 0x95, 0x55, 0x8b, 0xb6, 0x3c, 0x49, 0x3b, 0x47, 0xea, 0x5a, 0xf2, 0x9d, 0xb3, 0xe1, 0xfc, 0xea, 0xd0, 0xbe, 0x03, 0x3b, 0xe8, 0x91, 0x78, 0x50, 0x8f, 0x2d, 0x35, 0xab, 0x0d, 0x49, 0x60, 0xe7, 0x60, 0x79, 0x92, 0x4b, 0x84, 0x5d, 0x38, 0x9f, 0xf1, 0x18, 0x3a, 0x3e, 0x66, 0x04, 0xdb, 0x6d, 0xe5, 0xa5, 0xe1, 0xeb, 0xfe, 0xdb, 0xf5, 0xca, 0x51, 0x5b, 0x4c, 0x7c, 0x4f, 0x5f, 0x87, 0x31, 0x40, 0x9d, 0xd8, 0x61, 0x8a, 0x76, 0x67, 0xa4, 0x30, 0x71, 0xf4, 0xca, 0x99, 0xe7, 0xbd, 0x28, 0x93, 0x00, 0xa2, 0x30, 0x97, 0xde, 0x87, 0x45, 0x4f, 0x17, 0xfa, 0xcd, 0x55, 0x69, 0x15, 0x87, 0x3e, 0xa9, 0xa6, 0x1e, 0xd7, 0xfd, 0x8e, 0xff, 0xae, 0x4b, 0x67, 0x68, 0xd4, 0xf1, 0x6a, 0xc2, 0xe2, 0xb7, 0x8f, 0x31, 0x3a, 0x01, 0xf5, 0x69, 0x8f, 0x4a, 0x85, 0xc3, 0xa8, 0xcd, 0xd3, 0x90, 0x60, 0x85, 0x44, 0xad, 0xf2, 0x58, 0x76, 0x58, 0x73, 0x90, 0xdc, 0x41, 0xa0, 0x8a, 0xa9, 0xe4, 0xda, 0xb2, 0xf0, 0x17, 0x6f, 0xaf, 0x09, 0xdf, 0x1b, 0xda, 0x36, 0x88, 0xcf, 0xf5, 0x86, 0xf5, 0xb0, 0x1a, 0xfa, 0x34, 0x63, 0xf1, 0xe7, 0x55, 0x88, 0x26, 0x9b, 0x7d, 0x84, 0x1a, 0x43, 0x36, 0x84, 0xd9, 0x0d, 0x09, 0xbf, 0x4d, 0x89, 0x4f, 0xfb, 0xb1, 0x55, 0x44, 0x52, 0x47, 0xf9, 0x5d, 0x36, 0x4e, 0x10, 0xdc, 0xb3, 0x2f, 0xa9, 0xa1, 0xf4, 0xf7, 0xec, 0x43, 0x09, 0x09, 0x01, 0x5f, 0xe7, 0x15, 0x2d, 0x30, 0xb0, 0x44, 0x3e, 0x60, 0x35, 0xb5, 0x2a, 0x1e, 0xba, 0x2d, 0xf3, 0x71, 0xf9, 0x0a, 0xcd, 0xcc, 0x69, 0x79, 0x83, 0xe2, 0xbf, 0xe9, 0x17, 0xbb, 0xb5, 0xc0, 0xa9, 0x08, 0x0b, 0x4c, 0x99, 0xb4, 0xcc, 0xfc, 0xf0, 0xbb, 0xd3, 0xd0, 0xfc, 0x3f, 0x8d, 0x0e, 0x3b, 0xd9, 0x01, 0x37, 0x7b, 0x2d, 0x0d, 0x39, 0x3e, 0xc1, 0xf2, 0xe6, 0x63, 0x0f, 0x13, 0xa5, 0x03, 0xd8, 0xf9, 0x67, 0x9a, 0xbc, 0x9b, 0xdd, 0x67, 0x08, 0xdc, 0xe9, 0x15, 0xcf, 0x56, 0x52, 0x9a, 0x3c, 0x56, 0xbb, 0x60, 0x26, 0x27, 0xd6, 0xa2, 0xe5, 0x94, 0xd5, 0x1a, 0x64, 0xa8, 0x21, 0xd9, 0x78, 0xb8, 0x4f, 0x76, 0x70, 0xa4, 0x50, 0x6a, 0xee, 0x59, 0xe7, 0xbb, 0xf5, 0x9a, 0x60, 0xd8, 0x42, 0x01, 0x80, 0xc4, 0xe0, 0x40, 0xb8, 0x77, 0xf7, 0xad, 0x9d, 0x82, 0xe5, 0xfe, 0x9d, 0xf1, 0x8f, 0x50, 0xea, 0x75, 0xf9, 0x6f, 0xbb, 0xc3, 0x15, 0x51, 0xb4, 0x37, 0xd9, 0xe3, 0xa2, 0xbd, 0x94, 0x09, 0x6c, 0xf1, 0x82, 0xdf, 0x47, 0x85, 0x9e, 0x46, 0x28, 0xe3, 0xb7, 0x9c, 0x7f, 0x14, 0xc6, 0xca, 0x22, 0xe1, 0x7f, 0x84, 0x87, 0x38, 0x26, 0xcc, 0x37, 0xd1, 0xa4, 0xb8, 0x7f, 0x10, 0xda, 0x76, 0x69, 0x2e, 0x35, 0x8d, 0xeb, 0x94, 0x83, 0x65, 0x5d, 0x87, 0x05, 0x0a, 0x30, 0x0a, 0xc5, 0x2d, 0xde, 0x00, 0x29, 0x6c, 0x1d, 0x92, 0xc9, 0xd3, 0x58, 0xd0, 0x7e, 0xa2, 0x5f, 0x9b, 0xbb, 0x50, 0x5e, 0xc2, 0x21, 0xd1, 0x0c, 0x6b, 0x4d, 0x15, 0x24, 0xb5, 0xf5, 0xd1, 0x19, 0x9b, 0x33, 0x81, 0x06, 0x1c, 0x20, 0xae, 0xe3, 0x98, 0xa5, 0x6c, 0xff, 0x7e, 0x8e, 0x28, 0xaa, 0x24, 0xe0, 0xa0, 0x32, 0xf6, 0x6d, 0x33, 0x12, 0xd3, 0xa5, 0x5b, 0x65, 0xb4, 0xaf, 0x78, 0xa1, 0x8f, 0xb9, 0xcf, 0x81, 0x7b, 0x8c, 0xd2, 0x43, 0x14, 0x63, 0xa2, 0x14, 0x21, 0xfd, 0xd2, 0xc9, 0x74, 0xf1, 0x6e, 0xcf, 0x12, 0x42, 0x3b, 0x65, 0x94, 0x33, 0x41, 0x08, 0xcd, 0x5c, 0x87, 0x2f, 0xad, 0xfe, 0x1e, 0x39, 0x65, 0x94, 0x60, 0xa4, 0xcc, 0xaa, 0x7a, 0x7f, 0x02, 0xf2, 0x28, 0x22, 0x53, 0x95, 0xc0, 0x1c, 0x5e, 0xc7, 0x72, 0x6d, 0x76, 0x9e, 0xce, 0xf6, 0x48, 0x24, 0x86, 0x2d, 0xbe, 0xab, 0x76, 0x15, 0x24, 0x60, 0xe1, 0x6e, 0x8a, 0x23, 0xfe, 0x28, 0x69, 0x96, 0xb3, 0x1e, 0x89, 0x74, 0xa0, 0x01, 0x21, 0x25, 0x5f, 0x92, 0x41, 0x8f, 0x0a, 0x15, 0x6d, 0x2e, 0xfe, 0x02, 0x8a, 0x67, 0xdf, 0xfd, 0xff, 0x19, 0xdd, 0x08, 0x14, 0x76, 0x35, 0xf8, 0x9d, 0x11, 0xfa, 0x25, 0xdd, 0x37, 0x15, 0x66, 0xa5, 0x83, 0x8b, 0x3d, 0xbc, 0xad, 0xfe, 0x4e, 0x83, 0xa3, 0x77, 0x16, 0xd9, 0xdb, 0x62, 0xd9, 0x3d, 0xe7, 0xda, 0xdc, 0x32, 0x4a, 0x27, 0xd5, 0xe8, 0x8a, 0x85, 0xa0, 0x18, 0x86, 0x27, 0x33, 0x30, 0x0a, 0x7c, 0xd4, 0xb0, 0xa1, 0xb1, 0x8a, 0xd4, 0xaa, 0x77, 0xd1, 0x73, 0xae, 0x06, 0x91, 0x27, 0xf1, 0x62, 0x51, 0xae, 0x47, 0xdd, 0xa8, 0x90, 0x29, 0xdd, 0xf5, 0x02, 0x08, 0xdf, 0x50, 0x0b, 0xe1, 0xbc, 0xc1, 0xe5, 0x12, 0x2b, 0xaf, 0xa6, 0x6c, 0x88, 0x9b, 0x20, 0x89, 0xd4, 0x0e, 0x05, 0x60, 0xfc, 0xcf, 0x4f, 0x16, 0x5e, 0x5a, 0xde, 0x18, 0x89, 0x8e, 0x63, 0x66, 0x44, 0xa6, 0x7e, 0x32, 0xd3, 0x6a, 0x23, 0xa9, 0x75, 0xa6, 0x42, 0x11, 0x31, 0xdc, 0xa7, 0x14, 0xd2, 0x36, 0x1f, 0x5b, 0x31, 0xbe, 0xdc, 0x5f, 0xb2, 0xd1, 0x1a, 0x7c, 0x11, 0xd1, 0x03, 0x48, 0x5f, 0x1b, 0xd0, 0x22, 0x47, 0x39, 0x32, 0x0e, 0x96, 0x58, 0xf0, 0xc0, 0xfb, 0xfc, 0xd1, 0xf6, 0x0a, 0xf2, 0xbc, 0x0b, 0x87, 0x87, 0x1e, 0xc9, 0xe2, 0xf7, 0x8c, 0x80, 0xfe, 0x28, 0xaa, 0x54, 0x36, 0x98, 0x4b, 0xdb, 0xa2, 0x94, 0xd9, 0xe8, 0x96, 0xac, 0xf8, 0xa1, 0x6c, 0x63, 0x66, 0xd8, 0x84, 0x2b, 0x25, 0x98, 0x88, 0x90, 0xdd, 0xfd, 0xf5, 0xb3, 0x7c, 0x49, 0xd7, 0xfa, 0x1f, 0x35, 0xd4, 0x06, 0x35, 0x85, 0x6b, 0xe5, 0xe1, 0xdf, 0x7e, 0x89, 0xa1, 0xdd, 0x0e, 0x79, 0x2e, 0x61, 0x47, 0xc7, 0xa3, 0x29, 0xbc, 0x42, 0xe0, 0xa3, 0xf3, 0xec, 0x31, 0x02, 0x24, 0xaf, 0x2b, 0x91, 0x3e, 0x4b, 0xd7, 0x47, 0x2b, 0x93, 0x13, 0x9c, 0x55, 0xd9, 0x34, 0x9c, 0x69, 0xa7, 0xf0, 0x3a, 0x5b, 0xb0, 0x7c, 0xe6, 0xaa, 0x05, 0xf1, 0x62, 0xe5, 0x8c, 0xf4, 0xd1, 0x6e, 0xaf, 0x96, 0x11, 0x7e, 0x51, 0x79, 0x4a, 0x69, 0x06, 0x35, 0xc7, 0x23, 0x83, 0xf9, 0x05, 0x03, 0x53, 0x76, 0x0a, 0xc8, 0xcc, 0xf8, 0xf8, 0xda, 0x42, 0xd6, 0xe2, 0xd2, 0x7a, 0x0d, 0xde, 0x3b, 0x61, 0x28, 0x5c, 0x9a, 0xfe, 0x63, 0xb6, 0xad, 0xa6, 0x0f, 0x08, 0xf1, 0x6f, 0x38, 0x41, 0x66, 0xe7, 0x86, 0x7a, 0x96, 0x05, 0x61, 0x87, 0xd4, 0x5f, 0x58, 0xcc, 0xc2, 0x9e, 0xc4, 0x52, 0x16, 0x2f, 0xa8, 0x1b, 0x9d, 0x3c, 0xdc, 0xb2, 0x80, 0xdb, 0x6b, 0x05, 0xc6, 0x85, 0x39, 0x77, 0x1a, 0xc9, 0xe9, 0x32, 0xce, 0x41, 0xfd, 0xba, 0x21, 0xc6, 0x3f, 0xc8, 0xbd, 0xe0, 0x60, 0x55, 0x84, 0x80, 0xe0, 0xf5, 0x8c, 0xf2, 0x2d, 0x66, 0x68, 0x0d, 0x0f, 0x69, 0xaa, 0xad, 0x43, 0xd0, 0xa5, 0x63, 0x67, 0xd9, 0x78, 0x6a, 0x16, 0xba, 0x48, 0xdd, 0x53, 0x7d, 0xcc, 0x28, 0x2b, 0x0e, 0x0f, 0xbd, 0x96, 0x93, 0x71, 0x08, 0x9f, 0xfb, 0xef, 0xa4, 0xc4, 0xda, 0xa5, 0xcf, 0xa0, 0x74, 0x91, 0x1b, 0xc7, 0x17, 0x9a, 0x67, 0xf2, 0xaf, 0xd1, 0x0e, 0x5c, 0x94, 0xf6, 0x5e, 0x6b, 0xa6, 0x3e, 0x4c, 0x93, 0x9c, 0x53, 0x65, 0x78, 0x99, 0x9d, 0x08, 0x52, 0x00, 0xc0, 0xd3, 0x96, 0x8a, 0x66, 0x5b, 0xd3, 0x96, 0x3e, 0x20, 0xd9, 0xc0, 0x45, 0xc0, 0x21, 0xb4, 0x44, 0x6a, 0x69, 0x45, 0x99, 0x96, 0x9f, 0xb9, 0x3b, 0xf3, 0x00, 0x67, 0xf9, 0xa1, 0x81, 0x85, 0x02, 0xa1, 0x6e, 0x3b, 0xaa, 0x8a, 0x51, 0xfb, 0x6b, 0x7d, 0x15, 0x15, 0x2a, 0x5a, 0x6b, 0x86, 0xbc, 0x34, 0x6d, 0x11, 0xa9, 0x03, 0x81, 0x92, 0x30, 0x99, 0x81, 0x8e, 0x8b, 0xd8, 0x19, 0x0e, 0x74, 0x21, 0x70, 0xae, 0xe7, 0x0f, 0x0a, 0xf1, 0x2a, 0x66, 0xed, 0xd7, 0x0b, 0x46, 0x02, 0xb2, 0x69, 0xa5, 0xbf, 0x35, 0xf5, 0xfc, 0x03, 0xce, 0x3a, 0x3f, 0x41, 0x36, 0xdb, 0x13, 0xe1, 0x46, 0x1c, 0x3c, 0xe3, 0x0c, 0xa4, 0x54, 0xc6, 0x1e, 0x82, 0xc3, 0xa8, 0x2e, 0x6d, 0xeb, 0xae, 0xdf, 0x50, 0xa3, 0xa6, 0xd7, 0x06, 0xe7, 0xeb, 0x15, 0x61, 0xcd, 0x89, 0x85, 0x72, 0xbb, 0xa2, 0xd2, 0x04, 0xd8, 0x11, 0x7c, 0x6a, 0xc0, 0x4c, 0x2a, 0x7b, 0x7c, 0x8f, 0x41, 0xda, 0xb1, 0x37, 0xb5, 0x7b, 0x17, 0x6c, 0x20, 0x62, 0x2d, 0x02, 0x11, 0xae, 0x2c, 0xa1, 0xa6, 0xd7, 0x39, 0x24, 0x5d, 0x34, 0xde, 0x40, 0x27, 0xc0, 0xbb, 0x66, 0xbe, 0x1d, 0x79, 0xea, 0x39, 0xd9, 0x00, 0x64, 0xde, 0xf1, 0xea, 0x57, 0x37, 0x93, 0x37, 0x10, 0x68, 0x28, 0x42, 0xd1, 0xbf, 0x92, 0xf3, 0x2f, 0x8d, 0xb2, 0x37, 0xb9, 0x34, 0x2e, 0xad, 0xda, 0x82, 0x71, 0xa3, 0x01, 0x3d, 0xf3, 0x40, 0xfe, 0xff, 0xba, 0x02, 0xb0, 0x44, 0x21, 0x6c, 0xdd, 0xc2, 0xd8, 0xf8, 0x61, 0xf9, 0x2c, 0x53, 0x8b, 0x0a, 0x88, 0xc9, 0xc4, 0xcc, 0x3c, 0xfe, 0x71, 0x1d, 0x7e, 0xe0, 0x1b, 0x76, 0xae, 0xd9, 0xcd, 0xc3, 0xdf, 0x49, 0xbe, 0x71, 0x92, 0x33, 0x30, 0xc8, 0xc4, 0x37, 0x98, 0x7b, 0x2c, 0xc0, 0xff, 0x7d, 0xbe, 0x7e, 0xa8, 0x17, 0x73, 0x17, 0xf3, 0x38, 0x4c, 0x19, 0x81, 0x0c, 0x95, 0x34, 0x99, 0xcf, 0x67, 0xa6, 0xcb, 0xe4, 0x70, 0xf6, 0xd3, 0x21, 0xf6, 0xe5, 0xc0, 0x6e, 0x1a, 0xa2, 0x55, 0x8e, 0x5a, 0x3d, 0xaf, 0x3c, 0x5a, 0x5e, 0x28, 0x7a, 0xe4, 0x37, 0x7c, 0x26, 0x2d, 0xb7, 0x2a, 0xce, 0x5a, 0x00, 0x1d, 0xc5, 0x42, 0x1c, 0x8c, 0x76, 0x76, 0xeb, 0x1f, 0xf9, 0x7f, 0x60, 0x53, 0xe4, 0x66, 0xed, 0x1f, 0x64, 0x7a, 0x3c, 0xd8, 0x8c, 0x4d, 0x20, 0x52, 0xec, 0x00, 0xcb, 0x48, 0x66, 0xc0, 0x41, 0xfd, 0x3d, 0x91, 0x0d, 0x24, 0x6f, 0x4a, 0x32, 0xfd, 0x45, 0xe1, 0x64, 0xc2, 0x28, 0xe9, 0x78, 0x41, 0xb6, 0x59, 0x1a, 0xca, 0x15, 0x8f, 0xbe, 0x4b, 0x87, 0x95, 0xd9, 0xba, 0x3f, 0xa2, 0x50, 0xb3, 0x74, 0xe4, 0x30, 0x63, 0xb3, 0x7c, 0xa1, 0xa4, 0x79, 0xcb, 0x15, 0x69, 0x01, 0xec, 0xc5, 0x5d, 0x5b, 0x81, 0x5e, 0xc7, 0xbe, 0xb3, 0xf7, 0xb1, 0x1f, 0x74, 0x47, 0x49, 0x02, 0x07, 0x15, 0x87, 0x91, 0xc3, 0xef, 0x10, 0xeb, 0x14, 0x1f, 0x5b, 0xbe, 0xc2, 0xdb, 0x12, 0x18, 0x76, 0xbc, 0xbb, 0x7a, 0x7a, 0x72, 0x97, 0x2f, 0xc0, 0xb5, 0xca, 0xdb, 0x26, 0x7e, 0xbd, 0x57, 0xf8, 0x78, 0xc1, 0xbc, 0xb6, 0xb1, 0xf5, 0xbe, 0x18, 0x96, 0x69, 0x3c, 0x50, 0x1e, 0x83, 0x14, 0x8f, 0x45, 0xa2, 0x3c, 0xca, 0xbc, 0x02, 0x0f, 0xbe, 0xdf, 0xe0, 0xe4, 0x32, 0xe7, 0xde, 0xe5, 0x7c, 0x61, 0xa8, 0x1f, 0x46, 0xdf, 0xd8, 0xd5, 0x92, 0xed, 0x17, 0x1a, 0xfc, 0x46, 0x85, 0x9f, 0x3f, 0x48, 0x5c, 0xc9, 0xfb, 0xa6, 0xd0, 0x06, 0xb6, 0x5d, 0x39, 0x62, 0x20, 0xe9, 0x73, 0x55, 0x9b, 0xb8, 0x85, 0xdf, 0xfa, 0xdf, 0x82, 0xd7, 0x89, 0x0c, 0xad, 0x81, 0x4e, 0xbb, 0xe0, 0x5e, 0x8f, 0xad, 0x2f, 0x48, 0x95, 0x96, 0xc8, 0xbe, 0xaf, 0x17, 0x1d, 0x7c, 0x79, 0xeb, 0x46, 0x4e, 0x5d, 0x65, 0xa0, 0x27, 0x5b, 0x1a, 0xbb, 0x6d, 0x06, 0xdb, 0x73, 0x98, 0xcf, 0xe6, 0x5c, 0xfb, 0x86, 0x5c, 0x64, 0xe1, 0x1e, 0xf6, 0xb3, 0xdc, 0xb1, 0xf4, 0xd6, 0x5a, 0xc3, 0x57, 0x1d, 0x79, 0xcb, 0x50, 0x41, 0x1d, 0xf0, 0xf8, 0x4a, 0x3f, 0x10, 0x41, 0xb0, 0x88, 0x06, 0x2d, 0xc1, 0x1e, 0x2d, 0x3e, 0x42, 0xbe, 0x20, 0x2d, 0x59, 0x0b, 0xc4, 0xdf, 0xab, 0x25, 0x89, 0x94, 0xc1, 0x7e, 0xec, 0x62, 0xb0, 0xe9, 0x41, 0xe2, 0xf9, 0xf4, 0xaf, 0x29, 0xae, 0x78, 0x7c, 0xf9, 0xd6, 0x6e, 0x8a, 0x39, 0x13, 0x04, 0x22, 0xa3, 0x82, 0xf1, 0xf1, 0xbd, 0xe3, 0x05, 0x50, 0x0a, 0xfa, 0x04, 0xc9, 0x81, 0x34, 0xb4, 0xd6, 0x3e, 0x8e, 0x35, 0xeb, 0x78, 0xb3, 0x91, 0xb7, 0xb3, 0x64, 0x94, 0xa8, 0x36, 0x1d, 0xde, 0xad, 0xc0, 0xf6, 0x36, 0x3f, 0x77, 0xc7, 0x21, 0xa2, 0x21, 0x8f, 0xb3, 0x68, 0x96, 0x17, 0xa6, 0x38, 0x75, 0xd2, 0xa9, 0xcd, 0x17, 0x08, 0xfa, 0x41, 0xc1, 0x33, 0x37, 0x8c, 0x1e, 0xaa, 0x72, 0x48, 0xec, 0x7c, 0x83, 0xb7, 0xf5, 0x9f, 0xa2, 0x06, 0x41, 0x4a, 0x35, 0xd3, 0x8a, 0x9f, 0xe6, 0xee, 0xf0, 0x8d, 0xf9, 0x5c, 0xee, 0xf5, 0xdc, 0xa2, 0x8d, 0x0b, 0x00, 0x40, 0xd7, 0x00, 0xe8, 0x7b, 0x8f, 0xde, 0x80, 0x5f, 0x1f, 0xb3, 0xaf, 0x05, 0xd2, 0xf1, 0x2f, 0x12, 0x43, 0x15, 0x9d, 0x80, 0x16, 0x87, 0xcc, 0xa1, 0xe5, 0xc1, 0x5f, 0x60, 0x7d, 0xb4, 0x97, 0xcb, 0x4b, 0x67, 0x69, 0xce, 0x11, 0xe2, 0xd4, 0x41, 0xdd, 0x4a, 0x71, 0x26, 0x3c, 0x4d, 0x4c, 0x2b, 0xab, 0xc1, 0xf2, 0x77, 0x4e, 0x87, 0xcb, 0xa2, 0xe5, 0xb6, 0xaa, 0x05, 0xfb, 0xf5, 0xa3, 0x35, 0x60, 0x29, 0x1d, 0xca, 0xda, 0x51, 0x27, 0x65, 0x18, 0xad, 0x10, 0xf1, 0xe7, 0x26, 0x31, 0x28, 0xa9, 0xea, 0x0e, 0x59, 0x02, 0x57, 0x9e, 0x69, 0xd4, 0x1a, 0xe6, 0x19, 0x6e, 0x98, 0xcd, 0x86, 0x00, 0x8d, 0x2b, 0xf6, 0x52, 0xf2, 0x23, 0xd1, 0xb6, 0x25, 0xb3, 0xee, 0x3c, 0x44, 0x89, 0x10, 0x24, 0xd9, 0x18, 0xb1, 0x99, 0xbd, 0xec, 0xfe, 0x9c, 0x36, 0x3a, 0x22, 0x3e, 0x63, 0xbc, 0xc7, 0x12, 0xda, 0xbb, 0xda, 0xe2, 0x8f, 0x6e, 0x8f, 0xa1, 0xf8, 0x82, 0xa6, 0xa1, 0x6e, 0xfa, 0xec, 0x06, 0xd7, 0x39, 0x04, 0x7b, 0x82, 0x5d, 0x67, 0x23, 0x52, 0xcf, 0xaa, 0xd2, 0x1f, 0x18, 0x00, 0x7e, 0x59, 0xf7, 0xff, 0xf0, 0xee, 0xb0, 0xa7, 0xbf, 0x6e, 0xa6, 0xa0, 0x7f, 0x6e, 0x2c, 0xc3, 0x36, 0x2a, 0x99, 0xdc, 0x0f, 0x6e, 0x9a, 0xae, 0x53, 0xb6, 0xcd, 0x38, 0x94, 0x94, 0x8b, 0x37, 0x2c, 0x52, 0x05, 0xec, 0xe6, 0xd8, 0x92, 0x1f, 0xfa, 0xd1, 0x47, 0x64, 0x3f, 0x0a, 0xc9, 0x9d, 0x9c, 0x1a, 0x5f, 0xc0, 0xbf, 0x48, 0x4b, 0xdb, 0x12, 0xa9, 0x5b, 0x55, 0xeb, 0x89, 0xbb, 0x76, 0x04, 0x0c, 0x0d, 0x29, 0x2a, 0x15, 0xbb, 0x01, 0x39, 0x67, 0x8c, 0x7b, 0x47, 0x0b, 0x76, 0x83, 0x20, 0xf1, 0xb4, 0x39, 0xf3, 0xda, 0x18, 0xf4, 0x4a, 0x74, 0xa1, 0x87, 0x3f, 0xc7, 0x50, 0xc4, 0xed, 0xd1, 0x38, 0x3f, 0x26, 0x6d, 0xd5, 0x55, 0x64, 0x7a, 0x9e, 0x6c, 0x01, 0x38, 0xdd, 0x7b, 0xaa, 0xf5, 0xbf, 0xce, 0x11, 0xea, 0xa7, 0x03, 0xe2, 0x60, 0xc8, 0x59, 0xf9, 0x17, 0xf3, 0x2a, 0xd2, 0xe7, 0xad, 0xb5, 0x40, 0xa8, 0x85, 0x21, 0x62, 0x50, 0xa5, 0xbf, 0xd3, 0x5b, 0xa6, 0x90, 0x22, 0x70, 0xa9, 0x07, 0x82, 0x41, 0xa3, 0x0f, 0xc2, 0xb3, 0xf8, 0x50, 0x7f, 0x3f, 0x4c, 0xae, 0x98, 0x97, 0x95, 0x13, 0xe2, 0x8d, 0x75, 0x6f, 0x1d, 0x31, 0xc8, 0xfd, 0x27, 0x3a, 0x79, 0xc7, 0x70, 0xa8, 0x99, 0x6c, 0xae, 0xa7, 0xb2, 0x21, 0xd2, 0xb5, 0x58, 0xf6, 0x3a, 0x07, 0x02, 0x5b, 0x28, 0x29, 0x18, 0xe2, 0x73, 0xe6, 0x4d, 0x46, 0x7c, 0x67, 0x2f, 0xad, 0x64, 0x9f, 0xfc, 0x2a, 0x7c, 0xe6, 0xb8, 0x86, 0xfd, 0xe3, 0x7c, 0x40, 0xfa, 0xb0, 0x11, 0xd2, 0x92, 0x39, 0xbe, 0x36, 0x6a, 0xe5, 0x5d, 0xa9, 0x5b, 0x79, 0xb4, 0xaf, 0x67, 0x39, 0x03, 0x57, 0xf2, 0x50, 0xda, 0xc0, 0x2e, 0x71, 0x2d, 0xdc, 0xd8, 0xbf, 0xaa, 0x74, 0x22, 0xea, 0x4a, 0x6c, 0xf0, 0x9b, 0x27, 0x49, 0x46, 0x13, 0x8d, 0xf0, 0x01, 0x0f, 0x53, 0xb0, 0xc6, 0xee, 0x6c, 0x83, 0x39, 0x15, 0xb9, 0x91, 0x6f, 0x93, 0x21, 0xf6, 0xa5, 0x01, 0xe4, 0xc5, 0x32, 0xac, 0x2c, 0x4d, 0xba, 0xf7, 0xe6, 0x9b, 0xa5, 0xfa, 0xcf, 0x40, 0xcf, 0x6f, 0xd2, 0x54, 0x81, 0xcf, 0x91, 0xba, 0xa1, 0xb8, 0x42, 0xa6, 0x25, 0x92, 0xbc, 0x5d, 0xcd, 0x72, 0xd1, 0x3c, 0x12, 0x3e, 0xdf, 0xfc, 0x5a, 0x13, 0xa2, 0x34, 0x6d, 0xe3, 0x4c, 0x1f, 0x2c, 0x63, 0xd8, 0xa0, 0x81, 0x24, 0x9b, 0x83, 0x92, 0xff, 0x1c, 0x06, 0x3a, 0xb7, 0x25, 0x98, 0xb9, 0xda, 0x1a, 0xe0, 0xaa, 0xe8, 0x8a, 0x01, 0x36, 0xb7, 0x04, 0x1d, 0x88, 0x16, 0x2c, 0x18, 0x80, 0xb1, 0x0d, 0x9e, 0xac, 0x35, 0xb1, 0x67, 0x74, 0xb4, 0xef, 0xb9, 0x94, 0x4a, 0x85, 0x2f, 0xd0, 0x01, 0x67, 0xba, 0xe2, 0xf2, 0x56, 0xe5, 0xb8, 0xad, 0xb3, 0x5d, 0xdc, 0xdb, 0x96, 0xb0, 0x34, 0x22, 0x1b, 0x55, 0xeb, 0x49, 0xfc, 0xed, 0xaf, 0x9d, 0x65, 0xc8, 0x1d, 0x93, 0x03, 0xab, 0x79, 0xae, 0x5f, 0xd0, 0xa3, 0xa3, 0x6a, 0x2f, 0x46, 0xbc, 0x58, 0xfc, 0x53, 0x7a, 0xb2, 0x71, 0xae, 0x7e, 0xa7, 0xcd, 0x27, 0xa9, 0xa4, 0x9d, 0xab, 0x83, 0x24, 0x3a, 0xbb, 0xd9, 0xc8, 0x93, 0x1e, 0xab, 0xaa, 0x2c, 0xd3, 0x45, 0xef, 0x67, 0x4a, 0xab, 0x9b, 0x03, 0xd4, 0x3a, 0xa9, 0xe2, 0x57, 0x8d, 0x5c, 0x0f, 0x46, 0x9e, 0xd0, 0xff, 0xd0, 0x2d, 0xd4, 0x17, 0x58, 0x66, 0xfc, 0x6f, 0x26, 0xbe, 0xf1, 0xd6, 0x5c, 0x1e, 0x0c, 0x16, 0x2b, 0x43, 0x23, 0x79, 0x46, 0x65, 0xa3, 0x8b, 0x97, 0x16, 0xdf, 0x22, 0x32, 0x6e, 0xa8, 0x9c, 0x87, 0x65, 0x1e, 0x68, 0xdb, 0x80, 0xc5, 0xc8, 0xf9, 0xb0, 0xdc, 0xd4, 0x24, 0x77, 0xea, 0xc3, 0x51, 0x4c, 0x99, 0x66, 0x93, 0x41, 0xc7, 0xf5, 0xd7, 0xe3, 0xdb, 0x0e, 0xd1, 0x61, 0x55, 0xfb, 0x36, 0xf1, 0xaa, 0x34, 0x2c, 0x70, 0x4e, 0x24, 0xff, 0x48, 0x12, 0x30, 0x15, 0x97, 0xb0, 0xf6, 0x24, 0x8e, 0xa4, 0xd2, 0xa2, 0x17, 0x3e, 0xa7, 0x7d, 0xba, 0xf6, 0xdc, 0x0d, 0xc1, 0xff, 0xa4, 0x47, 0x9a, 0x1f, 0x83, 0x33, 0x7e, 0xbd, 0x0e, 0xa0, 0x50, 0x3c, 0xf2, 0x16, 0xc8, 0x87, 0x37, 0x0c, 0xd0, 0xed, 0xc6, 0x5b, 0x2e, 0x30, 0x29, 0xf3, 0x64, 0xd8, 0x93, 0xcc, 0xd4, 0xcd, 0x20, 0x20, 0x28, 0x25, 0x5d, 0xd8, 0xf1, 0x3b, 0x0b, 0x44, 0x8e, 0x01, 0x20, 0x0e, 0x50, 0x97, 0x0f, 0x71, 0xdc, 0x1c, 0x49, 0xa6, 0xd0, 0xc4, 0x04, 0x9f, 0xa9, 0x2a, 0x3b, 0xf8, 0xe4, 0xe8, 0xf6, 0x2b, 0x63, 0x66, 0xcb, 0x03, 0x13, 0xef, 0xa5, 0x53, 0xcc, 0x0a, 0xc4, 0xe7, 0x78, 0x07, 0x05, 0xbb, 0x78, 0xd8, 0x64, 0x6b, 0x43, 0x22, 0xbf, 0xeb, 0x50, 0x94, 0xdd, 0x78, 0x37, 0x78, 0xae, 0xce, 0x13, 0x87, 0xd4, 0x9c, 0x2a, 0x02, 0x63, 0x35, 0xd0, 0xfe, 0xe5, 0x88, 0x88, 0x00, 0xa2, 0x52, 0x6d, 0xc9, 0x1e, 0x92, 0xd0, 0x73, 0xe2, 0x3e, 0x23, 0xbd, 0x7f, 0x34, 0x15, 0xa4, 0xd1, 0x73, 0xff, 0x33, 0x81, 0x8b, 0x7f, 0x9b, 0xcd, 0x52, 0x62, 0x86, 0x8c, 0xd9, 0xc8, 0xa9, 0x6c, 0x9e, 0x82, 0x98, 0x7f, 0x03, 0xbf, 0xdf, 0xf6, 0xff, 0xe8, 0x4e, 0x2c, 0x14, 0xc8, 0x94, 0xe6, 0x81, 0xf0, 0x10, 0xd9, 0xb8, 0x5a, 0xe3, 0x6c, 0x12, 0x4c, 0x4a, 0xc0, 0xc2, 0x7f, 0x2b, 0xed, 0x08, 0x81, 0xed, 0x8f, 0xa7, 0x58, 0x8d, 0x82, 0x98, 0x68, 0xee, 0xe9, 0x00, 0x97, 0x71, 0x75, 0x60, 0xae, 0xc6, 0xe4, 0x0b, 0x02, 0x02, 0xc7, 0xde, 0x55, 0xf1, 0x89, 0x2b,
	};

	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("DIGEST(init/dofinal return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));

	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;
	LOG_INFO("DIGEST(reset), input data size == %u, hash_size == %u\n",
		 arg.ca_data.src_size, hash_size);

	DUMP_HEX("DIGEST RESULT:", hash, hash_size);
	static const uint8_t sha1[] = {
		0x18, 0xde, 0x12, 0x2b, 0xf5, 0x88, 0xdc, 0x3d,
		0x1e, 0xca, 0x78, 0x66, 0x16, 0x73, 0xfa, 0x8d,
		0x8a, 0xcf, 0x25, 0x4e,
	};
	static const uint8_t sha256[] = {
		0xec, 0xa2, 0x8c, 0x29, 0x03, 0xde, 0xbd, 0xb2, 0x62, 0xac, 0x13, 0x78, 0x94, 0x00, 0xc4, 0x05,
		0xf7, 0x53, 0xe2, 0xc2, 0x3e, 0x8b, 0x7d, 0x22, 0xfd, 0x5c, 0x9f, 0x7e, 0xd1, 0x91, 0xf4, 0x25,
	};
	static const uint8_t sha384[] = {
		0xca, 0x35, 0xfa, 0x4f, 0x9e, 0xf9, 0xec, 0xe4, 0xdb, 0x14, 0xdb, 0xc6, 0xad, 0xd1, 0xc8, 0x79,
		0x1b, 0xea, 0xfd, 0xff, 0x2b, 0xb4, 0xa0, 0x16, 0xf9, 0x35, 0xb9, 0x4c, 0xf8, 0x84, 0x8e, 0xd5,
		0x19, 0x53, 0x36, 0xd1, 0x7b, 0x20, 0x8a, 0x9d, 0x8e, 0xbb, 0xd2, 0x9c, 0xa3, 0x50, 0x6f, 0x8a,
	};
	static const uint8_t sha512[] = {
		0x9a, 0x51, 0xfc, 0xe6, 0x99, 0xbb, 0x0a, 0x2d, 0xed, 0xcf, 0xde, 0x7c, 0xa6, 0x4e, 0xf6, 0x68,
		0x3f, 0xd9, 0x54, 0x15, 0xd8, 0x63, 0xa9, 0x29, 0x53, 0x10, 0x82, 0x86, 0x4a, 0xd7, 0xed, 0xaf,
		0x73, 0x49, 0x25, 0xe9, 0x91, 0x7d, 0x39, 0x4f, 0xe8, 0x3a, 0x8c, 0xe6, 0x08, 0xb6, 0xed, 0xe0,
		0xb9, 0xc9, 0x34, 0x54, 0x4d, 0xe0, 0xcc, 0xe4, 0xdf, 0x9a, 0xe4, 0x09, 0xb8, 0xb0, 0x96, 0xe4,
	};

#if HAVE_NIST_TRUNCATED_SHA2
	static const uint8_t sha512_224[] = {
		0x3c, 0x6a, 0x53, 0xde, 0xc4, 0x1c, 0x61, 0xb2, 0xd3, 0xaa, 0x42, 0x25, 0x2f, 0x44, 0x48, 0xf7,
		0xd2, 0x47, 0xe2, 0x8f, 0xcb, 0x98, 0xa8, 0x9a, 0xc9, 0xb4, 0x63, 0x58,
	};
	static const uint8_t sha512_256[] = {
		0x3b, 0xca, 0xe7, 0x1b, 0x66, 0xd7, 0x68, 0xde, 0x83, 0x80, 0x9e, 0x62, 0xed, 0x1d, 0xca, 0xb8,
		0x5e, 0x5b, 0x0d, 0x51, 0x17, 0x18, 0xff, 0xa0, 0x81, 0xbf, 0x70, 0x71, 0xef, 0xde, 0x8f, 0xb7,
	};
#endif

	const uint8_t *correct = NULL;

	switch (digest) {
	case TE_ALG_MD5:
		TRAP_ASSERT(hash_size == 16);
		break;
	case TE_ALG_SHA1:
		correct = sha1;
		TRAP_ASSERT(hash_size == 20);
		break;
	case TE_ALG_SHA224:
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA256:
		correct = sha256;
		TRAP_ASSERT(hash_size == 32);
		break;
	case TE_ALG_SHA384:
		correct = sha384;
		TRAP_ASSERT(hash_size == 48);
		break;
	case TE_ALG_SHA512:
		correct = sha512;
		TRAP_ASSERT(hash_size == 64);
		break;
#if HAVE_NIST_TRUNCATED_SHA2
	case TE_ALG_SHA512_224:
		correct = sha512_224;
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA512_256:
		correct = sha512_256;
		TRAP_ASSERT(hash_size == 32);
		break;
#endif
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* LONG_DIGEST_TEST */

#if HAVE_NIST_TRUNCATED_SHA2
__STATIC__ status_t TEST_digest_truncated(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t data[3U] = "abc";
	uint8_t hash[64U];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	/* First callwlate digest of NULL input
	 */
	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_data.src_size = 0U;
	arg.ca_data.src = NULL;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;

	DUMP_HEX("NULL INPUT DIGEST RESULT:", hash, hash_size);

	/* Verify result */
	{
		const uint8_t *correct = NULL;

		static const uint8_t sha512_224[] = {
			0x6e, 0xd0, 0xdd, 0x02, 0x80, 0x6f, 0xa8, 0x9e,
			0x25, 0xde, 0x06, 0x0c, 0x19, 0xd3, 0xac, 0x86,
			0xca, 0xbb, 0x87, 0xd6, 0xa0, 0xdd, 0xd0, 0x5c,
			0x33, 0x3b, 0x84, 0xf4,
		};

		static const uint8_t sha512_256[] = {
			0xc6, 0x72, 0xb8, 0xd1, 0xef, 0x56, 0xed, 0x28,
			0xab, 0x87, 0xc3, 0x62, 0x2c, 0x51, 0x14, 0x06,
			0x9b, 0xdd, 0x3a, 0xd7, 0xb8, 0xf9, 0x73, 0x74,
			0x98, 0xd0, 0xc0, 0x1e, 0xce, 0xf0, 0x96, 0x7a,
		};

		switch (digest) {
		case TE_ALG_SHA512_224:
			correct = sha512_224;
			TRAP_ASSERT(28U == hash_size);
			break;
		case TE_ALG_SHA512_256:
			correct = sha512_256;
			TRAP_ASSERT(32U == hash_size);
			break;
		default:
			CCC_ERROR_MESSAGE("Correct result not defined for digest 0x%x\n",
					  digest);
			break;
		}

		if (NULL != correct) {
			VERIFY_ARRAY_VALUE(hash, correct, hash_size);
		} else {
			LOG_ERROR("algo 0x%x result not verified\n", digest);
		}
	}

	/* Then callwlate truncated sha from data array
	 */
	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));
	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;

	DUMP_HEX("DIGEST RESULT:", hash, hash_size);

	/* Verify result */
	{
		const uint8_t *correct = NULL;

		static const uint8_t sha512_224[] = {
			0x46, 0x34, 0x27, 0x0F, 0x70, 0x7B, 0x6A, 0x54,
			0xDA, 0xAE, 0x75, 0x30, 0x46, 0x08, 0x42, 0xE2,
			0x0E, 0x37, 0xED, 0x26, 0x5C, 0xEE, 0xE9, 0xA4,
			0x3E, 0x89, 0x24, 0xAA,
		};

		static const uint8_t sha512_256[] = {
			0x53, 0x04, 0x8E, 0x26, 0x81, 0x94, 0x1E, 0xF9,
			0x9B, 0x2E, 0x29, 0xB7, 0x6B, 0x4C, 0x7D, 0xAB,
			0xE4, 0xC2, 0xD0, 0xC6, 0x34, 0xFC, 0x6D, 0x46,
			0xE0, 0xE2, 0xF1, 0x31, 0x07, 0xE7, 0xAF, 0x23,
		};

		switch (digest) {
		case TE_ALG_SHA512_224:
			correct = sha512_224;
			TRAP_ASSERT(28U == hash_size);
			break;
		case TE_ALG_SHA512_256:
			correct = sha512_256;
			TRAP_ASSERT(32U == hash_size);
			break;
		default:
			CCC_ERROR_MESSAGE("Correct result not defined for digest 0x%x\n", digest);
			break;
		}

		if (NULL != correct) {
			VERIFY_ARRAY_VALUE(hash, correct, hash_size);
		} else {
			LOG_ERROR("algo 0x%x result not verified\n", digest);
		}
	}


fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_NIST_TRUNCATED_SHA2 */

__STATIC__ status_t TEST_digest_with_update(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	unsigned char data[16] = "0000000000000000";
	static uint8_t hash[128];

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_opcode = TE_OP_INIT;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init return): ret %d (sizeof arg %u)\n",
		   ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	arg.ca_opcode = TE_OP_UPDATE;

	arg.ca_data.src_size = 16;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = 0;
	arg.ca_data.dst = NULL;

	LOG_INFO("DIGEST(update) DATA ADDR %p, HASH ADDR %p\n",
		   data, hash);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(update return) handle %u: ret %d\n",
		   arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	arg.ca_opcode = TE_OP_DOFINAL;

	arg.ca_data.src_size = 16;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	LOG_INFO("DIGEST(dofinal) DATA ADDR %p, HASH ADDR %p\n",
		   data, hash);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(dofinal return) handle %u: ret %d\n",
		   arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DIGEST RESULT:", hash, arg.ca_data.dst_size);
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_digest_with_update_long(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t data1[] = {
		0xE3, 0xDB, 0x47, 0xA1, 0x1E, 0x10, 0xE7, 0x88, 0x92, 0x5D, 0x14, 0xB1, 0xE2, 0x8B, 0x54, 0xC9, 0xFC, 0xF9, 0xB6, 0xAC, 0xC1, 0xDF, 0x8C, 0x14, 0xF6, 0x83, 0xA5, 0x67, 0x2F, 0xD5, 0x04, 0xDD,
		0xB8, 0xCE, 0xA2, 0x15, 0xA0, 0x12, 0x4E, 0xED, 0x27, 0x00, 0x57, 0x25, 0xD8, 0x97, 0x78, 0x1E, 0xA0, 0x64, 0xDC, 0xEF, 0xB2, 0x14, 0x22, 0xC8, 0xBD, 0x24, 0x02, 0xC5, 0x6A, 0x10, 0x57, 0x1C,
		0x0A, 0x9F, 0xDA, 0x8B, 0x8C, 0xFC, 0xA7, 0xA5, 0xB0, 0x5D, 0x78, 0x11, 0x6F, 0xCE, 0xE1, 0x9A, 0xB8, 0x03, 0xC1, 0xC6, 0x01, 0x0C, 0xE1, 0x1D, 0xAA, 0x8E, 0x93, 0xA6, 0x6D, 0x12, 0xC1, 0x2E,
		0x47, 0x4E, 0xB9, 0x1C, 0x26, 0x40, 0xD9, 0x7A, 0x81, 0x3D, 0x9A, 0x83, 0x0D, 0x26, 0x88, 0x68, 0xEB, 0x2E, 0x37, 0x70, 0x42, 0x5F, 0x10, 0xC7, 0x58, 0x40, 0x46, 0x8E, 0x66, 0x9D, 0xC7, 0xF6,
	};

	static uint8_t data2[] = {
		0x1D, 0x3B, 0xE2, 0xDE, 0x88, 0xAE, 0x0E, 0x54, 0x2B, 0xC8, 0x09, 0x67, 0x91, 0x13, 0x95, 0x7A, 0x14, 0xDA, 0x4E, 0xAF, 0xF5, 0x49, 0xBF, 0xDE, 0x63, 0x7D, 0x7C, 0xAF, 0xDC, 0x6A, 0xA8, 0x39,
		0x94, 0x83, 0x73, 0x97, 0xF8, 0x6E, 0x4F, 0xDE, 0x86, 0xD4, 0x02, 0xFA, 0x9A, 0xEF, 0x7F, 0x65, 0x54, 0x9A, 0x21, 0x43, 0x73, 0xE5, 0x60, 0xE6, 0xD7, 0xA1, 0xC2, 0x76, 0x9E, 0x0C, 0x7D, 0x5A,
		0x01, 0x71, 0xE7, 0xCC, 0x00, 0xDF, 0xF3, 0x6E, 0x04, 0x29, 0x79, 0x8B, 0x53, 0xAA, 0x62, 0x16, 0x24, 0xBD, 0xA7, 0x4D, 0x6D, 0xF0, 0xBF, 0xFF, 0xFB, 0xD8, 0xFD, 0x7B, 0xEF, 0x1A, 0x64, 0xF3,
		0x6C, 0x00, 0x07, 0x82, 0xF6, 0xED, 0x03, 0x1A, 0xF5, 0xC2, 0xA7, 0x4A, 0x18, 0x96, 0x35, 0x98, 0xC9, 0xBA, 0x06, 0x23, 0x92, 0xDE, 0x96, 0x02, 0x03, 0x67, 0x94, 0xB7, 0xB5, 0xE6, 0x8C, 0x25,
		0xC9, 0x3F, 0xE7, 0xCF, 0xAD, 0x47, 0xA7, 0xC5, 0xB9, 0x79, 0xD4, 0x76, 0xCD, 0x51, 0x3A, 0x12, 0xBF, 0x03, 0x07, 0xCB, 0x16, 0x31, 0x74, 0x00, 0x42, 0xA9, 0xFB, 0xF3, 0xEB, 0x0B, 0xE5, 0x17,
		0x06, 0x20, 0xDA, 0xFD, 0x5F, 0x16, 0xED, 0x89, 0x34, 0x2C, 0x26, 0x25, 0xD7, 0x83, 0xE7, 0x4E, 0xE0, 0xD7, 0x84, 0xBF, 0x05, 0x19, 0x43, 0x74, 0x0C, 0x88, 0xB0, 0xBE, 0xF7, 0xBC, 0x85, 0xE1,
		0xA6, 0xA4, 0xA5, 0x17, 0xD4, 0x92, 0xFB, 0x73, 0x7E, 0x77, 0x66, 0x99, 0x59, 0x0C, 0x93, 0x22, 0x4C, 0xD4, 0xD9, 0x24, 0x5D, 0x4E, 0x93, 0x71, 0xA3, 0x67, 0xC0, 0x71, 0x2F, 0x87, 0x49, 0x0F,
		0x92, 0x47, 0xC4, 0x9A, 0xDD, 0x93, 0x13, 0xF2, 0x77, 0xA4, 0xD9, 0xF2, 0x6B, 0x75, 0xAA, 0xE4, 0xDE, 0xD6, 0xA3, 0xDE, 0xF8, 0x5F, 0x83, 0xFC, 0x99, 0x59, 0x10, 0x40, 0x55, 0x48, 0xAF, 0x67,
		0x0E, 0xD8, 0xAA, 0xA3, 0x05, 0x24, 0xAB, 0x82, 0x9C, 0xCB, 0x56, 0xA5, 0x00, 0x5B, 0x58, 0xBC, 0xE8, 0x68, 0xC9, 0xE8, 0x07, 0x4F, 0x07, 0xDD, 0x7F, 0x38, 0x18, 0xF2, 0x99, 0xE4, 0xE0, 0x86,
		0xBE, 0xD9, 0xEA, 0xB9, 0x02, 0xCF, 0x11, 0xB3, 0x98, 0xD5, 0x31, 0xB8, 0x63, 0x2E, 0x7D, 0x52, 0x3A, 0x8F, 0x87, 0x76, 0x95, 0xF4, 0x6C, 0xCF, 0x9C, 0xE2, 0x4E, 0x62, 0xCA, 0xB2, 0xC7, 0xCD,
		0x0A, 0xAE, 0xE1, 0x7D, 0xB5, 0x26, 0x76, 0xA4, 0xB5, 0x05, 0x8E, 0x9C, 0x1D, 0x7C, 0x47, 0xBF, 0xFC, 0xB6, 0x41, 0xB0, 0xEA, 0x2B, 0x09, 0x44, 0xF3, 0x9A, 0x75, 0x66, 0x5A, 0x7E, 0xF2, 0x9B,
		0x7F, 0x02, 0xA8, 0x78, 0xDB, 0x82, 0x38, 0x83, 0xBD, 0xAC, 0xFB, 0x0F, 0xBE, 0x5D, 0xFE, 0x5A, 0x9B, 0xED, 0x9F, 0xDA, 0xC7, 0xE4, 0x14, 0x2E, 0x3E, 0xB5, 0x0D, 0x5E, 0x84, 0x0B, 0xD0, 0xAC,
		0x0B, 0xEC, 0xF4, 0xFA, 0x97, 0xE1, 0xFC, 0x48, 0x27, 0xC3, 0x97, 0xA5, 0x24, 0x65, 0xD9, 0x16, 0x88, 0x99, 0x54, 0xB3, 0x70, 0x1B, 0x0F, 0xAC, 0x61, 0x15, 0x9B, 0x23, 0x09, 0x2F, 0x46, 0x85,
		0xF4, 0x78, 0x8B, 0xAD, 0x35, 0xD0, 0x0D, 0xA2, 0x67, 0x9E, 0xCC, 0x54, 0x92, 0x1F, 0x1A, 0x86, 0x47, 0x10, 0x16, 0x57, 0xAB, 0x49, 0x47, 0x74, 0x20, 0x56, 0x7A, 0xED, 0x67, 0xC8, 0x60, 0x59,
		0x30, 0x44, 0x4B, 0x5D, 0x07, 0x92, 0x7C, 0x17, 0xEF, 0xF1, 0xF8, 0x57, 0x0C, 0xF2, 0xAF, 0x29, 0xE7, 0x19, 0xF8, 0x5C, 0xA7, 0x84, 0x9B, 0x89, 0x55, 0x49, 0xF1, 0x3D, 0xFE, 0xCA, 0x68, 0xBB,
		0xEF, 0x71, 0xE3, 0xCE, 0x8B, 0x6C, 0xED, 0xD2, 0xFF, 0x68, 0xD3, 0x2B, 0x02, 0xCA, 0xF5, 0x95, 0x1A, 0x0B, 0x3E, 0x6B, 0x0B, 0xAE, 0x6A, 0x96, 0xC0, 0x20, 0x58, 0x19, 0x1F, 0x30, 0x5E, 0x09,
		0x07, 0x11, 0xC4, 0x6D, 0xAD, 0xDC, 0xD5, 0xAE, 0xEE, 0x76, 0x9C, 0x3A, 0x10, 0x5E, 0x9A, 0x82, 0x7B, 0xBD, 0x19, 0x5D, 0x32, 0x92, 0x31, 0xC2, 0x62, 0x38, 0x47, 0x9A, 0x9B, 0xB0, 0x07, 0x1A,
		0xFB, 0x16, 0x0E, 0xF9, 0x55, 0xE8, 0x74, 0xD7, 0xA4, 0x20, 0xC5, 0x67, 0x85, 0xF4, 0x4A, 0xE0, 0xA1, 0x8C, 0x52, 0xD8, 0x28, 0x0C, 0x59, 0x98, 0xCF, 0x38, 0x88, 0xFE, 0xAF, 0x89, 0x89, 0x81,
		0x34, 0xBC, 0x8D, 0x41, 0x1F, 0xC9, 0xF6, 0xC5, 0x76, 0x8E, 0xA7, 0xA2, 0x49, 0x72, 0x94, 0x13, 0x73, 0x9E, 0x53, 0x2B, 0x64, 0x39, 0x37, 0x15, 0x2C, 0xDF, 0xB8, 0xD2, 0xFF, 0x87, 0xFD, 0x48,
		0x08, 0x4D, 0xD8, 0xAE, 0xEB, 0xEA, 0xF0, 0xF7, 0xB1, 0x0D, 0x87, 0xB6, 0xE4, 0x42, 0x32, 0x28, 0xC9, 0xFC, 0x8D, 0xC5, 0xE3, 0x85, 0x2A, 0xA8, 0xB8, 0xAC, 0xC5, 0x45, 0xD1, 0x8F, 0x25, 0xC5,
		0x5D, 0x73, 0xDA, 0x1B, 0xB8, 0x2E, 0x3E, 0xB3, 0x76, 0xF9, 0xEF, 0x05, 0xB2, 0x74, 0xD7, 0xEC, 0xB1, 0x84, 0x5D, 0x65, 0xCA, 0x0C, 0xD2, 0x62, 0x9F, 0x03, 0x8A, 0x2D, 0x66, 0x4D, 0x7A, 0x69,
		0x78, 0x1C, 0x84, 0xE9, 0x8D, 0xE2, 0xC2, 0x09, 0xC4, 0x6E, 0xFC, 0x51, 0x16, 0x21, 0x72, 0x85, 0x66, 0x49, 0x46, 0x9E, 0x67, 0x33, 0x08, 0xDC, 0xC1, 0x45, 0xEA, 0xF7, 0x83, 0xF5, 0xCB, 0x5B,
		0x4B, 0xE7, 0xD9, 0xFD, 0x58, 0xEE, 0x09, 0x74, 0xC9, 0x81, 0xA3, 0x8F, 0xEA, 0x8E, 0x31, 0x26, 0x7A, 0xBF, 0xA4, 0x10, 0xE6, 0x9E, 0x46, 0x48, 0x2F, 0x51, 0x34, 0xF3, 0xDA, 0x1F, 0xFE, 0x38,
		0x1B, 0xD6, 0x9D, 0x8D, 0x0B, 0x78, 0xEA, 0x90, 0x9B, 0x4A, 0xF9, 0x39, 0x6D, 0xCA, 0xFF, 0x89, 0x96, 0x0A, 0x04, 0x9E, 0xDA, 0x69, 0x46, 0x61, 0x6F, 0xC2, 0x7C, 0xCF, 0x9A, 0x9E, 0x5B, 0xA1,
		0xA0, 0x13, 0x57, 0x64, 0xF3, 0x77, 0x19, 0xDA, 0x4D, 0x28, 0x07, 0x81, 0x85, 0xD0, 0x4D, 0x72, 0x41, 0x9C, 0x2C, 0x70, 0xF2, 0x90, 0xD9, 0x7E, 0x1F, 0x82, 0xB8, 0x79, 0xF7, 0x1B, 0x9E, 0x19,
		0xD5, 0x04, 0xD3, 0x64, 0xCD, 0x3B, 0xA2, 0x2C, 0xF9, 0x05, 0x25, 0x0F, 0xD3, 0x7D, 0x58, 0xE5, 0xFE, 0x40, 0x20, 0x9F, 0x60, 0x72, 0xA0, 0x6D, 0x8B, 0x5B, 0xA7, 0x01, 0x96, 0x23, 0x05, 0x77,
		0x87, 0x7E, 0xC4, 0x61, 0x53, 0x16, 0x7A, 0x7C, 0x7A, 0xEA, 0x27, 0x0F, 0xA1, 0x09, 0x8A, 0xBA, 0x9E, 0x3A, 0x74, 0xAC, 0xB3, 0x6A, 0x11, 0xB0, 0x9B, 0xD0, 0x7A, 0x3B, 0x88, 0xEA, 0x65, 0x4E,
		0x26, 0x83, 0x65, 0x62, 0x5B, 0x58, 0x9B, 0x22, 0x06, 0xC7, 0x10, 0xD9, 0x60, 0xF4, 0x2E, 0xA4, 0x19, 0xB7, 0xE4, 0xE3, 0xDA, 0x47, 0x59, 0xFC, 0xBC, 0xA5, 0x0E, 0x4B, 0xF4, 0xCC, 0x55, 0xCF,
		0x88, 0xF7, 0x0B, 0x31, 0x80, 0xC8, 0x05, 0xA7, 0x04, 0x50, 0x86, 0xAF, 0xA0, 0x4C, 0x6B, 0xE2, 0x32, 0x23, 0xEC, 0xAE, 0x5F, 0x82, 0xC1, 0x46, 0xD5, 0x43, 0x11, 0xD1, 0x80, 0x7C, 0x2E, 0x4A,
		0x53, 0xF9, 0xE0, 0xA4, 0x48, 0x2B, 0x4E, 0x1E,
	};

	static uint8_t hash[128];

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_opcode = TE_OP_INIT;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	arg.ca_opcode = TE_OP_UPDATE;

	arg.ca_data.src_size = sizeof_u32(data1);
	arg.ca_data.src = data1;
	arg.ca_data.dst_size = 0;
	arg.ca_data.dst = NULL;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(update return) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	arg.ca_opcode = TE_OP_DOFINAL;

	arg.ca_data.src_size = sizeof_u32(data2);
	arg.ca_data.src = data2;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(dofinal return) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	const uint8_t correct[] = {
		0x04, 0xD5, 0x35, 0xED, 0xDA, 0xA3, 0xF9, 0x0D, 0xCF, 0x55, 0x33, 0x42, 0x8D, 0x7B, 0xD5, 0x0A, 0x8D, 0xDC, 0x15, 0x05, 0xE4, 0xCF, 0x75, 0x2F, 0x29, 0x87, 0x91, 0xF5, 0xA4, 0x8E, 0x40, 0x83,
		0x1F, 0x21, 0x45, 0x97, 0xB6, 0xBA, 0xED, 0x3C, 0x54, 0x01, 0x79, 0x9C, 0x90, 0xC7, 0x60, 0xCF, 0x6C, 0xC1, 0x35, 0x63, 0xC7, 0xF4, 0x30, 0x72, 0x9C, 0x7B, 0xD2, 0x53, 0x75, 0xA0, 0xB2, 0x12,
	};

	DUMP_HEX("DIGEST RESULT:", hash, arg.ca_data.dst_size);

	VERIFY_ARRAY_VALUE(hash, correct, 64U);

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_digest_empty(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields, do everythin in one syscall */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 0;
	arg.ca_data.src = NULL;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	LOG_INFO("DIGEST(COMBINED OPERATION) NULL data, HASH ADDR %p\n", hash);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(COMBINED => RETURN) handle %u: ret %d\n",
		   arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;
	DUMP_HEX("DIGEST RESULT:", hash, hash_size);

	const uint8_t sha1[] = {
		0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d,
		0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
		0xaf, 0xd8, 0x07, 0x09,
	};

	const uint8_t sha224[] = {
		0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,
		0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,
		0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,
		0xc5, 0xb3, 0xe4, 0x2f,
	};

	const uint8_t sha256[] = {
		0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
		0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
		0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
		0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
	};

	const uint8_t sha384[] = {
		0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,
		0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,
		0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,
		0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,
		0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,
		0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b,
	};

	const uint8_t sha512[] = {
		0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,
		0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,
		0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,
		0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,
		0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,
		0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,
		0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,
		0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e,
	};

	const uint8_t md5[] = {
		0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04,
		0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e,
	};

	const uint8_t whirlpool[] = {
		0x19, 0xfa, 0x61, 0xd7, 0x55, 0x22, 0xa4, 0x66,
		0x9b, 0x44, 0xe3, 0x9c, 0x1d, 0x2e, 0x17, 0x26,
		0xc5, 0x30, 0x23, 0x21, 0x30, 0xd4, 0x07, 0xf8,
		0x9a, 0xfe, 0xe0, 0x96, 0x49, 0x97, 0xf7, 0xa7,
		0x3e, 0x83, 0xbe, 0x69, 0x8b, 0x28, 0x8f, 0xeb,
		0xcf, 0x88, 0xe3, 0xe0, 0x3c, 0x4f, 0x07, 0x57,
		0xea, 0x89, 0x64, 0xe5, 0x9b, 0x63, 0xd9, 0x37,
		0x08, 0xb1, 0x38, 0xcc, 0x42, 0xa6, 0x6e, 0xb3,
	};

	const uint8_t *correct = NULL;

	switch (digest) {
	case TE_ALG_MD5:
		correct = md5;
		TRAP_ASSERT(hash_size == 16);
		break;
	case TE_ALG_SHA1:
		correct = sha1;
		TRAP_ASSERT(hash_size == 20);
		break;
	case TE_ALG_SHA224:
		correct = sha224;
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA256:
		correct = sha256;
		TRAP_ASSERT(hash_size == 32);
		break;
	case TE_ALG_SHA384:
		correct = sha384;
		TRAP_ASSERT(hash_size == 48);
		break;
	case TE_ALG_SHA512:
		correct = sha512;
		TRAP_ASSERT(hash_size == 64);
		break;
	case TE_ALG_WHIRLPOOL:
		correct = whirlpool;
		TRAP_ASSERT(hash_size == 64);
		break;
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

// XXX result not verified
__STATIC__ status_t TEST_digest_with_update_byte(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t hash[128];
	unsigned char byte = 'A';

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_opcode = TE_OP_INIT;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init return): ret %d (sizeof arg %u)\n",
		   ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	// UPDATE with single bytes, values 'A'..'Z' inclusive
	// update(&byte);
	//
	for (byte = 'A'; byte <= 'Z'; byte++) {
		arg.ca_opcode = TE_OP_UPDATE;

		arg.ca_data.src_size = 1;
		arg.ca_data.src = &byte;

		// These are not used for digest updates...
		arg.ca_data.dst_size = 0;
		arg.ca_data.dst = NULL;

		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret,
				LOG_INFO("DIGEST(update) byte %c, handle %u: ret %d\n",
					 byte, arg.ca_handle, ret));
	}

	// dofinal(" ");
	arg.ca_opcode = TE_OP_DOFINAL;

	byte = ' ';

	arg.ca_data.src_size = 1;
	arg.ca_data.src = &byte;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DIGEST RESULT:", hash, arg.ca_data.dst_size);
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if UPDATE_DIGEST_TEST
__STATIC__ status_t TEST_digest_updates(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid,
					uint32_t data_size, uint32_t iteration_count, uint8_t ch, uint8_t *data)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t hash[128];
	uint32_t count = 1U;
	bool verified = false;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	if (NULL == data) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     CCC_ERROR_MESSAGE("NULL buffer for SHA update test\n"));
	}

	if (0U == data_size) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     CCC_ERROR_MESSAGE("Invalid data size\n"));
	}

	se_util_mem_set(data, (ch & 0xFFU), data_size);
	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_opcode = TE_OP_INIT;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	if (0U == iteration_count) {
		iteration_count = 1;
	}

	LOG_ALWAYS("Digest[%u] iterations: %u, data_size: %u, byte value 0x%x\n",
		   digest, iteration_count, data_size, ch);

	count = 1U;

	arg.ca_opcode = TE_OP_UPDATE;

	arg.ca_data.src_size = data_size;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = 0;
	arg.ca_data.dst = NULL;

	while (count < iteration_count) {
		LOG_INFO("DIGEST(update) %u\n", count);

		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret,
				CCC_ERROR_MESSAGE("DIGEST loop failed: count %u\n", count));
		count++;
	}

	arg.ca_opcode = TE_OP_DOFINAL;

	arg.ca_data.src_size = data_size;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	LOG_INFO("DIGEST(dofinal) [count %u], byte 0x%x\n", iteration_count, ch);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(dofinal return) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DIGEST RESULT:", (const uint8_t *)hash, arg.ca_data.dst_size);

	if (digest == TE_ALG_SHA256) {
		const uint8_t *p = NULL;

		if (4096U == data_size) {
			if (ch == 0x61) {
				uint8_t s1[32] = {
					0xc9, 0x3e, 0xee, 0x2d, 0x0d, 0xb0, 0x2f, 0x10, 0xac, 0xc7, 0x46, 0x0d, 0x95, 0x76, 0xe1, 0x22, 0xdc, 0xf8, 0xcd, 0x53, 0xc4, 0xbf, 0x8d, 0xfc, 0xae, 0x1b, 0x3e, 0x74, 0xeb, 0xcf, 0xff, 0x5a,
				};
				uint8_t s2[32] = {
					0xdd, 0x4e, 0x67, 0x30, 0x52, 0x09, 0x32, 0x76, 0x7e, 0xc0, 0xa9, 0xe3, 0x3f, 0xe1, 0x9c, 0x4c, 0xe2, 0x43, 0x99, 0xd6, 0xeb, 0xa4, 0xff, 0x62, 0xf1, 0x30, 0x13, 0xc9, 0xed, 0x30, 0xef, 0x87,
				};
				uint8_t s100[32] = {
					0x0c, 0xe9, 0xf6, 0x78, 0x6b, 0x0f, 0x58, 0x49, 0x36, 0xe8, 0x83, 0xc5, 0x09, 0x16, 0xbc, 0x5e, 0x2d, 0x07, 0x95, 0xb9, 0x42, 0x20, 0x41, 0x7c, 0xb3, 0x38, 0xd3, 0xf4, 0xe0, 0x78, 0x89, 0x46,
				};
				uint8_t s1000[32] = {
					0x9a, 0x83, 0x67, 0x50, 0x50, 0xd9, 0xfa, 0x6b, 0x27, 0x73, 0x75, 0xe9, 0x5e, 0x76, 0x5a, 0xcf, 0x6d, 0x91, 0xf0, 0x14, 0xc7, 0x92, 0xd0, 0xeb, 0x79, 0xf9, 0xa6, 0x73, 0xf1, 0x35, 0xa8, 0x4c,
				};

				switch (iteration_count) {
				case 1:
					p = &s1[0];
					break;

				case 2:
					p = &s2[0];
					break;

				case 100:
					p = &s100[0];
					break;

				case 1000:
					p = &s1000[0];
					break;

				default:
					break;
				}

				if (NULL != p) {
					CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
							  ch, data_size, iteration_count);
					VERIFY_ARRAY_VALUE(hash, p, 32U);
					verified = true;
				}
			} else if (ch == 0x00) {
				uint8_t z1[32] = {
					0xad, 0x7f, 0xac, 0xb2, 0x58, 0x6f, 0xc6, 0xe9, 0x66, 0xc0, 0x04, 0xd7, 0xd1, 0xd1, 0x6b, 0x02, 0x4f, 0x58, 0x05, 0xff, 0x7c, 0xb4, 0x7c, 0x7a, 0x85, 0xda, 0xbd, 0x8b, 0x48, 0x89, 0x2c, 0xa7,
				};
				uint8_t z2[32] = {
					0x9f, 0x1d, 0xcb, 0xc3, 0x5c, 0x35, 0x0d, 0x60, 0x27, 0xf9, 0x8b, 0xe0, 0xf5, 0xc8, 0xb4, 0x3b, 0x42, 0xca, 0x52, 0xb7, 0x60, 0x44, 0x59, 0xc0, 0xc4, 0x2b, 0xe3, 0xaa, 0x88, 0x91, 0x3d, 0x47,
				};
				uint8_t z100[32] = {
					0xd5, 0x82, 0x01, 0xa3, 0x0b, 0x35, 0xa6, 0x06, 0x12, 0x30, 0x66, 0x67, 0xb0, 0x83, 0xca, 0x4d, 0xfa, 0xf9, 0xef, 0xa1, 0x07, 0x38, 0x6f, 0xff, 0x36, 0x18, 0x8e, 0x42, 0xc3, 0x4c, 0x3c, 0x19,
				};
				uint8_t z1000[32] = {
					0x83, 0x04, 0x97, 0xac, 0xdc, 0x4c, 0xbd, 0xeb, 0xb0, 0xfc, 0x5a, 0x05, 0xf6, 0x5c, 0xb0, 0x2a, 0x18, 0x36, 0x48, 0x32, 0x9f, 0x30, 0x67, 0xac, 0x2e, 0xd2, 0x7f, 0xbc, 0xb0, 0xea, 0x34, 0x19,
				};

				switch (iteration_count) {
				case 1:
					p = &z1[0];
					break;

				case 2:
					p = &z2[0];
					break;

				case 100:
					p = &z100[0];
					break;

				case 1000:
					p = &z1000[0];
					break;

				default:
					break;
				}

				if (NULL != p) {
					CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
							  ch, data_size, iteration_count);
					VERIFY_ARRAY_VALUE(hash, p, 32U);
					verified = true;
				}
			}
		} else if (262144U == data_size) {
			uint8_t r1[32] = {
				0xdd, 0x3d, 0xde, 0x87, 0x62, 0x3d, 0x9a, 0x6b, 0x35, 0x4c, 0x68, 0xc9, 0x43, 0xd1, 0x89, 0xc8, 0x9c, 0x63, 0x65, 0x2d, 0x94, 0x5e, 0x7b, 0xbd, 0xf0, 0x98, 0x6c, 0xae, 0x91, 0xa4, 0x95, 0x21,
			};
			uint8_t r2[32] = {
				0x85, 0xa8, 0x4a, 0x75, 0x88, 0x6e, 0x8a, 0x52, 0x6d, 0xbe, 0xc4, 0xe1, 0x6e, 0x33, 0x75, 0xfa, 0xa3, 0x07, 0xb4, 0xae, 0xad, 0x79, 0xc9, 0xed, 0x32, 0x64, 0xc0, 0x47, 0x7a, 0x6f, 0x6e, 0xba,
			};
			uint8_t r100[32] = {
				0xe2, 0x4e, 0x1d, 0xeb, 0x14, 0x66, 0x61, 0x44, 0x96, 0xdd, 0xfc, 0x6a, 0xf6, 0x31, 0x6e, 0x5c, 0x04, 0x32, 0x84, 0x9c, 0xce, 0x72, 0x05, 0xd4, 0x6e, 0x2d, 0x18, 0x23, 0x0e, 0x2a, 0x83, 0xf3,
			};
			uint8_t r1000[32] = {
				0x70, 0x65, 0xc7, 0xfb, 0x55, 0x1f, 0xf3, 0x0a, 0xcc, 0x0e, 0x31, 0xf6, 0xaf, 0x44, 0x70, 0xa0, 0x1e, 0xba, 0x1b, 0xb0, 0x00, 0x0f, 0x54, 0xb0, 0xbd, 0x06, 0x02, 0x41, 0x70, 0x77, 0xf5, 0xab,
			};

			switch (iteration_count) {
			case 1:
				p = &r1[0];
				break;

			case 2:
				p = &r2[0];
				break;

			case 100:
				p = &r100[0];
				break;

			case 1000:
				p = &r1000[0];
				break;

			default:
				break;
			}

			if (NULL != p) {
				CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
						  ch, data_size, iteration_count);
				VERIFY_ARRAY_VALUE(hash, p, 32U);
				verified = true;
			}
		}
	}

fail:
	if (! verified) {
		CCC_ERROR_MESSAGE("Digest result not verified\n");
		ret = SE_ERROR(ERR_BAD_STATE);
	}

	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if ASYNC_TEST
__STATIC__ status_t TEST_async_digest_updates(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid,
					      uint32_t data_size, uint32_t iteration_count, uint8_t ch, uint8_t *data)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t hash[128];
	uint32_t count = 1U;
	bool verified = false;
	bool done = false;
	uint32_t checks = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	if (NULL == data) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     CCC_ERROR_MESSAGE("NULL buffer for SHA update test\n"));
	}

	if (0U == data_size) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     CCC_ERROR_MESSAGE("Invalid data size\n"));
	}

	se_util_mem_set(data, (ch & 0xFFU), data_size);
	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_opcode = TE_OP_INIT;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("DIGEST(init return): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	if (0U == iteration_count) {
		iteration_count = 1;
	}

	LOG_ALWAYS("Digest[%u] iterations: %u, data_size: %u, byte value 0x%x\n",
		   digest, iteration_count, data_size, ch);

	count = 1U;

	while (count < iteration_count) {
		LOG_INFO("DIGEST(update) %u\n", count);

		arg.ca_opcode = TE_OP_ASYNC_UPDATE_START;

		arg.ca_data.src_size = data_size;
		arg.ca_data.src = data;
		arg.ca_data.dst_size = 0;
		arg.ca_data.dst = NULL;

		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret,
				CCC_ERROR_MESSAGE("DIGEST[start] loop failed: count %u\n", count));

		/* At this point your code can do what it likes, but it must
		 * complete the SE engine triggered call to release the engine
		 * before the Mutex watchdog timer traps
		 *
		 * No later than about 1.6 seconds @ 600 MHz SE clock.
		 *
		 * Every check state resets the mutex counter value
		 * (let me know if you prefer leaving the mutex timeout alone
		 *  and just let it trap. In 1.6. seconds the SE engine is able
		 *  to process a lot of data!)
		 */

		/* The engine state is placed to this init field by the check state call.
		 * Using a CCC macro to fetch it for readability.
		 */
		arg.ca_init.async_state = 0xDEADBEEF;	// Make sure there is some value which traps unless syscall works

		done = false;
		checks = 0;
		while(! done) {
			checks++;
			arg.ca_opcode = TE_OP_ASYNC_CHECK_STATE;
			ret = CRYPTO_OPERATION(c, &arg);
			CCC_ERROR_CHECK(ret,
					CCC_ERROR_MESSAGE("CHECK STATE: checks %u\n", checks));

			switch (ASYNC_GET_SE_ENGINE_STATE(&arg)) {
			case ASYNC_CHECK_ENGINE_NONE:
				LOG_ERROR("update:start => No operation ongoing\n");
				ret = SE_ERROR(ERR_BAD_STATE);
				break;
			case  ASYNC_CHECK_ENGINE_BUSY:
				LOG_INFO("update:start => SE engine is busy\n");
				continue;
			case ASYNC_CHECK_ENGINE_IDLE:
				LOG_INFO("update:start => SE engine is IDLE\n");
				done = true;
				break;
			default:
				LOG_ERROR("update:start => bad state value: 0x%x\n",
					  ASYNC_GET_SE_ENGINE_STATE(&arg));
				ret = SE_ERROR(ERR_BAD_STATE);
				break;
			}
			CCC_ERROR_CHECK(ret);
		}

		arg.ca_opcode = TE_OP_ASYNC_FINISH;
		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret,
				CCC_ERROR_MESSAGE("DIGEST[finish] loop failed: count %u\n", count));

		count++;
	}

	arg.ca_opcode = TE_OP_ASYNC_DOFINAL_START;

	arg.ca_data.src_size = data_size;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	LOG_INFO("DIGEST(dofinal:start) [count %u], byte 0x%x (async probes: %u)\n", iteration_count, ch, checks);

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(dofinal:start return) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	arg.ca_init.async_state = 0xDEADBEEF;	// Make sure there is some value which traps unless syscall works

	done = false;
	checks = 0;
	while(! done) {
		checks++;
		arg.ca_opcode = TE_OP_ASYNC_CHECK_STATE;
		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret,
				CCC_ERROR_MESSAGE("CHECK STATE: checks %u\n", checks));

		switch (ASYNC_GET_SE_ENGINE_STATE(&arg)) {
		case ASYNC_CHECK_ENGINE_NONE:
			LOG_ERROR("dofinal:start => No operation ongoing\n");
			ret = SE_ERROR(ERR_BAD_STATE);
			break;
		case  ASYNC_CHECK_ENGINE_BUSY:
			LOG_INFO("dofinal:start => SE engine is busy\n");
			continue;
		case ASYNC_CHECK_ENGINE_IDLE:
			LOG_INFO("dofinal:start => SE engine is IDLE\n");
			done = true;
			break;
		default:
			LOG_ERROR("dofinal:start => bad state value: 0x%x\n",
				  ASYNC_GET_SE_ENGINE_STATE(&arg));
			ret = SE_ERROR(ERR_BAD_STATE);
			break;
		}
		CCC_ERROR_CHECK(ret);
	}

	LOG_INFO("DIGEST(dofinal:finish) [count %u], byte 0x%x (async probes: %u)\n", iteration_count, ch, checks);

	arg.ca_opcode = TE_OP_ASYNC_FINISH;
	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("DIGEST(dofinal:finish return) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DIGEST RESULT:", (const uint8_t *)hash, arg.ca_data.dst_size);

	if (digest == TE_ALG_SHA256) {
		const uint8_t *p = NULL;

		if (4096U == data_size) {
			if (ch == 0x61) {
				uint8_t s1[32] = {
					0xc9, 0x3e, 0xee, 0x2d, 0x0d, 0xb0, 0x2f, 0x10, 0xac, 0xc7, 0x46, 0x0d, 0x95, 0x76, 0xe1, 0x22, 0xdc, 0xf8, 0xcd, 0x53, 0xc4, 0xbf, 0x8d, 0xfc, 0xae, 0x1b, 0x3e, 0x74, 0xeb, 0xcf, 0xff, 0x5a,
				};
				uint8_t s2[32] = {
					0xdd, 0x4e, 0x67, 0x30, 0x52, 0x09, 0x32, 0x76, 0x7e, 0xc0, 0xa9, 0xe3, 0x3f, 0xe1, 0x9c, 0x4c, 0xe2, 0x43, 0x99, 0xd6, 0xeb, 0xa4, 0xff, 0x62, 0xf1, 0x30, 0x13, 0xc9, 0xed, 0x30, 0xef, 0x87,
				};
				uint8_t s100[32] = {
					0x0c, 0xe9, 0xf6, 0x78, 0x6b, 0x0f, 0x58, 0x49, 0x36, 0xe8, 0x83, 0xc5, 0x09, 0x16, 0xbc, 0x5e, 0x2d, 0x07, 0x95, 0xb9, 0x42, 0x20, 0x41, 0x7c, 0xb3, 0x38, 0xd3, 0xf4, 0xe0, 0x78, 0x89, 0x46,
				};
				uint8_t s1000[32] = {
					0x9a, 0x83, 0x67, 0x50, 0x50, 0xd9, 0xfa, 0x6b, 0x27, 0x73, 0x75, 0xe9, 0x5e, 0x76, 0x5a, 0xcf, 0x6d, 0x91, 0xf0, 0x14, 0xc7, 0x92, 0xd0, 0xeb, 0x79, 0xf9, 0xa6, 0x73, 0xf1, 0x35, 0xa8, 0x4c,
				};

				switch (iteration_count) {
				case 1:
					p = &s1[0];
					break;

				case 2:
					p = &s2[0];
					break;

				case 100:
					p = &s100[0];
					break;

				case 1000:
					p = &s1000[0];
					break;

				default:
					break;
				}

				if (NULL != p) {
					CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
							  ch, data_size, iteration_count);
					VERIFY_ARRAY_VALUE(hash, p, 32U);
					verified = true;
				}
			} else if (ch == 0x00) {
				uint8_t z1[32] = {
					0xad, 0x7f, 0xac, 0xb2, 0x58, 0x6f, 0xc6, 0xe9, 0x66, 0xc0, 0x04, 0xd7, 0xd1, 0xd1, 0x6b, 0x02, 0x4f, 0x58, 0x05, 0xff, 0x7c, 0xb4, 0x7c, 0x7a, 0x85, 0xda, 0xbd, 0x8b, 0x48, 0x89, 0x2c, 0xa7,
				};
				uint8_t z2[32] = {
					0x9f, 0x1d, 0xcb, 0xc3, 0x5c, 0x35, 0x0d, 0x60, 0x27, 0xf9, 0x8b, 0xe0, 0xf5, 0xc8, 0xb4, 0x3b, 0x42, 0xca, 0x52, 0xb7, 0x60, 0x44, 0x59, 0xc0, 0xc4, 0x2b, 0xe3, 0xaa, 0x88, 0x91, 0x3d, 0x47,
				};
				uint8_t z100[32] = {
					0xd5, 0x82, 0x01, 0xa3, 0x0b, 0x35, 0xa6, 0x06, 0x12, 0x30, 0x66, 0x67, 0xb0, 0x83, 0xca, 0x4d, 0xfa, 0xf9, 0xef, 0xa1, 0x07, 0x38, 0x6f, 0xff, 0x36, 0x18, 0x8e, 0x42, 0xc3, 0x4c, 0x3c, 0x19,
				};
				uint8_t z1000[32] = {
					0x83, 0x04, 0x97, 0xac, 0xdc, 0x4c, 0xbd, 0xeb, 0xb0, 0xfc, 0x5a, 0x05, 0xf6, 0x5c, 0xb0, 0x2a, 0x18, 0x36, 0x48, 0x32, 0x9f, 0x30, 0x67, 0xac, 0x2e, 0xd2, 0x7f, 0xbc, 0xb0, 0xea, 0x34, 0x19,
				};

				switch (iteration_count) {
				case 1:
					p = &z1[0];
					break;

				case 2:
					p = &z2[0];
					break;

				case 100:
					p = &z100[0];
					break;

				case 1000:
					p = &z1000[0];
					break;

				default:
					break;
				}

				if (NULL != p) {
					CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
							  ch, data_size, iteration_count);
					VERIFY_ARRAY_VALUE(hash, p, 32U);
					verified = true;
				}
			}
		} else if (262144U == data_size) {
			uint8_t r1[32] = {
				0xdd, 0x3d, 0xde, 0x87, 0x62, 0x3d, 0x9a, 0x6b, 0x35, 0x4c, 0x68, 0xc9, 0x43, 0xd1, 0x89, 0xc8, 0x9c, 0x63, 0x65, 0x2d, 0x94, 0x5e, 0x7b, 0xbd, 0xf0, 0x98, 0x6c, 0xae, 0x91, 0xa4, 0x95, 0x21,
			};
			uint8_t r2[32] = {
				0x85, 0xa8, 0x4a, 0x75, 0x88, 0x6e, 0x8a, 0x52, 0x6d, 0xbe, 0xc4, 0xe1, 0x6e, 0x33, 0x75, 0xfa, 0xa3, 0x07, 0xb4, 0xae, 0xad, 0x79, 0xc9, 0xed, 0x32, 0x64, 0xc0, 0x47, 0x7a, 0x6f, 0x6e, 0xba,
			};
			uint8_t r100[32] = {
				0xe2, 0x4e, 0x1d, 0xeb, 0x14, 0x66, 0x61, 0x44, 0x96, 0xdd, 0xfc, 0x6a, 0xf6, 0x31, 0x6e, 0x5c, 0x04, 0x32, 0x84, 0x9c, 0xce, 0x72, 0x05, 0xd4, 0x6e, 0x2d, 0x18, 0x23, 0x0e, 0x2a, 0x83, 0xf3,
			};
			uint8_t r1000[32] = {
				0x70, 0x65, 0xc7, 0xfb, 0x55, 0x1f, 0xf3, 0x0a, 0xcc, 0x0e, 0x31, 0xf6, 0xaf, 0x44, 0x70, 0xa0, 0x1e, 0xba, 0x1b, 0xb0, 0x00, 0x0f, 0x54, 0xb0, 0xbd, 0x06, 0x02, 0x41, 0x70, 0x77, 0xf5, 0xab,
			};

			switch (iteration_count) {
			case 1:
				p = &r1[0];
				break;

			case 2:
				p = &r2[0];
				break;

			case 100:
				p = &r100[0];
				break;

			case 1000:
				p = &r1000[0];
				break;

			default:
				break;
			}

			if (NULL != p) {
				CCC_ERROR_MESSAGE("Check: ch=%u data_size=%u iter=%u\n",
						  ch, data_size, iteration_count);
				VERIFY_ARRAY_VALUE(hash, p, 32U);
				verified = true;
			}
		}
	}

fail:
	if (! verified) {
		CCC_ERROR_MESSAGE("Digest result not verified\n");
		ret = SE_ERROR(ERR_BAD_STATE);
	}

	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif // ASYNC_TEST
#endif /* UPDATE_DIGEST_TEST */

#if ASYNC_TEST
__STATIC__ status_t TEST_digest_async(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	unsigned char data[16] = "abcdefghijklmnop";
	static uint8_t hash[128];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = (TE_OP_INIT | TE_OP_ASYNC_DOFINAL_START);

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 16;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("ASYNC DIGEST(init/dofinal:start): ret %d (sizeof arg %u)\n",
		 ret, sizeof_u32(arg));
	CCC_ERROR_CHECK(ret);

	{
		bool done = false;
		uint32_t checks = 0U;
		while(! done) {
			checks++;
			arg.ca_opcode = TE_OP_ASYNC_CHECK_STATE;
			ret = crypto_handle_operation(c, &arg);
			CCC_ERROR_CHECK(ret,
					CCC_ERROR_MESSAGE("CHECK STATE: count %u\n", checks));

			switch (ASYNC_GET_SE_ENGINE_STATE(&arg)) {
			case ASYNC_CHECK_ENGINE_NONE:
				LOG_ERROR("dofinal:start => No operation ongoing\n");
				ret = SE_ERROR(ERR_BAD_STATE);
				break;
			case  ASYNC_CHECK_ENGINE_BUSY:
				LOG_INFO("dofinal:start => SE engine is busy\n");
				continue;
			case ASYNC_CHECK_ENGINE_IDLE:
				LOG_INFO("dofinal:start => SE engine is IDLE\n");
				done = true;
				break;
			default:
				LOG_ERROR("dofinal:start => bad state value: 0x%x\n",
					  ASYNC_GET_SE_ENGINE_STATE(&arg));
				ret = SE_ERROR(ERR_BAD_STATE);
				break;
			}
			CCC_ERROR_CHECK(ret);
		}
		LOG_INFO("dofinal:start => check state %u times\n", checks);
	}

	arg.ca_opcode = (TE_OP_ASYNC_FINISH | TE_OP_RESET);
	ret = crypto_handle_operation(c, &arg);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("ASYNC DIGEST: ALGO: 0x%x => ret %d\n", digest, ret));

	hash_size = arg.ca_data.dst_size;

	LOG_ALWAYS("ASYNC DIGEST(reset), hash_size == %u\n", hash_size);

	DUMP_HEX("ASYNC DIGEST RESULT:", hash, hash_size);

	const uint8_t sha1[] = {
		0x14, 0xf3, 0x99, 0x52, 0x88, 0xac, 0xd1, 0x89,
		0xe6, 0xe5, 0x0a, 0x7a, 0xf4, 0x7e, 0xe7, 0x09,
		0x9a, 0xa6, 0x82, 0xb9, };

	const uint8_t sha224[] = {
		0x63, 0xd6, 0xe3, 0x65, 0x02, 0x59, 0xc7, 0x1e,
		0x25, 0x6b, 0x1f, 0x4b, 0x13, 0xf4, 0x5c, 0x15,
		0x8c, 0x4e, 0xa0, 0xdd, 0x59, 0x52, 0xb1, 0x87,
		0x83, 0xf8, 0xb1, 0x5a,
	};

	const uint8_t sha256[] = {
		0xf3, 0x9d, 0xac, 0x6c, 0xba, 0xba, 0x53, 0x5e,
		0x2c, 0x20, 0x7c, 0xd0, 0xcd, 0x8f, 0x15, 0x49,
		0x74, 0x22, 0x3c, 0x84, 0x8f, 0x72, 0x7f, 0x98,
		0xb3, 0x56, 0x4c, 0xea, 0x56, 0x9b, 0x41, 0xcf,
	};

	const uint8_t sha384[] = {
		0x96, 0xd3, 0xc1, 0xb5, 0x4b, 0x19, 0x38, 0x60,
		0x0a, 0xbe, 0x5b, 0x57, 0x23, 0x2e, 0x18, 0x5d,
		0xf1, 0xc5, 0x85, 0x6f, 0x74, 0x65, 0x6b, 0x8f,
		0x98, 0x37, 0xc5, 0x31, 0x7c, 0xf5, 0xb2, 0x2a,
		0xc3, 0x82, 0x26, 0xfa, 0xfc, 0x8c, 0x94, 0x6b,
		0x9d, 0x20, 0xac, 0xa1, 0xb0, 0xc5, 0x3a, 0x98,
	};

	const uint8_t sha512[] = {
		0xd0, 0xca, 0xdd, 0x68, 0x34, 0xfa, 0x0c, 0x15,
		0x7b, 0x36, 0xcc, 0xa3, 0x0e, 0xe8, 0xb0, 0xb1,
		0x43, 0x5d, 0x84, 0x1a, 0xa5, 0xb5, 0xac, 0x85,
		0x0c, 0x11, 0xae, 0x80, 0xa1, 0x44, 0x0f, 0x51,
		0x74, 0x3e, 0x98, 0xfb, 0x1f, 0x1e, 0x73, 0x76,
		0xc7, 0x0f, 0x2f, 0x65, 0x40, 0x4f, 0x08, 0x8c,
		0x28, 0xbc, 0xb4, 0xa5, 0x11, 0xdf, 0x2e, 0x64,
		0x11, 0x1f, 0x8f, 0x74, 0x24, 0x36, 0x4b, 0x60,
	};

	const uint8_t md5[] = {
		0x1d, 0x64, 0xdc, 0xe2, 0x39, 0xc4, 0x43, 0x7b,
		0x77, 0x36, 0x04, 0x1d, 0xb0, 0x89, 0xe1, 0xb9,
	};

	const uint8_t *correct = NULL;

	// XXX Support NIST partial digests 512/224 and 512/256 !!!!

	switch (digest) {
	case TE_ALG_MD5:
		correct = md5;
		TRAP_ASSERT(hash_size == 16);
		break;
	case TE_ALG_SHA1:
		correct = sha1;
		TRAP_ASSERT(hash_size == 20);
		break;
	case TE_ALG_SHA224:
		correct = sha224;
		TRAP_ASSERT(hash_size == 28);
		break;
	case TE_ALG_SHA256:
		correct = sha256;
		TRAP_ASSERT(hash_size == 32);
		break;
	case TE_ALG_SHA384:
		correct = sha384;
		TRAP_ASSERT(hash_size == 48);
		break;
	case TE_ALG_SHA512:
		correct = sha512;
		TRAP_ASSERT(hash_size == 64);
		break;
	default:
		LOG_INFO("Correct result not defined for digest 0x%x\n", digest);
		break;
	}

	if (NULL != correct) {
		VERIFY_ARRAY_VALUE(hash, correct, hash_size);
	} else {
		LOG_ERROR("%s: algo 0x%x result not verified\n", __func__, digest);
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#endif /* ASYNC_TEST */

#ifdef TEST_SEC_SAFE_REQ_VERIFY
status_t tegra_se_sha_hw_reg_clear_verify(uint32_t result_size);

__STATIC__ status_t TEST_sha_clr_hw_regs_verify(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;

	(void)algo;

	/* Verfiy the CCC clearing the HW registers after crypto operations
	 * SE0 has the following HW registers storing result
	 * - SE0_SHA_HASH_RESULT_0
	 */

	/* Regular SHA-512 test */
	TEST_digest(c, TE_ALG_SHA512, eid);
	CCC_ERROR_CHECK(ret);

	/* Verify SE0_SHA_HASH_RESULT_0 is cleared */
	ret = tegra_se_sha_hw_reg_clear_verify(64); // 512-bit (64 bytes)
	CCC_ERROR_CHECK(ret);

fail:
	return ret;
}
#endif /* TEST_SEC_SAFE_REQ_VERIFY */
#endif /* TEST_DIGEST */

__STATIC__ status_t TEST_digest_192_bytes(crypto_context_t *c, te_crypto_algo_t digest, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static const uint8_t data[128+64] = {
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x1D, 0x37, 0x4B, 0xED, 0x42, 0x05, 0xAC, 0x3E, 0xD5, 0xFF, 0xF3, 0x8E, 0x41, 0x38, 0x7A, 0x58,
		0xBD, 0x2D, 0x99, 0x9C, 0xBD, 0x79, 0x01, 0xDF, 0x78, 0xDB, 0x31, 0x17, 0xC2, 0x0B, 0xDA, 0x45,
		0x16, 0x7B, 0xC6, 0xD7, 0x5D, 0x31, 0x4C, 0xB8, 0xAB, 0x0D, 0x0F, 0x06, 0xF4, 0x1F, 0x96, 0x78,
		0x90, 0x27, 0x23, 0x75, 0xC8, 0xC3, 0xC7, 0x13, 0xB4, 0xAD, 0xFC, 0xC2, 0xFE, 0x0C, 0xF2, 0x25,
	};
	static uint8_t hash_first[64];
	static uint8_t hash[64];
	uint32_t hash_size = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	LOG_INFO("Test case: digest 192 bytes in one call (algo 0x%x)\n", digest);

	se_util_mem_set(hash_first, 0U, sizeof_u32(hash_first));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest 0x%x\n", eid, eid_name(eid), digest);
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 128+64;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(hash_first);
	arg.ca_data.dst = hash_first;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;
	DUMP_HEX("DIGEST RESULT (192):", hash_first, hash_size);

	/******************/

	LOG_INFO("Test case: digest 128 bytes in update call and 64 bytes in dofinal call\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));
	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = op_INIT | TE_OP_UPDATE;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 128;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = 0;
	arg.ca_data.dst = NULL;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	arg.ca_opcode   = op_FINAL_REL;

	arg.ca_data.src_size = 64;
	arg.ca_data.src = &data[128];
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);

	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;
	DUMP_HEX("DIGEST RESULT (128+64):", hash, hash_size);

	/* Verify that the first and second result match */
	VERIFY_ARRAY_VALUE(hash_first, hash, hash_size);

	/******************/

	LOG_INFO("Test case: digest 192 bytes in update call and 0 bytes in dofinal call\n");

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DIGEST, digest);

	se_util_mem_set(hash, 0U, sizeof_u32(hash));
	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DIGEST;
	arg.ca_algo     = digest;
	arg.ca_opcode   = op_INIT | TE_OP_UPDATE;

	LOG_INFO("Hint: use engine 0x%x (%s) for digest\n", eid, eid_name(eid));
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 192;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = 0;
	arg.ca_data.dst = NULL;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	arg.ca_opcode   = op_FINAL_REL;

	arg.ca_data.src_size = 0;
	arg.ca_data.src = NULL;
	arg.ca_data.dst_size = sizeof_u32(hash);
	arg.ca_data.dst = hash;

	ret = CRYPTO_OPERATION(c, &arg);

	CCC_ERROR_CHECK(ret);

	hash_size = arg.ca_data.dst_size;
	DUMP_HEX("DIGEST RESULT (192+0):", hash, hash_size);

	/* Verify that the first and third result match */
	VERIFY_ARRAY_VALUE(hash_first, hash, hash_size);
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if HAVE_SE_RANDOM || HAVE_RNG1_DRNG || HAVE_PKA1_TRNG
__STATIC__ status_t TEST_output_random_bytes(crypto_context_t *c,
					     te_crypto_algo_t rand_alg,
					     engine_id_t eid,
					     uint32_t bytes)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	static uint8_t rnd[10240];
	uint32_t count = 0U;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_RANDOM, rand_alg);

	if (bytes == 0) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	/* Preset fields generate random */
	arg.ca_alg_mode = TE_ALG_MODE_RANDOM;
	arg.ca_algo     = rand_alg;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 0;
	arg.ca_data.src = NULL;
	arg.ca_data.dst = rnd;

	while (count < bytes) {
		uint32_t bcount = sizeof_u32(rnd);

		if (bytes - count < bcount) {
			bcount = bytes - count;
		}

		arg.ca_data.dst_size = bcount;
		ret = CRYPTO_OPERATION(c, &arg);

		DUMP_HEX("RNG: ", rnd, bcount);

		CCC_ERROR_CHECK(ret);
		count += arg.ca_data.dst_size;
	}

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

static status_t generate_random(crypto_context_t *c, te_crypto_algo_t rand_alg, engine_id_t eid,
	uint8_t *dst, uint32_t bytes)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_RANDOM, rand_alg);

	/* Preset fields, do everythin in one syscall */
	arg.ca_alg_mode = TE_ALG_MODE_RANDOM;
	arg.ca_algo     = rand_alg;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for random 0x%x\n", eid, eid_name(eid), rand_alg);
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 0;
	arg.ca_data.src = NULL;
	arg.ca_data.dst_size = bytes;
	arg.ca_data.dst = dst;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));
	LOG_INFO("RANDOM(COMBINED => RETURN) handle %u: ret %d\n",
		 arg.ca_handle,ret);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("RANDOM generation result:", dst, arg.ca_data.dst_size);
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_random(crypto_context_t *c, te_crypto_algo_t rand_alg, engine_id_t eid, uint32_t bytes)
{
	status_t ret = NO_ERROR;
	static DMA_ALIGN_DATA uint8_t dma_aligned_rnd[DMA_ALIGN_SIZE(1025)] = { 0x0U };

	if (bytes > (sizeof_u32(dma_aligned_rnd) - 1U)) {
		LOG_INFO("RND request %u too long for test: using %u byte size\n",
			 bytes, (sizeof_u32(dma_aligned_rnd) - 1U));
		bytes = (sizeof_u32(dma_aligned_rnd) - 1U);
	}

	if (bytes == 0) {
		bytes = 1;
	}

	/* test with Word aligned dst */
	LOG_INFO("RANDOM with Word aligned dst\n");
	se_util_mem_set(dma_aligned_rnd, 0U, sizeof_u32(dma_aligned_rnd));
	ret = generate_random(c, rand_alg, eid, &dma_aligned_rnd[0], bytes);
	CCC_ERROR_CHECK(ret);

	/* test with Word unaligned dst */
	LOG_INFO("RANDOM with Word unaligned dst\n");
	se_util_mem_set(dma_aligned_rnd, 0U, sizeof_u32(dma_aligned_rnd));
	ret = generate_random(c, rand_alg, eid, &dma_aligned_rnd[1], bytes);
	CCC_ERROR_CHECK(ret);

fail:
	return ret;
}

/* Three methods to generate randomness for the kernel context
 */
__STATIC__ status_t TEST_kernel_random(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint32_t value = 0U;

#if defined(CCC_GENERATE_RANDOM)
	/* Use the selected random umber generator */
	ret = CCC_GENERATE_RANDOM((uint8_t *)&value, sizeof_u32(value));
	CCC_ERROR_CHECK(ret);

	/* bad luck... */
	TRAP_ASSERT(value != 0U);

	LOG_ALWAYS("SE_DRNG => RANDOM generation result#1 (word): 0x%x\n", value);
#endif

#if HAVE_RNG1_DRNG
	/* Use the Elliptic RNG1 device to generate DRNG values */
	ret = rng1_generate_drng((uint8_t *)&value, sizeof_u32(value));
	CCC_ERROR_CHECK(ret);

	TRAP_ASSERT(value != 0U);

	LOG_ALWAYS("RNG1 DRNG => RANDOM generation result#1 (word): 0x%x\n", value);
#endif

	/* Use what ever is specified in the EID to generate
	 * values (with mode TE_ALG_MODE_RANDOM and algorithm TE_ALG_RANDOM_DRNG)
	 *
	 * CCC_ENGINE_ANY => lwrrently defaults to SE/DRNG in CCC_ENGINE_SE0_AES0.
	 * CCC_ENGINE_SE0_AES0 (or CCC_ENGINE_SE1_AES0) => uses SE/DRNG in that device.
	 * CCC_ENGINE_RNG1 => Uses elliptic RNG1 engine
	 *
	 * TE_ALG_RANDOM_TRNG would use the PKA1 TRNG engine, but it is not tested here
	 * and should not be used. RNG1 generating TRNG in promislwous mode
	 * is not supported (at least for now, please let me know if you need that).
	 */
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_RANDOM, algo);

	value = 0U;

	/* Preset fields, do everythin in one syscall */
	arg.ca_alg_mode = TE_ALG_MODE_RANDOM;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for random 0x%x\n", eid, eid_name(eid), algo);
	arg.ca_init.engine_hint = eid;

	arg.ca_data.src_size = 0;
	arg.ca_data.src = NULL;
	arg.ca_data.dst_size = sizeof_u32(value);
	arg.ca_data.dst = (uint8_t *)&value;

	ret = CRYPTO_OPERATION(c, &arg);
	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("RANDOM(COMBINED => RETURN) handle %u: ret %d\n",
		 arg.ca_handle,ret);

	CCC_ERROR_CHECK(ret);

	TRAP_ASSERT(value != 0U);

	LOG_ALWAYS("RANDOM generation result#2 (word): 0x%x\n", value);
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_SE_RANDOM || HAVE_RNG1_DRNG || HAVE_PKA1_TRNG */

#ifdef TEST_ECDH

__STATIC__ status_t TEST_ecdh_192(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// Shared secret from ECDH callwlated here (max 80 bytes from P-521)
	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[24] = {
		0x37, 0xf9, 0x79, 0x6a, 0xc4, 0x9d, 0x00, 0x04, 0xe3, 0xfe, 0xc8, 0xc9,
		0xc0, 0x08, 0xc0, 0xbf, 0x1f, 0x09, 0x29, 0xf9, 0xe0, 0xcf, 0x40, 0x35
	};

#define ECDH_SELF_192 0

#if !ECDH_SELF_192
	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * By some magic co-incidence (eh...) this happens to be the public key matching
	 * the private key in akey.k_ec_private.key below...
	 *
	 * => the result is identical if ECDH_SELF_192 is defined either 0 or 1
	 */
	te_ec_point_t peer_pubkey = {
		.x = { 0x9a, 0x94, 0x55, 0xa1, 0x69, 0x1a, 0xff, 0x53, 0xaf, 0x59, 0xdf, 0x4b,
		       0x68, 0xe4, 0xb9, 0xc2, 0xed, 0xe1, 0x1b, 0x6a, 0x21, 0x5c, 0x16, 0x29 },
		.y = { 0xef, 0xdb, 0x86, 0xbe, 0x66, 0xa9, 0xe4, 0x88, 0xed, 0x39, 0x00, 0xb4,
		       0x43, 0xf1, 0x4f, 0x77, 0x0c, 0xe6, 0x31, 0xa0, 0xf7, 0xb6, 0x0b, 0xc2 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};
#endif

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 *
	 * XXX test value in my ~/src/ecdh/nist-p192-key.pem
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		.k_flags     = KEY_FLAG_PLAIN,
		// .k_byte_size = (192 / 8), /* ACTUALLY using LWRVE PARAMETERS for the size */
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = { 0x5d, 0x79, 0x6b, 0xf6, 0x0f, 0x82, 0xd3, 0x37, 0x91, 0x69, 0xc5, 0x71,
				 0xd5, 0x64, 0xd1, 0x4f, 0xe7, 0x4f, 0xd1, 0x11, 0x10, 0xa1, 0xd3, 0x54 },
			.key_length = 24,
			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_192; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

#if ECDH_SELF_192
	/* If src_point == NULL => callwlate the ECDH value
	 * with <my_private_key,my_public_key>
	 *
	 * my_private_key is the private key in .k_ec_private.key above
	 */
	arg.ca_data.src_size  = 0;
	arg.ca_data.src_point = NULL;
#else
	/* If src_point != NULL => callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
#endif
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* prime256v1 (NIST P-256) prime lwrve ECDH test */
__STATIC__ status_t TEST_ecdh_256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// Shared secret from ECDH callwlated here (max 80 bytes from P-521)
	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[32] = {
		0xb4, 0x3d, 0xa2, 0x67, 0xf1, 0x6b, 0x3c, 0x4f,
		0x1e, 0x81, 0x75, 0xfa, 0xce, 0x9c, 0x8b, 0x76,
		0xea, 0xa0, 0xd1, 0x69, 0x1a, 0x94, 0x70, 0x50,
		0xb1, 0x03, 0xbf, 0x57, 0xb7, 0x8b, 0xe8, 0x96
	};

#define ECDH_SELF_256 0
#define TEST_ecdh_256_with_LE_point 1

#if !ECDH_SELF_256
	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * By some magic co-incidence (eh...) this happens to be the public key matching
	 * the private key in akey.k_ec_private.key below...
	 *
	 * => the result is identical if ECDH_SELF_256 is defined either 0 or 1
	 */
	te_ec_point_t peer_pubkey = {
#if TEST_ecdh_256_with_LE_point
		.x = { 0x25, 0x08, 0x3c, 0x2b, 0x40, 0x03, 0x62, 0x3e,
		       0xb8, 0xcb, 0x76, 0x99, 0x21, 0x1c, 0xec, 0x93,
		       0x81, 0xcd, 0x4f, 0xf4, 0x91, 0xb8, 0x4b, 0x5e,
		       0x75, 0xf3, 0x01, 0xfe, 0x4c, 0x2e, 0x98, 0x26 },
		.y = { 0x24, 0x2b, 0xc5, 0x30, 0x82, 0x79, 0x8f, 0x86,
		       0xd5, 0x4d, 0xde, 0xce, 0x1e, 0xe7, 0xea, 0xe9,
		       0x38, 0x16, 0x96, 0xa8, 0x8d, 0x74, 0x0e, 0x2b,
		       0x90, 0x06, 0xf1, 0x88, 0x5b, 0xa4, 0x58, 0x5c },
		.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
#else /* TEST_ecdh_256_with_LE_point */
		.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
		       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
		       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
		       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
		.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
		       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
		       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
		       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
#endif /* TEST_ecdh_256_with_LE_point */
	};
#endif /* !ECDH_SELF_256 */

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 *
	 * XXX test value in my ~/src/ecdh/nist-p256-key.pem
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = {
				0x88, 0x4e, 0x9b, 0x4f, 0x24, 0x13, 0xa4, 0xef,
				0x79, 0xa8, 0xb9, 0xe6, 0xb5, 0x07, 0x02, 0x95,
				0xfa, 0x8c, 0x6e, 0xdb, 0x24, 0x83, 0x02, 0x2a,
				0x36, 0x94, 0x2b, 0xb7, 0x6d, 0x5f, 0xc9, 0xf4
			},
			.key_length = 32,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

#if ECDH_SELF_256
	/* If src_point == NULL => callwlate the ECDH value
	 * with <my_private_key,my_public_key>
	 *
	 * my_private_key is the private key in .k_ec_private.key above
	 */
	arg.ca_data.src_size  = 0;
	arg.ca_data.src_point = NULL;
#else
	/* If src_point != NULL => callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
#endif
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if CCC_EC_MIN_PRIME_BITS <= 256U

#ifdef TEST_PKA1_ECDH_KSLOT
/* prime256v1 (NIST P-256) prime lwrve ECDH test */
__STATIC__ status_t TEST_ecdh_256_kslot(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// Shared secret from ECDH callwlated here (max 80 bytes from P-521)
	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[32] = {
		0xb4, 0x3d, 0xa2, 0x67, 0xf1, 0x6b, 0x3c, 0x4f,
		0x1e, 0x81, 0x75, 0xfa, 0xce, 0x9c, 0x8b, 0x76,
		0xea, 0xa0, 0xd1, 0x69, 0x1a, 0x94, 0x70, 0x50,
		0xb1, 0x03, 0xbf, 0x57, 0xb7, 0x8b, 0xe8, 0x96
	};

	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * By some magic co-incidence (eh...) this happens to be the public key matching
	 * the private key in akey.k_ec_private.key below...
	 *
	 * => the result is identical if ECDH_SELF_256 is defined either 0 or 1
	 */
	te_ec_point_t peer_pubkey = {
		.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
		       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
		       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
		       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
		.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
		       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
		       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
		       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 *
	 * XXX test value in my ~/src/ecdh/nist-p256-key.pem
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		// Use the key via keyslot and leave it there for later use.
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_FORCE_KEYSLOT | KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = {
				0x88, 0x4e, 0x9b, 0x4f, 0x24, 0x13, 0xa4, 0xef,
				0x79, 0xa8, 0xb9, 0xe6, 0xb5, 0x07, 0x02, 0x95,
				0xfa, 0x8c, 0x6e, 0xdb, 0x24, 0x83, 0x02, 0x2a,
				0x36, 0x94, 0x2b, 0xb7, 0x6d, 0x5f, 0xc9, 0xf4
			},
			.key_length = 32,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* If src_point != NULL => callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* prime256v1 (NIST P-256) prime lwrve ECDH test */
__STATIC__ status_t TEST_ecdh_self_256_kslot(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// Shared secret from ECDH callwlated here (max 80 bytes from P-521)
	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[32] = {
		0xb4, 0x3d, 0xa2, 0x67, 0xf1, 0x6b, 0x3c, 0x4f,
		0x1e, 0x81, 0x75, 0xfa, 0xce, 0x9c, 0x8b, 0x76,
		0xea, 0xa0, 0xd1, 0x69, 0x1a, 0x94, 0x70, 0x50,
		0xb1, 0x03, 0xbf, 0x57, 0xb7, 0x8b, 0xe8, 0x96
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 *
	 * XXX test value in my ~/src/ecdh/nist-p256-key.pem
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		// Use the key via keyslot and leave it there for later use.
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_FORCE_KEYSLOT | KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = {
				0x88, 0x4e, 0x9b, 0x4f, 0x24, 0x13, 0xa4, 0xef,
				0x79, 0xa8, 0xb9, 0xe6, 0xb5, 0x07, 0x02, 0x95,
				0xfa, 0x8c, 0x6e, 0xdb, 0x24, 0x83, 0x02, 0x2a,
				0x36, 0x94, 0x2b, 0xb7, 0x6d, 0x5f, 0xc9, 0xf4
			},
			.key_length = 32,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* If src_point == NULL => callwlate the ECDH value
	 * with <my_private_key,my_public_key>
	 *
	 * my_private_key is the private key in .k_ec_private.key above
	 */
	arg.ca_data.src_size  = 0;
	arg.ca_data.src_point = NULL;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* prime256v1 (NIST P-256) prime lwrve ECDH test */
__STATIC__ status_t TEST_ecdh_256_key3(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// Shared secret from ECDH callwlated here (max 80 bytes from P-521)
	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[32] = {
		0xb4, 0x3d, 0xa2, 0x67, 0xf1, 0x6b, 0x3c, 0x4f,
		0x1e, 0x81, 0x75, 0xfa, 0xce, 0x9c, 0x8b, 0x76,
		0xea, 0xa0, 0xd1, 0x69, 0x1a, 0x94, 0x70, 0x50,
		0xb1, 0x03, 0xbf, 0x57, 0xb7, 0x8b, 0xe8, 0x96
	};

#define ECDH_SELF_256 0

#if !ECDH_SELF_256
	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * By some magic co-incidence (eh...) this happens to be the public key matching
	 * the private key in akey.k_ec_private.key below...
	 *
	 * => the result is identical if ECDH_SELF_256 is defined either 0 or 1
	 */
	te_ec_point_t peer_pubkey = {
		.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
		       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
		       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
		       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
		.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
		       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
		       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
		       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};
#endif

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 *
	 * XXX test value in my ~/src/ecdh/nist-p256-key.pem
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// Use the key lwrrently in keyslot.
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY,
		.k_keyslot = 3U,
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

#if ECDH_SELF_256
	/* If src_point == NULL => callwlate the ECDH value
	 * with <my_private_key,my_public_key>
	 *
	 * my_private_key is the private key in .k_ec_private.key above
	 */
	arg.ca_data.src_size  = 0;
	arg.ca_data.src_point = NULL;
#else
	/* If src_point != NULL => callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
#endif
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* TEST_PKA1_ECDH_KSLOT */
#endif /* CCC_EC_MIN_PRIME_BITS <= 256U */

#endif /* TEST_ECDH */

#ifdef TEST_X25519
#if X25519_OPENSSL_COMPAT_TEST
/* C25519 prime lwrve ECDH test (X25519) */
/*
 * NOTE: OpenSSL operates on LITTLE ENDIAN BYTE VECTORS for X25519 and lwrve25519 values!!
 * For most other such operations it uses big endian byte vectors.
 *
 * So, to get compatible results (e.g. callwlate the X25519 key agreement
 * values with openssl generated lwrve25519 values) please set the
 * little endian flasg for values which are in LE.
 *
 * I think the RFC refers to the value being "little endian" so maybe this is
 ' de-facto setting for clients.
 */
__STATIC__ status_t TEST_x25519_ossl(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	// (requires openssl-1.1 or later)
	// openssl genpkey -algorithm X25519
	//
	// Generate two private key blobs, extract pubkeys and do X25519 (ECDH derivation)
/*
  openssl genpkey -algorithm X25519 -out first-x25519-pkey.pem
  openssl genpkey -algorithm X25519 -out second-x25519-pkey.pem

  openssl pkey -text < first-x25519-pkey.pem
  openssl pkey -text < second-x25519-pkey.pem

  openssl pkey -pubout < first-x25519-pkey.pem  > first-x25519-pub.pem
  openssl pkey -pubout < second-x25519-pkey.pem  > second-x25519-pub.pem

  Derive X25519 (ECDH) with those (the generated values must match):

  openssl pkeyutl -derive -inkey first-x25519-pkey.pem -peerkey second-x25519-pub.pem | xxd -p
  openssl pkeyutl -derive -inkey second-x25519-pkey.pem -peerkey first-x25519-pub.pem | xxd -p
 */

	// Shared secret from ECDH callwlated here (only 32 bytes for C25519)
	// Because ss is the X-coordinate
	//
	uint8_t ss[TE_MAX_ECC_BYTES];

	const uint8_t correct[32] = {
		0x7f, 0xd6, 0xdb, 0x5e, 0x8c, 0xa8, 0xd0, 0x60,
		0xea, 0xba, 0x12, 0xac, 0x9b, 0x4e, 0xe5, 0x1b,
		0x82, 0xde, 0xa1, 0x87, 0x54, 0x22, 0xf8, 0x5c,
		0x66, 0x38, 0xa0, 0x07, 0xdc, 0xe7, 0x02, 0x16,
	};

	/*
	 * OpenSSL generated lwrve25519 is in LITTLE ENDIAN => Set CCC_EC_POINT_FLAG_LITTLE_ENDIAN
	 * point flag.
	 *
	 * PEER Px value in the X co-ordinate. Y co-ordinate is not used for X25519 callwlations
	 * setting zero (value does not matter).
	 */
	te_ec_point_t peer_pubkey = {
		.x = { 0x3d, 0x21, 0xe2, 0x2c, 0x8b, 0x2e, 0x21, 0x4d,
		       0x60, 0x93, 0xcd, 0x76, 0x9a, 0x38, 0x8b, 0xd0,
		       0x18, 0x5e, 0x9c, 0x5d, 0x2b, 0x21, 0x57, 0x97,
		       0x12, 0x53, 0xa7, 0x69, 0x78, 0xe5, 0x56, 0x49, },
		.y = { 0x00 },	// Not used in X25519

		/* OpenSSL lwrve X coordinate is little endian
		 */
		.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,

		/* EC private key data is BIG ENDIAN by default.
		 * But OpenSSL generated private key is LITTLE ENDIAN
		 * for lwrve25519 => must set the flag to get compatible
		 * results.
		 */
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,

		.k_keyslot = 3U, /* PKA1 does not use this keyslot with default options */
		.k_ec_private = {

			/* 1 < key < OBP (value of n) (first private key)
			 *
			 * Private key is in LITTLE ENDIAN byte order.
			 */
			.key = {
				0xe8, 0x92, 0x4c, 0xc7, 0x05, 0xa9, 0x4f, 0xd8,
				0x9e, 0x3e, 0xa4, 0x82, 0x0a, 0x28, 0x7a, 0xb4,
				0x9f, 0xcf, 0x05, 0x00, 0x05, 0x4b, 0x53, 0xc3,
				0x71, 0x04, 0x00, 0xcc, 0x3d, 0xc1, 0x6e, 0x40,
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_X25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the X25519 ECDH test\n",
					       algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_X25519;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_C25519; /* Select the C25519 lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* callwlate the X25519 (ECDH) value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("X25519 derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("X25519 result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* X25519_OPENSSL_COMPAT_TEST */

/* C25519 prime lwrve ECDH test (X25519). IAS 0.71 sample data */
__STATIC__ status_t TEST_x25519_IAS(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t ss[TE_MAX_ECC_BYTES];

	// Callwlated with openssl (see: ~/src/ecdh/openssl-ecdh.c)
	const uint8_t correct[32] = {
		0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc,
		0xa1, 0x35, 0x0b, 0x3e, 0x2b, 0xb7, 0x27, 0x9f,
		0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85, 0x4b, 0x78,
		0x3c, 0x60, 0xe8, 0x03, 0x11, 0xae, 0x30, 0x79,
	};

	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * (Peer Px value (in big endian), Py not used)
	 *
	 * XXX Maybe add another param type for the Px in X25519???
	 */
	te_ec_point_t peer_pubkey = {
		.x = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09
		},
		.y = { 0x00 },	// Not used in X25519
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,

		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 1 < key < OBP (value of n) (first private key) */
			.key = {
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_X25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the X25519 ECDH test\n",
					       algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_X25519;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_C25519; /* Select the C25519 lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("X25519 derivation result:",  ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("X25519 result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* C25519 prime lwrve ECDH test (X25519). RFC-7748 test data */
__STATIC__ status_t TEST_x25519_rfc_test1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t ss[TE_MAX_ECC_BYTES];

	const uint8_t correct[32] = {
		0xc3, 0xda, 0x55, 0x37, 0x9d, 0xe9, 0xc6, 0x90,
		0x8e, 0x94, 0xea, 0x4d, 0xf2, 0x8d, 0x08, 0x4f,
		0x32, 0xec, 0xcf, 0x03, 0x49, 0x1c, 0x71, 0xf7,
		0x54, 0xb4, 0x07, 0x55, 0x77, 0xa2, 0x85, 0x52,
	};

	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * (Peer Px value (in LITTLE ENDIAN), Py not used)
	 *
	 * XXX Maybe add another param type for the Px in X25519???
	 */
	te_ec_point_t peer_pubkey = {
		.x = {
			0xe6, 0xdb, 0x68, 0x67, 0x58, 0x30, 0x30, 0xdb,
			0x35, 0x94, 0xc1, 0xa4, 0x24, 0xb1, 0x5f, 0x7c,
			0x72, 0x66, 0x24, 0xec, 0x26, 0xb3, 0x35, 0x3b,
			0x10, 0xa9, 0x03, 0xa6, 0xd0, 0xab, 0x1c, 0x4c,
		},
		.y = { 0x00 },	// Not used in X25519
		.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,

		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 1 < key < OBP (value of n) */
			.key = {
				0xa5, 0x46, 0xe3, 0x6b, 0xf0, 0x52, 0x7c, 0x9d,
				0x3b, 0x16, 0x15, 0x4b, 0x82, 0x46, 0x5e, 0xdd,
				0x62, 0x14, 0x4c, 0x0a, 0xc1, 0xfc, 0x5a, 0x18,
				0x50, 0x6a, 0x22, 0x44, 0xba, 0x44, 0x9a, 0xc4,
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_X25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the X25519 ECDH test\n",
					       algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_X25519;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_C25519; /* Select the C25519 lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("X25519 derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("X25519 result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

__STATIC__ status_t TEST_x25519_rfc_test2(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t ss[TE_MAX_ECC_BYTES];

	const uint8_t correct[32] = {
		0x95, 0xcb, 0xde, 0x94, 0x76, 0xe8, 0x90, 0x7d,
		0x7a, 0xad, 0xe4, 0x5c, 0xb4, 0xb8, 0x73, 0xf8,
		0x8b, 0x59, 0x5a, 0x68, 0x79, 0x9f, 0xa1, 0x52,
		0xe6, 0xf8, 0xf7, 0x64, 0x7a, 0xac, 0x79, 0x57,
	};

	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * (Peer Px value (in LITTLE ENDIAN), Py not used)
	 *
	 * XXX Maybe add another param type for the Px in X25519???
	 */
	te_ec_point_t peer_pubkey = {
		.x = {
			0xe5, 0x21, 0x0f, 0x12, 0x78, 0x68, 0x11, 0xd3,
			0xf4, 0xb7, 0x95, 0x9d, 0x05, 0x38, 0xae, 0x2c,
			0x31, 0xdb, 0xe7, 0x10, 0x6f, 0xc0, 0x3c, 0x3e,
			0xfc, 0x4c, 0xd5, 0x49, 0xc7, 0x15, 0xa4, 0x93,
		},
		.y = { 0x00 },	// Not used in X25519
		.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,

		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 1 < key < OBP (value of n) */
			.key = {
				0x4b, 0x66, 0xe9, 0xd4, 0xd1, 0xb4, 0x67, 0x3c,
				0x5a, 0xd2, 0x26, 0x91, 0x95, 0x7d, 0x6a, 0xf5,
				0xc1, 0x1b, 0x64, 0x21, 0xe0, 0xea, 0x01, 0xd4,
				0x2c, 0xa4, 0x16, 0x9e, 0x79, 0x18, 0xba, 0x0d,
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_X25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the X25519 ECDH test\n",
					       algo));
	}

	se_util_mem_set(ss, 0U, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_X25519;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_C25519; /* Select the C25519 lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	/* callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("X25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("X25519 derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("X25519 result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if X25519_ITERATION
__STATIC__ status_t TEST_x25519_rfc_iteration(crypto_context_t *c, te_crypto_algo_t algo,
					      engine_id_t eid, uint32_t end_round)
{
	status_t ret = NO_ERROR;
	uint32_t rounds = 0U;

	static const uint8_t correct_1[32] = {
		0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc,
		0xa1, 0x35, 0x0b, 0x3e, 0x2b, 0xb7, 0x27, 0x9f,
		0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85, 0x4b, 0x78,
		0x3c, 0x60, 0xe8, 0x03, 0x11, 0xae, 0x30, 0x79,
	};

	static const uint8_t correct_1000[32] = {
		0x68, 0x4c, 0xf5, 0x9b, 0xa8, 0x33, 0x09, 0x55,
		0x28, 0x00, 0xef, 0x56, 0x6f, 0x2f, 0x4d, 0x3c,
		0x1c, 0x38, 0x87, 0xc4, 0x93, 0x60, 0xe3, 0x87,
		0x5f, 0x2e, 0xb9, 0x4d, 0x99, 0x53, 0x2c, 0x51,
	};

	static const uint8_t correct_1000000[32] = {
		0x7c, 0x39, 0x11, 0xe0, 0xab, 0x25, 0x86, 0xfd,
		0x86, 0x44, 0x97, 0x29, 0x7e, 0x57, 0x5e, 0x6f,
		0x3b, 0xc6, 0x01, 0xc0, 0x88, 0x3c, 0x30, 0xdf,
		0x5f, 0x4d, 0xd2, 0xd2, 0x4f, 0x66, 0x54, 0x24,
	};


	/* The peer pubkey by default BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * (Peer Px value (in LITTLE ENDIAN), Py not used)
	 *
	 * XXX Maybe add another param type for the Px in X25519???
	 */
	te_ec_point_t peer_pubkey = {
		// modified by each loop
		.x = { 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		.y = { 0x00 },	// Not used in X25519
		.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,

		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 1 < key < OBP (value of n) */
			// key rewritten by each loop
			.key = { 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_X25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the X25519 ECDH test\n",
					       algo));
	}

	if (0U == end_round) {
		end_round = 1000000;
	}

	// Due to rewrites => init on first run to allow rerunning test!
	static const uint8_t first_value[32U] = { 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	// init X and private key
	se_util_mem_move(&peer_pubkey.x[0], first_value, 32U);
	se_util_mem_move((uint8_t *)&akey.k_ec_private.key, first_value, 32U);

	for (rounds = 1; rounds <= end_round; rounds++) {
		uint8_t ss[32U];
		te_crypto_args_t arg = { .ca_handle = 0U, };

		LOG_INFO("Round: %u\n", rounds);

		/* Preset fields */
		arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
		arg.ca_algo     = TE_ALG_X25519;
		arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

		arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
		arg.ca_init.ec.lwrve_id = TE_LWRVE_C25519; /* Select the C25519 lwrve in init ec parameters */
		arg.ca_init.engine_hint = eid;		 /* Pass the engine selector hint in init generics */

		/* Pass the key params */
		arg.ca_set_key.kdata = &akey;

		/* callwlate the ECDH value
		 * with <my_private_key, peer_pubkey>
		 */
		arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
		arg.ca_data.src_point = &peer_pubkey;
		arg.ca_data.dst_size = sizeof_u32(ss);
		arg.ca_data.dst = &ss[0];

		ret = CRYPTO_OPERATION(c, &arg);
		CCC_ERROR_CHECK(ret);

		if (arg.ca_data.dst_size != sizeof_u32(correct_1)) {
			TRAP_ERROR("X25519 result length incorrect\n");
		}

		switch (rounds) {
		case 1:
			VERIFY_ARRAY_VALUE(ss, correct_1, sizeof_u32(correct_1));
			LOG_ALWAYS("Verified round: %u value\n", rounds);
			break;
		case 1000:
			VERIFY_ARRAY_VALUE(ss, correct_1000, sizeof_u32(correct_1000));
			LOG_ALWAYS("Verified round: %u value\n", rounds);
			break;
		case 1000000:
			VERIFY_ARRAY_VALUE(ss, correct_1000000, sizeof_u32(correct_1000000));
			LOG_ALWAYS("Verified round: %u value\n", rounds);
			break;
		}

		if ((rounds % 100000U) == 0U) {
			LOG_ALWAYS("still running, current round: %u value\n", rounds);
		}

		/* U := K (old private key) */
		se_util_mem_move(peer_pubkey.x, akey.k_ec_private.key, 32U);

		/* K := U' (generated shared secret) */
		se_util_mem_move(akey.k_ec_private.key, &ss[0], 32U);
	}

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* X25519_ITERATION */

#endif /* TEST_X25519 */

#ifdef TEST_ECDSA
#if CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL
__STATIC__ status_t TEST_ecdsa_verify_nist_p192(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign nist-p192-key.pem > ecdsa-sig.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p192-pubkey.pem
	//   -signature ecdsa-sig.bin
	//
	// See below p256 case for a short encoding info of the openssl ecdsa binary sig.
	// for p192, the ASN.1 length is 02 19 (25 bytes with zero pad per co-ordinate)
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x36, 0x02, 0x19, 0x00, 0xf4, 0x15, 0x19,
		0x91, 0xe8, 0x34, 0x88, 0xde, 0x91, 0x5e, 0xf5,
		0x1b, 0x20, 0x20, 0x1e, 0x5a, 0x48, 0x7a, 0x8a,
		0x98, 0x13, 0xa0, 0xf7, 0xe2, 0x02, 0x19, 0x00,
		0xc0, 0x19, 0x29, 0x99, 0x44, 0x0b, 0x9d, 0x64,
		0x50, 0xe2, 0x96, 0xbe, 0xba, 0x93, 0xf6, 0x45,
		0xc8, 0x71, 0x19, 0x62, 0x57, 0x3f, 0x4c, 0x95,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0xf4, 0x15, 0x19, 0x91, 0xe8, 0x34, 0x88, 0xde,
		       0x91, 0x5e, 0xf5, 0x1b, 0x20, 0x20, 0x1e, 0x5a,
		       0x48, 0x7a, 0x8a, 0x98, 0x13, 0xa0, 0xf7, 0xe2 },
		.s = { 0xc0, 0x19, 0x29, 0x99, 0x44, 0x0b, 0x9d, 0x64,
		       0x50, 0xe2, 0x96, 0xbe, 0xba, 0x93, 0xf6, 0x45,
		       0xc8, 0x71, 0x19, 0x62, 0x57, 0x3f, 0x4c, 0x95 },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			// XXX Should this extra intermediate field ".pubkey" be removed?
			.pubkey = {
				.x = { 0x9a, 0x94, 0x55, 0xa1, 0x69, 0x1a, 0xff, 0x53, 0xaf, 0x59, 0xdf, 0x4b,
				       0x68, 0xe4, 0xb9, 0xc2, 0xed, 0xe1, 0x1b, 0x6a, 0x21, 0x5c, 0x16, 0x29 },
				.y = { 0xef, 0xdb, 0x86, 0xbe, 0x66, 0xa9, 0xe4, 0x88, 0xed, 0x39, 0x00, 0xb4,
				       0x43, 0xf1, 0x4f, 0x77, 0x0c, 0xe6, 0x31, 0xa0, 0xf7, 0xb6, 0x0b, 0xc2 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	(void)data;
	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_192; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}
#endif /* CCC_EC_MIN_PRIME_BITS <= 192U */

#if CCC_EC_MIN_PRIME_BITS <= 256U
__STATIC__ status_t TEST_ecdsa_verify_nist_p256_ops(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						    uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign nist-p256-key.pem > ecdsa-sig-p256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p256-pubkey.pem
	//   -signature ecdsa-sig-p256.bin
	//
	// Openssl ECDSA big endian binary signature is ASN.1 encoded like this:
	// 30 44 02 20 <r> 02 20 <s>
	//
	// 02 20 may also be 02 21 if the co-ordinate is zero padded. This zero pad must be removed
	// from the r and s below. 20 == 32 (or 33) bytes for p256 sig co-ordinate
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x6a, 0xec, 0xf2, 0x0a,
		0x8d, 0xe7, 0x88, 0xad, 0x21, 0x49, 0x06, 0xc5,
		0x2d, 0xe3, 0xa0, 0xbe, 0x56, 0x74, 0xe4, 0xf5,
		0x77, 0x27, 0x1f, 0xe0, 0x7b, 0x01, 0x0d, 0xc2,
		0x9d, 0x0c, 0xd5, 0x56, 0x02, 0x20, 0x59, 0x05,
		0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6, 0xa5, 0xbc,
		0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7, 0x44, 0x1b,
		0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d, 0xab, 0x9d,
		0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0x6a, 0xec, 0xf2, 0x0a, 0x8d, 0xe7, 0x88, 0xad,
		       0x21, 0x49, 0x06, 0xc5, 0x2d, 0xe3, 0xa0, 0xbe,
		       0x56, 0x74, 0xe4, 0xf5, 0x77, 0x27, 0x1f, 0xe0,
		       0x7b, 0x01, 0x0d, 0xc2, 0x9d, 0x0c, 0xd5, 0x56 },
		.s = { 0x59, 0x05, 0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6,
		       0xa5, 0xbc, 0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7,
		       0x44, 0x1b, 0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d,
		       0xab, 0x9d, 0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48 },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			// XXX Should this extra intermediate field ".pubkey" be removed?
			.pubkey = {
				.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
				       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
				       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
				       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
				.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
				       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
				       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
				       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_INIT;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0U) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA[0x%x] VERIFY (INIT) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_opcode   = TE_OP_SET_KEY;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA[0x%x] VERIFY (SET_KEY) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0U) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	arg.ca_opcode   = TE_OP_DOFINAL;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (DO_FINAL) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

__STATIC__ status_t TEST_ecdsa_p256_ilwalid_signature_wyche(crypto_context_t *c,
						    te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[5] = "Hello";
	(void)data;
	(void)algo;

	// SHA_256(BIN(48656c6c6f))
	const uint8_t digest[32] = {
		0x18, 0x5f, 0x8d, 0xb3, 0x22, 0x71, 0xfe, 0x25,
		0xf5, 0x61, 0xa6, 0xfc, 0x93, 0x8b, 0x2e, 0x26,
		0x43, 0x06, 0xec, 0x30, 0x4e, 0xda, 0x51, 0x80,
		0x07, 0xd1, 0x76, 0x48, 0x26, 0x38, 0x19, 0x69,
	};

	/* invalid signature in ANS.1 long form integer */
	const uint8_t ecdsa_asn1_sig[] = {

		0x30, 0x4a, 0x02, 0x85, 0x01, 0x00, 0x00, 0x00,
		0x21, 0x00, 0xb7, 0xba, 0xba, 0xe9, 0x33, 0x2b,
		0x54, 0xb8, 0xa3, 0xa0, 0x5b, 0x70, 0x04, 0x57,
		0x98, 0x21, 0xa8, 0x87, 0xa1, 0xb2, 0x14, 0x65,
		0xf7, 0xdb, 0x8a, 0x3d, 0x49, 0x1b, 0x39, 0xfd,
		0x2c, 0x3f, 0x02, 0x20, 0x74, 0x72, 0x91, 0xdd,
		0x2f, 0x3f, 0x44, 0xaf, 0x7a, 0xce, 0x68, 0xea,
		0x33, 0x43, 0x1d, 0x6f, 0x94, 0xe4, 0x18, 0xc1,
		0x06, 0xa6, 0xe7, 0x62, 0x85, 0xcd, 0x59, 0xf4,
		0x32, 0x60, 0xec, 0xce,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			// XXX Should this extra intermediate field ".pubkey" be removed?
			.pubkey = {
				.x = { 0x4a, 0xf4, 0xf6, 0xd1, 0xd7, 0x34, 0x79, 0x8d,
					0x4c, 0x4c, 0x6f, 0x97, 0xc4, 0xff, 0xf3, 0x92,
					0xee, 0x65, 0xdc, 0x25, 0x2d, 0x61, 0x7b, 0x15,
					0x4c, 0xa8, 0x35, 0xea, 0x15, 0x35, 0xb1, 0x04, },
				.y = { 0xfb, 0x06, 0x91, 0x71, 0xd0, 0x0e, 0x87, 0xa9,
					0x2e, 0x6c, 0x4d, 0xb1, 0xd8, 0x92, 0xbc, 0x09,
					0xb0, 0x4b, 0x5d, 0xa8, 0xbd, 0x9b, 0x09, 0xcf,
					0xaa, 0x41, 0xd0, 0xa5, 0x26, 0xe5, 0x52, 0x37, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_INIT;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA[0x%x] VERIFY (INIT) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_opcode   = TE_OP_SET_KEY;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA[0x%x] VERIFY (SET_KEY) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	arg.ca_opcode   = TE_OP_DOFINAL;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (DO_FINAL) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

__STATIC__ status_t TEST_ecdsa_verify_nist_p256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign nist-p256-key.pem > ecdsa-sig-p256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p256-pubkey.pem
	//   -signature ecdsa-sig-p256.bin
	//
	// Openssl ECDSA big endian binary signature is ASN.1 encoded like this:
	// 30 44 02 20 <r> 02 20 <s>
	//
	// 02 20 may also be 02 21 if the co-ordinate is zero padded. This zero pad must be removed
	// from the r and s below. 20 == 32 (or 33) bytes for p256 sig co-ordinate
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x6a, 0xec, 0xf2, 0x0a,
		0x8d, 0xe7, 0x88, 0xad, 0x21, 0x49, 0x06, 0xc5,
		0x2d, 0xe3, 0xa0, 0xbe, 0x56, 0x74, 0xe4, 0xf5,
		0x77, 0x27, 0x1f, 0xe0, 0x7b, 0x01, 0x0d, 0xc2,
		0x9d, 0x0c, 0xd5, 0x56, 0x02, 0x20, 0x59, 0x05,
		0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6, 0xa5, 0xbc,
		0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7, 0x44, 0x1b,
		0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d, 0xab, 0x9d,
		0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0x6a, 0xec, 0xf2, 0x0a, 0x8d, 0xe7, 0x88, 0xad,
		       0x21, 0x49, 0x06, 0xc5, 0x2d, 0xe3, 0xa0, 0xbe,
		       0x56, 0x74, 0xe4, 0xf5, 0x77, 0x27, 0x1f, 0xe0,
		       0x7b, 0x01, 0x0d, 0xc2, 0x9d, 0x0c, 0xd5, 0x56 },
		.s = { 0x59, 0x05, 0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6,
		       0xa5, 0xbc, 0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7,
		       0x44, 0x1b, 0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d,
		       0xab, 0x9d, 0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48 },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			// XXX Should this extra intermediate field ".pubkey" be removed?
			.pubkey = {
				.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
				       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
				       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
				       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
				.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
				       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
				       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
				       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

#if CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY

#define EC_PUBKEY_KEYSLOT 2U

__STATIC__ status_t TEST_ecdsa_verify_nist_p256_pass_ks(crypto_context_t *c,
							te_crypto_algo_t algo,
							engine_id_t eid,
							uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	(void)algo;

	// SHA-1 digest of data[] (HelloWorld)
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign nist-p256-key.pem > ecdsa-sig-p256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p256-pubkey.pem
	//   -signature ecdsa-sig-p256.bin
	//
	// Openssl ECDSA big endian binary signature is ASN.1 encoded like this:
	// 30 44 02 20 <r> 02 20 <s>
	//
	// 02 20 may also be 02 21 if the co-ordinate is zero padded. This zero pad must be removed
	// from the r and s below. 20 == 32 (or 33) bytes for p256 sig co-ordinate
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x6a, 0xec, 0xf2, 0x0a,
		0x8d, 0xe7, 0x88, 0xad, 0x21, 0x49, 0x06, 0xc5,
		0x2d, 0xe3, 0xa0, 0xbe, 0x56, 0x74, 0xe4, 0xf5,
		0x77, 0x27, 0x1f, 0xe0, 0x7b, 0x01, 0x0d, 0xc2,
		0x9d, 0x0c, 0xd5, 0x56, 0x02, 0x20, 0x59, 0x05,
		0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6, 0xa5, 0xbc,
		0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7, 0x44, 0x1b,
		0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d, 0xab, 0x9d,
		0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0x6a, 0xec, 0xf2, 0x0a, 0x8d, 0xe7, 0x88, 0xad,
		       0x21, 0x49, 0x06, 0xc5, 0x2d, 0xe3, 0xa0, 0xbe,
		       0x56, 0x74, 0xe4, 0xf5, 0x77, 0x27, 0x1f, 0xe0,
		       0x7b, 0x01, 0x0d, 0xc2, 0x9d, 0x0c, 0xd5, 0x56 },
		.s = { 0x59, 0x05, 0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6,
		       0xa5, 0xbc, 0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7,
		       0x44, 0x1b, 0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d,
		       0xab, 0x9d, 0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48 },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	/* This pubkey is stored to keyslot and then loaded from there
	 * into akey object.
	 */
	static const te_ec_point_t passed_pubkey = {
		.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
		       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
		       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
		       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
		.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
		       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
		       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
		       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		.k_keyslot = EC_PUBKEY_KEYSLOT,
		.k_ec_public = {
			.pubkey = {
				.point_flags = (CCC_EC_POINT_FLAG_UNDEFINED |
						CCC_EC_POINT_FLAG_IN_KEYSLOT),
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature with keyslot loaded pubkey\n");

	/* Write passed_pubkey point to ec_keyslot.
	 */
	{
		ret = pka1_write_ec_point_keyslot(eid,
						  EC_PUBKEY_KEYSLOT,
						  TE_LWRVE_NIST_P_256,
						  &passed_pubkey);
		CCC_ERROR_CHECK(ret);
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}
#endif /* CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY */

#if HAVE_READ_PKA1_EC_KEYSLOT_PUBKEY && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY
__STATIC__ status_t TEST_ecdsa_verify_nist_p256_read_ks(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
							uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	uint32_t ec_keyslot = 3U;

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign nist-p256-key.pem > ecdsa-sig-p256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p256-pubkey.pem
	//   -signature ecdsa-sig-p256.bin
	//
	// Openssl ECDSA big endian binary signature is ASN.1 encoded like this:
	// 30 44 02 20 <r> 02 20 <s>
	//
	// 02 20 may also be 02 21 if the co-ordinate is zero padded. This zero pad must be removed
	// from the r and s below. 20 == 32 (or 33) bytes for p256 sig co-ordinate
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x6a, 0xec, 0xf2, 0x0a,
		0x8d, 0xe7, 0x88, 0xad, 0x21, 0x49, 0x06, 0xc5,
		0x2d, 0xe3, 0xa0, 0xbe, 0x56, 0x74, 0xe4, 0xf5,
		0x77, 0x27, 0x1f, 0xe0, 0x7b, 0x01, 0x0d, 0xc2,
		0x9d, 0x0c, 0xd5, 0x56, 0x02, 0x20, 0x59, 0x05,
		0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6, 0xa5, 0xbc,
		0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7, 0x44, 0x1b,
		0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d, 0xab, 0x9d,
		0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0x6a, 0xec, 0xf2, 0x0a, 0x8d, 0xe7, 0x88, 0xad,
		       0x21, 0x49, 0x06, 0xc5, 0x2d, 0xe3, 0xa0, 0xbe,
		       0x56, 0x74, 0xe4, 0xf5, 0x77, 0x27, 0x1f, 0xe0,
		       0x7b, 0x01, 0x0d, 0xc2, 0x9d, 0x0c, 0xd5, 0x56 },
		.s = { 0x59, 0x05, 0x5e, 0x3b, 0x1c, 0x69, 0xc3, 0xc6,
		       0xa5, 0xbc, 0x74, 0x74, 0x24, 0x82, 0x8a, 0xa7,
		       0x44, 0x1b, 0x38, 0xa8, 0xa3, 0xd8, 0x35, 0x1d,
		       0xab, 0x9d, 0x75, 0xf6, 0x9d, 0x94, 0x53, 0x48 },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	/* This pubkey is stored to keyslot and then loaded from there
	 * into akey object.
	 */
	static const te_ec_point_t passed_pubkey = {
		.x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
		       0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
		       0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
		       0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
		.y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
		       0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
		       0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
		       0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};

	static te_args_key_data_t akey = { .k_flags = 0U, };

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature with keyslot loaded pubkey\n");

	/* Write passed_pubkey point to ec_keyslot.
	 */
	{
		ret = pka1_write_ec_point_keyslot(eid,
						  ec_keyslot,
						  TE_LWRVE_NIST_P_256,
						  &passed_pubkey);
		CCC_ERROR_CHECK(ret);
	}

	/* Load EC pubkey from PKA1 ec_keyslot and setup akey for use of
	 * ECDSA verification.
	 */
	{
		akey.k_key_type  = KEY_TYPE_EC_PUBLIC;
		akey.k_flags     = KEY_FLAG_PLAIN;

		ret = pka1_read_ec_point_keyslot(eid,
						 ec_keyslot,
						 TE_LWRVE_NIST_P_256,
						 0U,
						 &akey.k_ec_public.pubkey);
		CCC_ERROR_CHECK(ret);
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}
#endif /* HAVE_READ_PKA1_EC_KEYSLOT_PUBKEY && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY */

#ifdef PSC_ECDSA_TEST
/**
 * ECDSA NIST P-256 signature verify digest
 */

// first test

/* SHA-256 digest of data */
static uint8_t p256_digest[32U] = {
    0x44, 0xac, 0xf6, 0xb7, 0xe3, 0x6c, 0x13, 0x42,
    0xc2, 0xc5, 0x89, 0x72, 0x04, 0xfe, 0x09, 0x50,
    0x4e, 0x1e, 0x2e, 0xfb, 0x1a, 0x90, 0x03, 0x77,
    0xdb, 0xc4, 0xe7, 0xa6, 0xa1, 0x33, 0xec, 0x56
};

/* ECDSA NIST P-256 public key Qx (little endian) */
static uint8_t pub_key_x[32U] = {
    0x83, 0xbf, 0x71, 0xc2, 0x46, 0xff, 0x59, 0x3c,
    0x2f, 0xb1, 0xbf, 0x4b, 0xe9, 0x5d, 0x56, 0xd3,
    0xcc, 0x8f, 0xdb, 0x48, 0xa2, 0xbf, 0x33, 0xf0,
    0xf4, 0xc7, 0x5f, 0x07, 0x1c, 0xe9, 0xcb, 0x1c
};

/* ECDSA NIST P-256 public key Qy (little endian) */
static uint8_t pub_key_y[32U] = {
    0xa9, 0x4c, 0x9a, 0xa8, 0x5c, 0xcd, 0x7c, 0xdc,
    0x78, 0x4e, 0x40, 0xb7, 0x93, 0xca, 0xb7, 0x6d,
    0xe0, 0x13, 0x61, 0x0e, 0x2c, 0xdb, 0x1f, 0x1a,
    0xa2, 0xf9, 0x11, 0x88, 0xc6, 0x14, 0x40, 0xce
};

/* ECDSA NIST P-256 'r' of signature (r,s) in little endian */
static uint8_t signature_r[32U] = {
    0xac, 0xc2, 0xc8, 0x79, 0x6f, 0x5e, 0xbb, 0xca,
    0x7a, 0x5a, 0x55, 0x6a, 0x1f, 0x6b, 0xfd, 0x2a,
    0xed, 0x27, 0x95, 0x62, 0xd6, 0xe3, 0x43, 0x88,
    0x5b, 0x79, 0x14, 0xb5, 0x61, 0x80, 0xac, 0xf3
};

/* ECDSA NIST P-256 's' of signature (r,s) in little endian */
static uint8_t signature_s[32U] = {
    0x03, 0x89, 0x05, 0xcc, 0x2a, 0xda, 0xcd, 0x3c,
    0x5a, 0x17, 0x6f, 0xe9, 0x18, 0xb2, 0x97, 0xef,
    0x1c, 0x37, 0xf7, 0x2b, 0x26, 0x76, 0x6c, 0x78,
    0xb2, 0xa6, 0x05, 0xca, 0x19, 0x78, 0xf7, 0x8b
};

// second test
#define MSG1_LEN 10

static uint8_t message[MSG1_LEN] = "HelloWorld";

/* ECDSA NIST P-256 public key Qx (little endian) */
static uint8_t pub_key_x_01[] = {
    0x25, 0x08, 0x3c, 0x2b, 0x40, 0x03, 0x62, 0x3e,
    0xb8, 0xcb, 0x76, 0x99, 0x21, 0x1c, 0xec, 0x93,
    0x81, 0xcd, 0x4f, 0xf4, 0x91, 0xb8, 0x4b, 0x5e,
    0x75, 0xf3, 0x01, 0xfe, 0x4c, 0x2e, 0x98, 0x26
};

/* ECDSA NIST P-256 public key Qy (little endian) */
static uint8_t pub_key_y_01[] = {
    0x24, 0x2b, 0xc5, 0x30, 0x82, 0x79, 0x8f, 0x86,
    0xd5, 0x4d, 0xde, 0xce, 0x1e, 0xe7, 0xea, 0xe9,
    0x38, 0x16, 0x96, 0xa8, 0x8d, 0x74, 0x0e, 0x2b,
    0x90, 0x06, 0xf1, 0x88, 0x5b, 0xa4, 0x58, 0x5c
};

/* ECDSA NIST P-256 'r' of signature (r,s) in little endian */
static uint8_t signature_r_01[] = {
    0xaa, 0x26, 0x38, 0x3c, 0x85, 0x82, 0xce, 0x63,
    0xb0, 0xeb, 0x01, 0x91, 0xca, 0xe7, 0x1d, 0x96,
    0x19, 0x49, 0x93, 0xfd, 0x2c, 0x21, 0x43, 0x37,
    0x02, 0xfb, 0x30, 0xbd, 0xf3, 0x71, 0xa2, 0xc6
};

/* ECDSA NIST P-256 's' of signature (r,s) in little endian */
static uint8_t signature_s_01[] = {
    0x5d, 0x2c, 0x02, 0xc1, 0x98, 0x94, 0xe2, 0x70,
    0xfc, 0x27, 0x31, 0xf2, 0x96, 0x54, 0x43, 0x32,
    0x98, 0x7e, 0x68, 0x9a, 0x58, 0x06, 0x0d, 0x82,
    0x94, 0x8c, 0xed, 0x1e, 0x61, 0x41, 0xcc, 0x6d
};

/*
 * Initialize arguments
 * This inline function is split from the caller function
 * in order to reduce its code complexity.
 */
static inline status_t ecdsa_init_args(
	te_crypto_args_t *arg,
	const uint8_t *data,
	const uint8_t *signature_r, const uint8_t *signature_s,
	const uint8_t *pub_key_x, const uint8_t *pub_key_y,
	uint32_t *hash_size_bytes,
	uint32_t *key_size_bytes,
	te_crypto_algo_t digest_algorithm,
	te_ec_lwrve_id_t input_lwrve_id)
{
	status_t ret = ERR_FAULT;

	/* Arguments sanitization */
	if ((NULL == data) || (NULL == signature_r) || (NULL == signature_s) ||
	    (NULL == pub_key_x) || (NULL == pub_key_y)) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	arg->ca_init.ec.lwrve_id = input_lwrve_id;
#if 0
	// XXXX JUKI: The data is not little endian ever...
	arg->ca_init.ec.flags = (INIT_FLAG_EC_NONE |
				 INIT_FLAG_EC_DATA_LITTLE_ENDIAN);
#else
	arg->ca_init.ec.flags = INIT_FLAG_EC_NONE;
#endif

	if ((TE_ALG_SHA256 == digest_algorithm) &&
	    (TE_LWRVE_NIST_P_256 == input_lwrve_id)) {
		/* Default parameters */
		ret = NO_ERROR;
	} else {
		ret = SE_ERROR(ERR_ILWALID_ARGS);
	}

fail:
	return ret;
}

/*
 * Set public key
 * This inline function is split from the caller function
 * in order to reduce its code complexity.
 */
static inline status_t ecdsa_set_public_key(
	uint32_t key_size_bytes,
	const uint8_t *pub_key_x,
	const uint8_t *pub_key_y,
	te_args_key_data_t *akey)
{
	status_t ret = NO_ERROR;

	se_util_mem_set((uint8_t *)(uintptr_t)akey, 0U,
			sizeof_u32(te_args_key_data_t));

	akey->k_key_type  = KEY_TYPE_EC_PUBLIC;
	akey->k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN;
	akey->k_ec_public.pubkey.point_flags = EC_POINT_FLAG_LITTLE_ENDIAN;

	se_util_mem_move(&akey->k_ec_public.pubkey.x[0], pub_key_x,
			 key_size_bytes);
	se_util_mem_move(&akey->k_ec_public.pubkey.y[0], pub_key_y,
			 key_size_bytes);
	return ret;
}

/*
 * Set (r, s) signature arguments
 * This inline function is split from the caller function
 * in order to reduce its code complexity.
 */
static inline status_t ecdsa_set_signature(
	te_ec_sig_t *ecdsa_signature,
	const uint8_t *signature_r,
	const uint8_t *signature_s,
	uint32_t key_size_bytes)
{
	status_t ret = NO_ERROR;

	se_util_mem_move(&ecdsa_signature->r[0], signature_r, key_size_bytes);

	se_util_mem_move(&ecdsa_signature->s[0], signature_s, key_size_bytes);
	ecdsa_signature->sig_flags = EC_SIG_FLAG_LITTLE_ENDIAN;

	return ret;
}

/**
 * @brief Verify the given ECDSA digital signature (r,s) with provided
 *	  public key Q = (x, y) EC point, where
 *	  ECC Lwrve = NIST P256
 *
 * @param[in] data the message used to verify against the signature
 * @param[in] data_size the length of the input data in bytes
 * @param[in] is_src_digest True if the input data is a digest,
 *	      False if the input data is the raw content
 * @param[in] signature_r 'r' of the ECDSA signature (r,s) in liitle endian.
 * @param[in] signature_s 's' of the ECDSA signature (r,s) in liitle endian.
 * @param[in] pub_key_x 'x' of of the public key Q (x, y) in little endian.
 * @param[in] pub_key_y 'y' of of the public key Q (x, y) in little endian.
 * @param[in] key_size_bits ECDSA key length in bits (e.g., 256 or 512)
 *
 * @return NO_ERROR if verification succeed, specific error if fails
 */
static status_t psc_crypto_ecdsa_verify(
	const uint8_t *data,
	uint32_t data_size,
	bool is_src_digest,
	te_crypto_algo_t digest_algorithm,
	const uint8_t *signature_r, const uint8_t *signature_s,
	const uint8_t *pub_key_x, const uint8_t *pub_key_y,
	te_ec_lwrve_id_t input_lwrve_id)
{
    status_t ret = ERR_NOT_IMPLEMENTED;
    uint32_t hash_size_bytes = 32U;
    uint32_t key_size_bytes = 32U;

    crypto_context_t ctx = {
	    .ctx_alg_mode = TE_ALG_MODE_VERIFY,
    };
    crypto_context_t *c = &ctx;

    /* FIXME: Consider to share the memory */
    static te_args_key_data_t akey;

    /* ECDSA signature structure */
    static te_ec_sig_t ecdsa_signature = {.sig_flags = 0};

    te_crypto_args_t arg = {
	.ca_alg_mode = TE_ALG_MODE_VERIFY,
	.ca_algo     = TE_ALG_ECDSA,
	.ca_opcode   = TE_OP_COMBINED_OPERATION,
	.ca_init     = {
	    .engine_hint = CCC_ENGINE_PKA1_PKA,
	},
    };

    /* Arguments sanitization and initialization */
    ret = ecdsa_init_args(&arg, data, signature_r, signature_s,
			  pub_key_x, pub_key_y,
			  &hash_size_bytes, &key_size_bytes,
			  digest_algorithm, input_lwrve_id);
    CCC_ERROR_CHECK(ret);

    if (! is_src_digest) {
	    // Digest the input message to generate digest to verify
	    arg.ca_init.ec.flags = INIT_FLAG_EC_DIGEST_INPUT;
	    arg.ca_init.ec.sig_digest_algo = digest_algorithm;
    }

    /* Set public key */
    ret = ecdsa_set_public_key(key_size_bytes, pub_key_x, pub_key_y, &akey);
    CCC_ERROR_CHECK(ret);

    /* Set signature */
    ret = ecdsa_set_signature(&ecdsa_signature, signature_r, signature_s,
			      key_size_bytes);
    CCC_ERROR_CHECK(ret);

    /* Context setup */
    CRYPTO_CONTEXT_SETUP(&ctx, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

    /* Set Common Crypto arguments */
    arg.ca_set_key.kdata = &akey;
    if (is_src_digest) {
	    arg.ca_data.src_digest_size = hash_size_bytes;
	    arg.ca_data.src_digest = &data[0];
    } else {
	    arg.ca_data.src_size = data_size;
	    arg.ca_data.src = &data[0];
    }

    arg.ca_data.src_signature_size = sizeof_u32(te_ec_sig_t);
    arg.ca_data.src_ec_signature = &ecdsa_signature;

    /* Ilwoke Common Crypto library Operation */
    ret = CRYPTO_OPERATION(&ctx, &arg);
    CCC_ERROR_CHECK(ret);

fail:
    CRYPTO_CONTEXT_RESET(c);
    return ret;
}

/**
 * @brief Verify input digest with the given ECDSA digital signature (r,s)
 *	  and public key EC point Q = (x, y), where
 *	  ECC Lwrve = NIST P256
 *
 * @param[in] digest the SHA-256 digest used to verify against the signature
 * @param[in] signature_r 'r' of the ECDSA signature (r,s) in liitle endian.
 * @param[in] signature_s 's' of the ECDSA signature (r,s) in liitle endian.
 * @param[in] pub_key_x 'x' of of the public key Q (x, y) in little endian.
 * @param[in] pub_key_y 'y' of of the public key Q (x, y) in little endian.
 *
 * @return NO_ERROR if verification succeed, specific error if fails
 */
static status_t psc_crypto_ecdsa_nist_p256_digest_verify(
	const uint8_t *digest,
	const uint8_t *signature_r,
	const uint8_t *signature_s,
	const uint8_t *pub_key_x,
	const uint8_t *pub_key_y)
{
	return psc_crypto_ecdsa_verify(digest, 32U,
	       CTRUE, TE_ALG_SHA256, signature_r, signature_s,
	       pub_key_x, pub_key_y, TE_LWRVE_NIST_P_256);
}

static status_t psc_crypto_ecdsa_nist_p256_message_verify(
	const uint8_t *data,
	uint32_t data_size,
	const uint8_t *signature_r,
	const uint8_t *signature_s,
	const uint8_t *pub_key_x,
	const uint8_t *pub_key_y)
{
    return psc_crypto_ecdsa_verify(data, data_size,
	    CFALSE, TE_ALG_SHA256, signature_r, signature_s,
	    pub_key_x, pub_key_y, TE_LWRVE_NIST_P_256);
}

__STATIC__ status_t TEST_psc_ecdsa(void)
{
	status_t ret = NO_ERROR;

	ret = psc_crypto_ecdsa_nist_p256_digest_verify(
		p256_digest,
		signature_r,
		signature_s,
		pub_key_x,
		pub_key_y);
	CCC_ERROR_CHECK(ret,
	   LTRACEF("ECDSA P256 Sig Digest Verify Failed! err=%d\n",
		   ret));

	ret = psc_crypto_ecdsa_nist_p256_message_verify(
		&message[0],
		MSG1_LEN,
		signature_r_01,
		signature_s_01,
		pub_key_x_01,
		pub_key_y_01);

	CCC_ERROR_CHECK(ret,
	   LTRACEF("ECDSA (SECOND) P256 Sig message Verify Failed! err=%d\n",
		   ret));


fail:
	return ret;
}
#endif // PSC_ECDSA_TEST

__STATIC__ status_t TEST_ecdsa_verify_nist_p256_sha256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	const char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-256 digest of data[]
	const uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4
	};

	// This is an ECDSA nist P256 (SHA-256) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -sign nist-p256-key.pem >
	//  ecdsa-sig-p256-sha256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify nist-p256-pubkey.pem
	//   -signature ecdsa-sig-p256-sha256.bin
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	 const uint8_t ecdsa_asn1_sig[] = {
		 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0xa2, 0x71,
		 0xf3, 0xbd, 0x30, 0xfb, 0x02, 0x37, 0x43, 0x21,
		 0x2c, 0xfd, 0x93, 0x49, 0x19, 0x96, 0x1d, 0xe7,
		 0xca, 0x91, 0x01, 0xeb, 0xb0, 0x63, 0xce, 0x82,
		 0x85, 0x3c, 0x38, 0x26, 0xaa, 0x02, 0x20, 0x6d,
		 0xcc, 0x41, 0x61, 0x1e, 0xed, 0x8c, 0x94, 0x82,
		 0x0d, 0x06, 0x58, 0x9a, 0x68, 0x7e, 0x98, 0x32,
		 0x43, 0x54, 0x96, 0xf2, 0x31, 0x27, 0xfc, 0x70,
		 0xe2, 0x94, 0x98, 0xc1, 0x02, 0x2c, 0x5d,
	 };

	 static te_args_key_data_t akey = {
		 .k_key_type  = KEY_TYPE_EC_PUBLIC,
		 .k_flags     = KEY_FLAG_PLAIN,
		 //.k_byte_size get this from the lwrve params
		 // .k_keyslot = 3U, not supported yet
		 .k_ec_public = {
			 // XXX Should this extra intermediate field ".pubkey" be removed?
			 .pubkey = {
				 .x = { 0x26, 0x98, 0x2e, 0x4c, 0xfe, 0x01, 0xf3, 0x75,
					0x5e, 0x4b, 0xb8, 0x91, 0xf4, 0x4f, 0xcd, 0x81,
					0x93, 0xec, 0x1c, 0x21, 0x99, 0x76, 0xcb, 0xb8,
					0x3e, 0x62, 0x03, 0x40, 0x2b, 0x3c, 0x08, 0x25 },
				 .y = { 0x5c, 0x58, 0xa4, 0x5b, 0x88, 0xf1, 0x06, 0x90,
					0x2b, 0x0e, 0x74, 0x8d, 0xa8, 0x96, 0x16, 0x38,
					0xe9, 0xea, 0xe7, 0x1e, 0xce, 0xde, 0x4d, 0xd5,
					0x86, 0x8f, 0x79, 0x82, 0x30, 0xc5, 0x2b, 0x24 },
				 .point_flags = CCC_EC_POINT_FLAG_NONE,
			 },
		 },
	 };

	 CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	 LOG_INFO("Check ECDSA P256 SHA256 signature\n");

	 /* Preset fields */
	 arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	 arg.ca_algo     = TE_ALG_ECDSA;
	 arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	 arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;

	 /* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	  */
	 arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	 arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	 arg.ca_init.engine_hint = eid;

	 LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		  arg.ca_init.ec.lwrve_id);

	 // No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	 //  but this can be changed by init ec flags.

	 // Pass the key params
	 arg.ca_set_key.kdata = &akey;

	 arg.ca_data.src_digest_size    = sizeof_u32(digest);
	 arg.ca_data.src_digest	= digest;

	 LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	 arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	 arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		  algo, data);

	 ret = CRYPTO_OPERATION(c, &arg);

	 LOG_INFO("Operation used engine 0x%x (%s)\n",
		  arg.ca_init.engine_hint,
		  eid_name(arg.ca_init.engine_hint));

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		  algo, ret, arg.ca_handle);
	 CCC_ERROR_CHECK(ret);

	 LOG_INFO("ECDSA P256 SHA-256 message signature check: OK\n");

	 CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	 LOG_INFO("Check ECDSA P256 SHA256 signature (digest message first)\n");

	 se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));

	 /* Preset fields */
	 arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	 arg.ca_algo     = TE_ALG_ECDSA;
	 arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	 arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;

	 /* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	  */
	 arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	 /* Digest the passed message first with SHA-256
	  */
	 arg.ca_init.ec.flags |= INIT_FLAG_EC_DIGEST_INPUT;
	 arg.ca_init.ec.sig_digest_algo = TE_ALG_SHA256;

	 arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	 arg.ca_init.engine_hint = eid;

	 LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		  arg.ca_init.ec.lwrve_id);

	 // Pass the key params
	 arg.ca_set_key.kdata = &akey;

	 arg.ca_data.src_size = sizeof_u32(data);
	 arg.ca_data.src = (const uint8_t *)data;

	 LOG_INFO("ECDSA signature verify message with ASN.1 DER signature\n");
	 arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	 arg.ca_data.src_asn1		= ecdsa_asn1_sig;

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		  algo, data);

	 ret = CRYPTO_OPERATION(c, &arg);

	 LOG_INFO("Operation used engine 0x%x (%s)\n",
		  arg.ca_init.engine_hint,
		  eid_name(arg.ca_init.engine_hint));

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		  algo, ret, arg.ca_handle);
	 CCC_ERROR_CHECK(ret);

	 LOG_INFO("ECDSA P256 SHA-256 message signature check: OK\n");

 fail:
	 CRYPTO_CONTEXT_RESET(c);
	 if (NO_ERROR != ret) {
		 LOG_INFO("ECDSA P256 SHA-256 signature check: failed\n");
	 }
	 return ret;
 }

#if HAVE_P521
__STATIC__ status_t TEST_ecdsa_verify_nist_p521(crypto_context_t *c,
						te_crypto_algo_t algo,
						engine_id_t eid,
						uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-256 digest of data[]
	const uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4,
	};

	// This is an ECDSA P521 (SHA256) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" | openssl dgst -sha256 -sign p521-pkey.pem > sig-p521.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  dgst -sha256 -verify p521-pub.pem
	//   -signature sig-p521.bin
	//
	// Openssl ECDSA big endian binary signature is ASN.1 encoded like this:
	// 30 8186 02 41 <r> 02 41 <s>
	// (134 byte sequence with two 65 byte integers)
	//
	/* openssl generated ASN.1 DER formatted ECDSA binary signature object
	 * is also supported by the CCC.
	 *
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x81, 0x86,
		  0x02, 0x41,
		   0x11, 0x98, 0xce, 0x25, 0x40, 0xb7, 0x9c, 0x46,
		   0x1d, 0xb9, 0x23, 0x6a, 0xc7, 0x1b, 0x94, 0x17,
		   0x44, 0x3e, 0xfa, 0xd7, 0x1c, 0x54, 0x0e, 0xcf,
		   0x6b, 0x35, 0xf2, 0x5a, 0xb4, 0x0f, 0xb5, 0xd3,
		   0x34, 0x40, 0x91, 0xc0, 0xf4, 0x52, 0xcf, 0x49,
		   0x58, 0xfd, 0xaf, 0x11, 0xe5, 0x50, 0xcb, 0x75,
		   0xa4, 0x64, 0xa1, 0x90, 0x2b, 0x07, 0xba, 0xf5,
		   0x36, 0x5b, 0xf6, 0x33, 0x54, 0x5a, 0x1e, 0x94,
		   0x42,
		0x02, 0x41,
		   0x66, 0x36, 0x8c, 0x3f, 0x18, 0x66, 0x72, 0x28,
		   0x6f, 0xa5, 0x00, 0xa0, 0xe3, 0x78, 0x62, 0x4f,
		   0xc3, 0xba, 0xd6, 0x43, 0x27, 0x49, 0x95, 0xfa,
		   0x5c, 0xaa, 0x96, 0xac, 0x27, 0x14, 0xf5, 0x46,
		   0x72, 0x4b, 0x67, 0xcb, 0xc7, 0xce, 0x6a, 0xf8,
		   0x0b, 0xe0, 0xc2, 0xa0, 0x0f, 0xa1, 0xed, 0xc8,
		   0x2c, 0x0d, 0x4f, 0x21, 0xe4, 0x3e, 0xb4, 0x85,
		   0xdf, 0x0b, 0x49, 0x1e, 0xbf, 0xcb, 0x23, 0x16,
		   0xdb,
	};

	/* Signature object (same as the ASN.1 signature, different format) */
	te_ec_sig_t sig = {
		.r = { 0x00, 0x00, 0x00,
		       0x11, 0x98, 0xce, 0x25, 0x40, 0xb7, 0x9c, 0x46,
		       0x1d, 0xb9, 0x23, 0x6a, 0xc7, 0x1b, 0x94, 0x17,
		       0x44, 0x3e, 0xfa, 0xd7, 0x1c, 0x54, 0x0e, 0xcf,
		       0x6b, 0x35, 0xf2, 0x5a, 0xb4, 0x0f, 0xb5, 0xd3,
		       0x34, 0x40, 0x91, 0xc0, 0xf4, 0x52, 0xcf, 0x49,
		       0x58, 0xfd, 0xaf, 0x11, 0xe5, 0x50, 0xcb, 0x75,
		       0xa4, 0x64, 0xa1, 0x90, 0x2b, 0x07, 0xba, 0xf5,
		       0x36, 0x5b, 0xf6, 0x33, 0x54, 0x5a, 0x1e, 0x94,
		       0x42,},
		.s = { 0x00, 0x00, 0x00,
		       0x66, 0x36, 0x8c, 0x3f, 0x18, 0x66, 0x72, 0x28,
		       0x6f, 0xa5, 0x00, 0xa0, 0xe3, 0x78, 0x62, 0x4f,
		       0xc3, 0xba, 0xd6, 0x43, 0x27, 0x49, 0x95, 0xfa,
		       0x5c, 0xaa, 0x96, 0xac, 0x27, 0x14, 0xf5, 0x46,
		       0x72, 0x4b, 0x67, 0xcb, 0xc7, 0xce, 0x6a, 0xf8,
		       0x0b, 0xe0, 0xc2, 0xa0, 0x0f, 0xa1, 0xed, 0xc8,
		       0x2c, 0x0d, 0x4f, 0x21, 0xe4, 0x3e, 0xb4, 0x85,
		       0xdf, 0x0b, 0x49, 0x1e, 0xbf, 0xcb, 0x23, 0x16,
		       0xdb, },
		.sig_flags = CCC_EC_SIG_FLAG_NONE,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			// XXX Should this extra intermediate field ".pubkey" be removed?
			.pubkey = {
				.x = { 0x00, 0x00, 0x01,
				       0xdb, 0x66, 0xcf, 0xd6, 0x3a, 0xa9, 0x97, 0xaf,
				       0x5d, 0xc8, 0x1f, 0x66, 0xac, 0x4d, 0x9a, 0xe6,
				       0xe8, 0xdc, 0x08, 0x52, 0x88, 0xff, 0x56, 0x1f,
				       0x06, 0x06, 0xb7, 0xaa, 0x1d, 0xc5, 0xbd, 0x19,
				       0xbd, 0x36, 0x15, 0xab, 0x26, 0x4d, 0x57, 0x5f,
				       0x60, 0xe1, 0x96, 0xae, 0xe5, 0x1a, 0xee, 0x5c,
				       0x21, 0xd5, 0x46, 0xa9, 0x2d, 0xbd, 0x19, 0x39,
				       0x27, 0xa1, 0x27, 0x9c, 0x6f, 0x62, 0x39, 0x8e,
				       0xd1 },
				.y = { 0x00, 0x00, 0x01,
				       0x18, 0xc8, 0x23, 0x74, 0xbc, 0x92, 0x25, 0x66,
				       0xd8, 0xa9, 0x42, 0x00, 0x0f, 0x15, 0x99, 0x2c,
				       0xca, 0x7e, 0xe7, 0xb0, 0x84, 0xe0, 0x14, 0xb8,
				       0xe5, 0x9c, 0x93, 0x51, 0x58, 0x88, 0xfe, 0x7f,
				       0xc8, 0x6a, 0xb2, 0xff, 0x2b, 0x58, 0x48, 0xa4,
				       0x8a, 0x8d, 0x05, 0x1d, 0x23, 0xfc, 0x7c, 0x76,
				       0x3f, 0x82, 0xf0, 0x00, 0x3b, 0xdc, 0xa2, 0x9f,
				       0x21, 0x0e, 0x20, 0x9a, 0x19, 0xff, 0xcb, 0x9d,
				       0xd5 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_INIT;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0U) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	/* Select the EC lwrve in init ec parameters */
	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_521;
	arg.ca_init.engine_hint = eid;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA-P521[0x%x] VERIFY (INIT) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_opcode   = TE_OP_SET_KEY;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("ECDSA-P521[0x%x] VERIFY (SET_KEY) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	if (use_asn1_ec_sig != 0U) {
		LOG_INFO("ECDSA-P521 signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
		arg.ca_data.src_asn1	       = ecdsa_asn1_sig;
	} else {
		LOG_INFO("ECDSA-P521 signature verify with te_ec_sig_t object\n");
		arg.ca_data.src_signature_size = sizeof_u32(sig);
		arg.ca_data.src_ec_signature   = &sig;
	}

	arg.ca_opcode   = TE_OP_DOFINAL;

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA-P521[0x%x] VERIFY (DO_FINAL) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA-P521 signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA-P521 signature check: failed\n");
	}
	return ret;
}
#endif /* HAVE_P521 */

#if HAVE_BRAINPOOL_LWRVES
__STATIC__ status_t TEST_ecdsa_verify_brainpool_p256r1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an Brainpool P256r1 ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign bp256r1-pkey.pem > bp256r1-signature.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify bp256r1-pubkey.pem
	//   -signature bp256r1-signature.bin
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x4b, 0x0b, 0x4f, 0x1c, 0x1f, 0x6f, 0x06, 0x37, 0x2b, 0xf7, 0xa5, 0x77,
		0xec, 0x2e, 0x50, 0x31, 0x2b, 0x01, 0xef, 0x18, 0x4a, 0xe3, 0x16, 0xfa, 0xb8, 0x49, 0xd8, 0x6b,
		0xe6, 0x31, 0x60, 0x6f, 0x02, 0x20, 0x06, 0x66, 0x49, 0x86, 0x08, 0x96, 0x08, 0xd1, 0xb1, 0x25,
		0x56, 0x8e, 0x6b, 0xbc, 0x9a, 0xd4, 0x5d, 0x05, 0x68, 0x3d, 0x1d, 0x4b, 0xda, 0xa5, 0x63, 0x10,
		0x6a, 0x61, 0x8f, 0xac, 0x95, 0xd2,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			.pubkey = {
				.x = { 0x15, 0xcd, 0x73, 0x06, 0x80, 0x60, 0x78, 0x84, 0xc6, 0xc9, 0x88, 0x64, 0x07, 0xe8, 0x61, 0x7f,
				       0x2d, 0xd6, 0x01, 0xc9, 0x61, 0x7b, 0x53, 0x92, 0x86, 0x0a, 0x77, 0xc4, 0x5a, 0x6e, 0x1b, 0x0d, },
				.y = { 0x91, 0x8c, 0x38, 0xc6, 0x64, 0xa6, 0x90, 0xd7, 0x60, 0xa3, 0x8c, 0x39, 0x46, 0x1c, 0x50, 0x6c,
				       0x6a, 0xbb, 0x35, 0xcd, 0x1a, 0x0d, 0x46, 0x3d, 0xe6, 0x8a, 0xb1, 0x9e, 0xcc, 0x59, 0x51, 0x8f, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check brainpoolP256r1 signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	 */
	arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_BRAINPOOL_P256r1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

__STATIC__ status_t TEST_ecdsa_verify_brainpool_p512r1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-256 digest of data[]
	static const uint8_t digest[] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4,
	};

	// Generate bp512r1 private key:
	// openssl ecparam --name brainpoolP512r1 -genkey > private-bp512_key.pem
	//
	// Extract the public key:
	// openssl ec --pubout < private-bp512_key.pem > pubkey_bp512.pem
	//
	// View the public key:
	// openssl ec --pubin --text < pubkey_bp512.pem
	// pub: field contains the encoded public key www.secg.org/sec1-v2.pdf#page=17
	// (Remove the 0x04 byte and split in two => first half is X, the second half is Y)
	//
	// This is an Brainpool P512r1 ECDSA (SHA256) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -sign bp512r1-pkey.pem > bp512r1-signature.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -verify bp512r1-pubkey.pem
	//   -signature bp512r1-signature.bin
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	static const uint8_t ecdsa_asn1_sig[] = {
		0x30,		// sequence
		0x81, 0x84,	// length > 127, length encoded with 1 additional byte => value 0x84 == 132 bytes
		0x02, 0x40,	// 64 byte integer
		0x50, 0x37, 0x07, 0xee, 0x41, 0x01, 0x4c, 0x9b, 0x71, 0xab, 0x05, 0xd3, 0xc5, 0x62, 0x57, 0xe5,
		0x39, 0x83, 0xaf, 0x22, 0x23, 0x6a, 0xe6, 0xd1, 0xbd, 0x11, 0x2d, 0x84, 0x44, 0x05, 0x01, 0x50,
		0x90, 0xfc, 0xf7, 0xa7, 0x9d, 0x96, 0xf5, 0xb8, 0x3b, 0x1d, 0xbc, 0xf8, 0xe0, 0x40, 0x22, 0xf8,
		0xf8, 0x8e, 0x79, 0x5f, 0x88, 0xcd, 0xfc, 0x9b, 0xac, 0x26, 0x14, 0x2f, 0x42, 0x16, 0x86, 0x30,

		0x02, 0x40,	// 64 byte integer
		0x72, 0x0b, 0xe7, 0xed, 0x6b, 0x83, 0xee, 0xee, 0x35, 0xba, 0xcc, 0xe5, 0xdd, 0x85, 0x8c, 0xff,
		0x0b, 0xbf, 0xd4, 0xf5, 0xa5, 0xcd, 0x7c, 0x35, 0x48, 0x46, 0x3a, 0x56, 0xec, 0x78, 0xaa, 0x56,
		0x1a, 0xbb, 0x4b, 0xe4, 0x13, 0x12, 0x00, 0xb2, 0xa3, 0x99, 0xb0, 0x62, 0xc8, 0x6f, 0x0f, 0xc0,
		0x8b, 0xb0, 0xe1, 0x1b, 0x12, 0x87, 0xa0, 0xe1, 0xdf, 0x3e, 0x1c, 0x3b, 0xcb, 0x53, 0x72, 0x7c,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		.k_ec_public = {
			.pubkey = {
				.x = {
					0x78, 0xe6, 0x41, 0x6e, 0xb2, 0xf5, 0x93, 0x74,
					0x37, 0x69, 0x32, 0xe9, 0xed, 0x5e, 0xc1, 0x6f,
					0xd8, 0x29, 0x48, 0x12, 0xbc, 0xad, 0xd6, 0x8c,
					0xbb, 0x7c, 0xb5, 0x96, 0xea, 0xa9, 0x9a, 0xc3,
					0x33, 0xba, 0x94, 0xc5, 0xfe, 0x22, 0x37, 0x0d,
					0x27, 0x48, 0xa6, 0xed, 0x5c, 0x14, 0xc6, 0x8a,
					0xb9, 0x05, 0x95, 0xf7, 0x3b, 0xff, 0xb7, 0xce,
					0xb4, 0xaa, 0x76, 0xde, 0x6d, 0xc4, 0x94, 0x1a, },
				.y = {
					0x38, 0xb5, 0xda, 0x05, 0x97, 0xf1, 0x37, 0xb5,
					0x3c, 0xd0, 0x11, 0xa9, 0x5b, 0xb9, 0x18, 0xa9,
					0x03, 0xdd, 0x63, 0xad, 0x97, 0xf2, 0xfd, 0xfe,
					0x4a, 0xcd, 0x4c, 0x76, 0x0e, 0x9e, 0x1a, 0x78,
					0xfc, 0x04, 0xe0, 0x52, 0xed, 0x31, 0xd8, 0xb4,
					0x76, 0xe8, 0x7e, 0x1d, 0x90, 0xee, 0x00, 0xb9,
					0xd8, 0x50, 0x3d, 0x6d, 0xb4, 0x56, 0x76, 0x94,
					0xde, 0xeb, 0x09, 0xc6, 0xa2, 0x50, 0x6e, 0x39, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check brainpoolP512r1 signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	 */
	arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_BRAINPOOL_P512r1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

#if HAVE_BRAINPOOL_TWISTED_LWRVES
__STATIC__ status_t TEST_ecdsa_verify_brainpool_p256t1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// This is an Brainpool P256r1 ECDSA (SHA1) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -sign bp256t1-pkey.pem > bp256t1-signature.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha1 -verify bp256t1-pubkey.pem
	//   -signature bp256t1-signature.bin
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x45, 0x02, 0x21, 0x00, 0x9d, 0x13, 0x0c, 0x08, 0x29, 0x29, 0xa2, 0x9f, 0x7c, 0x58, 0x37,
		0xca, 0x4c, 0x9b, 0x7e, 0xd7, 0xba, 0xe4, 0xf8, 0xcc, 0x63, 0x75, 0x50, 0x54, 0xf9, 0xc4, 0xd9,
		0xd6, 0x9f, 0x4a, 0x3f, 0xc4, 0x02, 0x20, 0x16, 0xdf, 0xdc, 0x14, 0x99, 0x55, 0xeb, 0x23, 0xd7,
		0x12, 0xe1, 0xf2, 0x6b, 0xaf, 0x60, 0xbe, 0xe0, 0x66, 0x51, 0x6f, 0xfa, 0xdc, 0x84, 0xba, 0x5f,
		0xd2, 0xc7, 0x0d, 0x49, 0x70, 0xb4, 0xf9,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			.pubkey = {
				.x = { 0x9e, 0x96, 0x27, 0x79, 0xdd, 0xd9, 0x75, 0x6b, 0x8f, 0x09, 0x34, 0xe5, 0xac, 0xdc, 0xb3, 0x7c,
				       0x08, 0xbb, 0x49, 0x51, 0x0c, 0x8d, 0x54, 0x83, 0x77, 0x94, 0x32, 0xaf, 0xd6, 0x83, 0x46, 0xbc, },
				.y = { 0x2a, 0x09, 0x3b, 0x93, 0xda, 0x62, 0x2a, 0x32, 0x2f, 0x44, 0xf9, 0x02, 0xcf, 0xac, 0xdc, 0x0f,
				       0xca, 0x4b, 0xea, 0xb0, 0xb1, 0x90, 0x95, 0xa8, 0x6c, 0xad, 0x70, 0x95, 0x47, 0xc7, 0x38, 0x1c, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	LOG_INFO("Check brainpoolP256t1 signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	 */
	arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_BRAINPOOL_P256t1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;

	LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: failed\n");
	}
	return ret;
}

static status_t ecdsa_verify_generic(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
				     te_args_key_data_t *akey, te_ec_lwrve_id_t lwrve_id,
				     const uint8_t *digest, uint32_t digestlen,
				     const uint8_t *asn1_sig, uint32_t asn1_sig_len,
				     const struct te_ec_sig_s *ecdsa_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	bool asn1 = false;

	if (algo != TE_ALG_ECDSA) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, algo);

	LOG_INFO("Check ECDSA signature of data\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if ((NULL != asn1_sig) && (asn1_sig_len > 0U)) {
		/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
		asn1 = true;
	} else if (NULL == ecdsa_sig) {
		/* No signature parameters */
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	arg.ca_init.ec.lwrve_id = lwrve_id; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// Pass the key params
	arg.ca_set_key.kdata = akey;

	arg.ca_data.src_digest_size    = digestlen;
	arg.ca_data.src_digest	       = digest;

	if (BOOL_IS_TRUE(asn1)) {
		LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
		arg.ca_data.src_signature_size = asn1_sig_len;
		arg.ca_data.src_asn1	       = asn1_sig;
	} else {
		LOG_INFO("ECDSA signature verify with CCC sig blob\n");
		arg.ca_data.src_signature_size = sizeof_u32(struct te_ec_sig_s);
		arg.ca_data.src_ec_signature = ecdsa_sig;
	}

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		 algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);

	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature check: OK\n");
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA signature check: FAILED\n");
	}
	return ret;
}

__STATIC__ status_t TEST_ecdsa_verify_brainpool_p512t1(crypto_context_t *c,
						       te_crypto_algo_t algo,
						       engine_id_t eid)
{
	status_t ret = NO_ERROR;

	// SHA-256 digest of data[]
	const uint8_t digest[32U] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4,
	};

	// This is an Brainpool P256r1 ECDSA (SHA256) signature, created with cmd:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -sign bp512t1-pkey.pem > bp512t1-signature.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -verify bp512t1-pubkey.pem
	//   -signature bp512t1-signature.bin
	//

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x81, 0x84, 0x02, 0x40, 0x01, 0x14, 0xfc, 0x2a,
		0x78, 0xde, 0x19, 0xa0, 0xf4, 0xff, 0xb1, 0xfa, 0x67,
		0x2c, 0x57, 0x07, 0xae, 0x83, 0xf4, 0x06, 0x85, 0x99,
		0xbd, 0xf0, 0x5d, 0x69, 0x05, 0x4d, 0xa5, 0x57, 0x44,
		0xa0, 0x10, 0x1d, 0x6e, 0xfe, 0xed, 0x09, 0x7b, 0x1f,
		0x3f, 0xf5, 0x73, 0x22, 0x67, 0xe9, 0xe9, 0x08, 0xb1,
		0x9e, 0xa8, 0xef, 0x01, 0xa2, 0x9e, 0xda, 0xc4, 0x46,
		0x12, 0x31, 0x60, 0x36, 0xe7, 0x90, 0x02, 0x40, 0x4f,
		0x90, 0x0f, 0xd1, 0x25, 0x57, 0x0a, 0x00, 0xee, 0x23,
		0x38, 0x0d, 0x7f, 0x7a, 0xc5, 0xea, 0xdd, 0x65, 0x55,
		0x4a, 0xb2, 0xb6, 0xa5, 0x44, 0x6e, 0x1d, 0xb7, 0x0a,
		0x23, 0xb1, 0x34, 0xf8, 0x4e, 0x81, 0x31, 0x56, 0x3e,
		0x04, 0x71, 0x70, 0x62, 0x86, 0x1e, 0x97, 0x87, 0x0d,
		0x32, 0x4a, 0x3f, 0x3e, 0x55, 0x76, 0x34, 0x4b, 0x73,
		0xc0, 0xa9, 0x3d, 0xd8, 0xa8, 0x1f, 0x6b, 0xcc, 0xb4,
	};

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			.pubkey = {
				.x = { 0x1a, 0x30, 0x6b, 0x16, 0x2f, 0x50, 0xc1, 0x04,
				       0xf9, 0x9f, 0x96, 0x75, 0x5a, 0xea, 0x8e, 0xcc,
				       0x69, 0x99, 0x56, 0x3d, 0x0a, 0xa3, 0xd7, 0x49,
				       0xdd, 0xaa, 0x27, 0xbd, 0x7c, 0x9a, 0x76, 0x23,
				       0xa1, 0xc3, 0xd1, 0x5c, 0x46, 0x26, 0xe1, 0xdd,
				       0xbb, 0xac, 0xda, 0xfa, 0xea, 0x62, 0x66, 0xac,
				       0x4a, 0x47, 0x49, 0x7d, 0x8a, 0x9f, 0xea, 0xcf,
				       0x24, 0xbd, 0xc6, 0xf8, 0x5e, 0x05, 0xc5, 0x0c,
				},
				.y = { 0x90, 0xa0, 0xd1, 0xdc, 0x8f, 0x93, 0xf2, 0x30,
				       0x02, 0x5a, 0x08, 0xbe, 0x0e, 0x55, 0xae, 0xfd,
				       0x0d, 0xa8, 0x87, 0x04, 0x63, 0x28, 0x52, 0x10,
				       0xca, 0x77, 0x20, 0xb3, 0xe5, 0xe2, 0xc4, 0x9d,
				       0xcf, 0xb8, 0x46, 0x39, 0x5a, 0xc8, 0x9a, 0xb9,
				       0x0c, 0xb4, 0x58, 0x1f, 0x1b, 0xe5, 0xd8, 0x0c,
				       0x1b, 0x0c, 0x04, 0x97, 0xb8, 0x34, 0xcc, 0x3a,
				       0xc7, 0x92, 0x99, 0x6c, 0xc8, 0x3a, 0xe6, 0x65,
				},
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	LOG_INFO("Check brainpoolP256t1 signature of data; SE driver gets the digest from caller\n");

	ret = ecdsa_verify_generic(c, algo, eid,
				   &akey, TE_LWRVE_BRAINPOOL_P512t1,
				   digest, sizeof_u32(digest),
				   ecdsa_asn1_sig, sizeof_u32(ecdsa_asn1_sig),
				   NULL);
	CCC_ERROR_CHECK(ret);

fail:
	return ret;
}
#endif /* HAVE_BRAINPOOL_TWISTED_LWRVES */
#endif /* HAVE_BRAINPOOL_LWRVES */
#endif /* TEST_ECDSA */

#if HAVE_KOBLITZ_LWRVES
#ifdef TEST_ECDH

__STATIC__ status_t TEST_ecdh_koblitz_secp256k1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t ss[TE_MAX_ECC_BYTES];

	const uint8_t correct[32] = {
		0xbc, 0xf5, 0xda, 0x13, 0x90, 0x9e, 0xe3, 0xeb,
		0xec, 0xfa, 0x1d, 0xa7, 0x44, 0x18, 0xdc, 0x48,
		0x5b, 0x03, 0x99, 0xec, 0x60, 0xb5, 0xb1, 0xe7,
		0x83, 0x69, 0x96, 0x9a, 0xa3, 0x6a, 0x6c, 0x02,
	};

#define ECDH_SELF_256k1 0

#if !ECDH_SELF_256k1
	/* The peer pubkey in given in BIG ENDIAN; set point_flags bit
	 * set CCC_EC_POINT_FLAG_LITTLE_ENDIAN if is in LE
	 *
	 * By some magic co-incidence (eh...) this happens to be the public key matching
	 * the private key in akey.k_ec_private.key below...
	 *
	 * => the result is identical if ECDH_SELF_256k1 is defined either 0 or 1
	 */
	te_ec_point_t peer_pubkey = {
		.x = {
			0x0a, 0x8f, 0xaf, 0xc7, 0x5f, 0x9e, 0x93, 0x87,
			0x98, 0x95, 0x6a, 0x77, 0x6c, 0x98, 0x2a, 0x5a,
			0x29, 0xd0, 0xba, 0xfe, 0x7d, 0xa8, 0xc0, 0xb3,
			0xba, 0xcf, 0x31, 0x33, 0x52, 0xf8, 0xb6, 0x10,
		},
		.y = {
			0x9b, 0x81, 0x3f, 0x78, 0xa6, 0xee, 0x2d, 0xd2,
			0x88, 0xec, 0xd4, 0x29, 0x3c, 0xe4, 0x23, 0x7a,
			0xe4, 0x2a, 0xbd, 0xbf, 0x28, 0x3a, 0x70, 0xe9,
			0x78, 0x8c, 0x0d, 0xf4, 0x0c, 0xbd, 0xca, 0xdc,
		},
		.point_flags = CCC_EC_POINT_FLAG_NONE,
	};
#endif

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		// EC private key data is BIG ENDIAN by default (set a flag if it is LE)
		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = {
				0x8d, 0x85, 0x90, 0xa3, 0xcf, 0x16, 0xf1, 0xb7,
				0x10, 0xd6, 0x95, 0xbf, 0x52, 0xac, 0xe3, 0x1d,
				0x86, 0xc7, 0x2f, 0xbe, 0xc7, 0xaa, 0xf3, 0xfb,
				0x54, 0xad, 0x2a, 0xd5, 0x40, 0x30, 0x4a, 0xcd,
			},
			.key_length = 32U,

			/* SW to callwlate P = d * Q; (i.e. EC public key, which is not provided here
			 * in this example)
			 *
			 * Flag the pubkey as "undefined" so the SE driver callwlates it when required.
			 */
			.pubkey = {
				.x = {
					0xc5, 0xfe, 0x07, 0xd8, 0xbf, 0x19, 0xbe, 0x66,
					0xb0, 0x80, 0x96, 0x80, 0x33, 0x45, 0x93, 0xc9,
					0x27, 0x06, 0x24, 0x53, 0x91, 0xe9, 0xec, 0xf7,
					0x5e, 0x2a, 0x39, 0xa3, 0xbd, 0x52, 0xc6, 0x97,},

				.y = { 0x18, 0x38, 0x9a, 0x30, 0xa6, 0x04, 0x18, 0x46,
				       0xe7, 0x21, 0x5a, 0x38, 0x2a, 0x1a, 0x43, 0xff,
				       0xe4, 0x75, 0x0a, 0xfc, 0xb2, 0x88, 0x0f, 0x91,
				       0x2e, 0x69, 0xb4, 0xe3, 0x8f, 0xa4, 0x8b, 0x6a, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	if (algo != TE_ALG_ECDH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ECDH for the ECDH test\n", algo));
	}

	se_util_mem_set(ss, 0, sizeof_u32(ss));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = TE_ALG_ECDH;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_KOBLITZ_P_256k1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;		       /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDH lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

#if ECDH_SELF_256k1
	/* If src_point == NULL => callwlate the ECDH value
	 * with <my_private_key,my_public_key>
	 *
	 * my_private_key is the private key in .k_ec_private.key above
	 */
	arg.ca_data.src_size  = 0;
	arg.ca_data.src_point = NULL;
#else
	/* If src_point != NULL => callwlate the ECDH value
	 * with <my_private_key, peer_pubkey>
	 */
	arg.ca_data.src_size  = sizeof_u32(peer_pubkey);
	arg.ca_data.src_point = &peer_pubkey;
#endif
	arg.ca_data.dst_size = sizeof_u32(ss);
	arg.ca_data.dst = ss;

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) src is peer EC public key\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("ECDH derivation result:", ss, arg.ca_data.dst_size);
	VERIFY_ARRAY_VALUE(ss, correct, sizeof_u32(correct));

	if (arg.ca_data.dst_size != sizeof_u32(correct)) {
		TRAP_ERROR("ECDH result length incorrect\n");
	}
fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* TEST_ECDH */

#ifdef TEST_ECDSA
__STATIC__ status_t TEST_ecdsa_verify_koblitz_secp256k1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;
	(void)algo;

	// SHA-256 digest of data[]
	const uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8,
		0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a,
		0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4
	};

	/* openssl generated ASN.1 DER formatted binary signature object
	 * is also supported by the SE driver (fixed format requirement!)
	 * The ASN.1 integer fields are in big endian always.
	 *
	 * This and the sig object below contain the same signature,
	 * format is different.
	 */
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0x50, 0xf8, 0x39, 0x25,
		0x46, 0x1a, 0x93, 0x11, 0xeb, 0x27, 0xbb, 0x3a,
		0xd4, 0xd1, 0x2c, 0x82, 0xf7, 0xb6, 0x07, 0x0f,
		0x11, 0x72, 0xa3, 0xea, 0x08, 0x7e, 0x02, 0x58,
		0x74, 0x39, 0xfd, 0x66, 0x02, 0x20, 0x16, 0xd7,
		0x3d, 0x0a, 0xae, 0x7d, 0x45, 0x38, 0x4f, 0x05,
		0x17, 0x39, 0x81, 0x43, 0xe6, 0xc1, 0x73, 0x8f,
		0xce, 0x8d, 0x3d, 0x35, 0xac, 0x74, 0xcb, 0xc6,
		0x34, 0x67, 0x71, 0x5c, 0x82, 0xe4, };

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_public = {
			.pubkey = {
				.x = { 0xc5, 0xfe, 0x07, 0xd8, 0xbf, 0x19, 0xbe, 0x66,
				       0xb0, 0x80, 0x96, 0x80, 0x33, 0x45, 0x93, 0xc9,
				       0x27, 0x06, 0x24, 0x53, 0x91, 0xe9, 0xec, 0xf7,
				       0x5e, 0x2a, 0x39, 0xa3, 0xbd, 0x52, 0xc6, 0x97, },
				.y = { 0x18, 0x38, 0x9a, 0x30, 0xa6, 0x04, 0x18, 0x46,
				       0xe7, 0x21, 0x5a, 0x38, 0x2a, 0x1a, 0x43, 0xff,
				       0xe4, 0x75, 0x0a, 0xfc, 0xb2, 0x88, 0x0f, 0x91,
				       0x2e, 0x69, 0xb4, 0xe3, 0x8f, 0xa4, 0x8b, 0x6a, },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	 CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ECDSA);

	 LOG_INFO("Check ECDSA Koblitz secp256k1 SHA256 signature\n");

	 /* Preset fields */
	 arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	 arg.ca_algo     = TE_ALG_ECDSA;
	 arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	 arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;

	 /* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	  */
	 arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	 arg.ca_init.ec.lwrve_id = TE_LWRVE_KOBLITZ_P_256k1; /* Select the EC lwrve in init ec parameters */
	 arg.ca_init.engine_hint = eid;

	 LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		  arg.ca_init.ec.lwrve_id);

	 // No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	 //  but this can be changed by init ec flags.

	 // Pass the key params
	 arg.ca_set_key.kdata = &akey;

	 arg.ca_data.src_digest_size    = sizeof_u32(digest);
	 arg.ca_data.src_digest		= digest;

	 LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	 arg.ca_data.src_signature_size = sizeof_u32(ecdsa_asn1_sig);
	 arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src %p data\n",
		  algo, data);

	 ret = CRYPTO_OPERATION(c, &arg);

	 LOG_INFO("Operation used engine 0x%x (%s)\n",
		  arg.ca_init.engine_hint,
		  eid_name(arg.ca_init.engine_hint));

	 LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
		  algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	 LOG_INFO("ECDSA KOBLITZ secp256k1 SHA-256 signature check: OK\n");
 fail:
	 CRYPTO_CONTEXT_RESET(c);
	 if (NO_ERROR != ret) {
		 LOG_INFO("ECDSA secp256k1 SHA-256 signature check: failed\n");
	 }
	 return ret;
 }
#endif /* TEST_ECDSA */

#endif /* HAVE_KOBLITZ_LWRVES */
#endif /* CCC_EC_MIN_PRIME_BITS <= 256U */

#ifdef TEST_ECDSA_SIGN

#if HAVE_BRAINPOOL_TWISTED_LWRVES
__STATIC__ status_t TEST_ecdsa_sign_verify_bp512t1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						   uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	struct te_ec_sig_s sig = { .sig_flags = 0U };
	static uint8_t sigbuf[164] = { 0x0U };

	(void)algo;

	// SHA-256 digest of data[]
	// char data[10] = "HelloWorld";
	//
	const uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8, 0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a, 0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4,
	};

	// ECDSA signature of a SHA-256 digest can be created and verified with openssl cmd using this key:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -sign bp-512t1-pkey.pem
	//   > ecdsa-sig-bp512t1-sha256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -verify bp-512t1-pub.pem
	//   -signature ecdsa-sig-bp512t1-sha256.bin
	//
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U
		.k_ec_private = {
			.key = { /* 2 < d < lwrve order */
				0x38, 0x5a, 0xf9, 0x23, 0xb5, 0x75, 0x63, 0x72,
				0x0c, 0xf2, 0x85, 0x2d, 0xe9, 0xa4, 0xb0, 0x30,
				0x0c, 0x88, 0x09, 0xca, 0x4b, 0xf7, 0x90, 0x0b,
				0x5a, 0xfc, 0xa4, 0x4d, 0xfd, 0x20, 0x9d, 0x7b,
				0x72, 0x6d, 0x5f, 0x57, 0x75, 0xff, 0x5b, 0x22,
				0x73, 0x89, 0x63, 0x32, 0x95, 0xda, 0x2f, 0x85,
				0x87, 0xb6, 0x20, 0x9b, 0xe4, 0xe0, 0x9c, 0x1b,
				0xca, 0xb0, 0xf0, 0x40, 0xbd, 0x1e, 0x79, 0x78,
			},
			.key_length = 64U,
			.pubkey = {
				.x = { 0x1a, 0x30, 0x6b, 0x16, 0x2f, 0x50, 0xc1, 0x04,
				       0xf9, 0x9f, 0x96, 0x75, 0x5a, 0xea, 0x8e, 0xcc,
				       0x69, 0x99, 0x56, 0x3d, 0x0a, 0xa3, 0xd7, 0x49,
				       0xdd, 0xaa, 0x27, 0xbd, 0x7c, 0x9a, 0x76, 0x23,
				       0xa1, 0xc3, 0xd1, 0x5c, 0x46, 0x26, 0xe1, 0xdd,
				       0xbb, 0xac, 0xda, 0xfa, 0xea, 0x62, 0x66, 0xac,
				       0x4a, 0x47, 0x49, 0x7d, 0x8a, 0x9f, 0xea, 0xcf,
				       0x24, 0xbd, 0xc6, 0xf8, 0x5e, 0x05, 0xc5, 0x0c,
				},
				.y = { 0x90, 0xa0, 0xd1, 0xdc, 0x8f, 0x93, 0xf2, 0x30,
				       0x02, 0x5a, 0x08, 0xbe, 0x0e, 0x55, 0xae, 0xfd,
				       0x0d, 0xa8, 0x87, 0x04, 0x63, 0x28, 0x52, 0x10,
				       0xca, 0x77, 0x20, 0xb3, 0xe5, 0xe2, 0xc4, 0x9d,
				       0xcf, 0xb8, 0x46, 0x39, 0x5a, 0xc8, 0x9a, 0xb9,
				       0x0c, 0xb4, 0x58, 0x1f, 0x1b, 0xe5, 0xd8, 0x0c,
				       0x1b, 0x0c, 0x04, 0x97, 0xb8, 0x34, 0xcc, 0x3a,
				       0xc7, 0x92, 0x99, 0x6c, 0xc8, 0x3a, 0xe6, 0x65,
				},
				.point_flags = CCC_EC_POINT_FLAG_NONE,
				//
				// XXX support deriving public key if UNDEFINED!!!
				// .point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_SIGN, TE_ALG_ECDSA);

	LOG_INFO("Sign SHA-256 digest with BP512t1 lwrve key\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_SIGN;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// No init flags needed (changed below for ASN.1 if required)
	arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_BRAINPOOL_P512t1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size   = sizeof_u32(digest);
	arg.ca_data.src_digest	      = digest;

	if (use_asn1_ec_sig != 0U) {
		LOG_INFO("ECDSA signature in ASN.1 DER signature format\n");
		arg.ca_data.dst_size = sizeof_u32(sigbuf);
		arg.ca_data.dst	     = sigbuf;

		// Generate and verify ASN.1 signatures
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	} else {
		LOG_INFO("ECDSA signature as te_ec_sig_t object\n");
		arg.ca_data.dst_size = sizeof_u32(sig);
		arg.ca_data.dst_ec_signature   = &sig;
	}

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) src %p data\n",
		 algo, digest);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	if (use_asn1_ec_sig != 0U) {
		LOG_INFO("ECDSA sign: signed => verifying ASN.1 signature\n");
		ret = ecdsa_verify_generic(c, algo, eid,
					   &akey, TE_LWRVE_BRAINPOOL_P512t1,
					   digest, sizeof_u32(digest),
					   sigbuf, arg.ca_data.dst_size,
					   NULL);
	} else {
		LOG_INFO("ECDSA sign: signed => verifying signature\n");
		ret = ecdsa_verify_generic(c, algo, eid,
					   &akey, TE_LWRVE_BRAINPOOL_P512t1,
					   digest, sizeof_u32(digest),
					   NULL, 0U,
					   &sig);
	}
	CCC_ERROR_CHECK(ret);

	// XXXX Verify the generated signature
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA sign-verify: failed\n");
	}
	return ret;
}

__STATIC__ status_t TEST_ecdsa_message_sign_verify_bp512t1(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
							   uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	struct te_ec_sig_s sig = { .sig_flags = 0U };
	static uint8_t sigbuf[164] = { 0x0U };

	(void)algo;

	const char message[10] = "HelloWorld";

	// SHA-256 digest of message[]
	//
	const uint8_t digest[32] = {
		0x87, 0x2e, 0x4e, 0x50, 0xce, 0x99, 0x90, 0xd8, 0xb0, 0x41, 0x33, 0x0c, 0x47, 0xc9, 0xdd, 0xd1,
		0x1b, 0xec, 0x6b, 0x50, 0x3a, 0xe9, 0x38, 0x6a, 0x99, 0xda, 0x85, 0x84, 0xe9, 0xbb, 0x12, 0xc4,
	};

	// ECDSA signature of a SHA-256 digest can be created and verified with openssl cmd using this key:
	//
	// Sign =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -sign bp-512t1-pkey.pem
	//   > ecdsa-sig-bp512t1-sha256.bin
	//
	// Verify =>
	// echo -n "HelloWorld" |  /usr/local/bin/openssl dgst -sha256 -verify bp-512t1-pub.pem
	//   -signature ecdsa-sig-bp512t1-sha256.bin
	//
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U
		.k_ec_private = {
			.key = { /* 2 < d < lwrve order */
				0x38, 0x5a, 0xf9, 0x23, 0xb5, 0x75, 0x63, 0x72,
				0x0c, 0xf2, 0x85, 0x2d, 0xe9, 0xa4, 0xb0, 0x30,
				0x0c, 0x88, 0x09, 0xca, 0x4b, 0xf7, 0x90, 0x0b,
				0x5a, 0xfc, 0xa4, 0x4d, 0xfd, 0x20, 0x9d, 0x7b,
				0x72, 0x6d, 0x5f, 0x57, 0x75, 0xff, 0x5b, 0x22,
				0x73, 0x89, 0x63, 0x32, 0x95, 0xda, 0x2f, 0x85,
				0x87, 0xb6, 0x20, 0x9b, 0xe4, 0xe0, 0x9c, 0x1b,
				0xca, 0xb0, 0xf0, 0x40, 0xbd, 0x1e, 0x79, 0x78,
			},
			.key_length = 64U,
			.pubkey = {
				.x = { 0x1a, 0x30, 0x6b, 0x16, 0x2f, 0x50, 0xc1, 0x04,
				       0xf9, 0x9f, 0x96, 0x75, 0x5a, 0xea, 0x8e, 0xcc,
				       0x69, 0x99, 0x56, 0x3d, 0x0a, 0xa3, 0xd7, 0x49,
				       0xdd, 0xaa, 0x27, 0xbd, 0x7c, 0x9a, 0x76, 0x23,
				       0xa1, 0xc3, 0xd1, 0x5c, 0x46, 0x26, 0xe1, 0xdd,
				       0xbb, 0xac, 0xda, 0xfa, 0xea, 0x62, 0x66, 0xac,
				       0x4a, 0x47, 0x49, 0x7d, 0x8a, 0x9f, 0xea, 0xcf,
				       0x24, 0xbd, 0xc6, 0xf8, 0x5e, 0x05, 0xc5, 0x0c,
				},
				.y = { 0x90, 0xa0, 0xd1, 0xdc, 0x8f, 0x93, 0xf2, 0x30,
				       0x02, 0x5a, 0x08, 0xbe, 0x0e, 0x55, 0xae, 0xfd,
				       0x0d, 0xa8, 0x87, 0x04, 0x63, 0x28, 0x52, 0x10,
				       0xca, 0x77, 0x20, 0xb3, 0xe5, 0xe2, 0xc4, 0x9d,
				       0xcf, 0xb8, 0x46, 0x39, 0x5a, 0xc8, 0x9a, 0xb9,
				       0x0c, 0xb4, 0x58, 0x1f, 0x1b, 0xe5, 0xd8, 0x0c,
				       0x1b, 0x0c, 0x04, 0x97, 0xb8, 0x34, 0xcc, 0x3a,
				       0xc7, 0x92, 0x99, 0x6c, 0xc8, 0x3a, 0xe6, 0x65,
				},
				.point_flags = CCC_EC_POINT_FLAG_NONE,
				//
				// XXX support deriving public key if UNDEFINED!!!
				// .point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_SIGN, TE_ALG_ECDSA);

	LOG_INFO("Sign SHA-256 digest with BP512t1 lwrve key\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_SIGN;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// Digest the input message to generate digest to sign
	// Digest message with SHA-256 first.
	arg.ca_init.ec.flags = INIT_FLAG_EC_DIGEST_INPUT;

	arg.ca_init.ec.sig_digest_algo = TE_ALG_SHA256;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_BRAINPOOL_P512t1; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(message);
	arg.ca_data.src      = (const uint8_t *)message;

	if (use_asn1_ec_sig != 0U) {
		// Generate and verify ASN.1 signature
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

		LOG_INFO("ECDSA signature in ASN.1 DER signature format\n");
		arg.ca_data.dst_size = sizeof_u32(sigbuf);
		arg.ca_data.dst	     = sigbuf;
	} else {
		LOG_INFO("ECDSA signature as te_ec_sig_t object\n");
		arg.ca_data.dst_size = sizeof_u32(sig);
		arg.ca_data.dst_ec_signature   = &sig;
	}

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) src %p message\n",
		 algo, message);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	if (use_asn1_ec_sig != 0U) {
		LOG_INFO("ECDSA sign: signed => verifying ASN.1 signature\n");
		ret = ecdsa_verify_generic(c, algo, eid,
					   &akey, TE_LWRVE_BRAINPOOL_P512t1,
					   digest, sizeof_u32(digest),
					   sigbuf, arg.ca_data.dst_size,
					   NULL);
	} else {
		LOG_INFO("ECDSA sign: signed => verifying signature\n");
		ret = ecdsa_verify_generic(c, algo, eid,
					   &akey, TE_LWRVE_BRAINPOOL_P512t1,
					   digest, sizeof_u32(digest),
					   NULL, 0U,
					   &sig);
	}
	CCC_ERROR_CHECK(ret);

	// XXXX Verify the generated signature
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA sign-verify: failed\n");
	}
	return ret;
}
#endif /* HAVE_BRAINPOOL_TWISTED_LWRVES */

#if CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL
__STATIC__ status_t TEST_ecdsa_sign_nist_p192(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
					      uint32_t use_asn1_ec_sig)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	char data[10] = "HelloWorld";
	(void)data;

	// SHA-1 digest of data[]
	const uint8_t digest[20] = {
		0xdb,0x8a,0xc1,0xc2,0x59,0xeb,0x89,0xd4,
		0xa1,0x31,0xb2,0x53,0xba,0xcf,0xca,0x5f,
		0x31,0x9d,0x54,0xf2,
	};

	// Large enough to hold the generated ASN.1 sig and the sig object
	uint8_t dst[256];

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		// .k_keyslot = 3U, not supported yet
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = { 0x5d, 0x79, 0x6b, 0xf6, 0x0f, 0x82, 0xd3, 0x37, 0x91, 0x69, 0xc5, 0x71,
				 0xd5, 0x64, 0xd1, 0x4f, 0xe7, 0x4f, 0xd1, 0x11, 0x10, 0xa1, 0xd3, 0x54 },
			.key_length = 24,

			.pubkey = {
				.x = { 0x9a, 0x94, 0x55, 0xa1, 0x69, 0x1a, 0xff, 0x53, 0xaf, 0x59, 0xdf, 0x4b,
				       0x68, 0xe4, 0xb9, 0xc2, 0xed, 0xe1, 0x1b, 0x6a, 0x21, 0x5c, 0x16, 0x29 },
				.y = { 0xef, 0xdb, 0x86, 0xbe, 0x66, 0xa9, 0xe4, 0x88, 0xed, 0x39, 0x00, 0xb4,
				       0x43, 0xf1, 0x4f, 0x77, 0x0c, 0xe6, 0x31, 0xa0, 0xf7, 0xb6, 0x0b, 0xc2 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_SIGN, TE_ALG_ECDSA);

	LOG_INFO("Create ECDSA signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_SIGN;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;

	if (use_asn1_ec_sig != 0) {
		/* Generate an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
		 */
		arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;
	}

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_192; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;
	arg.ca_data.dst_size	       = sizeof_u32(dst);
	arg.ca_data.dst		       = dst;

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);

	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature generation: OK\n");

	if (use_asn1_ec_sig != 0) {
		LOG_INFO("ECDSA sign generated ASN.1 DER signature\n");
		DUMP_HEX("ECDSA ASN.1 blob",
			 arg.ca_data.dst, arg.ca_data.dst_size);
	} else {
		LOG_INFO("ECDSA signed generated te_ec_sig_t object\n");
		DUMP_HEX("ECDSA sig object",
			 arg.ca_data.dst, sizeof_u32(struct te_ec_sig_s));
	}

fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA sign: failed (0x%x)\n",ret);
	}
	return ret;
}
#endif /* CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL */

/* Negative test verifies result when ECDSA signing is not enabled.
 */
#ifdef HAVE_ECDSA_SIGN
__STATIC__ status_t TEST_ecdsa_sign_nist_p256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t data[] = {
		0x44, 0xac, 0xf6, 0xb7, 0xe3, 0x6c, 0x13, 0x42,
		0xc2, 0xc5, 0x89, 0x72, 0x04, 0xfe, 0x09, 0x50,
		0x4e, 0x1e, 0x2e, 0xfb, 0x1a, 0x90, 0x03, 0x77,
		0xdb, 0xc4, 0xe7, 0xa6, 0xa1, 0x33, 0xec, 0x56
	};
	(void)data;

	// SHA-256 digest of data[]
	const uint8_t digest[32] = {
		0x51, 0x9b, 0x42, 0x3d, 0x71, 0x5f, 0x8b, 0x58,
		0x1f, 0x4f, 0xa8, 0xee, 0x59, 0xf4, 0x77, 0x1a,
		0x5b, 0x44, 0xc8, 0x13, 0x0b, 0x4e, 0x3e, 0xac,
		0xca, 0x54, 0xa5, 0x6d, 0xda, 0x72, 0xb4, 0x64
	};

	// Large enough to hold the generated ASN.1 sig and the sig object
	uint8_t dst[256];

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_flags     = KEY_FLAG_PLAIN,
		//.k_byte_size get this from the lwrve params
		.k_ec_private = {
			/* 2 < d < lwrve order */
			.key = { 0x94, 0xa1, 0xbb, 0xb1, 0x4b, 0x90, 0x6a, 0x61, 0xa2, 0x80, 0xf2, 0x45,
				 0xf9, 0xe9, 0x3c, 0x7f, 0x3b, 0x4a, 0x62, 0x47, 0x82, 0x4f, 0x5d, 0x33,
				 0xb9, 0x67, 0x07, 0x87, 0x64, 0x2a, 0x68, 0xde },
			.key_length = 32U,

			.pubkey = {
				.x = { 0x1c, 0xcb, 0xe9, 0x1c, 0x07, 0x5f, 0xc7, 0xf4, 0xf0, 0x33, 0xbf, 0xa2,
				       0x48, 0xdb, 0x8f, 0xcc, 0xd3, 0x56, 0x5d, 0xe9, 0x4b, 0xbf, 0xb1, 0x2f,
				       0x3c, 0x59, 0xff, 0x46, 0xc2, 0x71, 0xbf, 0x83 },
				.y = { 0xce, 0x40, 0x14, 0xc6, 0x88, 0x11, 0xf9, 0xa2, 0x1a, 0x1f, 0xdb, 0x2c,
				       0x0e, 0x61, 0x13, 0xe0, 0x6d, 0xb7, 0xca, 0x93, 0xb7, 0x40, 0x4e, 0x78,
				       0xdc, 0x7c, 0xcd, 0x5c, 0xa8, 0x9a, 0x4c, 0xa9 },
				.point_flags = CCC_EC_POINT_FLAG_NONE,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_SIGN, TE_ALG_ECDSA);

	LOG_INFO("Create ECDSA signature of data; SE driver gets the digest from caller\n");

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_SIGN;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	// arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;

	/* Test is now generating ASN.1 encoded ECDSA P256 signature
	 */
	arg.ca_init.ec.flags    = INIT_FLAG_EC_ASN1_SIGNATURE;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x (%s) for ECDSA, lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	// Pass the key params
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_digest_size    = sizeof_u32(digest);
	arg.ca_data.src_digest	       = digest;
	arg.ca_data.dst_size	       = sizeof_u32(dst);
	arg.ca_data.dst		       = dst;

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) src %p data\n",
		 algo, data);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ECDSA[0x%x] SIGN (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);

	CCC_ERROR_CHECK(ret);

	LOG_INFO("ECDSA signature generation: OK\n");

	DUMP_HEX("ECDSA sig:", dst, arg.ca_data.dst_size);
fail:
	CRYPTO_CONTEXT_RESET(c);
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA sign: failed (0x%x)\n",ret);
	}
	return ret;
}
#endif /* def HAVE_ECDSA_SIGN */
#endif /* TEST_ECDSA_SIGN */

#ifdef TEST_DH
#if RSA_MIN_KEYSIZE_BITS <= 512U /* short keys used in example */
/* Callwlate a Diffie-Hellman-Merkle (DH) shared secret value
 *   using an RSA engine pure modular exponentiation,
 *   i.e. internally does TE_ALG_RSA_PLAIN with the private exponent (value a)
 *   and modulus (value p).
 *
 * Public value for Alice =>
 *   A = g^a mod p => data^(privkey) mod modulus == public A value
 *
 * g  == 0x02 (primitive root modulo p)
 * p  == 2048 bit modulus (below)
 * xa == secret key (exponent) for callwlating A
 *
 * Shared secret value for Alice (with value B received from Bob) =>
 *   ss  = B^a mod p = B^(privkey) mod p
 */
__STATIC__ status_t TEST_dh_shared_secret(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// This is in LITTLE ENDIAN, it is swapped to big endian below.
	// (zero padded to 256 byte long array)
	//
	static uint8_t data_g[DH2048_BYTE_SIZE] = {
		0x02,
	};
	static uint8_t dst[DH2048_BYTE_SIZE];

	// This value is callwlated with the RSA engine below (first operation)
	static const uint8_t correct_A[] =	// value A
		{
			0x5c, 0x24, 0xdf, 0xeb, 0x5b, 0x4b, 0xf8, 0xc5,
			0xef, 0x39, 0x48, 0x82, 0xe0, 0x1e, 0x62, 0xee,
			0x8a, 0xae, 0xdf, 0x93, 0x6c, 0x2b, 0x16, 0x95,
			0x92, 0x16, 0x3f, 0x16, 0x7b, 0x75, 0x03, 0x85,
			0xd9, 0xf1, 0x69, 0xc2, 0x14, 0x87, 0x45, 0xfc,
			0xa4, 0x19, 0xf6, 0xf0, 0xa4, 0xf3, 0xec, 0xd4,
			0x6c, 0x5c, 0x03, 0x3b, 0x94, 0xc2, 0x2f, 0x92,
			0xe4, 0xce, 0xb3, 0xe4, 0x72, 0xe8, 0x17, 0xe6,
			0x23, 0x7e, 0x00, 0x01, 0x09, 0x59, 0x13, 0xbf,
			0xc1, 0x2f, 0x99, 0xa9, 0x07, 0xaa, 0x02, 0x23,
			0x4a, 0xca, 0x39, 0x4f, 0xbc, 0xec, 0x0f, 0x27,
			0x4f, 0x19, 0x93, 0x6c, 0xb9, 0x30, 0x52, 0xfd,
			0x2b, 0x9d, 0x86, 0xf1, 0x06, 0x1e, 0xb6, 0x56,
			0x27, 0x4a, 0xc9, 0x8a, 0xa7, 0x8a, 0x48, 0x5e,
			0xb5, 0x60, 0xcb, 0xdf, 0xff, 0x03, 0x26, 0x10,
			0xbf, 0x90, 0x8f, 0x46, 0x60, 0xeb, 0x9b, 0x9a,
			0xd6, 0x6f, 0x44, 0x91, 0x03, 0x92, 0x18, 0x2c,
			0x96, 0x5e, 0x40, 0x19, 0xfb, 0xf4, 0x4f, 0x3a,
			0x02, 0x7b, 0xaf, 0xcc, 0x22, 0x20, 0x79, 0xb9,
			0xf8, 0x9f, 0x8f, 0x85, 0x6b, 0xec, 0x44, 0xbb,
			0xe6, 0xa8, 0x8e, 0xb1, 0xe8, 0x2c, 0xee, 0x64,
			0xee, 0xf8, 0xbd, 0x00, 0xf3, 0xe2, 0x2b, 0x93,
			0xcd, 0xe7, 0xc4, 0xdf, 0xc9, 0x19, 0x46, 0xfe,
			0xb6, 0x07, 0x73, 0xc1, 0x8a, 0x64, 0x79, 0x26,
			0xe7, 0x30, 0xad, 0x2a, 0xdf, 0xe6, 0x8f, 0x59,
			0xf5, 0x81, 0xbf, 0x4a, 0x29, 0x91, 0xe7, 0xb7,
			0xcf, 0x48, 0x13, 0x27, 0x75, 0x79, 0x40, 0xd9,
			0xd6, 0x32, 0x52, 0x4e, 0x6a, 0x86, 0xae, 0x6f,
			0xc2, 0xbf, 0xec, 0x1f, 0xc2, 0x69, 0xb2, 0xb6,
			0x59, 0xe5, 0xa5, 0x17, 0xa4, 0x77, 0xb7, 0x62,
			0x46, 0xde, 0xe8, 0xd2, 0x89, 0x78, 0x9a, 0xef,
			0xa3, 0xb5, 0x8f, 0x26, 0xec, 0x80, 0xda, 0x39
		};

	// This is Alice's DH secret (priv_exponent) and modulus (p).
	//
	// This is used for callwlating A and the shared secret
	//
	static te_args_key_data_t akey_for_A = {
		.k_key_type  = KEY_TYPE_DH,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = DH2048_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_dh = { .modulus  =	// p
			  //
			  // DH modulus (p) in BIG ENDIAN
			  //
			  {
				  0xb9, 0x36, 0x3a, 0xf1, 0x82, 0x1f, 0x60, 0xd3,
				  0x22, 0x47, 0xb8, 0xbc, 0x2d, 0x22, 0x6b, 0x81,
				  0x7f, 0xe8, 0x20, 0x06, 0x09, 0x23, 0x73, 0x49,
				  0x9a, 0x59, 0x8b, 0x35, 0x25, 0xf8, 0x31, 0xbc,
				  0x7d, 0xa8, 0x1c, 0x9d, 0x56, 0x0d, 0x1a, 0xf7,
				  0x4b, 0x4f, 0x96, 0xa4, 0x35, 0x77, 0x6a, 0x89,
				  0xab, 0x42, 0x00, 0x49, 0x21, 0x71, 0xed, 0x28,
				  0x16, 0x1d, 0x87, 0x5a, 0x10, 0xa7, 0x9c, 0x64,
				  0x94, 0xd4, 0x87, 0x3d, 0x28, 0xef, 0x44, 0xfe,
				  0x4b, 0xe2, 0xb4, 0x15, 0x8c, 0x82, 0xa6, 0xf3,
				  0x50, 0x5f, 0xa8, 0xe8, 0xa2, 0x60, 0xe7, 0x00,
				  0x86, 0x78, 0x05, 0xd4, 0x78, 0x19, 0xa1, 0x98,
				  0x62, 0x4e, 0x4a, 0x00, 0x78, 0x56, 0x96, 0xe6,
				  0xcf, 0xd7, 0x10, 0x1b, 0x74, 0x5d, 0xd0, 0x26,
				  0x61, 0xdb, 0x6b, 0x32, 0x09, 0x51, 0xd8, 0xa5,
				  0xfd, 0x54, 0x16, 0x71, 0x01, 0xb3, 0x39, 0xe6,
				  0x4e, 0x69, 0xb1, 0xd7, 0x06, 0x8f, 0xd6, 0x1e,
				  0xdc, 0x72, 0x25, 0x26, 0x74, 0xc8, 0x41, 0x06,
				  0x5c, 0xd1, 0x26, 0x5c, 0xb0, 0x2f, 0xf9, 0x59,
				  0x13, 0xc1, 0x2a, 0x0f, 0x78, 0xea, 0x7b, 0xf7,
				  0xbd, 0x59, 0xa0, 0x90, 0x1d, 0xfc, 0x33, 0x5b,
				  0x4c, 0xbf, 0x05, 0x9c, 0x3a, 0x3f, 0x69, 0xa2,
				  0x45, 0x61, 0x4e, 0x10, 0x6a, 0xb3, 0x17, 0xc5,
				  0x68, 0x30, 0xfb, 0x07, 0x5f, 0x34, 0xc6, 0xfb,
				  0x73, 0x07, 0x3c, 0x70, 0xf6, 0xae, 0xe7, 0x72,
				  0x84, 0xc3, 0x18, 0x81, 0x8f, 0xe8, 0x11, 0x1f,
				  0x3d, 0x83, 0x83, 0x01, 0x2a, 0x14, 0x73, 0xbf,
				  0x32, 0x32, 0x2e, 0xc9, 0x4d, 0xdb, 0x2a, 0xca,
				  0xee, 0x71, 0xf9, 0xda, 0xad, 0xe8, 0x82, 0x0b,
				  0x4d, 0x0c, 0x1f, 0xb6, 0x1d, 0xef, 0x00, 0x67,
				  0x74, 0x3d, 0x95, 0xe0, 0xb7, 0xc4, 0x30, 0x8a,
				  0x24, 0x87, 0x12, 0x47, 0x27, 0x70, 0x0d, 0x73
			  },
			  .priv_exponent =	// xa (secret for A), private exponent
			  {
				  0x44, 0xc1, 0x48, 0x36, 0xa7, 0x2b, 0x6f, 0x4e,
				  0x43, 0x03, 0x68, 0xad, 0x31, 0x00, 0xda, 0xf3,
				  0x2a, 0x01, 0xa8, 0x32, 0x63, 0x5f, 0x89, 0x32,
				  0x1f, 0xdf, 0x4c, 0xa1, 0x6a, 0xbc, 0x10, 0x15,
				  0x90, 0x35, 0xc9, 0x26, 0x41, 0xdf, 0x7b, 0xaa,
				  0x56, 0x56, 0x3d, 0x85, 0x44, 0xb5, 0xc0, 0x8e,
				  0x37, 0x83, 0x06, 0x50, 0xb3, 0x5f, 0x0e, 0x28,
				  0x2c, 0xd5, 0x46, 0x15, 0xe3, 0xda, 0x7d, 0x74,
				  0x87, 0x13, 0x91, 0x4f, 0xd4, 0x2d, 0xf6, 0xc7,
				  0x5e, 0x14, 0x2c, 0x11, 0xc2, 0x26, 0xb4, 0x3a,
				  0xe3, 0xb2, 0x36, 0x20, 0x11, 0x3b, 0x22, 0xf2,
				  0x06, 0x65, 0x66, 0xe2, 0x57, 0x58, 0xf8, 0x22,
				  0x1a, 0x94, 0xbd, 0x2b, 0x0e, 0x8c, 0x55, 0xad,
				  0x61, 0x23, 0x45, 0x2b, 0x19, 0x1e, 0x63, 0x3a,
				  0x13, 0x61, 0xe3, 0xa0, 0x79, 0x70, 0x3e, 0x6d,
				  0x98, 0x32, 0xbc, 0x7f, 0x82, 0xc3, 0x11, 0xd8,
				  0xeb, 0x53, 0xb5, 0xfc, 0xb5, 0xd5, 0x3c, 0x4a,
				  0xea, 0x92, 0x3e, 0x01, 0xce, 0x15, 0x65, 0xd4,
				  0xaa, 0x85, 0xc1, 0x11, 0x90, 0x83, 0x31, 0x6e,
				  0xfe, 0xe7, 0x7f, 0x7d, 0xed, 0xab, 0xf9, 0x29,
				  0xf8, 0xc7, 0xf1, 0x68, 0xc6, 0xb7, 0xe4, 0x1f,
				  0x2f, 0x28, 0xa0, 0xc9, 0x1a, 0x50, 0x64, 0x29,
				  0x4b, 0x01, 0x6d, 0x1a, 0xda, 0x46, 0x63, 0x21,
				  0x07, 0x40, 0x8c, 0x8e, 0x4c, 0x6f, 0xb5, 0xe5,
				  0x12, 0xf3, 0xc2, 0x1b, 0x48, 0x27, 0x5e, 0x27,
				  0x01, 0xb1, 0xaa, 0xed, 0x68, 0x9b, 0x83, 0x18,
				  0x8f, 0xb1, 0xeb, 0x1f, 0x04, 0xd1, 0x3c, 0x79,
				  0xed, 0x4b, 0xf7, 0x0a, 0x33, 0xdc, 0xe0, 0xc6,
				  0xd8, 0x02, 0x51, 0x59, 0x00, 0x74, 0x30, 0x07,
				  0x4c, 0x2d, 0xac, 0xe4, 0x13, 0xf1, 0x80, 0xf0,
				  0xce, 0xfa, 0xff, 0xa9, 0xce, 0x29, 0x46, 0xdd,
				  0x9d, 0xad, 0xd1, 0xc3, 0xc6, 0x58, 0x1a, 0x63,
			  },
		},
	};

	if (algo != TE_ALG_DH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	// This is Alice callwlating public value A which is delivered to Bob (oob)

	se_util_mem_set(dst, 0U, sizeof_u32(dst));

#if 1
	//
	// NOTE: Because this was made static (to minimize stack use!) and
	// reversed below, it is also reset to the value shown above in the init.
	//
	se_util_mem_set(data_g, 0U, sizeof_u32(data_g));
	data_g[0] = 0x02;
#endif

	// Swap data to big endian
	ret = reverse_buffer(data_g, sizeof_u32(data_g));
	CCC_ERROR_CHECK(ret);

	/* Preset fields */
	//
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for DH\n", eid, eid_name(eid));

	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey_for_A;

	arg.ca_data.src_size = sizeof_u32(data_g);	// agreed value g => value 0x2
	arg.ca_data.src = data_g;
	arg.ca_data.dst_size = sizeof_u32(dst);	// A callwlated here
	arg.ca_data.dst = dst;

	LOG_INFO("DH[0x%x] => public A (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data_g, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DH cipher result (public value A):", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct_A, sizeof_u32(correct_A));

	// This is Alice callwlating the DH shared secret
	//
	// Callwlate DH shared secret for Alice... B received out-of-band from Bob
	//
	// ss = B^a mod p = B^(ax) mod p
	//
	// This value is the public value B from Bob
	// This is now in BIG ENDIAN
	//
	static uint8_t data_B[DH2048_BYTE_SIZE] = {
		0x2a, 0x67, 0x5c, 0xfd, 0x63, 0x5d, 0xc0, 0x97,
		0x0a, 0x8b, 0xa2, 0x1f, 0xf8, 0x8a, 0xcb, 0x54,
		0xca, 0x2f, 0xd3, 0x49, 0x3f, 0x01, 0x8e, 0x87,
		0xfe, 0xcc, 0x94, 0xa0, 0x3e, 0xd4, 0x26, 0x79,
		0x9a, 0x94, 0x3c, 0x11, 0x81, 0x58, 0x5c, 0x60,
		0x3d, 0xf5, 0x98, 0x90, 0x89, 0x64, 0x62, 0x1f,
		0xbd, 0x05, 0x6d, 0x2b, 0xcd, 0x84, 0x40, 0x9b,
		0x4a, 0x1f, 0xe0, 0x19, 0xf1, 0xca, 0x20, 0xb3,
		0x4e, 0xa0, 0x4f, 0x15, 0xcc, 0xa5, 0xfe, 0xa5,
		0xb4, 0xf5, 0x0b, 0x18, 0x7a, 0x5a, 0x37, 0xaa,
		0x58, 0x00, 0x19, 0x7f, 0xe2, 0xa3, 0xd9, 0x1c,
		0x44, 0x57, 0xcc, 0xde, 0x2e, 0xc1, 0x38, 0xea,
		0xeb, 0xe3, 0x90, 0x40, 0xc4, 0x6c, 0xf7, 0xcd,
		0xe9, 0x22, 0x50, 0x71, 0xf5, 0x7c, 0xdb, 0x37,
		0x0e, 0x80, 0xc3, 0xed, 0x7e, 0xb1, 0x2b, 0x2f,
		0xbe, 0x71, 0xa6, 0x11, 0xa5, 0x9d, 0xf5, 0x39,
		0xf1, 0xa2, 0xe5, 0x85, 0xbc, 0x25, 0x91, 0x4e,
		0x84, 0x8d, 0x26, 0x9f, 0x4f, 0xe6, 0x0f, 0xa6,
		0x2b, 0x6b, 0xf9, 0x0d, 0xaf, 0x6f, 0xbb, 0xfa,
		0x2d, 0x79, 0x15, 0x31, 0x57, 0xae, 0x19, 0x60,
		0x22, 0x0a, 0xf5, 0xfd, 0x98, 0x0e, 0xbf, 0x5d,
		0x49, 0x75, 0x58, 0x37, 0xbc, 0x7f, 0xf5, 0x21,
		0x56, 0x1e, 0xd5, 0xb3, 0x50, 0x0b, 0xca, 0x96,
		0xf3, 0xd1, 0x3f, 0xb3, 0x70, 0xa8, 0x6d, 0x63,
		0x48, 0xfb, 0x3d, 0xd7, 0x29, 0x91, 0x45, 0xb5,
		0x48, 0xcd, 0xb6, 0x78, 0x30, 0xf2, 0x3f, 0x1e,
		0xd6, 0x22, 0xd6, 0x35, 0x9b, 0xf9, 0x1f, 0x85,
		0xae, 0xab, 0x4b, 0xd7, 0xe0, 0xc7, 0x86, 0x67,
		0x3f, 0x05, 0x7f, 0xa6, 0x0d, 0x2f, 0x0d, 0xbf,
		0x53, 0x5f, 0x4d, 0x2c, 0x6d, 0x5e, 0x57, 0x40,
		0x30, 0x3a, 0x23, 0x98, 0xf9, 0xb4, 0x32, 0xf5,
		0x32, 0x83, 0xdd, 0x0b, 0xae, 0x33, 0x97, 0x2f,
	};

	// This is the correct DH shared secret value callwlated below
	static uint8_t correct_ss[DH2048_BYTE_SIZE] = {
		0x8f, 0xf3, 0xac, 0xa2, 0xea, 0x22, 0x11, 0x5c,
		0x45, 0x65, 0x1a, 0x77, 0x75, 0x2e, 0xcf, 0x46,
		0x23, 0x14, 0x1e, 0x67, 0x53, 0x4d, 0x35, 0xb0,
		0x38, 0x1d, 0x4e, 0xb9, 0x41, 0x9a, 0x21, 0x24,
		0x6e, 0x9f, 0x40, 0xfe, 0x90, 0x51, 0xb1, 0x06,
		0xa4, 0x7b, 0x87, 0x17, 0x2f, 0xe7, 0x5e, 0x22,
		0xf0, 0x7b, 0x54, 0x84, 0x0a, 0xac, 0x0a, 0x90,
		0xd2, 0xd7, 0xe8, 0x7f, 0xe7, 0xe3, 0x30, 0x75,
		0x01, 0x1f, 0x24, 0x75, 0x56, 0xbe, 0xcc, 0x8d,
		0x1e, 0x68, 0x0c, 0x41, 0x72, 0xd3, 0xfa, 0xbb,
		0xe5, 0x9c, 0x60, 0xc7, 0x28, 0x77, 0x0c, 0xbe,
		0x89, 0xab, 0x08, 0xd6, 0x21, 0xe7, 0x2e, 0x1a,
		0x58, 0x7a, 0xca, 0x4f, 0x22, 0xf3, 0x2b, 0x30,
		0xfd, 0xf4, 0x98, 0xc1, 0xa3, 0xf8, 0xf6, 0xcc,
		0xa9, 0xe4, 0xdb, 0x5b, 0xee, 0xd5, 0x5c, 0x6f,
		0x62, 0x4c, 0xd1, 0x1a, 0x02, 0x2a, 0x23, 0xe4,
		0xb5, 0x57, 0xf3, 0xf9, 0xec, 0x04, 0x83, 0x54,
		0xfe, 0x08, 0x5e, 0x35, 0xac, 0xfb, 0xa8, 0x09,
		0x82, 0x32, 0x60, 0x11, 0xb2, 0x16, 0x62, 0x6b,
		0xdf, 0xda, 0xde, 0x9c, 0xcb, 0x63, 0x44, 0x6c,
		0x59, 0x26, 0x6a, 0x8f, 0xb0, 0x24, 0xcb, 0xa6,
		0x72, 0x48, 0x1e, 0xeb, 0xe0, 0xe1, 0x09, 0x44,
		0xdd, 0xee, 0x66, 0x6d, 0x84, 0xcf, 0xa5, 0xc1,
		0xb8, 0x36, 0x74, 0xd3, 0x15, 0x96, 0xc3, 0xe4,
		0xc6, 0x5a, 0x4d, 0x23, 0x97, 0x0c, 0x5c, 0xcb,
		0xa9, 0xf5, 0x29, 0xc2, 0x0e, 0xff, 0x93, 0x82,
		0xd3, 0x34, 0x49, 0xad, 0x64, 0xa6, 0xb1, 0xc0,
		0x59, 0x28, 0x75, 0x60, 0xa7, 0x8a, 0xb0, 0x11,
		0x56, 0x89, 0x42, 0x74, 0x11, 0xf5, 0xf6, 0x5e,
		0x6f, 0x16, 0x54, 0x6a, 0xb1, 0x76, 0x4d, 0x50,
		0x8a, 0x68, 0xc1, 0x5b, 0x82, 0xb9, 0x0d, 0x00,
		0x32, 0x50, 0xed, 0x88, 0x87, 0x48, 0x92, 0x17,
	};

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DERIVE, algo);

	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));
	se_util_mem_set(dst, 0U, sizeof_u32(dst));

	/* Preset fields */
	//
	arg.ca_alg_mode = TE_ALG_MODE_DERIVE;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for DH\n", eid, eid_name(eid));

	arg.ca_init.engine_hint = eid;
	// Pass the key params
	arg.ca_set_key.kdata = &akey_for_A;

	arg.ca_data.src_size = sizeof_u32(data_B);
	arg.ca_data.src = data_B;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("DH[0x%x] shared secret (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data_B, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DH shared secret result:", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct_ss, sizeof_u32(correct_ss));

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* This is identical with the above, but callwlates DH
 * values using RSA setup. The above may look a little bit nicer,
 * because it uses DH fields in the key setup.
 */
__STATIC__ status_t TEST_dh_with_rsa_setup(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Making these static is not wise, but saves stack space and this is TEST CODE
	 * TODO: colwert to heap objects
	 */

	// This is in LITTLE ENDIAN, it is swapped to big endian below.
	// (zero padded to 256 byte long array)
	//
	static uint8_t data_g[RSA2048_BYTE_SIZE] = {
		0x02,
	};
	static uint8_t dst[RSA2048_BYTE_SIZE];

	// This value is callwlated with the RSA engine below (first operation)
	static const uint8_t correct_A[] =	// value A
		{
			0x5c, 0x24, 0xdf, 0xeb, 0x5b, 0x4b, 0xf8, 0xc5,
			0xef, 0x39, 0x48, 0x82, 0xe0, 0x1e, 0x62, 0xee,
			0x8a, 0xae, 0xdf, 0x93, 0x6c, 0x2b, 0x16, 0x95,
			0x92, 0x16, 0x3f, 0x16, 0x7b, 0x75, 0x03, 0x85,
			0xd9, 0xf1, 0x69, 0xc2, 0x14, 0x87, 0x45, 0xfc,
			0xa4, 0x19, 0xf6, 0xf0, 0xa4, 0xf3, 0xec, 0xd4,
			0x6c, 0x5c, 0x03, 0x3b, 0x94, 0xc2, 0x2f, 0x92,
			0xe4, 0xce, 0xb3, 0xe4, 0x72, 0xe8, 0x17, 0xe6,
			0x23, 0x7e, 0x00, 0x01, 0x09, 0x59, 0x13, 0xbf,
			0xc1, 0x2f, 0x99, 0xa9, 0x07, 0xaa, 0x02, 0x23,
			0x4a, 0xca, 0x39, 0x4f, 0xbc, 0xec, 0x0f, 0x27,
			0x4f, 0x19, 0x93, 0x6c, 0xb9, 0x30, 0x52, 0xfd,
			0x2b, 0x9d, 0x86, 0xf1, 0x06, 0x1e, 0xb6, 0x56,
			0x27, 0x4a, 0xc9, 0x8a, 0xa7, 0x8a, 0x48, 0x5e,
			0xb5, 0x60, 0xcb, 0xdf, 0xff, 0x03, 0x26, 0x10,
			0xbf, 0x90, 0x8f, 0x46, 0x60, 0xeb, 0x9b, 0x9a,
			0xd6, 0x6f, 0x44, 0x91, 0x03, 0x92, 0x18, 0x2c,
			0x96, 0x5e, 0x40, 0x19, 0xfb, 0xf4, 0x4f, 0x3a,
			0x02, 0x7b, 0xaf, 0xcc, 0x22, 0x20, 0x79, 0xb9,
			0xf8, 0x9f, 0x8f, 0x85, 0x6b, 0xec, 0x44, 0xbb,
			0xe6, 0xa8, 0x8e, 0xb1, 0xe8, 0x2c, 0xee, 0x64,
			0xee, 0xf8, 0xbd, 0x00, 0xf3, 0xe2, 0x2b, 0x93,
			0xcd, 0xe7, 0xc4, 0xdf, 0xc9, 0x19, 0x46, 0xfe,
			0xb6, 0x07, 0x73, 0xc1, 0x8a, 0x64, 0x79, 0x26,
			0xe7, 0x30, 0xad, 0x2a, 0xdf, 0xe6, 0x8f, 0x59,
			0xf5, 0x81, 0xbf, 0x4a, 0x29, 0x91, 0xe7, 0xb7,
			0xcf, 0x48, 0x13, 0x27, 0x75, 0x79, 0x40, 0xd9,
			0xd6, 0x32, 0x52, 0x4e, 0x6a, 0x86, 0xae, 0x6f,
			0xc2, 0xbf, 0xec, 0x1f, 0xc2, 0x69, 0xb2, 0xb6,
			0x59, 0xe5, 0xa5, 0x17, 0xa4, 0x77, 0xb7, 0x62,
			0x46, 0xde, 0xe8, 0xd2, 0x89, 0x78, 0x9a, 0xef,
			0xa3, 0xb5, 0x8f, 0x26, 0xec, 0x80, 0xda, 0x39
		};

	// This is Alice's RSA private key (pubkey is not used at all, it is
	// present there because the setup is for an "RSA operation", not
	// for a DH operation).
	//
	// This is used for callwlating A and the shared secret
	//
	static te_args_key_data_t akey_for_A = {
		.k_key_type  = KEY_TYPE_RSA_PRIVATE,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_byte_size = RSA2048_BYTE_SIZE,
		.k_keyslot = 3U,
		.k_rsa_priv = { .pub_exponent = { 0x00, 0x01, 0x00, 0x01 },
				.modulus  =	// p
				//
				// DH modulus (p) in BIG ENDIAN
				//
				{
				       0xb9, 0x36, 0x3a, 0xf1, 0x82, 0x1f, 0x60, 0xd3,
				       0x22, 0x47, 0xb8, 0xbc, 0x2d, 0x22, 0x6b, 0x81,
				       0x7f, 0xe8, 0x20, 0x06, 0x09, 0x23, 0x73, 0x49,
				       0x9a, 0x59, 0x8b, 0x35, 0x25, 0xf8, 0x31, 0xbc,
				       0x7d, 0xa8, 0x1c, 0x9d, 0x56, 0x0d, 0x1a, 0xf7,
				       0x4b, 0x4f, 0x96, 0xa4, 0x35, 0x77, 0x6a, 0x89,
				       0xab, 0x42, 0x00, 0x49, 0x21, 0x71, 0xed, 0x28,
				       0x16, 0x1d, 0x87, 0x5a, 0x10, 0xa7, 0x9c, 0x64,
				       0x94, 0xd4, 0x87, 0x3d, 0x28, 0xef, 0x44, 0xfe,
				       0x4b, 0xe2, 0xb4, 0x15, 0x8c, 0x82, 0xa6, 0xf3,
				       0x50, 0x5f, 0xa8, 0xe8, 0xa2, 0x60, 0xe7, 0x00,
				       0x86, 0x78, 0x05, 0xd4, 0x78, 0x19, 0xa1, 0x98,
				       0x62, 0x4e, 0x4a, 0x00, 0x78, 0x56, 0x96, 0xe6,
				       0xcf, 0xd7, 0x10, 0x1b, 0x74, 0x5d, 0xd0, 0x26,
				       0x61, 0xdb, 0x6b, 0x32, 0x09, 0x51, 0xd8, 0xa5,
				       0xfd, 0x54, 0x16, 0x71, 0x01, 0xb3, 0x39, 0xe6,
				       0x4e, 0x69, 0xb1, 0xd7, 0x06, 0x8f, 0xd6, 0x1e,
				       0xdc, 0x72, 0x25, 0x26, 0x74, 0xc8, 0x41, 0x06,
				       0x5c, 0xd1, 0x26, 0x5c, 0xb0, 0x2f, 0xf9, 0x59,
				       0x13, 0xc1, 0x2a, 0x0f, 0x78, 0xea, 0x7b, 0xf7,
				       0xbd, 0x59, 0xa0, 0x90, 0x1d, 0xfc, 0x33, 0x5b,
				       0x4c, 0xbf, 0x05, 0x9c, 0x3a, 0x3f, 0x69, 0xa2,
				       0x45, 0x61, 0x4e, 0x10, 0x6a, 0xb3, 0x17, 0xc5,
				       0x68, 0x30, 0xfb, 0x07, 0x5f, 0x34, 0xc6, 0xfb,
				       0x73, 0x07, 0x3c, 0x70, 0xf6, 0xae, 0xe7, 0x72,
				       0x84, 0xc3, 0x18, 0x81, 0x8f, 0xe8, 0x11, 0x1f,
				       0x3d, 0x83, 0x83, 0x01, 0x2a, 0x14, 0x73, 0xbf,
				       0x32, 0x32, 0x2e, 0xc9, 0x4d, 0xdb, 0x2a, 0xca,
				       0xee, 0x71, 0xf9, 0xda, 0xad, 0xe8, 0x82, 0x0b,
				       0x4d, 0x0c, 0x1f, 0xb6, 0x1d, 0xef, 0x00, 0x67,
				       0x74, 0x3d, 0x95, 0xe0, 0xb7, 0xc4, 0x30, 0x8a,
				       0x24, 0x87, 0x12, 0x47, 0x27, 0x70, 0x0d, 0x73
			       },
			       .priv_exponent =	// xa (secret for A), private exponent
			       {
				       0x44, 0xc1, 0x48, 0x36, 0xa7, 0x2b, 0x6f, 0x4e,
				       0x43, 0x03, 0x68, 0xad, 0x31, 0x00, 0xda, 0xf3,
				       0x2a, 0x01, 0xa8, 0x32, 0x63, 0x5f, 0x89, 0x32,
				       0x1f, 0xdf, 0x4c, 0xa1, 0x6a, 0xbc, 0x10, 0x15,
				       0x90, 0x35, 0xc9, 0x26, 0x41, 0xdf, 0x7b, 0xaa,
				       0x56, 0x56, 0x3d, 0x85, 0x44, 0xb5, 0xc0, 0x8e,
				       0x37, 0x83, 0x06, 0x50, 0xb3, 0x5f, 0x0e, 0x28,
				       0x2c, 0xd5, 0x46, 0x15, 0xe3, 0xda, 0x7d, 0x74,
				       0x87, 0x13, 0x91, 0x4f, 0xd4, 0x2d, 0xf6, 0xc7,
				       0x5e, 0x14, 0x2c, 0x11, 0xc2, 0x26, 0xb4, 0x3a,
				       0xe3, 0xb2, 0x36, 0x20, 0x11, 0x3b, 0x22, 0xf2,
				       0x06, 0x65, 0x66, 0xe2, 0x57, 0x58, 0xf8, 0x22,
				       0x1a, 0x94, 0xbd, 0x2b, 0x0e, 0x8c, 0x55, 0xad,
				       0x61, 0x23, 0x45, 0x2b, 0x19, 0x1e, 0x63, 0x3a,
				       0x13, 0x61, 0xe3, 0xa0, 0x79, 0x70, 0x3e, 0x6d,
				       0x98, 0x32, 0xbc, 0x7f, 0x82, 0xc3, 0x11, 0xd8,
				       0xeb, 0x53, 0xb5, 0xfc, 0xb5, 0xd5, 0x3c, 0x4a,
				       0xea, 0x92, 0x3e, 0x01, 0xce, 0x15, 0x65, 0xd4,
				       0xaa, 0x85, 0xc1, 0x11, 0x90, 0x83, 0x31, 0x6e,
				       0xfe, 0xe7, 0x7f, 0x7d, 0xed, 0xab, 0xf9, 0x29,
				       0xf8, 0xc7, 0xf1, 0x68, 0xc6, 0xb7, 0xe4, 0x1f,
				       0x2f, 0x28, 0xa0, 0xc9, 0x1a, 0x50, 0x64, 0x29,
				       0x4b, 0x01, 0x6d, 0x1a, 0xda, 0x46, 0x63, 0x21,
				       0x07, 0x40, 0x8c, 0x8e, 0x4c, 0x6f, 0xb5, 0xe5,
				       0x12, 0xf3, 0xc2, 0x1b, 0x48, 0x27, 0x5e, 0x27,
				       0x01, 0xb1, 0xaa, 0xed, 0x68, 0x9b, 0x83, 0x18,
				       0x8f, 0xb1, 0xeb, 0x1f, 0x04, 0xd1, 0x3c, 0x79,
				       0xed, 0x4b, 0xf7, 0x0a, 0x33, 0xdc, 0xe0, 0xc6,
				       0xd8, 0x02, 0x51, 0x59, 0x00, 0x74, 0x30, 0x07,
				       0x4c, 0x2d, 0xac, 0xe4, 0x13, 0xf1, 0x80, 0xf0,
				       0xce, 0xfa, 0xff, 0xa9, 0xce, 0x29, 0x46, 0xdd,
				       0x9d, 0xad, 0xd1, 0xc3, 0xc6, 0x58, 0x1a, 0x63,
			       },
		},
	};

	// Doing DH but the setup is using RSA DECIPHER
	if (algo != TE_ALG_MODEXP) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DECRYPT, TE_ALG_MODEXP);

	// This is Alice callwlating public value A which is delivered to Bob (oob)

	se_util_mem_set(dst, 0U, sizeof_u32(dst));

#if 1
	//
	// NOTE: Because this was made static (to minimize stack use!) and
	// reversed below, it is also reset to the value shown above in the init.
	//
	se_util_mem_set(data_g, 0U, sizeof_u32(data_g));
	data_g[0] = 0x02;
#endif

	// Swap data to big endian
	ret = reverse_buffer(data_g, sizeof_u32(data_g));
	CCC_ERROR_CHECK(ret);

	/* Preset fields */
	//
	// Because we use a private key for the RSA operation => do a decrypt.
	// RSA does not care if you call this "decrypt", it is still just modular exponentiation
	// [ SE driver code uses private key for DECRYPT, public key for ENCRYPT ]
	//
	arg.ca_alg_mode = TE_ALG_MODE_DECRYPT;
	arg.ca_algo     = TE_ALG_MODEXP;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for DH\n", eid, eid_name(eid));

	arg.ca_init.engine_hint = eid;

	// Pass the key params
	arg.ca_set_key.kdata = &akey_for_A;

	arg.ca_data.src_size = sizeof_u32(data_g);	// agreed value g => value 0x2
	arg.ca_data.src = data_g;
	arg.ca_data.dst_size = sizeof_u32(dst);	// A callwlated here
	arg.ca_data.dst = dst;

	LOG_INFO("DH[0x%x] => public A (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data_g, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DH cipher result (public value A):", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct_A, sizeof_u32(correct_A));

	// This is Alice callwlating the DH shared secret
	//
	// Callwlate DH shared secret for Alice... B received out-of-band from Bob
	//
	// ss = B^a mod p = B^(ax) mod p
	//
	// This value is the public value B from Bob
	// This is now in BIG ENDIAN
	//
	static uint8_t data_B[RSA2048_BYTE_SIZE] = {
		0x2a, 0x67, 0x5c, 0xfd, 0x63, 0x5d, 0xc0, 0x97,
		0x0a, 0x8b, 0xa2, 0x1f, 0xf8, 0x8a, 0xcb, 0x54,
		0xca, 0x2f, 0xd3, 0x49, 0x3f, 0x01, 0x8e, 0x87,
		0xfe, 0xcc, 0x94, 0xa0, 0x3e, 0xd4, 0x26, 0x79,
		0x9a, 0x94, 0x3c, 0x11, 0x81, 0x58, 0x5c, 0x60,
		0x3d, 0xf5, 0x98, 0x90, 0x89, 0x64, 0x62, 0x1f,
		0xbd, 0x05, 0x6d, 0x2b, 0xcd, 0x84, 0x40, 0x9b,
		0x4a, 0x1f, 0xe0, 0x19, 0xf1, 0xca, 0x20, 0xb3,
		0x4e, 0xa0, 0x4f, 0x15, 0xcc, 0xa5, 0xfe, 0xa5,
		0xb4, 0xf5, 0x0b, 0x18, 0x7a, 0x5a, 0x37, 0xaa,
		0x58, 0x00, 0x19, 0x7f, 0xe2, 0xa3, 0xd9, 0x1c,
		0x44, 0x57, 0xcc, 0xde, 0x2e, 0xc1, 0x38, 0xea,
		0xeb, 0xe3, 0x90, 0x40, 0xc4, 0x6c, 0xf7, 0xcd,
		0xe9, 0x22, 0x50, 0x71, 0xf5, 0x7c, 0xdb, 0x37,
		0x0e, 0x80, 0xc3, 0xed, 0x7e, 0xb1, 0x2b, 0x2f,
		0xbe, 0x71, 0xa6, 0x11, 0xa5, 0x9d, 0xf5, 0x39,
		0xf1, 0xa2, 0xe5, 0x85, 0xbc, 0x25, 0x91, 0x4e,
		0x84, 0x8d, 0x26, 0x9f, 0x4f, 0xe6, 0x0f, 0xa6,
		0x2b, 0x6b, 0xf9, 0x0d, 0xaf, 0x6f, 0xbb, 0xfa,
		0x2d, 0x79, 0x15, 0x31, 0x57, 0xae, 0x19, 0x60,
		0x22, 0x0a, 0xf5, 0xfd, 0x98, 0x0e, 0xbf, 0x5d,
		0x49, 0x75, 0x58, 0x37, 0xbc, 0x7f, 0xf5, 0x21,
		0x56, 0x1e, 0xd5, 0xb3, 0x50, 0x0b, 0xca, 0x96,
		0xf3, 0xd1, 0x3f, 0xb3, 0x70, 0xa8, 0x6d, 0x63,
		0x48, 0xfb, 0x3d, 0xd7, 0x29, 0x91, 0x45, 0xb5,
		0x48, 0xcd, 0xb6, 0x78, 0x30, 0xf2, 0x3f, 0x1e,
		0xd6, 0x22, 0xd6, 0x35, 0x9b, 0xf9, 0x1f, 0x85,
		0xae, 0xab, 0x4b, 0xd7, 0xe0, 0xc7, 0x86, 0x67,
		0x3f, 0x05, 0x7f, 0xa6, 0x0d, 0x2f, 0x0d, 0xbf,
		0x53, 0x5f, 0x4d, 0x2c, 0x6d, 0x5e, 0x57, 0x40,
		0x30, 0x3a, 0x23, 0x98, 0xf9, 0xb4, 0x32, 0xf5,
		0x32, 0x83, 0xdd, 0x0b, 0xae, 0x33, 0x97, 0x2f,
	};

	// This is the correct DH shared secret value callwlated below
	static uint8_t correct_ss[RSA2048_BYTE_SIZE] = {
		0x8f, 0xf3, 0xac, 0xa2, 0xea, 0x22, 0x11, 0x5c,
		0x45, 0x65, 0x1a, 0x77, 0x75, 0x2e, 0xcf, 0x46,
		0x23, 0x14, 0x1e, 0x67, 0x53, 0x4d, 0x35, 0xb0,
		0x38, 0x1d, 0x4e, 0xb9, 0x41, 0x9a, 0x21, 0x24,
		0x6e, 0x9f, 0x40, 0xfe, 0x90, 0x51, 0xb1, 0x06,
		0xa4, 0x7b, 0x87, 0x17, 0x2f, 0xe7, 0x5e, 0x22,
		0xf0, 0x7b, 0x54, 0x84, 0x0a, 0xac, 0x0a, 0x90,
		0xd2, 0xd7, 0xe8, 0x7f, 0xe7, 0xe3, 0x30, 0x75,
		0x01, 0x1f, 0x24, 0x75, 0x56, 0xbe, 0xcc, 0x8d,
		0x1e, 0x68, 0x0c, 0x41, 0x72, 0xd3, 0xfa, 0xbb,
		0xe5, 0x9c, 0x60, 0xc7, 0x28, 0x77, 0x0c, 0xbe,
		0x89, 0xab, 0x08, 0xd6, 0x21, 0xe7, 0x2e, 0x1a,
		0x58, 0x7a, 0xca, 0x4f, 0x22, 0xf3, 0x2b, 0x30,
		0xfd, 0xf4, 0x98, 0xc1, 0xa3, 0xf8, 0xf6, 0xcc,
		0xa9, 0xe4, 0xdb, 0x5b, 0xee, 0xd5, 0x5c, 0x6f,
		0x62, 0x4c, 0xd1, 0x1a, 0x02, 0x2a, 0x23, 0xe4,
		0xb5, 0x57, 0xf3, 0xf9, 0xec, 0x04, 0x83, 0x54,
		0xfe, 0x08, 0x5e, 0x35, 0xac, 0xfb, 0xa8, 0x09,
		0x82, 0x32, 0x60, 0x11, 0xb2, 0x16, 0x62, 0x6b,
		0xdf, 0xda, 0xde, 0x9c, 0xcb, 0x63, 0x44, 0x6c,
		0x59, 0x26, 0x6a, 0x8f, 0xb0, 0x24, 0xcb, 0xa6,
		0x72, 0x48, 0x1e, 0xeb, 0xe0, 0xe1, 0x09, 0x44,
		0xdd, 0xee, 0x66, 0x6d, 0x84, 0xcf, 0xa5, 0xc1,
		0xb8, 0x36, 0x74, 0xd3, 0x15, 0x96, 0xc3, 0xe4,
		0xc6, 0x5a, 0x4d, 0x23, 0x97, 0x0c, 0x5c, 0xcb,
		0xa9, 0xf5, 0x29, 0xc2, 0x0e, 0xff, 0x93, 0x82,
		0xd3, 0x34, 0x49, 0xad, 0x64, 0xa6, 0xb1, 0xc0,
		0x59, 0x28, 0x75, 0x60, 0xa7, 0x8a, 0xb0, 0x11,
		0x56, 0x89, 0x42, 0x74, 0x11, 0xf5, 0xf6, 0x5e,
		0x6f, 0x16, 0x54, 0x6a, 0xb1, 0x76, 0x4d, 0x50,
		0x8a, 0x68, 0xc1, 0x5b, 0x82, 0xb9, 0x0d, 0x00,
		0x32, 0x50, 0xed, 0x88, 0x87, 0x48, 0x92, 0x17,
	};

	CRYPTO_CONTEXT_RESET(c);
	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_DECRYPT, TE_ALG_MODEXP);

	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));
	se_util_mem_set(dst, 0U, sizeof_u32(dst));

	/* Preset fields */
	//
	// Again, because we use a private key for the RSA operation =>
	//  do a decrypt.
	//
	arg.ca_alg_mode = TE_ALG_MODE_DECRYPT;
	arg.ca_algo     = TE_ALG_MODEXP;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	LOG_INFO("Hint: use engine 0x%x (%s) for DH\n", eid, eid_name(eid));

	arg.ca_init.engine_hint = eid;
	// Pass the key params
	arg.ca_set_key.kdata = &akey_for_A;

	arg.ca_data.src_size = sizeof_u32(data_B);
	arg.ca_data.src = data_B;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	LOG_INFO("DH[0x%x] shared secret (COMBINED OPERATION) src %p data, result %p\n",
		   algo, data_B, dst);

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("DH shared secret result:", dst, sizeof_u32(dst));
	VERIFY_ARRAY_VALUE(dst, correct_ss, sizeof_u32(correct_ss));

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* RSA_MIN_KEYSIZE_BITS <= 512U */
#endif /* TEST_DH */

#if HAVE_RSA_MONTGOMERY_CALC

/* Compile time selection(...) for testing both little and big endian
 * values. Callwlated values are verified to be correct.
 *
 * Also loads the modulus and montgomery values to PKA1 keyslot;
 * no operations are performed with the keyslot here.
 */
#define MONT_LITTLE_ENDIAN 1

__STATIC__ status_t TEST_gen_rsa_mont(void)
{
	status_t ret = NO_ERROR;

	LOG_ALWAYS("RSA montgomery 3072 bit modulus values\n");

	/* The following values must be in the SAME ENDIAN
	 * (as specified in the key set function parameters)
	 * when passed to se_set_device_rsa_keyslot_montgomery().
	 *
	 * Big endian RSA values are used in this example.
	 *
	 * Exponent 65537
	 */
#if MONT_LITTLE_ENDIAN
	static uint8_t pub_exponent[] = { 0x01, 0x00, 0x01, 0x00 };
#else
	static uint8_t pub_exponent[] = { 0x00, 0x01, 0x00, 0x01 };
#endif

	/* RSA 3072 bit modulus (file: ITS public key modulus => Kranti) */
	static uint8_t modulus[] = {
#if MONT_LITTLE_ENDIAN
0x53, 0x31, 0x8a, 0x49, 0xd8, 0xe5, 0x1e, 0x4a, 0x5f, 0xae, 0x4e, 0xc8, 0xca, 0x3e, 0x0c, 0x2c,
0x83, 0x2e, 0xe2, 0x29, 0xd2, 0x77, 0xfc, 0x4b, 0x10, 0x8e, 0x2f, 0x0b, 0xb9, 0xae, 0xe9, 0x39,
0x8b, 0x18, 0x0c, 0x6e, 0x33, 0x4e, 0xf0, 0xac, 0x4c, 0x87, 0x67, 0xd4, 0x5b, 0x76, 0xdb, 0x8d,
0xd7, 0x01, 0x86, 0x07, 0xf6, 0x46, 0xf2, 0x15, 0x2f, 0xf5, 0xfc, 0x13, 0xa5, 0x28, 0x43, 0x89,
0xc4, 0xa5, 0x95, 0x63, 0x99, 0x16, 0xc7, 0x15, 0x72, 0x39, 0x57, 0x8a, 0xf0, 0xfa, 0x67, 0xb3,
0x3d, 0x78, 0x8a, 0xe3, 0x76, 0xf8, 0x6d, 0xec, 0xfa, 0x31, 0x4b, 0x0c, 0xc8, 0x57, 0x31, 0x74,
0xa6, 0x56, 0x9d, 0x07, 0x51, 0x77, 0xf2, 0x79, 0xf1, 0x6a, 0x26, 0x6a, 0x9b, 0x5e, 0x3b, 0x59,
0xb0, 0x85, 0x91, 0x36, 0x48, 0xab, 0xe8, 0x3b, 0xa6, 0x0a, 0xb7, 0xc6, 0x12, 0xb1, 0x34, 0xdf,
0x14, 0x5b, 0x51, 0x49, 0xb3, 0xbf, 0xaa, 0x3d, 0xf7, 0x08, 0xb0, 0x23, 0xfe, 0x00, 0xb1, 0xef,
0xf5, 0xa1, 0xfe, 0x7f, 0xe3, 0x6e, 0x28, 0x08, 0xf5, 0x1c, 0x0f, 0xc2, 0x25, 0xb9, 0xe6, 0x2f,
0xf1, 0x0a, 0x77, 0x29, 0xc0, 0xcf, 0x3d, 0xca, 0x1f, 0x9b, 0x88, 0x15, 0x20, 0x6f, 0x9c, 0x53,
0x6e, 0x37, 0xd7, 0x27, 0x1c, 0xd3, 0xe2, 0x1c, 0x03, 0x8f, 0xab, 0x50, 0x83, 0x5d, 0xc3, 0x04,
0x12, 0x1a, 0xbd, 0x67, 0x15, 0xa7, 0x81, 0x91, 0x63, 0x40, 0x5e, 0x0c, 0x4c, 0xb3, 0x05, 0xdf,
0x65, 0xa0, 0x5b, 0x7e, 0x59, 0x3f, 0x79, 0x80, 0x53, 0xd2, 0x80, 0xbf, 0xa7, 0x23, 0xf9, 0x39,
0xfb, 0x36, 0xb7, 0x37, 0x3b, 0x23, 0xa3, 0x81, 0x40, 0x2d, 0xf4, 0x4a, 0x22, 0xce, 0x03, 0xce,
0xf5, 0xdc, 0xf7, 0x76, 0x2a, 0x3d, 0x55, 0x74, 0xc8, 0xde, 0x0f, 0x4d, 0xd9, 0xe7, 0x8b, 0xe0,
0x89, 0xdd, 0x45, 0xfd, 0x7f, 0x80, 0xa7, 0x8e, 0xbc, 0x26, 0x57, 0xe7, 0x34, 0x67, 0xa4, 0xee,
0xd3, 0x3a, 0xb8, 0x1d, 0xc8, 0x24, 0x7c, 0xc4, 0x49, 0x5a, 0x8a, 0x53, 0x81, 0xaa, 0xe9, 0x61,
0x9e, 0x79, 0x6f, 0xa0, 0xb0, 0xb7, 0xf6, 0xe3, 0x97, 0x77, 0x6e, 0x90, 0x46, 0xc2, 0xa4, 0x73,
0x5c, 0xf3, 0x8c, 0x41, 0x59, 0x96, 0x4f, 0x49, 0x96, 0xd1, 0xbd, 0x8b, 0xde, 0x7b, 0xf4, 0xb3,
0x27, 0x6c, 0x97, 0x8f, 0xfe, 0xa5, 0xb7, 0x54, 0xf8, 0x34, 0xd4, 0xc0, 0x5f, 0xcf, 0xf3, 0x99,
0x44, 0xba, 0xb5, 0xe5, 0xf8, 0x1d, 0x78, 0xb8, 0x20, 0xc2, 0x40, 0xbb, 0x2e, 0xff, 0x62, 0x29,
0xfc, 0x98, 0x69, 0xa1, 0xa0, 0xf1, 0xd6, 0xc5, 0x97, 0x40, 0xa3, 0x25, 0xba, 0xca, 0x17, 0xda,
0xab, 0x29, 0xb4, 0x93, 0xf5, 0x11, 0x9a, 0x41, 0x1c, 0x2b, 0xc8, 0x26, 0x32, 0xad, 0x8c, 0xb3,
#else
0xb3, 0x8c, 0xad, 0x32, 0x26, 0xc8, 0x2b, 0x1c, 0x41, 0x9a, 0x11, 0xf5, 0x93, 0xb4, 0x29, 0xab,
0xda, 0x17, 0xca, 0xba, 0x25, 0xa3, 0x40, 0x97, 0xc5, 0xd6, 0xf1, 0xa0, 0xa1, 0x69, 0x98, 0xfc,
0x29, 0x62, 0xff, 0x2e, 0xbb, 0x40, 0xc2, 0x20, 0xb8, 0x78, 0x1d, 0xf8, 0xe5, 0xb5, 0xba, 0x44,
0x99, 0xf3, 0xcf, 0x5f, 0xc0, 0xd4, 0x34, 0xf8, 0x54, 0xb7, 0xa5, 0xfe, 0x8f, 0x97, 0x6c, 0x27,
0xb3, 0xf4, 0x7b, 0xde, 0x8b, 0xbd, 0xd1, 0x96, 0x49, 0x4f, 0x96, 0x59, 0x41, 0x8c, 0xf3, 0x5c,
0x73, 0xa4, 0xc2, 0x46, 0x90, 0x6e, 0x77, 0x97, 0xe3, 0xf6, 0xb7, 0xb0, 0xa0, 0x6f, 0x79, 0x9e,
0x61, 0xe9, 0xaa, 0x81, 0x53, 0x8a, 0x5a, 0x49, 0xc4, 0x7c, 0x24, 0xc8, 0x1d, 0xb8, 0x3a, 0xd3,
0xee, 0xa4, 0x67, 0x34, 0xe7, 0x57, 0x26, 0xbc, 0x8e, 0xa7, 0x80, 0x7f, 0xfd, 0x45, 0xdd, 0x89,
0xe0, 0x8b, 0xe7, 0xd9, 0x4d, 0x0f, 0xde, 0xc8, 0x74, 0x55, 0x3d, 0x2a, 0x76, 0xf7, 0xdc, 0xf5,
0xce, 0x03, 0xce, 0x22, 0x4a, 0xf4, 0x2d, 0x40, 0x81, 0xa3, 0x23, 0x3b, 0x37, 0xb7, 0x36, 0xfb,
0x39, 0xf9, 0x23, 0xa7, 0xbf, 0x80, 0xd2, 0x53, 0x80, 0x79, 0x3f, 0x59, 0x7e, 0x5b, 0xa0, 0x65,
0xdf, 0x05, 0xb3, 0x4c, 0x0c, 0x5e, 0x40, 0x63, 0x91, 0x81, 0xa7, 0x15, 0x67, 0xbd, 0x1a, 0x12,
0x04, 0xc3, 0x5d, 0x83, 0x50, 0xab, 0x8f, 0x03, 0x1c, 0xe2, 0xd3, 0x1c, 0x27, 0xd7, 0x37, 0x6e,
0x53, 0x9c, 0x6f, 0x20, 0x15, 0x88, 0x9b, 0x1f, 0xca, 0x3d, 0xcf, 0xc0, 0x29, 0x77, 0x0a, 0xf1,
0x2f, 0xe6, 0xb9, 0x25, 0xc2, 0x0f, 0x1c, 0xf5, 0x08, 0x28, 0x6e, 0xe3, 0x7f, 0xfe, 0xa1, 0xf5,
0xef, 0xb1, 0x00, 0xfe, 0x23, 0xb0, 0x08, 0xf7, 0x3d, 0xaa, 0xbf, 0xb3, 0x49, 0x51, 0x5b, 0x14,
0xdf, 0x34, 0xb1, 0x12, 0xc6, 0xb7, 0x0a, 0xa6, 0x3b, 0xe8, 0xab, 0x48, 0x36, 0x91, 0x85, 0xb0,
0x59, 0x3b, 0x5e, 0x9b, 0x6a, 0x26, 0x6a, 0xf1, 0x79, 0xf2, 0x77, 0x51, 0x07, 0x9d, 0x56, 0xa6,
0x74, 0x31, 0x57, 0xc8, 0x0c, 0x4b, 0x31, 0xfa, 0xec, 0x6d, 0xf8, 0x76, 0xe3, 0x8a, 0x78, 0x3d,
0xb3, 0x67, 0xfa, 0xf0, 0x8a, 0x57, 0x39, 0x72, 0x15, 0xc7, 0x16, 0x99, 0x63, 0x95, 0xa5, 0xc4,
0x89, 0x43, 0x28, 0xa5, 0x13, 0xfc, 0xf5, 0x2f, 0x15, 0xf2, 0x46, 0xf6, 0x07, 0x86, 0x01, 0xd7,
0x8d, 0xdb, 0x76, 0x5b, 0xd4, 0x67, 0x87, 0x4c, 0xac, 0xf0, 0x4e, 0x33, 0x6e, 0x0c, 0x18, 0x8b,
0x39, 0xe9, 0xae, 0xb9, 0x0b, 0x2f, 0x8e, 0x10, 0x4b, 0xfc, 0x77, 0xd2, 0x29, 0xe2, 0x2e, 0x83,
0x2c, 0x0c, 0x3e, 0xca, 0xc8, 0x4e, 0xae, 0x5f, 0x4a, 0x1e, 0xe5, 0xd8, 0x49, 0x8a, 0x31, 0x53,
#endif
	};

	/* Pre-computed montgomery value M_PRIME,
	 * this depends on the modulus value
	 *
	 * Matching IST pubkey montgomery values from
	 * bootloader/mb1/src-t19x/mb1/core/include/mb1_se_public_keys.h#281
	 */
	static uint8_t mont_m_prime[] = {
#if MONT_LITTLE_ENDIAN
0x25, 0xc5, 0x66, 0x20, 0xe4, 0x12, 0x65, 0xc3, 0x9b, 0x47, 0x37, 0x44, 0x2e, 0x75, 0x59, 0xd4,
0x55, 0xab, 0x13, 0x2e, 0x10, 0x44, 0x9c, 0xf0, 0x7b, 0x4e, 0x0b, 0x15, 0xa0, 0xb6, 0x13, 0xe6,
0xda, 0xda, 0xb2, 0xde, 0x9d, 0x7d, 0x59, 0x43, 0x4b, 0x0e, 0x33, 0x71, 0x3c, 0xc3, 0x9f, 0xc2,
0xae, 0xad, 0x2e, 0x4b, 0x21, 0x8b, 0xe5, 0xb3, 0xe3, 0x15, 0x36, 0x6e, 0x56, 0xeb, 0xe1, 0xbb,
0x58, 0xf2, 0x90, 0xac, 0x7c, 0xa6, 0x64, 0xeb, 0x79, 0xb1, 0x7f, 0xed, 0x44, 0xe4, 0x4d, 0x34,
0xaf, 0x6b, 0x8f, 0x7c, 0x94, 0x1b, 0x9e, 0x03, 0xd1, 0x4e, 0xa3, 0x45, 0x41, 0x6b, 0x9b, 0x9d,
0xcc, 0xb0, 0x5c, 0x7c, 0x82, 0xa5, 0x91, 0xd2, 0xce, 0xd3, 0x58, 0x4a, 0x57, 0xd4, 0xc4, 0xc6,
0x71, 0x58, 0xad, 0x33, 0x7e, 0xb5, 0x5e, 0xb4, 0x56, 0xf4, 0xe1, 0x37, 0x40, 0x82, 0xb2, 0xd4,
0xb1, 0x36, 0x4c, 0x39, 0x30, 0x88, 0xa3, 0xee, 0x7d, 0xa9, 0xac, 0x3c, 0xa4, 0xee, 0x4b, 0xbb,
0xbb, 0x56, 0xda, 0x53, 0x2c, 0x77, 0x5d, 0x21, 0x85, 0x03, 0x48, 0x94, 0x78, 0x5c, 0x92, 0xd4,
0x6c, 0x5d, 0xc8, 0x45, 0x90, 0x60, 0xaa, 0xd1, 0x8a, 0xcf, 0xba, 0x52, 0x08, 0x3e, 0x3d, 0x38,
0x67, 0x43, 0x12, 0x8a, 0xcf, 0x5d, 0x8d, 0x8e, 0x2c, 0xa1, 0x4f, 0x5e, 0x70, 0xc8, 0xd9, 0x85,
0xf2, 0x96, 0x00, 0x48, 0x14, 0xf3, 0xf1, 0x53, 0xb1, 0xb1, 0xc5, 0x2c, 0xc7, 0xff, 0xf7, 0x98,
0x6d, 0x6c, 0xe9, 0x66, 0x84, 0xfc, 0xd9, 0xde, 0x2d, 0x71, 0x8f, 0x3d, 0x22, 0x02, 0x9a, 0x79,
0xd4, 0xc3, 0x28, 0xf6, 0x34, 0x04, 0xf0, 0x5e, 0x9b, 0x70, 0x25, 0xf6, 0x87, 0xe6, 0x84, 0xc6,
0x1f, 0xa9, 0x5d, 0xf2, 0xcc, 0x54, 0x89, 0x3f, 0x44, 0xe6, 0x8f, 0x56, 0x40, 0x37, 0xb7, 0x26,
0x57, 0x93, 0x5b, 0xb7, 0x27, 0x77, 0xb1, 0x0c, 0xc1, 0x34, 0x22, 0xfb, 0x32, 0x24, 0x2b, 0xed,
0x79, 0x53, 0x92, 0xee, 0xd8, 0xa2, 0xa8, 0x4c, 0x1c, 0xa5, 0x36, 0x73, 0xde, 0x52, 0xe3, 0x7f,
0xa9, 0x40, 0x0e, 0x77, 0x98, 0xfd, 0x62, 0xf9, 0x45, 0x76, 0x84, 0x98, 0xab, 0x7e, 0xd7, 0x15,
0xb7, 0x3a, 0xf3, 0xac, 0xf9, 0x4a, 0x0b, 0x6e, 0xaa, 0x79, 0x4b, 0x5e, 0x9f, 0xc1, 0xdb, 0x09,
0x41, 0xdb, 0x3e, 0xfe, 0xe7, 0xd9, 0xd2, 0xe7, 0x70, 0x8b, 0x9d, 0xca, 0x8e, 0x80, 0x18, 0xef,
0xcf, 0x8e, 0x66, 0x99, 0x11, 0xcc, 0x69, 0xa5, 0x4b, 0x4e, 0x50, 0xf6, 0xfd, 0xe9, 0xf1, 0xd6,
0x49, 0x09, 0xf4, 0x3c, 0x56, 0x02, 0x0d, 0x23, 0xe5, 0xb8, 0xc2, 0x87, 0x05, 0x76, 0xbf, 0xcb,
0x9d, 0x85, 0x8c, 0x26, 0xf7, 0x11, 0xee, 0xc1, 0x31, 0x68, 0x23, 0x1e, 0x74, 0x1c, 0xae, 0xc2
#else
0xc2, 0xae, 0x1c, 0x74, 0x1e, 0x23, 0x68, 0x31, 0xc1, 0xee, 0x11, 0xf7, 0x26, 0x8c, 0x85, 0x9d,
0xcb, 0xbf, 0x76, 0x05, 0x87, 0xc2, 0xb8, 0xe5, 0x23, 0x0d, 0x02, 0x56, 0x3c, 0xf4, 0x09, 0x49,
0xd6, 0xf1, 0xe9, 0xfd, 0xf6, 0x50, 0x4e, 0x4b, 0xa5, 0x69, 0xcc, 0x11, 0x99, 0x66, 0x8e, 0xcf,
0xef, 0x18, 0x80, 0x8e, 0xca, 0x9d, 0x8b, 0x70, 0xe7, 0xd2, 0xd9, 0xe7, 0xfe, 0x3e, 0xdb, 0x41,
0x09, 0xdb, 0xc1, 0x9f, 0x5e, 0x4b, 0x79, 0xaa, 0x6e, 0x0b, 0x4a, 0xf9, 0xac, 0xf3, 0x3a, 0xb7,
0x15, 0xd7, 0x7e, 0xab, 0x98, 0x84, 0x76, 0x45, 0xf9, 0x62, 0xfd, 0x98, 0x77, 0x0e, 0x40, 0xa9,
0x7f, 0xe3, 0x52, 0xde, 0x73, 0x36, 0xa5, 0x1c, 0x4c, 0xa8, 0xa2, 0xd8, 0xee, 0x92, 0x53, 0x79,
0xed, 0x2b, 0x24, 0x32, 0xfb, 0x22, 0x34, 0xc1, 0x0c, 0xb1, 0x77, 0x27, 0xb7, 0x5b, 0x93, 0x57,
0x26, 0xb7, 0x37, 0x40, 0x56, 0x8f, 0xe6, 0x44, 0x3f, 0x89, 0x54, 0xcc, 0xf2, 0x5d, 0xa9, 0x1f,
0xc6, 0x84, 0xe6, 0x87, 0xf6, 0x25, 0x70, 0x9b, 0x5e, 0xf0, 0x04, 0x34, 0xf6, 0x28, 0xc3, 0xd4,
0x79, 0x9a, 0x02, 0x22, 0x3d, 0x8f, 0x71, 0x2d, 0xde, 0xd9, 0xfc, 0x84, 0x66, 0xe9, 0x6c, 0x6d,
0x98, 0xf7, 0xff, 0xc7, 0x2c, 0xc5, 0xb1, 0xb1, 0x53, 0xf1, 0xf3, 0x14, 0x48, 0x00, 0x96, 0xf2,
0x85, 0xd9, 0xc8, 0x70, 0x5e, 0x4f, 0xa1, 0x2c, 0x8e, 0x8d, 0x5d, 0xcf, 0x8a, 0x12, 0x43, 0x67,
0x38, 0x3d, 0x3e, 0x08, 0x52, 0xba, 0xcf, 0x8a, 0xd1, 0xaa, 0x60, 0x90, 0x45, 0xc8, 0x5d, 0x6c,
0xd4, 0x92, 0x5c, 0x78, 0x94, 0x48, 0x03, 0x85, 0x21, 0x5d, 0x77, 0x2c, 0x53, 0xda, 0x56, 0xbb,
0xbb, 0x4b, 0xee, 0xa4, 0x3c, 0xac, 0xa9, 0x7d, 0xee, 0xa3, 0x88, 0x30, 0x39, 0x4c, 0x36, 0xb1,
0xd4, 0xb2, 0x82, 0x40, 0x37, 0xe1, 0xf4, 0x56, 0xb4, 0x5e, 0xb5, 0x7e, 0x33, 0xad, 0x58, 0x71,
0xc6, 0xc4, 0xd4, 0x57, 0x4a, 0x58, 0xd3, 0xce, 0xd2, 0x91, 0xa5, 0x82, 0x7c, 0x5c, 0xb0, 0xcc,
0x9d, 0x9b, 0x6b, 0x41, 0x45, 0xa3, 0x4e, 0xd1, 0x03, 0x9e, 0x1b, 0x94, 0x7c, 0x8f, 0x6b, 0xaf,
0x34, 0x4d, 0xe4, 0x44, 0xed, 0x7f, 0xb1, 0x79, 0xeb, 0x64, 0xa6, 0x7c, 0xac, 0x90, 0xf2, 0x58,
0xbb, 0xe1, 0xeb, 0x56, 0x6e, 0x36, 0x15, 0xe3, 0xb3, 0xe5, 0x8b, 0x21, 0x4b, 0x2e, 0xad, 0xae,
0xc2, 0x9f, 0xc3, 0x3c, 0x71, 0x33, 0x0e, 0x4b, 0x43, 0x59, 0x7d, 0x9d, 0xde, 0xb2, 0xda, 0xda,
0xe6, 0x13, 0xb6, 0xa0, 0x15, 0x0b, 0x4e, 0x7b, 0xf0, 0x9c, 0x44, 0x10, 0x2e, 0x13, 0xab, 0x55,
0xd4, 0x59, 0x75, 0x2e, 0x44, 0x37, 0x47, 0x9b, 0xc3, 0x65, 0x12, 0xe4, 0x20, 0x66, 0xc5, 0x25
#endif
	};

	/* Pre-computed montgomery value R_SQR,
	 * this depends on the modulus value
	 */
	static uint8_t mont_r_sqr[] = {
#if MONT_LITTLE_ENDIAN
0x83, 0x0b, 0x29, 0xae, 0x56, 0xb8, 0xc3, 0x77, 0x5f, 0xba, 0xfa, 0xa3, 0xae, 0x8b, 0x74, 0xf9,
0xde, 0x3c, 0xf8, 0xd4, 0xf1, 0x8c, 0x57, 0xce, 0x75, 0xf0, 0x07, 0xb4, 0x3b, 0x7a, 0xe4, 0x07,
0x92, 0xf7, 0x9e, 0x0f, 0xae, 0x28, 0x6b, 0x11, 0xfa, 0xb6, 0xb8, 0xed, 0xf0, 0xad, 0x8f, 0xac,
0x7c, 0x01, 0x30, 0xb6, 0x88, 0xfc, 0x45, 0x19, 0x15, 0x1a, 0x0d, 0xcc, 0x63, 0x01, 0x38, 0x32,
0xac, 0xe5, 0x8e, 0x61, 0x88, 0xb4, 0x95, 0xd5, 0x5a, 0x91, 0x50, 0x3e, 0x9e, 0x65, 0x85, 0xe5,
0x45, 0xf8, 0xf2, 0x96, 0x04, 0x9d, 0xb8, 0x82, 0x48, 0xf9, 0xc2, 0x2b, 0x24, 0x97, 0x85, 0x11,
0x26, 0x22, 0x97, 0xa0, 0xe7, 0x57, 0x3a, 0xcc, 0x77, 0x9c, 0x2e, 0x37, 0x85, 0x10, 0x70, 0xfc,
0x32, 0x23, 0x8c, 0x17, 0x9f, 0xa8, 0x09, 0x26, 0xdb, 0x50, 0x2d, 0x36, 0xaf, 0x69, 0x16, 0x7b,
0x89, 0x85, 0x1f, 0x45, 0xdf, 0x19, 0x63, 0x4c, 0xeb, 0xee, 0xff, 0xf4, 0xa5, 0xd1, 0x66, 0xd8,
0x7a, 0xdf, 0x68, 0x7b, 0x06, 0x5b, 0x6e, 0xcd, 0xa1, 0x00, 0xe9, 0x0e, 0x76, 0xc7, 0x6e, 0x57,
0x02, 0xf0, 0x85, 0x0c, 0x04, 0x8c, 0xae, 0x94, 0x5d, 0x1d, 0x0b, 0x6f, 0xb4, 0x7f, 0x08, 0x3d,
0xa2, 0x19, 0x9c, 0x6b, 0x0e, 0x28, 0x80, 0x7e, 0x0b, 0x0c, 0x3f, 0x4f, 0x1c, 0x2a, 0x80, 0x65,
0xe2, 0x18, 0xa7, 0x7d, 0x54, 0x35, 0x0d, 0xba, 0xe8, 0x22, 0x0d, 0xd4, 0xb9, 0x4c, 0x63, 0xb3,
0x77, 0x71, 0x17, 0x48, 0x54, 0x7b, 0xea, 0xf8, 0x83, 0x59, 0x49, 0x85, 0xc2, 0xe0, 0xa2, 0xf7,
0x3f, 0x6c, 0x24, 0x48, 0x62, 0xb9, 0x36, 0xa8, 0x64, 0x9d, 0x52, 0xed, 0x52, 0x69, 0x30, 0x3b,
0x9f, 0x37, 0x76, 0x49, 0xb0, 0xae, 0x05, 0x9e, 0x6a, 0xb3, 0xf7, 0x05, 0xe3, 0xef, 0x38, 0xe9,
0x7e, 0x2f, 0x76, 0x50, 0xa3, 0x1e, 0xa2, 0xe5, 0xb2, 0xae, 0x1d, 0xc9, 0xc7, 0x5a, 0xc2, 0xcf,
0xc3, 0x61, 0x7d, 0x3a, 0x9d, 0xf0, 0xb5, 0x38, 0xb1, 0xdb, 0x56, 0x11, 0xaa, 0x30, 0x23, 0xdd,
0x41, 0xcd, 0xd6, 0xd4, 0x56, 0xa3, 0x3d, 0xaf, 0x85, 0xd2, 0xfe, 0xec, 0x2a, 0xeb, 0x23, 0x44,
0xfc, 0x4e, 0x4d, 0xcf, 0x2f, 0x69, 0xaf, 0x15, 0xf3, 0x6a, 0x38, 0xbe, 0xdf, 0x17, 0xe2, 0xe4,
0x2a, 0x8a, 0x10, 0x16, 0x55, 0x9c, 0x15, 0xe8, 0xf7, 0x69, 0x0c, 0x5a, 0x54, 0xd3, 0x70, 0xc0,
0x8f, 0x0d, 0x2f, 0x39, 0x6f, 0x8f, 0x74, 0x78, 0xb5, 0xa7, 0xdf, 0xb8, 0xa7, 0x40, 0x6e, 0x3f,
0x14, 0x98, 0xe4, 0xe3, 0x85, 0xb3, 0x4f, 0x09, 0x4c, 0xbe, 0xaa, 0x61, 0x41, 0xd1, 0x83, 0x8f,
0x71, 0xda, 0x93, 0xdc, 0xd4, 0x3d, 0x59, 0x04, 0x46, 0x80, 0x2f, 0xd0, 0x25, 0xbc, 0xab, 0x02
#else
0x02, 0xab, 0xbc, 0x25, 0xd0, 0x2f, 0x80, 0x46, 0x04, 0x59, 0x3d, 0xd4, 0xdc, 0x93, 0xda, 0x71,
0x8f, 0x83, 0xd1, 0x41, 0x61, 0xaa, 0xbe, 0x4c, 0x09, 0x4f, 0xb3, 0x85, 0xe3, 0xe4, 0x98, 0x14,
0x3f, 0x6e, 0x40, 0xa7, 0xb8, 0xdf, 0xa7, 0xb5, 0x78, 0x74, 0x8f, 0x6f, 0x39, 0x2f, 0x0d, 0x8f,
0xc0, 0x70, 0xd3, 0x54, 0x5a, 0x0c, 0x69, 0xf7, 0xe8, 0x15, 0x9c, 0x55, 0x16, 0x10, 0x8a, 0x2a,
0xe4, 0xe2, 0x17, 0xdf, 0xbe, 0x38, 0x6a, 0xf3, 0x15, 0xaf, 0x69, 0x2f, 0xcf, 0x4d, 0x4e, 0xfc,
0x44, 0x23, 0xeb, 0x2a, 0xec, 0xfe, 0xd2, 0x85, 0xaf, 0x3d, 0xa3, 0x56, 0xd4, 0xd6, 0xcd, 0x41,
0xdd, 0x23, 0x30, 0xaa, 0x11, 0x56, 0xdb, 0xb1, 0x38, 0xb5, 0xf0, 0x9d, 0x3a, 0x7d, 0x61, 0xc3,
0xcf, 0xc2, 0x5a, 0xc7, 0xc9, 0x1d, 0xae, 0xb2, 0xe5, 0xa2, 0x1e, 0xa3, 0x50, 0x76, 0x2f, 0x7e,
0xe9, 0x38, 0xef, 0xe3, 0x05, 0xf7, 0xb3, 0x6a, 0x9e, 0x05, 0xae, 0xb0, 0x49, 0x76, 0x37, 0x9f,
0x3b, 0x30, 0x69, 0x52, 0xed, 0x52, 0x9d, 0x64, 0xa8, 0x36, 0xb9, 0x62, 0x48, 0x24, 0x6c, 0x3f,
0xf7, 0xa2, 0xe0, 0xc2, 0x85, 0x49, 0x59, 0x83, 0xf8, 0xea, 0x7b, 0x54, 0x48, 0x17, 0x71, 0x77,
0xb3, 0x63, 0x4c, 0xb9, 0xd4, 0x0d, 0x22, 0xe8, 0xba, 0x0d, 0x35, 0x54, 0x7d, 0xa7, 0x18, 0xe2,
0x65, 0x80, 0x2a, 0x1c, 0x4f, 0x3f, 0x0c, 0x0b, 0x7e, 0x80, 0x28, 0x0e, 0x6b, 0x9c, 0x19, 0xa2,
0x3d, 0x08, 0x7f, 0xb4, 0x6f, 0x0b, 0x1d, 0x5d, 0x94, 0xae, 0x8c, 0x04, 0x0c, 0x85, 0xf0, 0x02,
0x57, 0x6e, 0xc7, 0x76, 0x0e, 0xe9, 0x00, 0xa1, 0xcd, 0x6e, 0x5b, 0x06, 0x7b, 0x68, 0xdf, 0x7a,
0xd8, 0x66, 0xd1, 0xa5, 0xf4, 0xff, 0xee, 0xeb, 0x4c, 0x63, 0x19, 0xdf, 0x45, 0x1f, 0x85, 0x89,
0x7b, 0x16, 0x69, 0xaf, 0x36, 0x2d, 0x50, 0xdb, 0x26, 0x09, 0xa8, 0x9f, 0x17, 0x8c, 0x23, 0x32,
0xfc, 0x70, 0x10, 0x85, 0x37, 0x2e, 0x9c, 0x77, 0xcc, 0x3a, 0x57, 0xe7, 0xa0, 0x97, 0x22, 0x26,
0x11, 0x85, 0x97, 0x24, 0x2b, 0xc2, 0xf9, 0x48, 0x82, 0xb8, 0x9d, 0x04, 0x96, 0xf2, 0xf8, 0x45,
0xe5, 0x85, 0x65, 0x9e, 0x3e, 0x50, 0x91, 0x5a, 0xd5, 0x95, 0xb4, 0x88, 0x61, 0x8e, 0xe5, 0xac,
0x32, 0x38, 0x01, 0x63, 0xcc, 0x0d, 0x1a, 0x15, 0x19, 0x45, 0xfc, 0x88, 0xb6, 0x30, 0x01, 0x7c,
0xac, 0x8f, 0xad, 0xf0, 0xed, 0xb8, 0xb6, 0xfa, 0x11, 0x6b, 0x28, 0xae, 0x0f, 0x9e, 0xf7, 0x92,
0x07, 0xe4, 0x7a, 0x3b, 0xb4, 0x07, 0xf0, 0x75, 0xce, 0x57, 0x8c, 0xf1, 0xd4, 0xf8, 0x3c, 0xde,
0xf9, 0x74, 0x8b, 0xae, 0xa3, 0xfa, 0xba, 0x5f, 0x77, 0xc3, 0xb8, 0x56, 0xae, 0x29, 0x0b, 0x83
#endif
	};

	/* Since KEY_FLAG_LEAVE_KEY_IN_KEYSLOT is not set in k_flags =>
	 * the PKA1 RSA keyslot will get erased when the operation
	 * is done.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_RSA_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_USE_KEYSLOT_KEY,
		.k_byte_size = RSA3072_BYTE_SIZE,
		.k_keyslot = 3U,
	};

#if MONT_LITTLE_ENDIAN
	bool key_big_endian = false;
#else
	bool key_big_endian = true;
#endif

	LOG_ERROR("Always using PKA1 RSA engine for pre-loading montgomery values test case\n");

	{
		uint8_t m_prime_out[ sizeof_u32(modulus) ];
		uint8_t r2_out[ sizeof_u32(modulus) ];

		ret = se_get_rsa_montgomery_values(akey.k_byte_size,
						   modulus,
						   key_big_endian,
						   m_prime_out,
						   r2_out);
		CCC_ERROR_CHECK(ret);

		DUMP_HEX("MODULUS:", modulus, akey.k_byte_size);
		DUMP_HEX("M_PRIME (calc):", m_prime_out, akey.k_byte_size);
		DUMP_HEX("R^2 (calc):", r2_out, akey.k_byte_size);
		LOG_INFO("IS_BIG_ENDIAN: %u\n", key_big_endian);

		VERIFY_ARRAY_VALUE(mont_m_prime, m_prime_out, sizeof_u32(mont_m_prime));
		VERIFY_ARRAY_VALUE(mont_r_sqr, r2_out, sizeof_u32(mont_r_sqr));
	}

	/* Store the RSA pubkey and montgomery values matching that modulus
	 * to the PKA1 keyslot.
	 */
	ret = se_set_device_rsa_keyslot_montgomery(SE_CDEV_PKA1, akey.k_keyslot,
						   sizeof_u32(pub_exponent), akey.k_byte_size,
						   pub_exponent, modulus,
						   key_big_endian, mont_m_prime,
						   mont_r_sqr);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to set up PKA1 keyslot with montgomery values\n"));

fail:
	return ret;
}
#endif /* HAVE_RSA_MONTGOMERY_CALC */

#if HAVE_SE_UNWRAP

/* Correct result when key is zero */
static const uint8_t uw_ok_zero[] = {
	0x66, 0xE9, 0x4B, 0xD4, 0xEF, 0x8A, 0x2C, 0x3B,
	0x88, 0x4C, 0xFA, 0x59, 0xCA, 0x34, 0x2B, 0x2E,
};

static status_t keyop_kwuw_key_verification(crypto_context_t *c, uint32_t key_index,
					    uint32_t key_blen, const uint8_t *correct16)
{
	status_t ret = NO_ERROR;

	static DMA_ALIGN_DATA uint8_t dst[DMA_ALIGN_SIZE(16)];
	static DMA_ALIGN_DATA uint8_t data[ 16 ] = { 0x00 };

	te_crypto_args_t arg =  { .ca_handle = 0U, };
	te_crypto_algo_t algo = TE_ALG_AES_ECB_NOPAD;

	static te_args_key_data_t akey = {
		.k_key_type = KEY_TYPE_AES,
		.k_flags = KEY_FLAG_USE_KEYSLOT_KEY | KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
	};

	uint32_t data_len = sizeof_u32(data);

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_ENCRYPT, algo);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_ENCRYPT;
	arg.ca_algo     = algo;
	arg.ca_opcode	= TE_OP_COMBINED_OPERATION;

	arg.ca_init.engine_hint = CCC_ENGINE_SE0_AES1;

	akey.k_byte_size = key_blen;
	akey.k_keyslot = key_index;

	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = data_len;
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	ret = CRYPTO_OPERATION(c, &arg);
	TRAP_IF_ERROR(ret, "key wrap cipher test operation failed: %d\n", ret);

#if MODULE_TRACE
	{
		uint32_t written = 0U;
		written = arg.ca_data.dst_size;
		LOG_INFO("CRYPTO DST_SIZE %u, cipher with keyslot %u, key len %u bytes\n", written, key_index, key_blen);
		DUMP_HEX("KWUW CIPHER RESULT:", dst, written);
	}
#endif

	VERIFY_ARRAY_VALUE(dst, correct16, 16U);
fail:
	return ret;
}

/* T19X / T18X key unwrap to keyslot
 *
 * Note: The called functions do not need additional memory
 * so the cmem reference is NULL also in the case when mempool operations
 * from the subsystem are disabled.
 *
 * Otherwise would need to prepare memory  (e.g. static buffer or such)
 * when memory pools are not available and colwert it to CMEM.
 */
#include <crypto_cipher_proc.h>

/* When called with AES-CTR caller has set up the counter value and
 * iv_or_null is NULL.
 */
static status_t t19x_unwrap_key(struct se_engine_aes_context *econtext,
				struct context_mem_s *cmem,
				engine_id_t eid,
				te_crypto_algo_t algo,
				const uint8_t *wrapped_key, uint32_t wklen,
				uint32_t target_index,
				const uint8_t *uwkey,
				uint32_t uwkey_bytes,
				bool write_unwrap_key_to_keyslot,
				const uint8_t *iv_or_null)
{
	status_t ret = NO_ERROR;
	struct se_data_params input;

	// Only AES engines allowed here
	if ((CCC_ENGINE_SE0_AES0 != eid) && (CCC_ENGINE_SE0_AES1 != eid)) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	/* Init an AES engine object for unwrapping key */
	ret = aes_engine_context_static_init_cm(TE_CRYPTO_DOMAIN_KERNEL,
						eid,
						algo,
						econtext,
						cmem);
	CCC_ERROR_CHECK(ret);

	if (NULL != iv_or_null) {
		/* IV from caller */
		se_util_mem_move((uint8_t *)&econtext->iv_stash[0], iv_or_null, SE_AES_BLOCK_LENGTH);
	}

	if (BOOL_IS_TRUE(write_unwrap_key_to_keyslot)) {
		/* Let CCC write the unwrap key to the keyslot set below.
		 */
		econtext->se_ks.ks_keydata = uwkey;
	} else {
		/* Set the uwkey to keyslot AES_KEYSLOT and use it from there
		 * in the unwrap operation.
		 */
		ret = se_set_device_aes_keyslot(SE_CDEV_SE0, AES_KEYSLOT,
						uwkey, (uwkey_bytes * 8U));
		CCC_ERROR_CHECK(ret,
				LOG_ERROR("Failed to set unwrap aes key to keyslot %u\n", AES_KEYSLOT));

		/* Key to unwrap with, set also AES_FLAGS_LEAVE_KEY_TO_KEYSLOT
		 * in case the unwrap (decipher) key must be left in AES_KEYSLOT.
		 *
		 * In this case unwrap key gets erased after use.
		 */
		econtext->aes_flags |= AES_FLAGS_USE_PRESET_KEY;
	}

	econtext->se_ks.ks_bitsize = (uwkey_bytes * 8U);
	econtext->se_ks.ks_slot    = AES_KEYSLOT;

	econtext->is_last = true;

	/* Key index to unwrap to */
	econtext->se_ks.ks_target_keyslot = target_index;

	/* DST is null no size operations writes to keyslot
	 * not to memory.
	 */
	input.src = wrapped_key;
	input.input_size = wklen;
	input.dst = NULL;
	input.output_size = 0U;

	HW_MUTEX_TAKE_ENGINE(econtext->engine);
	ret = engine_aes_unwrap_locked(&input, econtext);
	HW_MUTEX_RELEASE_ENGINE(econtext->engine);

	CCC_ERROR_CHECK(ret);
fail:
	return ret;
}

const uint8_t zero_iv[ SE_AES_BLOCK_LENGTH ] = { 0 };

/* Verify: correct result for ECB zero block cipher with the unwrapped key */
const uint8_t uw_ok_nonzero_128[] = {
	0xC6, 0xA1, 0x3B, 0x37, 0x87, 0x8F, 0x5B, 0x82,
	0x6F, 0x4F, 0x81, 0x62, 0xA1, 0xC8, 0xD8, 0x79,
};

__STATIC__ status_t tegra_engine_t19x_unwrap_iv(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						bool unwrap_key_to_keyslot, const uint8_t *iv,
						const uint8_t *wrapped_key, uint32_t wrapped_key_len,
						const uint8_t *aes_key, uint32_t aes_key_len,
						const uint8_t *verify_block)
{
	status_t ret = NO_ERROR;
	struct se_engine_aes_context econtext = { .engine = NULL, };
	uint32_t wrapped_index = 3U;
	struct context_mem_s *cmem = NULL;

	LOG_ALWAYS("Test for zero key in keyslot\n");

	// Clear the unwrap target keyslot
	ret = se_clear_device_aes_keyslot(SE_CDEV_SE0, wrapped_index);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to clear aes keyslot %u\n", wrapped_index));

	// Verify that there is a 16 byte zero key in the key slot
	ret = keyop_kwuw_key_verification(c, wrapped_index, 16U, uw_ok_zero);
	TRAP_IF_ERROR(ret, "Zero key init test failed");

	LOG_ALWAYS("T19X unwrap key to keyslot %u\n", wrapped_index);

	ret = t19x_unwrap_key(&econtext, cmem, eid,
			      algo, wrapped_key, wrapped_key_len,
			      wrapped_index, aes_key, aes_key_len, unwrap_key_to_keyslot,
			      iv);
	CCC_ERROR_CHECK(ret);

	LOG_ALWAYS("T19X verifying unwrapped key value\n");

	/* Crypto context used for verification;the engine calls do not use it
	 * here.
	 *
	 * Unwrapped wrapped_key_len byte AES key to wrapped_index.
	 */
	{
		ret = keyop_kwuw_key_verification(c, wrapped_index, wrapped_key_len, verify_block);
		CCC_ERROR_CHECK(ret, LOG_ERROR("T19X unwrap key verify failed: %d\n", ret));
	}

fail:
	return ret;
}

__STATIC__ status_t tegra_engine_t19x_unwrap_ctr(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						 bool is_write_key, uint8_t *aes_ctr,
						 const uint8_t *wrapped_key, uint32_t wrapped_key_len,
						 const uint8_t *aes_key, uint32_t aes_key_len,
						 const uint8_t *verify_block)
{
	status_t ret = NO_ERROR;
	struct se_engine_aes_context econtext = { .engine = NULL, };
	struct context_mem_s *cmem = NULL;
	uint32_t wrapped_index = 3U;

	if (algo != TE_ALG_AES_CTR) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	LOG_ALWAYS("Test for zero key in keyslot\n");

	// Clear the unwrap target keyslot
	ret = se_clear_device_aes_keyslot(SE_CDEV_SE0, wrapped_index);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to clear aes keyslot %u\n", wrapped_index));

	// Verify that there is a zero key in the key slot
	ret = keyop_kwuw_key_verification(c, wrapped_index, 16U, uw_ok_zero);
	TRAP_IF_ERROR(ret, "Zero key init test failed");

	LOG_ALWAYS("T19X AES_CTR unwrap key to keyslot %u\n", wrapped_index);

	se_util_mem_move((uint8_t *)econtext.ctr.counter, aes_ctr, 16U);
	econtext.aes_flags |= AES_FLAGS_CTR_MODE_BIG_ENDIAN;

	/* This MUST be set by engine layer callers for AES-CTR !
	 *
	 * Default increment is zero, it is colwerted by upper layers to 1
	 * but if directly calling the engine layer => caller must set it.
	 */
	econtext.ctr.increment = 1U;

	ret = t19x_unwrap_key(&econtext, cmem, eid,
			      algo, wrapped_key, wrapped_key_len,
			      wrapped_index, aes_key, aes_key_len,
			      is_write_key, NULL);
	CCC_ERROR_CHECK(ret);

	LOG_ALWAYS("T19X verifying AES-CTR unwrapped key value\n");

	/* Crypto context used for verification;the engine calls do not use it
	 */
	{
		ret = keyop_kwuw_key_verification(c, wrapped_index, wrapped_key_len, verify_block);
		CCC_ERROR_CHECK(ret, LOG_ERROR("T19X unwrap key verify failed: %d\n", ret));
	}

fail:
	return ret;
}

__STATIC__ status_t tegra_engine_t19x_unwrap256(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
						const uint8_t *iv,
						const uint8_t *wrapped_key, uint32_t wrapped_key_len,
						const uint8_t *aes_key, uint32_t aes_key_len,
						const uint8_t *verify_block)
{
	status_t ret = NO_ERROR;
	struct se_engine_aes_context econtext = { .engine = NULL, };
	uint32_t wrapped_index = 3U;
	struct context_mem_s *cmem = NULL;

	LOG_ALWAYS("Test for zero key in keyslot\n");

	// Clear the unwrap target keyslot
	ret = se_clear_device_aes_keyslot(SE_CDEV_SE0, wrapped_index);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to clear aes keyslot %u\n", wrapped_index));

	// Verify that there is a 16 byte zero key in the key slot
	ret = keyop_kwuw_key_verification(c, wrapped_index, 16U, uw_ok_zero);
	TRAP_IF_ERROR(ret, "Zero key init test failed");

	LOG_ALWAYS("T19X unwrap key to keyslot %u\n", wrapped_index);

	ret = t19x_unwrap_key(&econtext, cmem, eid,
			      algo, wrapped_key, wrapped_key_len,
			      wrapped_index, aes_key, aes_key_len, false,
			      iv);
	CCC_ERROR_CHECK(ret);

	LOG_ALWAYS("T19X verifying unwrapped key value\n");

	/* Crypto context used for verification;the engine calls do not use it
	 * here.
	 *
	 * Unwrapped wrapped_key_len byte AES key to wrapped_index.
	 */
	{
		ret = keyop_kwuw_key_verification(c, wrapped_index, wrapped_key_len, verify_block);
		CCC_ERROR_CHECK(ret, LOG_ERROR("T19X unwrap key verify failed: %d\n", ret));
	}

fail:
	return ret;
}

__STATIC__ status_t tegra_engine_t19x_unwrap_unalign(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	struct se_engine_aes_context econtext = { .engine = NULL, };

	(void)c;

	/* This test is only generated for function call coverage.
	 * It is expected to return ERR_ILWALID_ARGS error code.
	 */
	uint8_t src[] = {
		0xfb, 0xd4, 0x9b, 0x09, 0x1a, 0x38, 0xf8, 0x7a, 0xd5, 0xc3, 0xee, 0x25, 0x80, 0xba, 0x41, 0x4c,
		0x10, 0x1c, 0x02, 0xcb, 0x4e, 0x2d, 0x91, 0x6c, 0xad, 0x4a, 0x3d, 0xce, 0x8b, 0x9a, 0xa6, 0x37,
		0xde, 0xad, 0xbe,
	};
	uint32_t wrapped_index = 3U;

	/* It is wrapped with this key and zero IV
	 */
	uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
	struct context_mem_s *cmem = NULL;

	LOG_ALWAYS("Test for zero key in keyslot\n");

	// Clear the unwrap target keyslot
	ret = se_clear_device_aes_keyslot(SE_CDEV_SE0, wrapped_index);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("Failed to clear aes keyslot %u\n", wrapped_index));

	LOG_ALWAYS("T19X unwrap key to keyslot %u\n", wrapped_index);

	ret = t19x_unwrap_key(&econtext, cmem, eid,
			      algo, src, sizeof_u32(src),
			      wrapped_index, aes_key, sizeof_u32(aes_key), true,
			      zero_iv);
	CCC_ERROR_CHECK(ret);
fail:
	return ret;
}

__STATIC__ status_t TEST_unwrap_and_cmac_64_bytes(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };
	uint32_t wrapped_index = 3U;

	static DMA_ALIGN_DATA unsigned char data[16] = "abcdefghijklmnop";
	static DMA_ALIGN_DATA uint8_t dst[16];

	// This is the value of the CMAC key unwrapped to keyslot 3U
	//
	// .k_aes_key = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff },
	static te_args_key_data_t akey = {
		.k_key_type = KEY_TYPE_AES,
		.k_flags = KEY_FLAG_USE_KEYSLOT_KEY | KEY_FLAG_LEAVE_KEY_IN_KEYSLOT,
		.k_keyslot = 3U, // wrapped_index!!!
		.k_byte_size = 16U,
	};

#if 1
	uint8_t correct_cmac_aes128[] = { 0x1a, 0xf7, 0x0d, 0x39, 0x28, 0xeb, 0x1d, 0x92,
					  0x0d, 0xeb, 0x9a, 0x47, 0xc2, 0x7a, 0x38, 0x55,
	};
#else
	uint8_t correct_cmac_aes128[] = {
		0xce, 0xe6, 0x2a, 0x49, 0x55, 0x05, 0x07, 0x05,
		0x05, 0x91, 0x27, 0x3b, 0x2a, 0x5a, 0x12, 0x84,
	};
#endif

	// Key to unwrap with
	uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	// Wrapped with the above aes key with zero IV and AES-CBC-NOPAD
	uint8_t wrapped_key[] = {
		0x39, 0xbb, 0xd9, 0xed, 0xf8, 0x29, 0x06, 0x3d,
		0x5e, 0x7e, 0x70, 0x2e, 0xbe, 0xa4, 0x0a, 0x38,
	};

	struct se_engine_aes_context econtext = { .engine = NULL, };
	struct context_mem_s *cmem = NULL;

	if (algo != TE_ALG_CMAC_AES) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS);
	}

	LOG_ALWAYS("Test for zero key in keyslot\n");

	// Clear the unwrap target keyslot
	ret = se_clear_device_aes_keyslot(SE_CDEV_SE0, wrapped_index);
	CCC_ERROR_CHECK(ret,
			    LOG_ERROR("Failed to clear aes keyslot %u\n", wrapped_index));

	// Verify that there is a zero key in the key slot
	ret = keyop_kwuw_key_verification(c, wrapped_index, 16U, uw_ok_zero);
	TRAP_IF_ERROR(ret, "Zero key init test failed");

	LOG_ALWAYS("T19X unwrap key to keyslot %u\n", wrapped_index);

	ret = t19x_unwrap_key(&econtext, cmem, eid,
			      TE_ALG_AES_CBC_NOPAD, wrapped_key, sizeof_u32(wrapped_key),
			      wrapped_index, aes_key, sizeof_u32(aes_key), false,
			      zero_iv);
	CCC_ERROR_CHECK(ret);

	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));
	se_util_mem_set(dst, 0U, sizeof_u32(dst));

	LOG_ALWAYS("Use existing AES-128 key in keyslot %u and perform CMAC_AES\n", wrapped_index);

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_MAC, algo);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_MAC;
	arg.ca_algo     = TE_ALG_CMAC_AES;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.engine_hint = eid;

	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = sizeof_u32(data);
	arg.ca_data.src = data;
	arg.ca_data.dst_size = sizeof_u32(dst);
	arg.ca_data.dst = dst;

	ret = CRYPTO_OPERATION(c, &arg);
	CCC_ERROR_CHECK(ret);

	DUMP_HEX("CMAC-AES-128:", dst, 16U);
	TRAP_ASSERT(arg.ca_data.dst_size == 16U);
	VERIFY_ARRAY_VALUE(dst, correct_cmac_aes128, 16U);

fail:
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_SE_UNWRAP */

#if HAVE_SE_RANDOM || HAVE_RNG1_DRNG || HAVE_PKA1_TRNG
static status_t run_rng_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

#if 0
	/* 13107200 bytes => 100*1024*1024 bits
	 * 32 * 409600 = 13107200 bytes
	 */
	TEST_ERRCHK(TEST_output_random_bytes, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG,
		    409600);
	return ret;
#else
	TEST_ERRCHK(TEST_output_random_bytes, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG,
		    2048);
#endif

	/* Test the DRGN generation */
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 1);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 7);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 16);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 17);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 128);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 512);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 1024);

	TEST_ERRCHK(TEST_kernel_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG);

#if HAVE_RNG1_DRNG
	/* Test the DRGN generation in RNG1 engine*/
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 1);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 7);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 16);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 17);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 42);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 128);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 512);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_RNG1, TE_ALG_RANDOM_DRNG, 1024);

#endif

fail:
	return ret;
}
#endif /* HAVE_SE_RANDOM || HAVE_RNG1_DRNG || HAVE_PKA1_TRNG */

#if HAVE_SE_UNWRAP
static status_t t194_unwrap_128_zero_iv(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	/* Wrapped 128 bit key, plaintext value 000102030405060708090a0b0c0d0e0f
	 * (same as the key used for wrapping it)
	 *
	 * Wrapped with CBC-NOPAD, IV value was zero vector
	 */
	const uint8_t cbc_nopad_src[] = {
		0x0a, 0x94, 0x0b, 0xb5, 0x41, 0x6e, 0xf0, 0x45,
		0xf1, 0xc3, 0x94, 0x58, 0xc6, 0x53, 0xea, 0x5a,
	};

	const uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	LTRACEF("entry\n");

	LOG_ALWAYS("T194 unwrap 128, zero iv\n");

	/* Test T18X and T19X key unwrapping */
	TEST_ERRCHK(tegra_engine_t19x_unwrap_iv, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CBC_NOPAD, false,
		    zero_iv, cbc_nopad_src, sizeof_u32(cbc_nopad_src), aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
	TEST_ERRCHK(tegra_engine_t19x_unwrap_iv, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CBC_NOPAD, true,
		    zero_iv, cbc_nopad_src, sizeof_u32(cbc_nopad_src), aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_unwrap_128_nonzero_iv(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	/* Unwrapped key value 000102030405060708090a0b0c0d0e0f
	 * (same as the key used for wrapping it, so it is "self-wrapped"
	 * for minimum security...)
	 *
	 * 128 bit aes key wrapped with CBC-NOPAD using aes_key,
	 * IV value is nonzero_iv below.
	 */
	const uint8_t cbc_nopad_wrapped_key[] = {
		0xb6, 0x92, 0x8d, 0x22, 0xf3, 0x05, 0xb6, 0x0a,
		0x29, 0xa0, 0x67, 0x72, 0xb0, 0x2c, 0xe7, 0x36,
	};

	const uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	const uint8_t nonzero_iv[] = {
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
	};

	LTRACEF("entry\n");

	LOG_ALWAYS("T194 unwrap 128, non-zero iv\n");

	/* Test T18X and T19X key unwrapping */
	TEST_ERRCHK(tegra_engine_t19x_unwrap_iv, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CBC_NOPAD, false,
		    nonzero_iv, cbc_nopad_wrapped_key, sizeof_u32(cbc_nopad_wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);

	TEST_ERRCHK(tegra_engine_t19x_unwrap_iv, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CBC_NOPAD, true,
		    nonzero_iv, cbc_nopad_wrapped_key, sizeof_u32(cbc_nopad_wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);

fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_unwrap_256_zero_iv(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	/* Wrapped 256 bit key, plaintext key value in hex:
	 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	 * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc
	 *
	 * Wrapped with CBC-NOPAD, IV value was zero vector for these values.
	 */
	const uint8_t wk[] = {
		0xfb, 0xd4, 0x9b, 0x09, 0x1a, 0x38, 0xf8, 0x7a, 0xd5, 0xc3, 0xee, 0x25, 0x80, 0xba, 0x41, 0x4c,
		0x10, 0x1c, 0x02, 0xcb, 0x4e, 0x2d, 0x91, 0x6c, 0xad, 0x4a, 0x3d, 0xce, 0x8b, 0x9a, 0xa6, 0x37,
	};

	/* It is wrapped with this key and zero IV
	 */
	const uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	/* verify: zero block AES-ECB ciphered by the 256 bit unwrapped key */
	const uint8_t uw256_ok[] = {
		0x89, 0xce, 0xeb, 0xb2, 0x57, 0xbb, 0x9c, 0xb1,
		0x7b, 0x0e, 0x25, 0xfd, 0x28, 0xaa, 0x44, 0x23
	};

	LTRACEF("entry\n");

	LOG_ALWAYS("T194 unwrap 256, zero iv\n");

	TEST_ERRCHK(tegra_engine_t19x_unwrap256, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CBC_NOPAD,
		    zero_iv, wk, sizeof_u32(wk), aes_key, sizeof_u32(aes_key), uw256_ok);
	TEST_ERRCHK(tegra_engine_t19x_unwrap256, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CBC_NOPAD,
		    zero_iv, wk, sizeof_u32(wk), aes_key, sizeof_u32(aes_key), uw256_ok);
fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_unwrap_256_nonzero_iv(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	/* Wrapped 256 bit key, plaintext key value in hex:
	 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	 * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc
	 *
	 * Wrapped 256 bit key (CBC-NOPAD), IV value was zero vector for these values.
	 * Wrapped with aes_key.
	 *
	 * Again, this is a self-wrap.
	 */
	const uint8_t wk[] = {
		0x72, 0x9b, 0x64, 0x9e, 0x2b, 0x55, 0x92, 0xb4,
		0xfb, 0x5c, 0x81, 0x36, 0x3e, 0x09, 0x98, 0x5d,
		0xdb, 0xe8, 0xee, 0x6d, 0xdf, 0xa0, 0x51, 0x94,
		0xe5, 0x3f, 0xed, 0xd4, 0x54, 0xd6, 0xb0, 0xf3,
	};

	/* It is wrapped with this key and IV below.
	 */
	const uint8_t aes_key[] = {
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbc,
	};

	const uint8_t nonzero_iv[] = {
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
	};

	/* verify: zero block AES-ECB ciphered by the 256 bit unwrapped key */
	const uint8_t uw256_ok[] = {
		0x89, 0xce, 0xeb, 0xb2, 0x57, 0xbb, 0x9c, 0xb1,
		0x7b, 0x0e, 0x25, 0xfd, 0x28, 0xaa, 0x44, 0x23
	};

	LTRACEF("entry\n");

	LOG_ALWAYS("T194 unwrap 256, nonzero iv\n");

	TEST_ERRCHK(tegra_engine_t19x_unwrap256, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CBC_NOPAD,
		    nonzero_iv, wk, sizeof_u32(wk), aes_key, sizeof_u32(aes_key), uw256_ok);
	TEST_ERRCHK(tegra_engine_t19x_unwrap256, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CBC_NOPAD,
		    nonzero_iv, wk, sizeof_u32(wk), aes_key, sizeof_u32(aes_key), uw256_ok);
fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_ctr_unwrap_128_zero_counter(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	uint8_t aes_counter[16] = { 0U };

	/* Wrapped 128 bit key, plaintext value 000102030405060708090a0b0c0d0e0f
	 * (same as the key used for wrapping it)
	 *
	 * Wrapped with AES-CTR, counter it zero.
	 *
	 * AES mode here is AES-CTR.
	 */
	const uint8_t wrapped_key[] = {
		0xc6, 0xa0, 0x39, 0x34, 0x83, 0x8a, 0x5d, 0x85,
		0x67, 0x46, 0x8b, 0x69, 0xad, 0xc5, 0xd6, 0x76,
	};

	const uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	LOG_ALWAYS("AES-CTR unwrap 128 bit, start counter zero\n");

#if CCC_SOC_FAMILY_IS(CCC_SOC_FAMILY_T18X)
	/* T18X HW does not allow AES-CTR to keyslot */
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES0,
			TE_ALG_AES_CTR, true, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw_ok_nonzero_128);
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES1,
			TE_ALG_AES_CTR, false, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw_ok_nonzero_128);
#else
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CTR, true,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CTR, false,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
#endif

fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_ctr_unwrap_128_nonzero_counter(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	uint8_t aes_counter[16] = { 0U };
	aes_counter[15] = 0xFFU;

	/* Wrapped 128 bit key, plaintext value 000102030405060708090a0b0c0d0e0f
	 * (same as the key used for wrapping it)
	 *
	 * Wrapped with AES-CTR, counter is 000000000000000000000000000000FF
	 *
	 * AES mode here is AES-CTR.
	 */
	const uint8_t wrapped_key[] = {
		0x39, 0xba, 0xdb, 0xee, 0xfc, 0x2c, 0x00, 0x3a,
		0x56, 0x77, 0x7a, 0x25, 0xb2, 0xa9, 0x04, 0x37,
	};

	const uint8_t aes_key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

	LOG_ALWAYS("AES-CTR unwrap 128 bit, start counter nonzero\n");

#if CCC_SOC_FAMILY_IS(CCC_SOC_FAMILY_T18X)
	/* T18X HW does not allow AES-CTR to keyslot */
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES0,
			TE_ALG_AES_CTR, true, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw_ok_nonzero_128);
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES1,
			TE_ALG_AES_CTR, false, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw_ok_nonzero_128);
#else
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CTR, true,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CTR, false,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw_ok_nonzero_128);
#endif
fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_ctr_unwrap_256_zero_counter(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	uint8_t aes_counter[16] = { 0U };

	/* Wrapped 128 bit key, plaintext value
 	 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	 * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc
	 * (same as the key used for wrapping it)
	 *
	 * Wrapped with AES-CTR, counter it zero.
	 *
	 * AES mode here is AES-CTR.
	 */
	const uint8_t wrapped_key[] = {
		0x23, 0x64, 0x41, 0x18, 0xfd, 0x11, 0x36, 0x1b,
		0xd1, 0xa4, 0x8f, 0x57, 0x82, 0x00, 0xee, 0x89,
		0x39, 0x25, 0xf1, 0xb0, 0x4e, 0x97, 0xaa, 0x84,
		0x8b, 0x3c, 0x2b, 0x0b, 0xe1, 0x28, 0x33, 0xe6,
	};

	const uint8_t aes_key[] = {
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbc,
	};

	const uint8_t uw256_ok[] = {
		0x89, 0xce, 0xeb, 0xb2, 0x57, 0xbb, 0x9c, 0xb1,
		0x7b, 0x0e, 0x25, 0xfd, 0x28, 0xaa, 0x44, 0x23
	};

	LOG_ALWAYS("AES-CTR unwrap 256 bit, start counter zero\n");

#if CCC_SOC_FAMILY_IS(CCC_SOC_FAMILY_T18X)
	/* T18X HW does not allow AES-CTR to keyslot */
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES0,
			TE_ALG_AES_CTR, true, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw256_ok);
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES1,
			TE_ALG_AES_CTR, false, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw256_ok);
#else
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CTR, true,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw256_ok);
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CTR, false,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw256_ok);
#endif

fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t t194_ctr_unwrap_256_nonzero_counter(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	uint8_t aes_counter[16] = { 0U };
	aes_counter[15] = 0xFFU;

	/* Wrapped 128 bit key, plaintext value
 	 * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	 * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc
	 * (same as the key used for wrapping it)
	 *
	 * Wrapped with AES-CTR, counter it zero.
	 *
	 * AES mode here is AES-CTR.
	 */
	const uint8_t wrapped_key[] = {
		0x25, 0x76, 0x11, 0x32, 0xaf, 0xab, 0xdf, 0x8e,
		0x62, 0xea, 0xcd, 0xcb, 0x38, 0xbf, 0x4a, 0xa0,
		0x18, 0x1a, 0x1f, 0x3a, 0x90, 0x4a, 0xf0, 0x33,
		0x69, 0x7c, 0xe1, 0x77, 0xf3, 0xce, 0x59, 0x4e,
	};

	const uint8_t aes_key[] = {
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbc,
	};

	/* verify: zero block AES-ECB ciphered by the 256 bit unwrapped key */
	const uint8_t uw256_ok[] = {
		0x89, 0xce, 0xeb, 0xb2, 0x57, 0xbb, 0x9c, 0xb1,
		0x7b, 0x0e, 0x25, 0xfd, 0x28, 0xaa, 0x44, 0x23
	};

	LOG_ALWAYS("AES-CTR unwrap 256 bit, start counter nonzero\n");

#if CCC_SOC_FAMILY_IS(CCC_SOC_FAMILY_T18X)
	/* T18X HW does not allow AES-CTR to keyslot */
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES0,
			TE_ALG_AES_CTR, true, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw256_ok);
	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_ctr, ERR_NOT_ALLOWED, CCC_ENGINE_SE0_AES1,
			TE_ALG_AES_CTR, false, aes_counter,
			wrapped_key, sizeof_u32(wrapped_key),
			aes_key, sizeof_u32(aes_key),
			uw256_ok);
#else
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES0, TE_ALG_AES_CTR, true,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw256_ok);
	TEST_ERRCHK(tegra_engine_t19x_unwrap_ctr, CCC_ENGINE_SE0_AES1, TE_ALG_AES_CTR, false,
		    aes_counter,
		    wrapped_key, sizeof_u32(wrapped_key),
		    aes_key, sizeof_u32(aes_key),
		    uw256_ok);
#endif

fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}

static status_t run_unwrap_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	ret = t194_unwrap_128_zero_iv(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_unwrap_128_nonzero_iv(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_unwrap_256_zero_iv(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_unwrap_256_nonzero_iv(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_ctr_unwrap_128_zero_counter(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_ctr_unwrap_128_nonzero_counter(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_ctr_unwrap_256_zero_counter(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	ret = t194_ctr_unwrap_256_nonzero_counter(crypto_ctx);
	CCC_ERROR_CHECK(ret);

	TEST_ERRCHK(TEST_unwrap_and_cmac_64_bytes, CCC_ENGINE_SE0_AES0, TE_ALG_CMAC_AES);
	TEST_ERRCHK(TEST_unwrap_and_cmac_64_bytes, CCC_ENGINE_SE0_AES1, TE_ALG_CMAC_AES);

	TEST_EXPECT_RET(tegra_engine_t19x_unwrap_unalign, ERR_ILWALID_ARGS,
			CCC_ENGINE_SE0_AES0, TE_ALG_AES_CBC_NOPAD);

fail:
	return ret;
}
#endif /* HAVE_SE_UNWRAP */

#if HAVE_RSA_MONTGOMERY_CALC
static status_t run_montgomery_calc_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

	/* Test the optional RSA modulus montgomery value calculator
	 * and test importing the values to PKA1 keyslot.
	 */
	TEST_ERRCHK_FUN(TEST_gen_rsa_mont, "RSA modulus montgomery generator");
fail:
	return ret;
}
#endif /* HAVE_RSA_MONTGOMERY_CALC */

#if HAVE_ENGINE_API_TESTS
static status_t run_engine_api_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

	TEST_SUITE("Direct engine API tests", run_engine_api_tests());
fail:
	return ret;
}
#endif /* HAVE_ENGINE_API_TESTS */

#ifdef TEST_DIGEST
static status_t run_digest_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	uint8_t *dyn_buf = NULL;

/************************/

#if TEST_N_PAGE_DIGEST
	/* One page of static data digested by sha256 is always tested if enabled
	 */
	TEST_ERRCHK(TEST_4Kdigest, CCC_ENGINE_ANY, TE_ALG_SHA256);

#if TEST_N_PAGE_DIGEST > 1
	/* Additionally test arbitrary long sha256 digest contiguous pages.
	 * Result verfified if TEST_N_PAGE_DIGEST_RESULT contains a 32 result byte vector;
	 * pass NULL if result check can be ignored.
	 */
	TEST_ERRCHK(TEST_n_page_digest, CCC_ENGINE_ANY, TE_ALG_SHA256, TEST_N_PAGE_DIGEST, TEST_N_PAGE_DIGEST_RESULT);
#endif
#endif /* TEST_N_PAGE_DIGEST */

#if HAVE_SHA1
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA1);
#endif

#if HAVE_SHA224
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA224);
#endif

	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA512);
	TEST_ERRCHK(TEST_digest_with_update_long, CCC_ENGINE_ANY, TE_ALG_SHA512);

#if LONG_DIGEST_TEST
#if HAVE_SHA1
	TEST_ERRCHK(TEST_long_digest, CCC_ENGINE_ANY, TE_ALG_SHA1);
#endif
	TEST_ERRCHK(TEST_long_digest, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_long_digest, CCC_ENGINE_ANY, TE_ALG_SHA512);
#endif /* LONG_DIGEST_TEST */

/*+++++++++++++++++++++*/

#if HAVE_NIST_TRUNCATED_SHA2
	/* NIST truncated SHA-512/224 and SHA-512/256 digest test */
	TEST_ERRCHK(TEST_digest_truncated, CCC_ENGINE_ANY, TE_ALG_SHA512_224);
	TEST_ERRCHK(TEST_digest_truncated, CCC_ENGINE_ANY, TE_ALG_SHA512_256);

#if LONG_DIGEST_TEST
	TEST_ERRCHK(TEST_long_digest, CCC_ENGINE_ANY, TE_ALG_SHA512_224);
	TEST_ERRCHK(TEST_long_digest, CCC_ENGINE_ANY, TE_ALG_SHA512_256);
#endif /* LONG_DIGEST_TEST */
#endif /* HAVE_NIST_TRUNCATED_SHA2 */

/*+++++++++++++++++++++*/

#if CCC_WITH_SHA3
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_224);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_256);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_384);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_512);
#endif /* CCC_WITH_SHA3 */

/*+++++++++++++++++++++*/

#if ASYNC_TEST

#if HAVE_SHA1
	TEST_ERRCHK(TEST_digest_async, CCC_ENGINE_ANY, TE_ALG_SHA1);
#endif

#if HAVE_SHA224
	TEST_ERRCHK(TEST_digest_async, CCC_ENGINE_ANY, TE_ALG_SHA224);
#endif
	TEST_ERRCHK(TEST_digest_async, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest_async, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest_async, CCC_ENGINE_ANY, TE_ALG_SHA512);
#endif /* ASYNC_TEST */

#if UPDATE_DIGEST_TEST

#if ASYNC_TEST
	dyn_buf = CMTAG_MEM_GET_BUFFER(NULL,
	    CMTAG_ALIGNED_BUFFER, CACHE_LINE, MAX_TEST_FRAGMENT_SIZE);
#else
	dyn_buf = CMTAG_MEM_GET_BUFFER(NULL,
	    CMTAG_ALIGNED_BUFFER, CACHE_LINE, MAX_TEST_FRAGMENT_SIZE);
#endif
	if (NULL == dyn_buf) {
		CCC_ERROR_WITH_ECODE(ERR_NO_MEMORY,
				     CCC_ERROR_MESSAGE("Failed to allocate %u byte mem buffer\n",
						       MAX_TEST_FRAGMENT_SIZE));
	}

	if (MAX_TEST_FRAGMENT_SIZE >= 4096) {
		/* With 4096 * N times filled with 0x00 */
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 2, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 100, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1000, 0x00, dyn_buf);

		/* With 4096 * N times filled with 'a' (0x61) */
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 2, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 100, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1000, 0x61, dyn_buf);
	}

	if (MAX_TEST_FRAGMENT_SIZE >= 262144) {
		/* With 256 KB * N times filled with 'a' */
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 1, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 2, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 100, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 1000, 0x61, dyn_buf);
	}

#if ASYNC_TEST
	if (MAX_TEST_FRAGMENT_SIZE >= 4096) {
		/* With 4096 * N times filled with 0x00 */
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 2, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 100, 0x00, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1000, 0x00, dyn_buf);

		/* With 4096 * N times filled with 'a' (0x61) */
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 2, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 100, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 4096, 1000, 0x61, dyn_buf);
	}

	if (MAX_TEST_FRAGMENT_SIZE >= 262144) {
		/* XXXX NOTE: ASYNC test requires CONTIGUOUS BUFFER!
		 * These tests will fail unless buffer is contiguous.
		 *
		 * Tests blocked above where ASYNC_TEST is defined.
		 */
		/* With 256 KB * N times filled with 'a' */
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 1, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 2, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 100, 0x61, dyn_buf);
		TEST_ERRCHK(TEST_async_digest_updates, CCC_ENGINE_ANY, TE_ALG_SHA256, 262144, 1000, 0x61, dyn_buf);
	}
#endif /* ASYNC_TEST */
#endif /* UPDATE_DIGEST_TEST */

	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_SHA512);

#ifndef HAVE_VDK_ERROR_SKIP
#if HAVE_SHA1
	TEST_ERRCHK(TEST_digest_192_bytes, CCC_ENGINE_ANY, TE_ALG_SHA1);
#endif
#endif	/* HAVE_VDK_ERROR_SKIP */

	TEST_ERRCHK(TEST_digest_192_bytes, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest_192_bytes, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest_192_bytes, CCC_ENGINE_ANY, TE_ALG_SHA512);

	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA512);

#if HAVE_SHA1
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_SHA1);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA1);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA1);
	TEST_ERRCHK(TEST_digest_with_update_byte, CCC_ENGINE_ANY, TE_ALG_SHA1);
#endif

#if HAVE_SHA224
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_SHA224);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA224);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA224);
	TEST_ERRCHK(TEST_digest_192_bytes, CCC_ENGINE_ANY, TE_ALG_SHA224);
#endif

	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA512);

	TEST_ERRCHK(TEST_digest_with_update_byte, CCC_ENGINE_ANY, TE_ALG_SHA256);

#ifdef TEST_SEC_SAFE_REQ_VERIFY
	/* CCC security requirement to verify HW reg. cleared after crypto operations  */
	TEST_ERRCHK(TEST_sha_clr_hw_regs_verify, CCC_ENGINE_ANY, TE_ALG_SHA512);
#endif
fail:
	if (NULL != dyn_buf) {
#if ASYNC_TEST
	CMTAG_MEM_RELEASE(NULL, CMTAG_ALIGNED_BUFFER, dyn_buf);
#else
	CMTAG_MEM_RELEASE(NULL, CMTAG_ALIGNED_BUFFER, dyn_buf);
#endif
	}

	return ret;
}
#endif /* TEST_DIGEST */

#if HAVE_RSA_PKCS_SIGN || HAVE_RSA_PSS_SIGN
static status_t run_rsa_sign_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

	/* RSA signing tests (PKCS#1v1_5 and PSS signatures are supported) */
#if HAVE_SE_RSA
	TEST_SUITE("rsa signing SE PKA0", run_rsa_sign_tests(crypto_ctx, CCC_ENGINE_SE0_PKA0));
#endif
	TEST_SUITE("rsa signing PKA1", run_rsa_sign_tests(crypto_ctx, CCC_ENGINE_PKA1_PKA));

#ifdef TEST_RSASP1
	/* Test RSA SP1 part of RSA-PSS signing with NIST test cases
	 * csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/
	 *   dolwments/components/RSA2SP1VS.pdf
	 */
	TEST_SUITE("NIST RSA SP1 tests (SE0 PK0)", run_rsasp1_tests(crypto_ctx, CCC_ENGINE_SE0_PKA0));
	TEST_SUITE("NIST RSA SP1 tests (PKA1)", run_rsasp1_tests(crypto_ctx, CCC_ENGINE_PKA1_PKA));
#endif

fail:
	return ret;
}
#endif /* HAVE_RSA_PKCS_SIGN || HAVE_RSA_PSS_SIGN */

/* Small subset of the wyche tests run by ctester
 */
#if HAVE_WYCHE_ECDH || HAVE_WYCHE_ECDSA
static status_t run_wyche_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if HAVE_WYCHE_ECDH && CCC_WITH_ECDH
	TEST_SUITE("wyche-ecdh-tests (PKA1)", run_wyche_ecdh_tests(crypto_ctx, CCC_ENGINE_PKA1_PKA));
#endif

#if HAVE_WYCHE_ECDSA
	TEST_SUITE("wyche-ecdsa-tests (PKA1)", run_wyche_ecdsa_tests(crypto_ctx, CCC_ENGINE_PKA1_PKA));
#if MODULE_TRACE
	/* XXX R&D for Wyche tests is WIP */
	CCC_ERROR_MESSAGE("Returning after WYCHE tests\n");
	return ret;
#endif
#endif

fail:
	return ret;
}
#endif /*  HAVE_WYCHE_ECDH || HAVE_WYCHE_ECDSA */

#if HAVE_SE_RSA || CCC_WITH_RSA

#if HAVE_READ_PKA1_RSA_KEYSLOT_PUBKEY

static struct ks_rsa_data rsa_pubkey_store;

static status_t test_read_rsa_keyslot(engine_id_t eid, uint32_t keyslot, uint32_t rsa_bitlen)
{
	status_t ret = NO_ERROR;

	LOG_ALWAYS("Reading RSA-%u keyslot %u\n", rsa_bitlen, keyslot);

	se_util_mem_set((uint8_t *)&rsa_pubkey_store, 0xFFU, sizeof_u32(rsa_pubkey_store));

	ret = pka1_read_rsa_keyslot(eid, keyslot, rsa_bitlen, true, &rsa_pubkey_store);
	CCC_ERROR_CHECK(ret);

	VERIFY_ARRAY_VALUE(rsa_pubkey_store.rsa_pub_exponent, R3072_pub_exponent, sizeof_u32(R3072_pub_exponent));
	VERIFY_ARRAY_VALUE(rsa_pubkey_store.rsa_modulus, R3072_modulus, sizeof_u32(R3072_modulus));
	VERIFY_ARRAY_VALUE(rsa_pubkey_store.rsa_r2_sqr, R3072_mont_r_sqr, sizeof_u32(R3072_mont_r_sqr));
	VERIFY_ARRAY_VALUE(rsa_pubkey_store.rsa_m_prime, R3072_mont_m_prime, sizeof_u32(R3072_mont_m_prime));

	LOG_ALWAYS("Reading RSA-%u keyslot %u => verified\n", rsa_bitlen, keyslot);
fail:
	LTRACEF("exit: %d\n", ret);
	return ret;
}
#endif /* HAVE_READ_PKA1_RSA_KEYSLOT_PUBKEY */

static status_t run_rsa_verify_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

	TEST_ERRCHK(TEST_le_rsa3072_pss_verify_sha256, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

#ifdef TEST_PKA1_RSA_KSLOT
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen_oob_mont, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

#if HAVE_READ_PKA1_RSA_KEYSLOT_PUBKEY
	ret = test_read_rsa_keyslot(CCC_ENGINE_PKA1_PKA, 3U, 3072U);
	CCC_ERROR_CHECK(ret);
#endif

	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);
#if HAVE_SHA1
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

#if HAVE_SHA1
#if HAVE_SE_RSA
	/* Test automatic swap of engine if selected one does not support e.g. long keys */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_SE0_PKA0, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif

	/* PKA1 4096 bit RSA
	 *
	 * 1) Bank registers.
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	/*
	 * 2) keyslot 3 (write key to keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/*
	 * 3) keyslot 3 (use existing key in keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_key3, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Test 2048 bit key setup via PKA1 HW keyslot 2 (same function used far
	 * below for testing SE0 PKA0 slot)
	 */
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1_keyslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);	/* PKA1  */

	/* test PKA1 keyslot 2 with 4096 bit key */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_set_key2, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Set keyslot 3; do an op with it. Then clear keyslot 3 and try again to do an operation
	 * with it; this time we MUST FAIL with error code -50
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	/* Clear keyslot 3 */
	ret = se_clear_device_rsa_keyslot(SE_CDEV_PKA1, 3);
	CCC_ERROR_CHECK(ret);

#ifndef HAVE_VDK_ERROR_SKIP	/* XXX VDK crashes.... */
	/* retry op => must fail with ERR_SIGNATURE_ILWALID */
	LOG_ALWAYS("Cleared (ret=%d) PKA1 keyslot %u after setting it; now attempt using it\n", ret, 3);
	TEST_EXPECT_RET(TEST_rsa4096_pss_verify_sha1_saltlen_key3, ERR_SIGNATURE_ILWALID,
			CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif
#endif	/* HAVE_SHA1 */
#endif /* TEST_PKA1_RSA_KSLOT */

#ifdef TEST_RSA

#ifdef TEST_RSA4096
#if HAVE_SHA1
	/* 4096 bit RSA pss signature validation tests */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

#if HAVE_SE_RSA
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_SE0_PKA0, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif

	/* PKA1 4096 bit RSA
	 *
	 * 1) Bank registers.
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif /* HAVE_SHA1 */

#ifdef TEST_PKA1_RSA_KSLOT
#if HAVE_SHA1
	/*
	 * 2) keyslot 3 (write key to keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	/*
	 * 3) keyslot 3 (use existing key in keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_key3, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif
#endif /* TEST_PKA1_RSA_KSLOT */

	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);
#endif /* TEST_RSA4096 */

#if HAVE_SHA1
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1, CCC_ENGINE_SE0_PKA0, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);	/* SE0 RSA0 */
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);	/* PKA1 */

	/* XX algo value is fixed!!! param ignored */
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

#if HAVE_SE_RSA
	/* Test key setup via SE0 HW keyslot 2 */
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1_keyslot, CCC_ENGINE_SE0_PKA0, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);	/* SE0 RSA0 */
#endif /* HAVE_SE_RSA */
#endif /* HAVE_SHA1 */
#endif /* TEST_RSA */

fail:
	return ret;
}
#endif /* HAVE_SE_RSA || CCC_WITH_RSA */

#if defined(TEST_RSA_CIPHER) && HAVE_RSA_CIPHER
static status_t run_rsa_cipher_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

#if HAVE_SE_RSA
	TEST_SUITE("rsa cipher tests (SE0 PK0)", run_rsa_cipher_tests(crypto_ctx, CCC_ENGINE_SE0_PKA0));
#endif
	TEST_SUITE("rsa cipher tests (PKA1 PKA)", run_rsa_cipher_tests(crypto_ctx, CCC_ENGINE_PKA1_PKA));
fail:
	return ret;
}
#endif

#ifdef TEST_MD5
static status_t run_md5_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_MD5);
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_MD5);

#if HAVE_HMAC_MD5
	TEST_ERRCHK(TEST_hmac, CCC_ENGINE_ANY, TE_ALG_HMAC_MD5);
	TEST_ERRCHK(TEST_mac_empty, CCC_ENGINE_ANY, TE_ALG_HMAC_MD5);
#endif

fail:
	return ret;
}
#endif

#ifdef TEST_WHIRLPOOL
static status_t run_whirlpool_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	/* Whirlpool digests */
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_WHIRLPOOL);
	TEST_ERRCHK(TEST_digest_empty, CCC_ENGINE_ANY, TE_ALG_WHIRLPOOL);
fail:
	return ret;
}
#endif /* TEST_WHIRLPOOL */

#ifdef TEST_ECDH

#ifdef TEST_PKA1_ECDH_KSLOT
static status_t run_pka1_ecdh_kslot_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if CCC_WITH_ECDH
	TEST_ERRCHK(TEST_ecdh_256, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_ERRCHK(TEST_ecdh_256_kslot, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_ERRCHK(TEST_ecdh_self_256_kslot, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_ERRCHK(TEST_ecdh_256_key3, CCC_ENGINE_ANY, TE_ALG_ECDH);
#else
	TEST_EXPECT_RET(TEST_ecdh_256, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_EXPECT_RET(TEST_ecdh_256_kslot, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_EXPECT_RET(TEST_ecdh_self_256_kslot, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_EXPECT_RET(TEST_ecdh_256_key3, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
#endif

fail:
	return ret;
}
#endif /* TEST_PKA1_ECDH_KSLOT */

static status_t run_ecdh_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if CCC_WITH_ECDH

#if CCC_EC_MIN_PRIME_BITS <= 192U
	TEST_ERRCHK(TEST_ecdh_192, CCC_ENGINE_ANY, TE_ALG_ECDH);
#else
	/* Should change the error to ERR_NOT_SUPPORTED */
	TEST_EXPECT_RET(TEST_ecdh_192, ERR_ILWALID_ARGS, CCC_ENGINE_ANY, TE_ALG_ECDH);
#endif
#if CCC_EC_MIN_PRIME_BITS <= 256U
	TEST_ERRCHK(TEST_ecdh_256, CCC_ENGINE_ANY, TE_ALG_ECDH);
#else
	/* Should change the error to ERR_NOT_SUPPORTED */
	TEST_EXPECT_RET(TEST_ecdh_256, ERR_ILWALID_ARGS, CCC_ENGINE_ANY, TE_ALG_ECDH);
#endif

#if HAVE_KOBLITZ_LWRVES
	TEST_ERRCHK(TEST_ecdh_koblitz_secp256k1, CCC_ENGINE_ANY, TE_ALG_ECDH);
#endif /* HAVE_KOBLITZ_LWRVES */

#else
	TEST_EXPECT_RET(TEST_ecdh_192, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
	TEST_EXPECT_RET(TEST_ecdh_256, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDH);
#endif /* CCC_WITH_ECDH */
	CCC_ERROR_CHECK(ret);

fail:
	return ret;
}
#endif /* TEST_ECDH */

#ifdef TEST_X25519
static status_t run_X25519_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

	TEST_ERRCHK(TEST_x25519_IAS, CCC_ENGINE_ANY, TE_ALG_X25519);
	TEST_ERRCHK(TEST_x25519_rfc_test1, CCC_ENGINE_ANY, TE_ALG_X25519);
	TEST_ERRCHK(TEST_x25519_rfc_test2, CCC_ENGINE_ANY, TE_ALG_X25519);

#if X25519_ITERATION
	/* This is the RFC-7748 feedback loop test from 1..1000, results verified at
	 * steps 1 and 1000 and 1000000.
	 *
	 * Testing for 1000000 takes a LONG TIME => testing with 1000 rounds by default
	 * in Xavier.
	 */
#if 0	/* Takes a really long time on HW as well => only run 1000 rounds in normal tests */
	/* Run the full iteration (1.000.000 rounds defined in the RFC) */
	TEST_ERRCHK(TEST_x25519_rfc_iteration, CCC_ENGINE_ANY, TE_ALG_X25519, 0);
#else
	TEST_ERRCHK(TEST_x25519_rfc_iteration, CCC_ENGINE_ANY, TE_ALG_X25519, 1000);
#endif
#endif /* X25519_ITERATION */

#if X25519_OPENSSL_COMPAT_TEST
	/* Test fixed */
	TEST_ERRCHK(TEST_x25519_ossl, CCC_ENGINE_ANY, TE_ALG_X25519);
#endif

fail:
	return ret;
}
#endif /* TEST_X25519 */

#ifdef TEST_ECDSA_SIGN

status_t run_ecdsa_sign_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if HAVE_ECDSA_SIGN

#if CCC_EC_MIN_PRIME_BITS <= 192U
	TEST_ERRCHK(TEST_ecdsa_sign_nist_p192, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

	TEST_ERRCHK(TEST_ecdsa_sign_nist_p256, CCC_ENGINE_ANY, TE_ALG_ECDSA);

#if HAVE_BRAINPOOL_TWISTED_LWRVES
	// Use sig object signature format
	TEST_ERRCHK(TEST_ecdsa_sign_verify_bp512t1, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0U);
	TEST_ERRCHK(TEST_ecdsa_message_sign_verify_bp512t1, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0U);

	// Use ASN.1 signature format
	TEST_ERRCHK(TEST_ecdsa_sign_verify_bp512t1, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1U);
	TEST_ERRCHK(TEST_ecdsa_message_sign_verify_bp512t1, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1U);
#endif

#else

#if CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL
	TEST_EXPECT_RET(TEST_ecdsa_sign_nist_p192, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

	TEST_EXPECT_RET(TEST_ecdsa_sign_nist_p256, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDSA);

#if HAVE_BRAINPOOL_TWISTED_LWRVES
	TEST_EXPECT_RET(TEST_ecdsa_sign_verify_bp512t1, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1U);
	TEST_EXPECT_RET(TEST_ecdsa_message_sign_verify_bp512t1, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0U);

#endif

#endif /* HAVE_ECDSA_SIGN */

	CCC_ERROR_CHECK(ret); /* for the label... */
fail:
	return ret;
}
#endif /* TEST_ECDSA_SIGN */

#ifdef TEST_ECDSA

status_t run_ecdsa_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if HAVE_READ_PKA1_EC_KEYSLOT_PUBKEY && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_read_ks, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_read_ks, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

#if CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_pass_ks, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_pass_ks, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

	/* First pass signature in a signature object */
#if CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p192, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
#endif

#if CCC_EC_MIN_PRIME_BITS <= 256U
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_sha256, CCC_ENGINE_ANY, TE_ALG_ECDSA);

	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_ops, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_ops, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);

	TEST_EXPECT_RET(TEST_ecdsa_p256_ilwalid_signature_wyche, ERR_NOT_VALID, CCC_ENGINE_ANY, TE_ALG_ECDSA);
#endif

	/* Then pass signature in an openssl generated ASN.1 DER data blob */
#if CCC_EC_MIN_PRIME_BITS <= 192U && HAVE_NIST_LWRVE_ALL
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p192, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

#if CCC_EC_MIN_PRIME_BITS <= 256U
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif /* CCC_EC_MIN_PRIME_BITS <= 256U */

#if HAVE_P521
	/* Signature verification with NIST P-521 / SHA-256 */
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p521, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
#endif

#if HAVE_BRAINPOOL_LWRVES
	LOG_ALWAYS("Verifying BRAINPOOL LWRVE P256r1 signature\n");
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p256r1, CCC_ENGINE_ANY, TE_ALG_ECDSA);
	LOG_ALWAYS("Verifying BRAINPOOL LWRVE P512r1 signature\n");
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p512r1, CCC_ENGINE_ANY, TE_ALG_ECDSA);

#if HAVE_BRAINPOOL_TWISTED_LWRVES
	LOG_ALWAYS("Verifying BRAINPOOL LWRVE P256t1 (twisted lwrve) signature\n");
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p256t1, CCC_ENGINE_ANY, TE_ALG_ECDSA);
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p512t1, CCC_ENGINE_ANY, TE_ALG_ECDSA);
#endif /* HAVE_BRAINPOOL_TWISTED_LWRVES */
#endif /* HAVE_BRAINPOOL_LWRVES */

#if HAVE_KOBLITZ_LWRVES
	TEST_ERRCHK(TEST_ecdsa_verify_koblitz_secp256k1, CCC_ENGINE_ANY, TE_ALG_ECDSA);
#endif /* HAVE_KOBLITZ_LWRVES */

fail:
	return ret;
}
#endif /* TEST_ECDSA */

#ifdef TEST_DH
static status_t run_dh_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	(void)crypto_ctx;

#if RSA_MIN_KEYSIZE_BITS <= 512U /* short keys used in example */

	/* This callwlates DH shared secret in steps using the RSA engine
	 *  with TE_ALG_MODEXP algorithm setup...
	 *
	 * Test both RSA engines.
	 *
	 */
#if HAVE_RSA_CIPHER
	TEST_ERRCHK(TEST_dh_with_rsa_setup, CCC_ENGINE_PKA1_PKA, TE_ALG_MODEXP);
	TEST_ERRCHK(TEST_dh_with_rsa_setup, CCC_ENGINE_SE0_PKA0, TE_ALG_MODEXP);
#else
	TEST_EXPECT_RET(TEST_dh_with_rsa_setup, ERR_NOT_SUPPORTED, CCC_ENGINE_PKA1_PKA, TE_ALG_MODEXP);
	TEST_EXPECT_RET(TEST_dh_with_rsa_setup, ERR_NOT_SUPPORTED, CCC_ENGINE_SE0_PKA0, TE_ALG_MODEXP);
#endif

#if HAVE_PLAIN_DH
	/* DH operation with PKA1 && PKA0 rsa engines using "DH setup". */
	TEST_ERRCHK(TEST_dh_shared_secret, CCC_ENGINE_PKA1_PKA, TE_ALG_DH);
	TEST_ERRCHK(TEST_dh_shared_secret, CCC_ENGINE_SE0_PKA0, TE_ALG_DH);
#else
	TEST_EXPECT_RET(TEST_dh_shared_secret, ERR_NOT_SUPPORTED, CCC_ENGINE_PKA1_PKA, TE_ALG_DH);
	TEST_EXPECT_RET(TEST_dh_shared_secret, ERR_NOT_SUPPORTED, CCC_ENGINE_SE0_PKA0, TE_ALG_DH);
#endif
#endif /* RSA_MIN_KEYSIZE_BITS <= 512U */

	CCC_ERROR_CHECK(ret);
fail:
	return ret;
}
#endif /* TEST_DH */

#ifdef TEST_RECIPROCAL
static status_t run_reciprocal_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

	TEST_SUITE("LW reciprocal test (AES0)", run_reciprocal_hash_test(crypto_ctx, CCC_ENGINE_SE0_AES0));
	TEST_SUITE("LW reciprocal test (AES1)", run_reciprocal_hash_test(crypto_ctx, CCC_ENGINE_SE0_AES1));
fail:
	return ret;
}
#endif /* TEST_RECIPROCAL */

/************************************************************************/

#ifdef TEST_PSC
/* TODO: rework later with Orin code
 */
static status_t run_psc_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;
	(void)crypto_ctx;

#ifdef PSC_ECDSA_TEST
	ret = TEST_psc_ecdsa();
	CCC_ERROR_CHECK(ret);
#endif

#if CCC_SOC_FAMILY_IS(CCC_SOC_FAMILY_T23X)
	TEST_SUITE("PSC-tests", run_psc_tests(crypto_ctx, CCC_ENGINE_ANY));
#endif

#if CCC_WITH_SHA3
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_224);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_256);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_384);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA3_512);
#endif /* CCC_WITH_SHA3 */

#if TEST_PSC_LEGACY_TESTS	/* Short of memory => disable these */

#ifdef TEST_ECDSA
	/* First pass signature in a signature object */
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p192, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256, CCC_ENGINE_ANY, TE_ALG_ECDSA, 0);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256_sha256, CCC_ENGINE_ANY, TE_ALG_ECDSA);

	/* Then pass signature in an openssl generated ASN.1 DER data blob */
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p192, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);
	TEST_ERRCHK(TEST_ecdsa_verify_nist_p256, CCC_ENGINE_ANY, TE_ALG_ECDSA, 1);

#if HAVE_BRAINPOOL_LWRVES
	LOG_ALWAYS("Verifying BRAINPOOL LWRVE P256r1 signature\n");
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p256r1, CCC_ENGINE_ANY, TE_ALG_ECDSA);

	LOG_ALWAYS("Verifying BRAINPOOL LWRVE P512r1 signature\n");
	TEST_ERRCHK(TEST_ecdsa_verify_brainpool_p512r1, CCC_ENGINE_ANY, TE_ALG_ECDSA);
#endif /* HAVE_BRAINPOOL_LWRVES */

#endif /* TEST_ECDSA */

#if HAVE_CMAC_AES
	ret = run_mac_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA224);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest, CCC_ENGINE_ANY, TE_ALG_SHA512);
	TEST_ERRCHK(TEST_digest_with_update_long, CCC_ENGINE_ANY, TE_ALG_SHA512);

	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA224);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA256);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA384);
	TEST_ERRCHK(TEST_digest_with_update, CCC_ENGINE_ANY, TE_ALG_SHA512);

#if HAVE_SE_AES
	ret = run_cipher_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

	TEST_SUITE("NIST-aes-tests (SE0 AES0 engine)", run_NIST_aes_tests(crypto_ctx, CCC_ENGINE_SE0_AES0));
	TEST_SUITE("NIST-aes-tests (SE0 AES1 engine)", run_NIST_aes_tests(crypto_ctx, CCC_ENGINE_SE0_AES1));

#if HAVE_SE_RSA || CCC_WITH_RSA
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen_oob_mont, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);
#if HAVE_SHA1
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

	/* PKA1 4096 bit RSA
	 *
	 * 1) Bank registers.
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	/*
	 * 2) keyslot 3 (write key to keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/*
	 * 3) keyslot 3 (use existing key in keyslot 3)
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_key3, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	TEST_ERRCHK(TEST_rsa3072_pss_verify_sha256_saltlen, CCC_ENGINE_ANY, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256);

	/* Test 2048 bit key setup via PKA1 HW keyslot 2 (same function used far below
	 * for testing SE0 PKA0 slot)
	 */
	TEST_ERRCHK(TEST_rsa_pss_verify_sha1_keyslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);	/* PKA1  */

	/* test PKA1 keyslot 2 with 4096 bit key */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_set_key2, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);

	/* Set keyslot 3; do an op with it. Then clear keyslot 3 and try again to do an operation
	 * with it; this time we MUST FAIL with error code -50
	 */
	TEST_ERRCHK(TEST_rsa4096_pss_verify_sha1_saltlen_kslot, CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
	/* Clear keyslot 3 */
	ret = se_clear_device_rsa_keyslot(SE_CDEV_PKA1, 3U);
	CCC_ERROR_CHECK(ret,
			LOG_ALWAYS("Failed to clear PKA1 keyslot 3U\n"));

#ifdef HAVE_VDK_ERROR_SKIP	/* XXX VDK crashes....  */
	LOG_ALWAYS("Not running test 'use cleared PKA1 keyslot => causes division by zero in the VDK\n");
#else
	/* retry op => must fail with ERR_SIGNATURE_ILWALID */
	LOG_ERROR("Cleared (ret=%d) PKA1 keyslot %u after setting it; now attempt using it\n", ret, 3);
	TEST_EXPECT_RET(TEST_rsa4096_pss_verify_sha1_saltlen_key3, ERR_SIGNATURE_ILWALID,
			CCC_ENGINE_PKA1_PKA, TE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1);
#endif
#endif /* HAVE_SE_RSA || CCC_WITH_RSA */

	/* Test the DRGN generation */
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 1);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 7);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 16);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 17);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 128);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 512);
	TEST_ERRCHK(TEST_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG, 1024);

	TEST_ERRCHK(TEST_kernel_random, CCC_ENGINE_ANY, TE_ALG_RANDOM_DRNG);

#if HAVE_NIST_TRUNCATED_SHA2
	/* NIST truncated SHA-512/224 and SHA-512/256 digest test */
	TEST_ERRCHK(TEST_digest_truncated, CCC_ENGINE_ANY, TE_ALG_SHA512_224);
	TEST_ERRCHK(TEST_digest_truncated, CCC_ENGINE_ANY, TE_ALG_SHA512_256);
#endif

#endif /* TEST_PSC_LEGACY_TESTS */

	LOG_ALWAYS ("Tests enabled for PSC completed OK\n");
#if defined(HAVE_ONLY_PSC)
	return ret;
#endif

	CCC_ERROR_CHECK(ret); /* If all tests are disabled */
fail:

	return ret;
}
#endif /* TEST_PSC */

/************************************************************************/

/* crypto_ctx passed implicitly to tests via the TEST_ERRCHK macro
 */
static status_t run_se_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

#ifdef TEST_XMSS
	ret = run_xmss_test_cases(crypto_ctx, CCC_ENGINE_ANY);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_PSC
	ret = run_psc_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_PSC */

#ifdef TEST_RECIPROCAL
	ret = run_reciprocal_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_AES_KDF_TESTS
	ret = run_aes_kdf_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_SE_AES
	ret = run_cipher_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_CMAC_DST_KEYTABLE
	/* CMAC-AES MAC with keytable output (T19X) */
	ret = run_cmac_to_keytable_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_CMAC_KDF_TESTS
	/* CMAC-AES key derivation with NIST 800-108 counter mode (T19X) */
	ret = run_cmac_kdf_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_CMAC_AES
	ret = run_mac_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_SE_RANDOM || HAVE_RNG1_DRNG || HAVE_PKA1_TRNG
	ret = run_rng_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_SE_UNWRAP
	ret = run_unwrap_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* HAVE_SE_UNWRAP */

#if HAVE_RSA_MONTGOMERY_CALC
	ret = run_montgomery_calc_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* HAVE_RSA_MONTGOMERY_CALC */

#if HAVE_ENGINE_API_TESTS
	ret = run_engine_api_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_DIGEST
	ret = run_digest_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_DIGEST */

#if HAVE_RSA_PKCS_SIGN || HAVE_RSA_PSS_SIGN
	ret = run_rsa_sign_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* HAVE_RSA_PKCS_SIGN || HAVE_RSA_PSS_SIGN */

#if HAVE_WYCHE_ECDH || HAVE_WYCHE_ECDSA
	ret = run_wyche_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_SE_RSA || CCC_WITH_RSA
	ret = run_rsa_verify_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if defined(TEST_RSA_CIPHER) && HAVE_RSA_CIPHER
	ret = run_rsa_cipher_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_MD5
	ret = run_md5_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_WHIRLPOOL
	ret = run_whirlpool_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#if HAVE_HMAC_SHA
	ret = run_hmac_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* HAVE_HMAC_SHA */

#ifdef TEST_ECDH

#ifdef TEST_PKA1_ECDH_KSLOT
	ret = run_pka1_ecdh_kslot_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif
	ret = run_ecdh_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_ECDH */

#ifdef TEST_ED25519
	ret = run_ed25519_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_ED25519 */

#ifdef TEST_ED25519_SIGN
	ret = run_ed25519_sign_verify_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_X25519
	ret = run_X25519_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_ECDSA_SIGN
	ret = run_ecdsa_sign_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif

#ifdef TEST_ECDSA
	ret = run_ecdsa_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_ECDSA */

#ifdef TEST_DH
	ret = run_dh_test_cases(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_DH */

#ifdef TEST_CLASS_INIT
	ret = run_class_init_tests(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_CLASS_INIT */

#ifdef TEST_SEC_SAFE_REQ_VERIFY
	ret = run_ccc_req_verify_tests(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_SEC_SAFE_REQ_VERIFY */

#ifdef TEST_CCC_PLC_API_TESTS
	ret = run_ccc_api_tests(crypto_ctx);
	CCC_ERROR_CHECK(ret);
#endif /* TEST_CCC_PLC_API_TESTS */

fail:
	if (NO_ERROR != ret) {
		LOG_ERROR("[ ***ERROR: SE TEST CASE FAILED! (err 0x%x) ]\n",ret);
	}
	return ret;
}

status_t TEST_kernel_ops(void)
{
	status_t ret = NO_ERROR;
	static crypto_context_t c = { .ctx_handle = 0U, };
	const char *soc_impl[] = { "CHIP", "FPGA", "VDK", };

	(void)soc_impl;

	LOG_ALWAYS("Kernel test version: %s\n", CCC_TESTS_VERSION_STRING);

	LOG_ALWAYS("CCC running on SoC family T%xX (on %s)\n",
		   CCC_SOC_FAMILY_ID(CCC_SOC_FAMILY_TYPE),
		   soc_impl[(CCC_SOC_FAMILY_TYPE & CCC_SOC_ON_VALUE_MASK) >> CCC_SOC_ON_VALUE_SHIFT]);

	ret = run_se_test_cases(&c);

#if TEGRA_MEASURE_MEMORY_USAGE
	LOG_ALWAYS("Object sizes for reference:\n");
	LOG_ALWAYS("  sizeof_u32(crypto_context_t) == %u\n", sizeof_u32(crypto_context_t));
	LOG_ALWAYS("  sizeof_u32(te_args_key_data_t) == %u\n", sizeof_u32(te_args_key_data_t));
	LOG_ALWAYS("  sizeof_u32(te_crypto_args_t) == %u\n", sizeof_u32(te_crypto_args_t));
	LOG_ALWAYS("  CACHE_LINE == %u\n", CACHE_LINE);
#endif

	LOG_ALWAYS("Object sizes: crypto_context_t %u, te_crypto_args_t %u, te_args_key_data_t %u\n",
		   sizeof_u32(crypto_context_t),
		   sizeof_u32(te_crypto_args_t),
		   sizeof_u32(te_args_key_data_t));

	return ret;
}
#endif /* KERNEL_TEST_MODE */
