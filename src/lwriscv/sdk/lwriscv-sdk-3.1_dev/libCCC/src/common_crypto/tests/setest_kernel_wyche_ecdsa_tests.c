/*
 * Copyright (c) 2017-2021, LWPU CORPORATION. All rights reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <crypto_system_config.h>
#include <tests/setest_kernel_tests.h>

#if KERNEL_TEST_MODE

#include <crypto_api.h>
#include <crypto_ops.h>

#if HAVE_WYCHE_ECDSA

status_t run_wyche_ecdsa_tests(crypto_context_t *crypto_ctx, engine_id_t engine_id);

#if MODULE_TRACE
#define LOCAL_TRACE MODULE_TRACE
#else
#define LOCAL_TRACE 0
#endif

/*
	char data[5] = "Hello";

	// SHA-256 digest of data[]
	const uint8_t digest[32] = {
		0x18, 0x5f, 0x8d, 0xb3, 0x22, 0x71, 0xfe, 0x25,
		0xf5, 0x61, 0xa6, 0xfc, 0x93, 0x8b, 0x2e, 0x26,
		0x43, 0x06, 0xec, 0x30, 0x4e, 0xda, 0x51, 0x80,
		0x07, 0xd1, 0x76, 0x48, 0x26, 0x38, 0x19, 0x69,
	};

	// This is an ECDSA nist P256 (SHA-256) signature, created with cmd:
	//
	// Sign =>
	// echo -n "Hello" |  /usr/local/bin/openssl dgst -sha256 -sign wyche-p256-key.pem >
	//  wyche-ecdsa-sig-p256-sha256.bin
	//
	// Verify =>
	// echo -n "Hello" |  /usr/local/bin/openssl dgst -sha1 -verify wyche-p256-pubkey.pem
	//   -signature wyche-ecdsa-sig-p256-sha256.bin
	//

#if 1
	// Original Wyche #106 invalid signature
	// (this must fail with ERR_ILWALID_ARGS)
	//
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x44, 0x02, 0x20, 0xb7, 0xba, 0xba, 0xe9,
		0x33, 0x2b, 0x54, 0xb8, 0xa3, 0xa0, 0x5b, 0x70,
		0x04, 0x57, 0x98, 0x21, 0xa8, 0x87, 0xa1, 0xb2,
		0x14, 0x65, 0xf7, 0xdb, 0x8a, 0x3d, 0x49, 0x1b,
		0x39, 0xfd, 0x2c, 0x3f, 0x02, 0x20, 0x74, 0x72,
		0x91, 0xdd, 0x2f, 0x3f, 0x44, 0xaf, 0x7a, 0xce,
		0x68, 0xea, 0x33, 0x43, 0x1d, 0x6f, 0x94, 0xe4,
		0x18, 0xc1, 0x06, 0xa6, 0xe7, 0x62, 0x85, 0xcd,
		0x59, 0xf4, 0x32, 0x60, 0xec, 0xce,
	};
#else
	// Fixed Wyche #106 signature
	const uint8_t ecdsa_asn1_sig[] = {
		0x30, 0x45, 0x02, 0x21, 0x00, 0xb7, 0xba, 0xba, 0xe9,
		0x33, 0x2b, 0x54, 0xb8, 0xa3, 0xa0, 0x5b, 0x70,
		0x04, 0x57, 0x98, 0x21, 0xa8, 0x87, 0xa1, 0xb2,
		0x14, 0x65, 0xf7, 0xdb, 0x8a, 0x3d, 0x49, 0x1b,
		0x39, 0xfd, 0x2c, 0x3f, 0x02, 0x20, 0x74, 0x72,
		0x91, 0xdd, 0x2f, 0x3f, 0x44, 0xaf, 0x7a, 0xce,
		0x68, 0xea, 0x33, 0x43, 0x1d, 0x6f, 0x94, 0xe4,
		0x18, 0xc1, 0x06, 0xa6, 0xe7, 0x62, 0x85, 0xcd,
		0x59, 0xf4, 0x32, 0x60, 0xec, 0xce,
	};
#endif

 */

static te_args_key_data_t akey = {
	.k_key_type  = KEY_TYPE_EC_PUBLIC,
	.k_flags     = KEY_FLAG_PLAIN,
	//.k_byte_size get this from the lwrve params
	// .k_keyslot = 3, not supported yet
	.k_ec_public = {
		// XXX Should this extra intermediate field ".pubkey" be removed?
		.pubkey = {
			.x = { 0x4a, 0xf4, 0xf6, 0xd1, 0xd7, 0x34, 0x79, 0x8d,
			       0x4c, 0x4c, 0x6f, 0x97, 0xc4, 0xff, 0xf3, 0x92,
			       0xee, 0x65, 0xdc, 0x25, 0x2d, 0x61, 0x7b, 0x15,
			       0x4c, 0xa8, 0x35, 0xea, 0x15, 0x35, 0xb1, 0x04, },
			.y = { 0xfb, 0x06, 0x91, 0x71, 0xd0, 0x0e, 0x87, 0xa9,
			       0x2e, 0x6c, 0x4d, 0xb1, 0xd8, 0x92, 0xbc, 0x09,
			       0xb0, 0x4b, 0x5d, 0xa8, 0xbd, 0x9b, 0x09, 0xcf,
			       0xaa, 0x41, 0xd0, 0xa5, 0x26, 0xe5, 0x52, 0x37, },
			.point_flags = EC_POINT_FLAG_NONE,
		},
	},
};

static status_t wyche_ecdsa_verify(crypto_context_t *c,
				   te_crypto_algo_t algo,
				   engine_id_t eid,
				   const uint8_t *ecdsa_asn1_sig,
				   uint32_t ecdsa_asn1_sig_len,
				   const char *comment,
				   uint32_t count,
				   bool expect_fail,
				   const uint8_t *digest,
				   uint32_t digest_len,
				   te_args_key_data_t *tkey)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg;

	if (NULL == comment) {
		comment = "";
	}

	ret = crypto_kernel_context_setup(c, 0x42U, TE_ALG_MODE_VERIFY, algo);
	CCC_ERROR_CHECK(ret);

	se_util_mem_set((uint8_t *)&arg, 0, sizeof_u32(arg));

	LOG_INFO("\nWyche count: %u, %s: check ECDSA P256 SHA256 signature\n",
		 count, comment);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ECDSA;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags = INIT_FLAG_EC_NONE;

	/* Provide an ASN.1 encoded ECDSA signature blob instead of an te_ec_sig_t object
	 */
	arg.ca_init.ec.flags |= INIT_FLAG_EC_ASN1_SIGNATURE;

	arg.ca_init.ec.lwrve_id = TE_LWRVE_NIST_P_256; /* Select the EC lwrve in init ec parameters */
	arg.ca_init.engine_hint = eid;

	LOG_INFO("Hint: use engine 0x%x for ECDSA, lwrve %u\n", eid,
		 arg.ca_init.ec.lwrve_id);

	// No init flags passed (e.g. ECDSA data is by default in BIG ENDIAN order)
	//  but this can be changed by init ec flags.

	// Pass the key params
	if (NULL == tkey) {
		tkey = &akey;
	}

	arg.ca_set_key.kdata = tkey;

	arg.ca_data.src_digest_size    = digest_len;
	arg.ca_data.src_digest         = digest;

	LOG_INFO("ECDSA signature verify with ASN.1 DER signature\n");
	arg.ca_data.src_signature_size = ecdsa_asn1_sig_len;
	arg.ca_data.src_asn1	       = ecdsa_asn1_sig;

	LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) src\n", algo);

	ret = crypto_handle_operation(c, &arg);
	if (BOOL_IS_TRUE(expect_fail)) {
		if (NO_ERROR == ret) {
			CCC_ERROR_WITH_ECODE(ERR_BAD_STATE,
					     LTRACEF("crypto op succeeded => TEST FAILED !!!\n"));
		}

		LOG_ERROR("ECDSA verify test %u expected failure; ret %d\n", count, ret);
		ret = SE_ERROR(NO_ERROR);
	} else {
		CCC_ERROR_CHECK(ret,
				LTRACEF("crypto op failed (%u) => TEST FAILED...\n", ret));

		LOG_INFO("ECDSA[0x%x] VERIFY (COMBINED OPERATION) ret %d, attached handle: %u\n",
			 algo, ret, arg.ca_handle);
		CCC_ERROR_CHECK(ret);
	}

	LOG_INFO("Operation used engine 0x%x\n",
		 arg.ca_init.engine_hint);

	if (BOOL_IS_TRUE(expect_fail)) {
		LOG_INFO("ECDSA wyche test expected to fail\n");
	} else {
		LOG_INFO("ECDSA P256 SHA-256 signature check: OK\n");
	}

fail:
	if (NULL != c) {
		crypto_kernel_context_reset(c);
	}
	if (NO_ERROR != ret) {
		LOG_INFO("ECDSA P256 SHA-256 signature check: failed\n");
	}
	return ret;
}

#define WYCHE_ECDSA_TEST(comment, count, sig, sig_len,			\
			 expect_fail, dig, dig_len, keyp)		\
	do { ret = wyche_ecdsa_verify(crypto_ctx,			\
				      algo,				\
				      engine_id,			\
				      sig, sig_len,			\
				      comment, count,			\
				      expect_fail,			\
				      dig, dig_len, keyp);	\
	     CCC_ERROR_CHECK(ret,						\
			     LOG_ERROR("[ WYCHE ECDSA vector "		\
				       "test %u (line %u) FAILED (%d)]\n", \
				       count, __LINE__, ret));		\
	} while(0)

static status_t wyche_ecdsa_tests(crypto_context_t *crypto_ctx,
				  engine_id_t engine_id)
{
	status_t ret = NO_ERROR;
	uint32_t COUNT = 0U;
	bool fail = false;
	const char *comment = NULL;
	te_crypto_algo_t algo = TE_ALG_ECDSA;

	static te_args_key_data_t tst_key;

	// SHA_256(BIN(48656c6c6f))
	const uint8_t digest[32] = {
		0x18, 0x5f, 0x8d, 0xb3, 0x22, 0x71, 0xfe, 0x25,
		0xf5, 0x61, 0xa6, 0xfc, 0x93, 0x8b, 0x2e, 0x26,
		0x43, 0x06, 0xec, 0x30, 0x4e, 0xda, 0x51, 0x80,
		0x07, 0xd1, 0x76, 0x48, 0x26, 0x38, 0x19, 0x69,
	};
	uint32_t digest_len = sizeof_u32(digest);
	(void)digest;

	tst_key = akey;

#if 0

	{
		COUNT = 1;
		comment = "signature malleability";
		fail = false;

		uint8_t sig[] = { 0x30, 0x46, 0x02, 0x21, 0x00, 0xb7, 0xba, 0xba, 0xe9, 0x33, 0x2b, 0x54, 0xb8, 0xa3, 0xa0, 0x5b, 0x70, 0x04, 0x57, 0x98, 0x21, 0xa8, 0x87, 0xa1, 0xb2, 0x14, 0x65, 0xf7, 0xdb, 0x8a, 0x3d, 0x49, 0x1b, 0x39, 0xfd, 0x2c, 0x3f, 0x02, 0x21, 0x00, 0x8b, 0x8d, 0x6e, 0x21, 0xd0, 0xc0, 0xbb, 0x51, 0x85, 0x31, 0x97, 0x15, 0xcc, 0xbc, 0xe2, 0x90, 0x28, 0x02, 0xe1, 0xec, 0xa0, 0x70, 0xb7, 0x22, 0x6d, 0xec, 0x70, 0xce, 0xca, 0x02, 0x38, 0x83, };

		WYCHE_ECDSA_TEST(comment, COUNT, sig, sizeof_u32(sig),
				 fail, digest, digest_len, NULL);
	}

	{
		COUNT = 106;
		comment = "truncate integer";
		fail = true;

		uint8_t sig[] = { 0x30, 0x44, 0x02, 0x20, 0xb7, 0xba, 0xba, 0xe9, 0x33, 0x2b, 0x54, 0xb8, 0xa3, 0xa0, 0x5b, 0x70, 0x04, 0x57, 0x98, 0x21, 0xa8, 0x87, 0xa1, 0xb2, 0x14, 0x65, 0xf7, 0xdb, 0x8a, 0x3d, 0x49, 0x1b, 0x39, 0xfd, 0x2c, 0x3f, 0x02, 0x20, 0x74, 0x72, 0x91, 0xdd, 0x2f, 0x3f, 0x44, 0xaf, 0x7a, 0xce, 0x68, 0xea, 0x33, 0x43, 0x1d, 0x6f, 0x94, 0xe4, 0x18, 0xc1, 0x06, 0xa6, 0xe7, 0x62, 0x85, 0xcd, 0x59, 0xf4, 0x32, 0x60, 0xec, 0xce };

		WYCHE_ECDSA_TEST(comment, COUNT, sig, sizeof_u32(sig),
				 fail, digest, digest_len, NULL);
	}
#endif // XXXX donot run the above now

#if 0 // XXXX ASN.1 parser fails this! => FIXME
	{
		COUNT = 200;
		comment = "small r and s";
		fail = false;

		uint8_t sig[] = {
			0x30, 0x06, 0x02, 0x01, 0x05, 0x02, 0x01, 0x01,
		};

		uint8_t wx[] = {
			0x4a, 0x03, 0xef, 0x9f, 0x92, 0xeb, 0x26, 0x8c, 0xaf, 0xa6, 0x01, 0x07, 0x24, 0x89, 0xa5, 0x63, 0x80, 0xfa, 0x0d, 0xc4, 0x31, 0x71, 0xd7, 0x71, 0x28, 0x13, 0xb3, 0xa1, 0x9a, 0x1e, 0xb5, 0xe5,
		};
		uint8_t wy[] = {
			0x3e, 0x21, 0x3e, 0x28, 0xa6, 0x08, 0xce, 0x9a, 0x2f, 0x4a, 0x17, 0xfd, 0x83, 0x0c, 0x66, 0x54, 0x01, 0x8a, 0x79, 0xb3, 0xe0, 0x26, 0x3d, 0x91, 0xa8, 0xba, 0x90, 0x62, 0x2d, 0xf6, 0xf2, 0xf0,
		};
		se_util_mem_move(tst_key.k_ec_public.pubkey.x, wx, sizeof_u32(wx));
		se_util_mem_move(tst_key.k_ec_public.pubkey.y, wy, sizeof_u32(wy));

		uint8_t d[] = {
			0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c, 0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25,
		};

		WYCHE_ECDSA_TEST(comment, COUNT, sig, sizeof_u32(sig),
				 fail, d, digest_len, &key_tst);
	}
#endif

	{
		COUNT = 203;
		comment = "point at infinity during verify";
		fail = true;

		uint8_t sig[] = { 0x30, 0x44, 0x02, 0x20, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0x73, 0x7d, 0x56, 0xd3, 0x8b, 0xcf, 0x42, 0x79, 0xdc, 0xe5, 0x61, 0x7e, 0x31, 0x92, 0xa8, 0x02, 0x20, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x3e, 0xf7, 0xa8, 0xe4, 0x8d, 0x07, 0xdf, 0x81, 0xa6, 0x93, 0x43, 0x96, 0x54, 0x21, 0x0c, 0x70, };

		uint8_t wx[] = {
			0x02, 0x03, 0x73, 0x6f, 0xcb, 0x19, 0x8b, 0x15, 0xd8, 0xd7, 0xa0, 0xc8, 0x0f, 0x66, 0xdd, 0xdd, 0x15, 0x25, 0x92, 0x40, 0xaa, 0x78, 0xd0, 0x8a, 0xae, 0x67, 0xc4, 0x67, 0xde, 0x04, 0x50, 0x34,
		};
		uint8_t wy[] = {
			0x34, 0x38, 0x34, 0x38, 0xd5, 0x04, 0x1e, 0xa9, 0xa3, 0x87, 0xee, 0x8e, 0x4d, 0x4e, 0x84, 0xb4, 0x47, 0x1b, 0x16, 0x0c, 0x6b, 0xcf, 0x25, 0x68, 0xb0, 0x72, 0xf8, 0xf2, 0x0e, 0x87, 0xa9, 0x96,
		};

		se_util_mem_move(tst_key.k_ec_public.pubkey.x, wx, sizeof_u32(wx));
		se_util_mem_move(tst_key.k_ec_public.pubkey.y, wy, sizeof_u32(wy));

		uint8_t d[] = {
			0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c, 0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25,
		};

		WYCHE_ECDSA_TEST(comment, COUNT, sig, sizeof_u32(sig),
				 fail, d, digest_len, &tst_key);
	}

#if 1
	{
		COUNT = 209;
		comment = "duplication bug";
		fail = true;

		uint8_t sig[] = {
			0x30, 0x45, 0x02, 0x20, 0x6f, 0x23, 0x47, 0xca, 0xb7, 0xdd, 0x76, 0x85, 0x8f, 0xe0, 0x55, 0x5a, 0xc3, 0xbc, 0x99, 0x04, 0x8c, 0x4a, 0xac, 0xaf, 0xdf, 0xb6, 0xbc, 0xbe, 0x05, 0xea, 0x6c, 0x42, 0xc4, 0x93, 0x45, 0x69, 0x02, 0x21, 0x00, 0xf2, 0x1d, 0x90, 0x7e, 0x38, 0x90, 0x91, 0x6d, 0xc4, 0xfa, 0x1f, 0x47, 0x03, 0xc1, 0xe5, 0x0d, 0x3f, 0x54, 0xdd, 0xf7, 0x38, 0x3e, 0x44, 0x02, 0x3a, 0x41, 0xde, 0x56, 0x2a, 0xa1, 0x8e, 0xd8,
		};

		uint8_t wx[] = {
			0x01, 0x58, 0x13, 0x77, 0x55, 0xb9, 0x01, 0xf7, 0x97, 0xa9, 0x0d, 0x4c, 0xa8, 0x88, 0x7e, 0x02, 0x3c, 0xb2, 0xef, 0x63, 0xb2, 0xba, 0x2c, 0x0d, 0x45, 0x5e, 0xda, 0xef, 0x42, 0xcf, 0x23, 0x7e,
		};
		uint8_t wy[] = {
			0xd5, 0x69, 0xb0, 0x3e, 0xf2, 0xc8, 0x85, 0x7b, 0x6d, 0x47, 0x49, 0xe5, 0x50, 0x58, 0x5b, 0x55, 0x58, 0x38, 0x46, 0x03, 0xd4, 0xbe, 0x29, 0x1f, 0x1e, 0x84, 0x2e, 0x45, 0xa9, 0x88, 0x12, 0x32,
		};
		se_util_mem_move(tst_key.k_ec_public.pubkey.x, wx, sizeof_u32(wx));
		se_util_mem_move(tst_key.k_ec_public.pubkey.y, wy, sizeof_u32(wy));

		uint8_t d[] = {
			0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c, 0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25,
		};

		WYCHE_ECDSA_TEST(comment, COUNT, sig, sizeof_u32(sig),
				 fail, d, digest_len, &tst_key);
	}
#endif

	LOG_INFO("[WYCHE-ECDSA tests: PASSED]\n");
fail:
	return ret;
}

status_t run_wyche_ecdsa_tests(crypto_context_t *crypto_ctx, engine_id_t engine_id)
{
	status_t ret = NO_ERROR;

	ret = wyche_ecdsa_tests(crypto_ctx, engine_id);
	CCC_ERROR_CHECK(ret,
			LOG_ERROR("[WYCHE-ECDSA tests: FAILED (%d)]\n", ret));

	LOG_INFO("[WYCHE-ECDSA tests: PASSED]\n");
fail:
	return ret;
}

#endif /* HAVE_WYCHE_ECDSA */
#endif /* KERNEL_TEST_MODE */
