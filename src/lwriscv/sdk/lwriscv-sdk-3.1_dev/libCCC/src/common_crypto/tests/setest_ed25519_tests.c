/*
 * Copyright (c) 2016-2021, LWPU CORPORATION. All rights reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* Edwards lwrve ED25519 related sign/verify tests
 */
#include <crypto_system_config.h>
#include <tests/setest_kernel_tests.h>

/* Defined nonzero to run the kernel mode crypto tests
 */
#if KERNEL_TEST_MODE

#if MODULE_TRACE
#define LOCAL_TRACE MODULE_TRACE
#else
#define LOCAL_TRACE 0
#endif

#ifdef TEST_ED25519
/* ED25519 twisted edwards lwrve signature verification test
 *
 * Test vector data is from RFC-8032 (TEST 3: message length 2 bytes)
 */
static status_t TEST_ED25519_verify_test3(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t message[2] = {
		0xaf, 0x82
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
		0x62, 0x91, 0xd6, 0x57, 0xde, 0xec, 0x24, 0x02,
		0x48, 0x27, 0xe6, 0x9c, 0x3a, 0xbe, 0x01, 0xa3,
		0x0c, 0xe5, 0x48, 0xa2, 0x84, 0x74, 0x3a, 0x44,
		0x5e, 0x36, 0x80, 0xd7, 0xdb, 0x5a, 0xc3, 0xac,

		/* enc(S) */
		0x18, 0xff, 0x9b, 0x53, 0x8d, 0x16, 0xf2, 0x90,
		0xae, 0x67, 0xf7, 0x60, 0x98, 0x4d, 0xc6, 0x59,
		0x4a, 0x7c, 0x15, 0xe9, 0x71, 0x6e, 0xd2, 0x8d,
		0xc0, 0x27, 0xbe, 0xce, 0xea, 0x1e, 0xc4, 0x0a,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xfc, 0x51, 0xcd, 0x8e, 0x62, 0x18, 0xa1, 0xa3,
					0x8d, 0xa4, 0x7e, 0xd0, 0x02, 0x30, 0xf0, 0x58,
					0x08, 0x16, 0xed, 0x13, 0xba, 0x33, 0x03, 0xac,
					0x5d, 0xeb, 0x91, 0x15, 0x48, 0x90, 0x80, 0x25,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

static status_t TEST_ED25519_verify_test1001(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t message[] = {
		0x0a, 0x9f, 0xda, 0x8b, 0x8c, 0xfc, 0xa7, 0xa5, 0xb0, 0x5d, 0x78, 0x11, 0x6f, 0xce, 0xe1, 0x9a, 0xb8, 0x03, 0xc1, 0xc6, 0x01, 0x0c, 0xe1, 0x1d, 0xaa, 0x8e, 0x93, 0xa6, 0x6d, 0x12, 0xc1, 0x2e, 0x47, 0x4e, 0xb9, 0x1c, 0x26, 0x40, 0xd9, 0x7a, 0x81, 0x3d, 0x9a, 0x83, 0x0d, 0x26, 0x88, 0x68, 0xeb, 0x2e, 0x37, 0x70, 0x42, 0x5f, 0x10, 0xc7, 0x58, 0x40, 0x46, 0x8e, 0x66, 0x9d, 0xc7, 0xf6, 0x1d, 0x3b, 0xe2, 0xde, 0x88, 0xae, 0x0e, 0x54, 0x2b, 0xc8, 0x09, 0x67, 0x91, 0x13, 0x95, 0x7a, 0x14, 0xda, 0x4e, 0xaf, 0xf5, 0x49, 0xbf, 0xde, 0x63, 0x7d, 0x7c, 0xaf, 0xdc, 0x6a, 0xa8, 0x39, 0x94, 0x83, 0x73, 0x97, 0xf8, 0x6e, 0x4f, 0xde, 0x86, 0xd4, 0x02, 0xfa, 0x9a, 0xef, 0x7f, 0x65, 0x54, 0x9a, 0x21, 0x43, 0x73, 0xe5, 0x60, 0xe6, 0xd7, 0xa1, 0xc2, 0x76, 0x9e, 0x0c, 0x7d, 0x5a, 0x01, 0x71, 0xe7, 0xcc, 0x00, 0xdf, 0xf3, 0x6e, 0x04, 0x29, 0x79, 0x8b, 0x53, 0xaa, 0x62, 0x16, 0x24, 0xbd, 0xa7, 0x4d, 0x6d, 0xf0, 0xbf, 0xff, 0xfb, 0xd8, 0xfd, 0x7b, 0xef, 0x1a, 0x64, 0xf3, 0x6c, 0x00, 0x07, 0x82, 0xf6, 0xed, 0x03, 0x1a, 0xf5, 0xc2, 0xa7, 0x4a, 0x18, 0x96, 0x35, 0x98, 0xc9, 0xba, 0x06, 0x23, 0x92, 0xde, 0x96, 0x02, 0x03, 0x67, 0x94, 0xb7, 0xb5, 0xe6, 0x8c, 0x25, 0xc9, 0x3f, 0xe7, 0xcf, 0xad, 0x47, 0xa7, 0xc5, 0xb9, 0x79, 0xd4, 0x76, 0xcd, 0x51, 0x3a, 0x12, 0xbf, 0x03, 0x07, 0xcb, 0x16, 0x31, 0x74, 0x00, 0x42, 0xa9, 0xfb, 0xf3, 0xeb, 0x0b, 0xe5, 0x17, 0x06, 0x20, 0xda, 0xfd, 0x5f, 0x16, 0xed, 0x89, 0x34, 0x2c, 0x26, 0x25, 0xd7, 0x83, 0xe7, 0x4e, 0xe0, 0xd7, 0x84, 0xbf, 0x05, 0x19, 0x43, 0x74, 0x0c, 0x88, 0xb0, 0xbe, 0xf7, 0xbc, 0x85, 0xe1, 0xa6, 0xa4, 0xa5, 0x17, 0xd4, 0x92, 0xfb, 0x73, 0x7e, 0x77, 0x66, 0x99, 0x59, 0x0c, 0x93, 0x22, 0x4c, 0xd4, 0xd9, 0x24, 0x5d, 0x4e, 0x93, 0x71, 0xa3, 0x67, 0xc0, 0x71, 0x2f, 0x87, 0x49, 0x0f, 0x92, 0x47, 0xc4, 0x9a, 0xdd, 0x93, 0x13, 0xf2, 0x77, 0xa4, 0xd9, 0xf2, 0x6b, 0x75, 0xaa, 0xe4, 0xde, 0xd6, 0xa3, 0xde, 0xf8, 0x5f, 0x83, 0xfc, 0x99, 0x59, 0x10, 0x40, 0x55, 0x48, 0xaf, 0x67, 0x0e, 0xd8, 0xaa, 0xa3, 0x05, 0x24, 0xab, 0x82, 0x9c, 0xcb, 0x56, 0xa5, 0x00, 0x5b, 0x58, 0xbc, 0xe8, 0x68, 0xc9, 0xe8, 0x07, 0x4f, 0x07, 0xdd, 0x7f, 0x38, 0x18, 0xf2, 0x99, 0xe4, 0xe0, 0x86, 0xbe, 0xd9, 0xea, 0xb9, 0x02, 0xcf, 0x11, 0xb3, 0x98, 0xd5, 0x31, 0xb8, 0x63, 0x2e, 0x7d, 0x52, 0x3a, 0x8f, 0x87, 0x76, 0x95, 0xf4, 0x6c, 0xcf, 0x9c, 0xe2, 0x4e, 0x62, 0xca, 0xb2, 0xc7, 0xcd, 0x0a, 0xae, 0xe1, 0x7d, 0xb5, 0x26, 0x76, 0xa4, 0xb5, 0x05, 0x8e, 0x9c, 0x1d, 0x7c, 0x47, 0xbf, 0xfc, 0xb6, 0x41, 0xb0, 0xea, 0x2b, 0x09, 0x44, 0xf3, 0x9a, 0x75, 0x66, 0x5a, 0x7e, 0xf2, 0x9b, 0x7f, 0x02, 0xa8, 0x78, 0xdb, 0x82, 0x38, 0x83, 0xbd, 0xac, 0xfb, 0x0f, 0xbe, 0x5d, 0xfe, 0x5a, 0x9b, 0xed, 0x9f, 0xda, 0xc7, 0xe4, 0x14, 0x2e, 0x3e, 0xb5, 0x0d, 0x5e, 0x84, 0x0b, 0xd0, 0xac, 0x0b, 0xec, 0xf4, 0xfa, 0x97, 0xe1, 0xfc, 0x48, 0x27, 0xc3, 0x97, 0xa5, 0x24, 0x65, 0xd9, 0x16, 0x88, 0x99, 0x54, 0xb3, 0x70, 0x1b, 0x0f, 0xac, 0x61, 0x15, 0x9b, 0x23, 0x09, 0x2f, 0x46, 0x85, 0xf4, 0x78, 0x8b, 0xad, 0x35, 0xd0, 0x0d, 0xa2, 0x67, 0x9e, 0xcc, 0x54, 0x92, 0x1f, 0x1a, 0x86, 0x47, 0x10, 0x16, 0x57, 0xab, 0x49, 0x47, 0x74, 0x20, 0x56, 0x7a, 0xed, 0x67, 0xc8, 0x60, 0x59, 0x30, 0x44, 0x4b, 0x5d, 0x07, 0x92, 0x7c, 0x17, 0xef, 0xf1, 0xf8, 0x57, 0x0c, 0xf2, 0xaf, 0x29, 0xe7, 0x19, 0xf8, 0x5c, 0xa7, 0x84, 0x9b, 0x89, 0x55, 0x49, 0xf1, 0x3d, 0xfe, 0xca, 0x68, 0xbb, 0xef, 0x71, 0xe3, 0xce, 0x8b, 0x6c, 0xed, 0xd2, 0xff, 0x68, 0xd3, 0x2b, 0x02, 0xca, 0xf5, 0x95, 0x1a, 0x0b, 0x3e, 0x6b, 0x0b, 0xae, 0x6a, 0x96, 0xc0, 0x20, 0x58, 0x19, 0x1f, 0x30, 0x5e, 0x09, 0x07, 0x11, 0xc4, 0x6d, 0xad, 0xdc, 0xd5, 0xae, 0xee, 0x76, 0x9c, 0x3a, 0x10, 0x5e, 0x9a, 0x82, 0x7b, 0xbd, 0x19, 0x5d, 0x32, 0x92, 0x31, 0xc2, 0x62, 0x38, 0x47, 0x9a, 0x9b, 0xb0, 0x07, 0x1a, 0xfb, 0x16, 0x0e, 0xf9, 0x55, 0xe8, 0x74, 0xd7, 0xa4, 0x20, 0xc5, 0x67, 0x85, 0xf4, 0x4a, 0xe0, 0xa1, 0x8c, 0x52, 0xd8, 0x28, 0x0c, 0x59, 0x98, 0xcf, 0x38, 0x88, 0xfe, 0xaf, 0x89, 0x89, 0x81, 0x34, 0xbc, 0x8d, 0x41, 0x1f, 0xc9, 0xf6, 0xc5, 0x76, 0x8e, 0xa7, 0xa2, 0x49, 0x72, 0x94, 0x13, 0x73, 0x9e, 0x53, 0x2b, 0x64, 0x39, 0x37, 0x15, 0x2c, 0xdf, 0xb8, 0xd2, 0xff, 0x87, 0xfd, 0x48, 0x08, 0x4d, 0xd8, 0xae, 0xeb, 0xea, 0xf0, 0xf7, 0xb1, 0x0d, 0x87, 0xb6, 0xe4, 0x42, 0x32, 0x28, 0xc9, 0xfc, 0x8d, 0xc5, 0xe3, 0x85, 0x2a, 0xa8, 0xb8, 0xac, 0xc5, 0x45, 0xd1, 0x8f, 0x25, 0xc5, 0x5d, 0x73, 0xda, 0x1b, 0xb8, 0x2e, 0x3e, 0xb3, 0x76, 0xf9, 0xef, 0x05, 0xb2, 0x74, 0xd7, 0xec, 0xb1, 0x84, 0x5d, 0x65, 0xca, 0x0c, 0xd2, 0x62, 0x9f, 0x03, 0x8a, 0x2d, 0x66, 0x4d, 0x7a, 0x69, 0x78, 0x1c, 0x84, 0xe9, 0x8d, 0xe2, 0xc2, 0x09, 0xc4, 0x6e, 0xfc, 0x51, 0x16, 0x21, 0x72, 0x85, 0x66, 0x49, 0x46, 0x9e, 0x67, 0x33, 0x08, 0xdc, 0xc1, 0x45, 0xea, 0xf7, 0x83, 0xf5, 0xcb, 0x5b, 0x4b, 0xe7, 0xd9, 0xfd, 0x58, 0xee, 0x09, 0x74, 0xc9, 0x81, 0xa3, 0x8f, 0xea, 0x8e, 0x31, 0x26, 0x7a, 0xbf, 0xa4, 0x10, 0xe6, 0x9e, 0x46, 0x48, 0x2f, 0x51, 0x34, 0xf3, 0xda, 0x1f, 0xfe, 0x38, 0x1b, 0xd6, 0x9d, 0x8d, 0x0b, 0x78, 0xea, 0x90, 0x9b, 0x4a, 0xf9, 0x39, 0x6d, 0xca, 0xff, 0x89, 0x96, 0x0a, 0x04, 0x9e, 0xda, 0x69, 0x46, 0x61, 0x6f, 0xc2, 0x7c, 0xcf, 0x9a, 0x9e, 0x5b, 0xa1, 0xa0, 0x13, 0x57, 0x64, 0xf3, 0x77, 0x19, 0xda, 0x4d, 0x28, 0x07, 0x81, 0x85, 0xd0, 0x4d, 0x72, 0x41, 0x9c, 0x2c, 0x70, 0xf2, 0x90, 0xd9, 0x7e, 0x1f, 0x82, 0xb8, 0x79, 0xf7, 0x1b, 0x9e, 0x19, 0xd5, 0x04, 0xd3, 0x64, 0xcd, 0x3b, 0xa2, 0x2c, 0xf9, 0x05, 0x25, 0x0f, 0xd3, 0x7d, 0x58, 0xe5, 0xfe, 0x40, 0x20, 0x9f, 0x60, 0x72, 0xa0, 0x6d, 0x8b, 0x5b, 0xa7, 0x01, 0x96, 0x23, 0x05, 0x77, 0x87, 0x7e, 0xc4, 0x61, 0x53, 0x16, 0x7a, 0x7c, 0x7a, 0xea, 0x27, 0x0f, 0xa1, 0x09, 0x8a, 0xba, 0x9e, 0x3a, 0x74, 0xac, 0xb3, 0x6a, 0x11, 0xb0, 0x9b, 0xd0, 0x7a, 0x3b, 0x88, 0xea, 0x65, 0x4e, 0x26, 0x83, 0x65, 0x62, 0x5b, 0x58, 0x9b, 0x22, 0x06, 0xc7, 0x10, 0xd9, 0x60, 0xf4, 0x2e, 0xa4, 0x19, 0xb7, 0xe4, 0xe3, 0xda, 0x47, 0x59, 0xfc, 0xbc, 0xa5, 0x0e, 0x4b, 0xf4, 0xcc, 0x55, 0xcf, 0x88, 0xf7, 0x0b, 0x31, 0x80, 0xc8, 0x05, 0xa7, 0x04, 0x50, 0x86, 0xaf, 0xa0, 0x4c, 0x6b, 0xe2, 0x32, 0x23, 0xec, 0xae, 0x5f, 0x82, 0xc1, 0x46, 0xd5, 0x43, 0x11, 0xd1, 0x80, 0x7c, 0x2e, 0x4a, 0x53, 0xf9, 0xe0, 0xa4, 0x48, 0x2b, 0x4e, 0x1e,
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
		0xe3, 0xdb, 0x47, 0xa1, 0x1e, 0x10, 0xe7, 0x88,
		0x92, 0x5d, 0x14, 0xb1, 0xe2, 0x8b, 0x54, 0xc9,
		0xfc, 0xf9, 0xb6, 0xac, 0xc1, 0xdf, 0x8c, 0x14,
		0xf6, 0x83, 0xa5, 0x67, 0x2f, 0xd5, 0x04, 0xdd,
		/* enc(S) */
		0x4a, 0x47, 0x5a, 0x33, 0x93, 0xb3, 0xef, 0x8b,
		0xce, 0xac, 0x23, 0x61, 0xdb, 0xba, 0x35, 0x30,
		0xaf, 0x25, 0xc2, 0x46, 0xc3, 0xec, 0x4c, 0x05,
		0x89, 0x9b, 0x51, 0x7f, 0x6c, 0xd3, 0x4f, 0x0a,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
#define ED25519_test_with_compressed_point 0
#if ED25519_test_with_compressed_point
				.ed25519_compressed_point = {
					0xb8, 0xce, 0xa2, 0x15, 0xa0, 0x12, 0x4e, 0xed,
					0x27, 0x00, 0x57, 0x25, 0xd8, 0x97, 0x78, 0x1e,
					0xa0, 0x64, 0xdc, 0xef, 0xb2, 0x14, 0x22, 0xc8,
					0xbd, 0x24, 0x02, 0xc5, 0x6a, 0x10, 0x57, 0x1c,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
#else /* ED25519_test_with_compressed_point */
				/* Below X, Y coordinates have been decompressed from
				 * above ed25519_compressed_point
				 */
				.y = {
					0xb8, 0xce, 0xa2, 0x15, 0xa0, 0x12, 0x4e, 0xed,
					0x27, 0x00, 0x57, 0x25, 0xd8, 0x97, 0x78, 0x1e,
					0xa0, 0x64, 0xdc, 0xef, 0xb2, 0x14, 0x22, 0xc8,
					0xbd, 0x24, 0x02, 0xc5, 0x6a, 0x10, 0x57, 0x1c,
				},
				.x = {
					0x88, 0x2a, 0xbd, 0x16, 0xa3, 0x2f, 0x7e, 0xce,
					0xcb, 0x0c, 0x32, 0x1d, 0xf3, 0xc9, 0x06, 0x58,
					0x1d, 0x96, 0x21, 0x69, 0xbf, 0x45, 0x71, 0x83,
					0x5d, 0x3f, 0x7d, 0xc2, 0xa5, 0xa7, 0xea, 0x65,
				},
				.point_flags = CCC_EC_POINT_FLAG_LITTLE_ENDIAN,
#endif /* ED25519_test_with_compressed_point */
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* ED25519 twisted edwards lwrve signature verification test
 *
 * Test vector data is from RFC-8032 (TEST 4: message length 1023 bytes)
 */
static status_t TEST_ED25519_verify_test4(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	static uint8_t message[1023] = {
	   0x08, 0xb8, 0xb2, 0xb7, 0x33, 0x42, 0x42, 0x43, 0x76, 0x0f, 0xe4, 0x26, 0xa4, 0xb5, 0x49, 0x08,
	   0x63, 0x21, 0x10, 0xa6, 0x6c, 0x2f, 0x65, 0x91, 0xea, 0xbd, 0x33, 0x45, 0xe3, 0xe4, 0xeb, 0x98,
	   0xfa, 0x6e, 0x26, 0x4b, 0xf0, 0x9e, 0xfe, 0x12, 0xee, 0x50, 0xf8, 0xf5, 0x4e, 0x9f, 0x77, 0xb1,
	   0xe3, 0x55, 0xf6, 0xc5, 0x05, 0x44, 0xe2, 0x3f, 0xb1, 0x43, 0x3d, 0xdf, 0x73, 0xbe, 0x84, 0xd8,
	   0x79, 0xde, 0x7c, 0x00, 0x46, 0xdc, 0x49, 0x96, 0xd9, 0xe7, 0x73, 0xf4, 0xbc, 0x9e, 0xfe, 0x57,
	   0x38, 0x82, 0x9a, 0xdb, 0x26, 0xc8, 0x1b, 0x37, 0xc9, 0x3a, 0x1b, 0x27, 0x0b, 0x20, 0x32, 0x9d,
	   0x65, 0x86, 0x75, 0xfc, 0x6e, 0xa5, 0x34, 0xe0, 0x81, 0x0a, 0x44, 0x32, 0x82, 0x6b, 0xf5, 0x8c,
	   0x94, 0x1e, 0xfb, 0x65, 0xd5, 0x7a, 0x33, 0x8b, 0xbd, 0x2e, 0x26, 0x64, 0x0f, 0x89, 0xff, 0xbc,
	   0x1a, 0x85, 0x8e, 0xfc, 0xb8, 0x55, 0x0e, 0xe3, 0xa5, 0xe1, 0x99, 0x8b, 0xd1, 0x77, 0xe9, 0x3a,
	   0x73, 0x63, 0xc3, 0x44, 0xfe, 0x6b, 0x19, 0x9e, 0xe5, 0xd0, 0x2e, 0x82, 0xd5, 0x22, 0xc4, 0xfe,
	   0xba, 0x15, 0x45, 0x2f, 0x80, 0x28, 0x8a, 0x82, 0x1a, 0x57, 0x91, 0x16, 0xec, 0x6d, 0xad, 0x2b,
	   0x3b, 0x31, 0x0d, 0xa9, 0x03, 0x40, 0x1a, 0xa6, 0x21, 0x00, 0xab, 0x5d, 0x1a, 0x36, 0x55, 0x3e,
	   0x06, 0x20, 0x3b, 0x33, 0x89, 0x0c, 0xc9, 0xb8, 0x32, 0xf7, 0x9e, 0xf8, 0x05, 0x60, 0xcc, 0xb9,
	   0xa3, 0x9c, 0xe7, 0x67, 0x96, 0x7e, 0xd6, 0x28, 0xc6, 0xad, 0x57, 0x3c, 0xb1, 0x16, 0xdb, 0xef,
	   0xef, 0xd7, 0x54, 0x99, 0xda, 0x96, 0xbd, 0x68, 0xa8, 0xa9, 0x7b, 0x92, 0x8a, 0x8b, 0xbc, 0x10,
	   0x3b, 0x66, 0x21, 0xfc, 0xde, 0x2b, 0xec, 0xa1, 0x23, 0x1d, 0x20, 0x6b, 0xe6, 0xcd, 0x9e, 0xc7,
	   0xaf, 0xf6, 0xf6, 0xc9, 0x4f, 0xcd, 0x72, 0x04, 0xed, 0x34, 0x55, 0xc6, 0x8c, 0x83, 0xf4, 0xa4,
	   0x1d, 0xa4, 0xaf, 0x2b, 0x74, 0xef, 0x5c, 0x53, 0xf1, 0xd8, 0xac, 0x70, 0xbd, 0xcb, 0x7e, 0xd1,
	   0x85, 0xce, 0x81, 0xbd, 0x84, 0x35, 0x9d, 0x44, 0x25, 0x4d, 0x95, 0x62, 0x9e, 0x98, 0x55, 0xa9,
	   0x4a, 0x7c, 0x19, 0x58, 0xd1, 0xf8, 0xad, 0xa5, 0xd0, 0x53, 0x2e, 0xd8, 0xa5, 0xaa, 0x3f, 0xb2,
	   0xd1, 0x7b, 0xa7, 0x0e, 0xb6, 0x24, 0x8e, 0x59, 0x4e, 0x1a, 0x22, 0x97, 0xac, 0xbb, 0xb3, 0x9d,
	   0x50, 0x2f, 0x1a, 0x8c, 0x6e, 0xb6, 0xf1, 0xce, 0x22, 0xb3, 0xde, 0x1a, 0x1f, 0x40, 0xcc, 0x24,
	   0x55, 0x41, 0x19, 0xa8, 0x31, 0xa9, 0xaa, 0xd6, 0x07, 0x9c, 0xad, 0x88, 0x42, 0x5d, 0xe6, 0xbd,
	   0xe1, 0xa9, 0x18, 0x7e, 0xbb, 0x60, 0x92, 0xcf, 0x67, 0xbf, 0x2b, 0x13, 0xfd, 0x65, 0xf2, 0x70,
	   0x88, 0xd7, 0x8b, 0x7e, 0x88, 0x3c, 0x87, 0x59, 0xd2, 0xc4, 0xf5, 0xc6, 0x5a, 0xdb, 0x75, 0x53,
	   0x87, 0x8a, 0xd5, 0x75, 0xf9, 0xfa, 0xd8, 0x78, 0xe8, 0x0a, 0x0c, 0x9b, 0xa6, 0x3b, 0xcb, 0xcc,
	   0x27, 0x32, 0xe6, 0x94, 0x85, 0xbb, 0xc9, 0xc9, 0x0b, 0xfb, 0xd6, 0x24, 0x81, 0xd9, 0x08, 0x9b,
	   0xec, 0xcf, 0x80, 0xcf, 0xe2, 0xdf, 0x16, 0xa2, 0xcf, 0x65, 0xbd, 0x92, 0xdd, 0x59, 0x7b, 0x07,
	   0x07, 0xe0, 0x91, 0x7a, 0xf4, 0x8b, 0xbb, 0x75, 0xfe, 0xd4, 0x13, 0xd2, 0x38, 0xf5, 0x55, 0x5a,
	   0x7a, 0x56, 0x9d, 0x80, 0xc3, 0x41, 0x4a, 0x8d, 0x08, 0x59, 0xdc, 0x65, 0xa4, 0x61, 0x28, 0xba,
	   0xb2, 0x7a, 0xf8, 0x7a, 0x71, 0x31, 0x4f, 0x31, 0x8c, 0x78, 0x2b, 0x23, 0xeb, 0xfe, 0x80, 0x8b,
	   0x82, 0xb0, 0xce, 0x26, 0x40, 0x1d, 0x2e, 0x22, 0xf0, 0x4d, 0x83, 0xd1, 0x25, 0x5d, 0xc5, 0x1a,
	   0xdd, 0xd3, 0xb7, 0x5a, 0x2b, 0x1a, 0xe0, 0x78, 0x45, 0x04, 0xdf, 0x54, 0x3a, 0xf8, 0x96, 0x9b,
	   0xe3, 0xea, 0x70, 0x82, 0xff, 0x7f, 0xc9, 0x88, 0x8c, 0x14, 0x4d, 0xa2, 0xaf, 0x58, 0x42, 0x9e,
	   0xc9, 0x60, 0x31, 0xdb, 0xca, 0xd3, 0xda, 0xd9, 0xaf, 0x0d, 0xcb, 0xaa, 0xaf, 0x26, 0x8c, 0xb8,
	   0xfc, 0xff, 0xea, 0xd9, 0x4f, 0x3c, 0x7c, 0xa4, 0x95, 0xe0, 0x56, 0xa9, 0xb4, 0x7a, 0xcd, 0xb7,
	   0x51, 0xfb, 0x73, 0xe6, 0x66, 0xc6, 0xc6, 0x55, 0xad, 0xe8, 0x29, 0x72, 0x97, 0xd0, 0x7a, 0xd1,
	   0xba, 0x5e, 0x43, 0xf1, 0xbc, 0xa3, 0x23, 0x01, 0x65, 0x13, 0x39, 0xe2, 0x29, 0x04, 0xcc, 0x8c,
	   0x42, 0xf5, 0x8c, 0x30, 0xc0, 0x4a, 0xaf, 0xdb, 0x03, 0x8d, 0xda, 0x08, 0x47, 0xdd, 0x98, 0x8d,
	   0xcd, 0xa6, 0xf3, 0xbf, 0xd1, 0x5c, 0x4b, 0x4c, 0x45, 0x25, 0x00, 0x4a, 0xa0, 0x6e, 0xef, 0xf8,
	   0xca, 0x61, 0x78, 0x3a, 0xac, 0xec, 0x57, 0xfb, 0x3d, 0x1f, 0x92, 0xb0, 0xfe, 0x2f, 0xd1, 0xa8,
	   0x5f, 0x67, 0x24, 0x51, 0x7b, 0x65, 0xe6, 0x14, 0xad, 0x68, 0x08, 0xd6, 0xf6, 0xee, 0x34, 0xdf,
	   0xf7, 0x31, 0x0f, 0xdc, 0x82, 0xae, 0xbf, 0xd9, 0x04, 0xb0, 0x1e, 0x1d, 0xc5, 0x4b, 0x29, 0x27,
	   0x09, 0x4b, 0x2d, 0xb6, 0x8d, 0x6f, 0x90, 0x3b, 0x68, 0x40, 0x1a, 0xde, 0xbf, 0x5a, 0x7e, 0x08,
	   0xd7, 0x8f, 0xf4, 0xef, 0x5d, 0x63, 0x65, 0x3a, 0x65, 0x04, 0x0c, 0xf9, 0xbf, 0xd4, 0xac, 0xa7,
	   0x98, 0x4a, 0x74, 0xd3, 0x71, 0x45, 0x98, 0x67, 0x80, 0xfc, 0x0b, 0x16, 0xac, 0x45, 0x16, 0x49,
	   0xde, 0x61, 0x88, 0xa7, 0xdb, 0xdf, 0x19, 0x1f, 0x64, 0xb5, 0xfc, 0x5e, 0x2a, 0xb4, 0x7b, 0x57,
	   0xf7, 0xf7, 0x27, 0x6c, 0xd4, 0x19, 0xc1, 0x7a, 0x3c, 0xa8, 0xe1, 0xb9, 0x39, 0xae, 0x49, 0xe4,
	   0x88, 0xac, 0xba, 0x6b, 0x96, 0x56, 0x10, 0xb5, 0x48, 0x01, 0x09, 0xc8, 0xb1, 0x7b, 0x80, 0xe1,
	   0xb7, 0xb7, 0x50, 0xdf, 0xc7, 0x59, 0x8d, 0x5d, 0x50, 0x11, 0xfd, 0x2d, 0xcc, 0x56, 0x00, 0xa3,
	   0x2e, 0xf5, 0xb5, 0x2a, 0x1e, 0xcc, 0x82, 0x0e, 0x30, 0x8a, 0xa3, 0x42, 0x72, 0x1a, 0xac, 0x09,
	   0x43, 0xbf, 0x66, 0x86, 0xb6, 0x4b, 0x25, 0x79, 0x37, 0x65, 0x04, 0xcc, 0xc4, 0x93, 0xd9, 0x7e,
	   0x6a, 0xed, 0x3f, 0xb0, 0xf9, 0xcd, 0x71, 0xa4, 0x3d, 0xd4, 0x97, 0xf0, 0x1f, 0x17, 0xc0, 0xe2,
	   0xcb, 0x37, 0x97, 0xaa, 0x2a, 0x2f, 0x25, 0x66, 0x56, 0x16, 0x8e, 0x6c, 0x49, 0x6a, 0xfc, 0x5f,
	   0xb9, 0x32, 0x46, 0xf6, 0xb1, 0x11, 0x63, 0x98, 0xa3, 0x46, 0xf1, 0xa6, 0x41, 0xf3, 0xb0, 0x41,
	   0xe9, 0x89, 0xf7, 0x91, 0x4f, 0x90, 0xcc, 0x2c, 0x7f, 0xff, 0x35, 0x78, 0x76, 0xe5, 0x06, 0xb5,
	   0x0d, 0x33, 0x4b, 0xa7, 0x7c, 0x22, 0x5b, 0xc3, 0x07, 0xba, 0x53, 0x71, 0x52, 0xf3, 0xf1, 0x61,
	   0x0e, 0x4e, 0xaf, 0xe5, 0x95, 0xf6, 0xd9, 0xd9, 0x0d, 0x11, 0xfa, 0xa9, 0x33, 0xa1, 0x5e, 0xf1,
	   0x36, 0x95, 0x46, 0x86, 0x8a, 0x7f, 0x3a, 0x45, 0xa9, 0x67, 0x68, 0xd4, 0x0f, 0xd9, 0xd0, 0x34,
	   0x12, 0xc0, 0x91, 0xc6, 0x31, 0x5c, 0xf4, 0xfd, 0xe7, 0xcb, 0x68, 0x60, 0x69, 0x37, 0x38, 0x0d,
	   0xb2, 0xea, 0xaa, 0x70, 0x7b, 0x4c, 0x41, 0x85, 0xc3, 0x2e, 0xdd, 0xcd, 0xd3, 0x06, 0x70, 0x5e,
	   0x4d, 0xc1, 0xff, 0xc8, 0x72, 0xee, 0xee, 0x47, 0x5a, 0x64, 0xdf, 0xac, 0x86, 0xab, 0xa4, 0x1c,
	   0x06, 0x18, 0x98, 0x3f, 0x87, 0x41, 0xc5, 0xef, 0x68, 0xd3, 0xa1, 0x01, 0xe8, 0xa3, 0xb8, 0xca,
	   0xc6, 0x0c, 0x90, 0x5c, 0x15, 0xfc, 0x91, 0x08, 0x40, 0xb9, 0x4c, 0x00, 0xa0, 0xb9, 0xd0,
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
	  /* enc(R) */
	  0x0a, 0xab, 0x4c, 0x90, 0x05, 0x01, 0xb3, 0xe2, 0x4d, 0x7c, 0xdf, 0x46, 0x63, 0x32, 0x6a, 0x3a,
	  0x87, 0xdf, 0x5e, 0x48, 0x43, 0xb2, 0xcb, 0xdb, 0x67, 0xcb, 0xf6, 0xe4, 0x60, 0xfe, 0xc3, 0x50,
	  /* enc(S) */
	  0xaa, 0x53, 0x71, 0xb1, 0x50, 0x8f, 0x9f, 0x45, 0x28, 0xec, 0xea, 0x23, 0xc4, 0x36, 0xd9, 0x4b,
	  0x5e, 0x8f, 0xcd, 0x4f, 0x68, 0x1e, 0x30, 0xa6, 0xac, 0x00, 0xa9, 0x70, 0x4a, 0x18, 0x8a, 0x03,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0x27, 0x81, 0x17, 0xfc, 0x14, 0x4c, 0x72, 0x34,
					0x0f, 0x67, 0xd0, 0xf2, 0x31, 0x6e, 0x83, 0x86,
					0xce, 0xff, 0xbf, 0x2b, 0x24, 0x28, 0xc9, 0xc5,
					0x1f, 0xef, 0x7c, 0x59, 0x7f, 0x1d, 0x42, 0x6e,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	se_util_mem_set((uint8_t *)&arg, 0U, sizeof_u32(arg));

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* ED25519 twisted edwards lwrve signature verification test
 *
 * Test vector data is from RFC-8032 (TEST SHA(abc): message length 64 (== SHA-512 digest of "abc")
 */
static status_t TEST_ED25519_verify_test_sha_abc(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t message[64] = {
	  0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,
	  0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2, 0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,
	  0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8, 0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
	  0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f,
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
	 0xdc, 0x2a, 0x44, 0x59, 0xe7, 0x36, 0x96, 0x33, 0xa5, 0x2b, 0x1b, 0xf2, 0x77, 0x83, 0x9a, 0x00,
	 0x20, 0x10, 0x09, 0xa3, 0xef, 0xbf, 0x3e, 0xcb, 0x69, 0xbe, 0xa2, 0x18, 0x6c, 0x26, 0xb5, 0x89,
		/* enc(S) */
	 0x09, 0x35, 0x1f, 0xc9, 0xac, 0x90, 0xb3, 0xec, 0xfd, 0xfb, 0xc7, 0xc6, 0x64, 0x31, 0xe0, 0x30,
	 0x3d, 0xca, 0x17, 0x9c, 0x13, 0x8a, 0xc1, 0x7a, 0xd9, 0xbe, 0xf1, 0x17, 0x73, 0x31, 0xa7, 0x04,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xec, 0x17, 0x2b, 0x93, 0xad, 0x5e, 0x56, 0x3b,
					0xf4, 0x93, 0x2c, 0x70, 0xe1, 0x24, 0x50, 0x34,
					0xc3, 0x54, 0x67, 0xef, 0x2e, 0xfd, 0x4d, 0x64,
					0xeb, 0xf8, 0x19, 0x68, 0x34, 0x67, 0xe2, 0xbf,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#if CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY

#define PASS_EC_KEYSLOT 3U

static status_t TEST_ED25519_verify_test_sha_abc_pass_ks(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t message[64] = {
	  0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,
	  0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2, 0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,
	  0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8, 0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
	  0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f,
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
	 0xdc, 0x2a, 0x44, 0x59, 0xe7, 0x36, 0x96, 0x33, 0xa5, 0x2b, 0x1b, 0xf2, 0x77, 0x83, 0x9a, 0x00,
	 0x20, 0x10, 0x09, 0xa3, 0xef, 0xbf, 0x3e, 0xcb, 0x69, 0xbe, 0xa2, 0x18, 0x6c, 0x26, 0xb5, 0x89,
		/* enc(S) */
	 0x09, 0x35, 0x1f, 0xc9, 0xac, 0x90, 0xb3, 0xec, 0xfd, 0xfb, 0xc7, 0xc6, 0x64, 0x31, 0xe0, 0x30,
	 0x3d, 0xca, 0x17, 0x9c, 0x13, 0x8a, 0xc1, 0x7a, 0xd9, 0xbe, 0xf1, 0x17, 0x73, 0x31, 0xa7, 0x04,
	};

	static const te_ec_point_t passed_pubkey = {
		.ed25519_compressed_point = {
			0xec, 0x17, 0x2b, 0x93, 0xad, 0x5e, 0x56, 0x3b,
			0xf4, 0x93, 0x2c, 0x70, 0xe1, 0x24, 0x50, 0x34,
			0xc3, 0x54, 0x67, 0xef, 0x2e, 0xfd, 0x4d, 0x64,
			0xeb, 0xf8, 0x19, 0x68, 0x34, 0x67, 0xe2, 0xbf,
		},
		.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = PASS_EC_KEYSLOT,
		.k_ec_public = {
			.pubkey = {
				.point_flags = (CCC_EC_POINT_FLAG_COMPRESSED_ED25519 |
						CCC_EC_POINT_FLAG_UNDEFINED |
						CCC_EC_POINT_FLAG_IN_KEYSLOT),
			},
		},
	};

	/* Write passed_pubkey compressed point to ec_keyslot.
	 */
	{
		ret = pka1_write_ec_point_keyslot(eid,
						  PASS_EC_KEYSLOT,
						  TE_LWRVE_ED25519,
						  &passed_pubkey);
		CCC_ERROR_CHECK(ret);
	}

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY */

/* ED25519 twisted edwards lwrve signature verification test
 *
 * Test vector data is from RFC-8032 (TEST prehash: message length 64 (== SHA-512 digest of "abc")
 *
 * TEST SHA(abc)
 */
static status_t TEST_ED25519_verify_test_PH(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* SHA512(abc) == PH(message) */
	uint8_t message[] = {
	  0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,
	  0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2, 0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,
	  0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8, 0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
	  0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f,
	};

	/* Little endian ED25519PH signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
		0x98, 0xa7, 0x02, 0x22, 0xf0, 0xb8, 0x12, 0x1a,
		0xa9, 0xd3, 0x0f, 0x81, 0x3d, 0x68, 0x3f, 0x80,
		0x9e, 0x46, 0x2b, 0x46, 0x9c, 0x7f, 0xf8, 0x76,
		0x39, 0x49, 0x9b, 0xb9, 0x4e, 0x6d, 0xae, 0x41,
		/* enc(S) */
		0x31, 0xf8, 0x50, 0x42, 0x46, 0x3c, 0x2a, 0x35,
		0x5a, 0x20, 0x03, 0xd0, 0x62, 0xad, 0xf5, 0xaa,
		0xa1, 0x0b, 0x8c, 0x61, 0xe6, 0x36, 0x06, 0x2a,
		0xaa, 0xd1, 0x1c, 0x2a, 0x26, 0x08, 0x34, 0x06,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xec, 0x17, 0x2b, 0x93, 0xad, 0x5e, 0x56, 0x3b,
					0xf4, 0x93, 0x2c, 0x70, 0xe1, 0x24, 0x50, 0x34,
					0xc3, 0x54, 0x67, 0xef, 0x2e, 0xfd, 0x4d, 0x64,
					0xeb, 0xf8, 0x19, 0x68, 0x34, 0x67, 0xe2, 0xbf,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519PH);

	if (algo != TE_ALG_ED25519PH) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519PH for the prehash ED25519PH verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	               = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519PH verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519PH[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519PH signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519PH signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

#define HAVE_ED_PKEY 1

#if HAVE_ED_PKEY
static status_t TEST_ED25519_verify_test1_derive(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
	  0xe5, 0x56, 0x43, 0x00, 0xc3, 0x60, 0xac, 0x72, 0x90, 0x86, 0xe2, 0xcc, 0x80, 0x6e, 0x82, 0x8a,
	  0x84, 0x87, 0x7f, 0x1e, 0xb8, 0xe5, 0xd9, 0x74, 0xd8, 0x73, 0xe0, 0x65, 0x22, 0x49, 0x01, 0x55,
		/* enc(S) */
	  0x5f, 0xb8, 0x82, 0x15, 0x90, 0xa3, 0x3b, 0xac, 0xc6, 0x1e, 0x39, 0x70, 0x1c, 0xf9, 0xb4, 0x6b,
	  0xd2, 0x5b, 0xf5, 0xf0, 0x59, 0x5b, 0xbe, 0x24, 0x65, 0x51, 0x41, 0x43, 0x8e, 0x7a, 0x10, 0x0b,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {

		.k_keyslot = 3U,	// XXX not supported yet

#if HAVE_ED_PKEY == 0
		/* This compressed point tested in TEST_ED25519_verify_test1_compressed
		 * where the key is not derived from private key
		 */
		.k_flags     = KEY_FLAG_PLAIN,
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xd7, 0x5a, 0x98, 0x01, 0x82, 0xb1, 0x0a, 0xb7,
					0xd5, 0x4b, 0xfe, 0xd3, 0xc9, 0x64, 0x07, 0x3a,
					0x0e, 0xe1, 0x72, 0xf3, 0xda, 0xa6, 0x23, 0x25,
					0xaf, 0x02, 0x1a, 0x68, 0xf7, 0x07, 0x51, 0x1a,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
#else
		/* Provide a private key => pubkey is generated internally */
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_ec_private = {
			.pubkey = {
				.x = { 0x0 },
				.y = { 0x0 },
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},
			.key = {
				0x9d, 0x61, 0xb1, 0x9d, 0xef, 0xfd, 0x5a, 0x60,
				0xba, 0x84, 0x4a, 0xf4, 0x92, 0xec, 0x2c, 0xc4,
				0x44, 0x49, 0xc5, 0x69, 0x7b, 0x32, 0x69, 0x19,
				0x70, 0x3b, 0xac, 0x03, 0x1c, 0xae, 0x7f, 0x60,
			},
			.key_length = 32U,
		},
#endif
	};

	LOG_ALWAYS("TESTING EDDSA PRIVATE KEY VALIDATION (callwlated pubkey)\n");

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = 0U;
	arg.ca_data.src	       = NULL;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) NULL message length with ZERO bytes\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}
#endif /* HAVE_ED_PKEY */

static status_t TEST_ED25519_verify_test1_compressed(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
	  0xe5, 0x56, 0x43, 0x00, 0xc3, 0x60, 0xac, 0x72, 0x90, 0x86, 0xe2, 0xcc, 0x80, 0x6e, 0x82, 0x8a,
	  0x84, 0x87, 0x7f, 0x1e, 0xb8, 0xe5, 0xd9, 0x74, 0xd8, 0x73, 0xe0, 0x65, 0x22, 0x49, 0x01, 0x55,
		/* enc(S) */
	  0x5f, 0xb8, 0x82, 0x15, 0x90, 0xa3, 0x3b, 0xac, 0xc6, 0x1e, 0x39, 0x70, 0x1c, 0xf9, 0xb4, 0x6b,
	  0xd2, 0x5b, 0xf5, 0xf0, 0x59, 0x5b, 0xbe, 0x24, 0x65, 0x51, 0x41, 0x43, 0x8e, 0x7a, 0x10, 0x0b,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {

		.k_keyslot = 3U,	// XXX not supported yet

		.k_flags     = KEY_FLAG_PLAIN,
		.k_key_type  = KEY_TYPE_EC_PUBLIC,
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xd7, 0x5a, 0x98, 0x01, 0x82, 0xb1, 0x0a, 0xb7,
					0xd5, 0x4b, 0xfe, 0xd3, 0xc9, 0x64, 0x07, 0x3a,
					0x0e, 0xe1, 0x72, 0xf3, 0xda, 0xa6, 0x23, 0x25,
					0xaf, 0x02, 0x1a, 0x68, 0xf7, 0x07, 0x51, 0x1a,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = 0U;
	arg.ca_data.src	       = NULL;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) NULL message length with ZERO bytes\n",
		 algo);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

static status_t TEST_ED25519_verify_test2(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	uint8_t message[1] = {
		0x72
	};

	/* Little endian ED25519 signature
	 */
	static uint8_t signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
	  0x92, 0xa0, 0x09, 0xa9, 0xf0, 0xd4, 0xca, 0xb8, 0x72, 0x0e, 0x82, 0x0b, 0x5f, 0x64, 0x25, 0x40,
	  0xa2, 0xb2, 0x7b, 0x54, 0x16, 0x50, 0x3f, 0x8f, 0xb3, 0x76, 0x22, 0x23, 0xeb, 0xdb, 0x69, 0xda,
		/* enc(S) */
	  0x08, 0x5a, 0xc1, 0xe4, 0x3e, 0x15, 0x99, 0x6e, 0x45, 0x8f, 0x36, 0x13, 0xd0, 0xf1, 0x1d, 0x8c,
	  0x38, 0x7b, 0x2e, 0xae, 0xb4, 0x30, 0x2a, 0xee, 0xb0, 0x0d, 0x29, 0x16, 0x12, 0xbb, 0x0c, 0x00,
	};

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0x3d, 0x40, 0x17, 0xc3, 0xe8, 0x43, 0x89, 0x5a,
					0x92, 0xb7, 0x0a, 0xa7, 0x4d, 0x1b, 0x7e, 0xbc,
					0x9c, 0x98, 0x2c, 0xcf, 0x2e, 0xc4, 0x96, 0x8c,
					0xc0, 0xcd, 0x55, 0xf1, 0x2a, 0xf4, 0x66, 0x0c
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519);

	if (algo != TE_ALG_ED25519) {
		CCC_ERROR_WITH_ECODE(ERR_ILWALID_ARGS,
				     LOG_ERROR("Algo 0x%x must be TE_ALG_ED25519 for the ED25519 verify test\n", algo));
	}

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = sizeof_u32(message);
	arg.ca_data.src	       = message;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519 verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, sizeof_u32(message));

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d, attached handle: %u\n",
		 algo, ret, arg.ca_handle);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* Verify signatures with TE_ALG_ED25519CTX
 */
static status_t ed25519_ctx_test(crypto_context_t *c, te_crypto_algo_t algo,
				 engine_id_t eid,
				 te_args_key_data_t *akey,
				 const uint8_t *signature,
				 const uint8_t *message,
				 uint32_t msg_len,
				 const uint8_t *ctx,
				 uint32_t ctx_len)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	(void)algo;

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, TE_ALG_ED25519CTX);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = TE_ALG_ED25519CTX;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	if ((NULL != ctx) && (ctx_len > 0U)) {
		if (ctx_len > MAX_ECC_DOM_CONTEXT_SIZE) {
			CCC_ERROR_WITH_ECODE(ERR_BAD_LEN);
		}

		se_util_mem_move(&arg.ca_init.ec.dom_context.value[0],
				 ctx, ctx_len);
		arg.ca_init.ec.dom_context.length = ctx_len;
	}

	LOG_INFO("Hint: use engine 0x%x (%s) for ED25519CTX, eddsa lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = akey;

	arg.ca_data.src_size	       = msg_len;
	arg.ca_data.src	               = message;
	arg.ca_data.src_signature_size = CCC_ED25519_SIGNATURE_SIZE;
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519CTX verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 TE_ALG_ED25519CTX, msg_len);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519CTX[0x%x] (COMBINED OPERATION) ret %d\n",
		 TE_ALG_ED25519CTX, ret);

	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519CTX signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519PH signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

/* ED25519CTX tests cases from RFC-8032
 */
static status_t TEST_ED25519_verify_test_CTX(crypto_context_t *crypto_ctx,
					     te_crypto_algo_t algo,
					     engine_id_t eid)
{
	status_t ret = NO_ERROR;

	static te_args_key_data_t akey = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0xdf, 0xc9, 0x42, 0x5e, 0x4f, 0x96, 0x8f, 0x7f,
					0x0c, 0x29, 0xf0, 0x25, 0x9c, 0xf5, 0xf9, 0xae,
					0xd6, 0x85, 0x1c, 0x2b, 0xb4, 0xad, 0x8b, 0xfb,
					0x86, 0x0c, 0xfe, 0xe0, 0xab, 0x24, 0x82, 0x92,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	/* -----foo */
	const uint8_t message_foo[] = {
		0xf7, 0x26, 0x93, 0x6d, 0x19, 0xc8, 0x00, 0x49,
		0x4e, 0x3f, 0xda, 0xff, 0x20, 0xb2, 0x76, 0xa8,
	};

	const uint8_t ctx_foo[] = {
		0x66, 0x6f, 0x6f,
	};

	static const uint8_t signature_foo[] = {
		0x55, 0xa4, 0xcc, 0x2f, 0x70, 0xa5, 0x4e, 0x04,
		0x28, 0x8c, 0x5f, 0x4c, 0xd1, 0xe4, 0x5a, 0x7b,
		0xb5, 0x20, 0xb3, 0x62, 0x92, 0x91, 0x18, 0x76,
		0xca, 0xda, 0x73, 0x23, 0x19, 0x8d, 0xd8, 0x7a,
		0x8b, 0x36, 0x95, 0x0b, 0x95, 0x13, 0x00, 0x22,
		0x90, 0x7a, 0x7f, 0xb7, 0xc4, 0xe9, 0xb2, 0xd5,
		0xf6, 0xcc, 0xa6, 0x85, 0xa5, 0x87, 0xb4, 0xb2,
		0x1f, 0x4b, 0x88, 0x8e, 0x4e, 0x7e, 0xdb, 0x0d,
	};

	TEST_ERRCHK(ed25519_ctx_test, eid, algo,
		    &akey, signature_foo, message_foo, sizeof_u32(message_foo),
		    ctx_foo, sizeof_u32(ctx_foo));

	/* -----bar */

	const uint8_t ctx_bar[] = {
		0x62, 0x61, 0x72,
	};

	static const uint8_t signature_bar[] = {
		0xfc, 0x60, 0xd5, 0x87, 0x2f, 0xc4, 0x6b, 0x3a,
		0xa6, 0x9f, 0x8b, 0x5b, 0x43, 0x51, 0xd5, 0x80,
		0x8f, 0x92, 0xbc, 0xc0, 0x44, 0x60, 0x6d, 0xb0,
		0x97, 0xab, 0xab, 0x6d, 0xbc, 0xb1, 0xae, 0xe3,
		0x21, 0x6c, 0x48, 0xe8, 0xb3, 0xb6, 0x64, 0x31,
		0xb5, 0xb1, 0x86, 0xd1, 0xd2, 0x8f, 0x8e, 0xe1,
		0x5a, 0x5c, 0xa2, 0xdf, 0x66, 0x68, 0x34, 0x62,
		0x91, 0xc2, 0x04, 0x3d, 0x4e, 0xb3, 0xe9, 0x0d,
	};

	TEST_ERRCHK(ed25519_ctx_test, eid, algo,
		    &akey, signature_bar, message_foo, sizeof_u32(message_foo),
		    ctx_bar, sizeof_u32(ctx_bar));

	/* -----foo2 */

	const uint8_t message_foo2[] = {
		0x50, 0x8e, 0x9e, 0x68, 0x82, 0xb9, 0x79, 0xfe,
		0xa9, 0x00, 0xf6, 0x2a, 0xdc, 0xea, 0xca, 0x35,
	};

	static const uint8_t signature_foo2[] = {
		0x8b, 0x70, 0xc1, 0xcc, 0x83, 0x10, 0xe1, 0xde,
		0x20, 0xac, 0x53, 0xce, 0x28, 0xae, 0x6e, 0x72,
		0x07, 0xf3, 0x3c, 0x32, 0x95, 0xe0, 0x3b, 0xb5,
		0xc0, 0x73, 0x2a, 0x1d, 0x20, 0xdc, 0x64, 0x90,
		0x89, 0x22, 0xa8, 0xb0, 0x52, 0xcf, 0x99, 0xb7,
		0xc4, 0xfe, 0x10, 0x7a, 0x5a, 0xbb, 0x5b, 0x2c,
		0x40, 0x85, 0xae, 0x75, 0x89, 0x0d, 0x02, 0xdf,
		0x26, 0x26, 0x9d, 0x89, 0x45, 0xf8, 0x4b, 0x0b,
	};

	TEST_ERRCHK(ed25519_ctx_test, CCC_ENGINE_ANY, TE_ALG_ED25519CTX,
		    &akey, signature_foo2, message_foo2, sizeof_u32(message_foo2),
		    ctx_foo, sizeof_u32(ctx_foo));

	/* -----foo3 */

	static te_args_key_data_t akey3 = {
		.k_key_type  = KEY_TYPE_EC_PUBLIC,

		.k_flags     = KEY_FLAG_PLAIN,
		.k_keyslot = 3U,	// XXX not supported yet
		.k_ec_public = {
			.pubkey = {
				.ed25519_compressed_point = {
					0x0f, 0x1d, 0x12, 0x74, 0x94, 0x3b, 0x91, 0x41,
					0x58, 0x89, 0x15, 0x2e, 0x89, 0x3d, 0x80, 0xe9,
					0x32, 0x75, 0xa1, 0xfc, 0x0b, 0x65, 0xfd, 0x71,
					0xb4, 0xb0, 0xdd, 0xa1, 0x0a, 0xd7, 0xd7, 0x72,
				},
				.point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
			},
		},
	};

	static const uint8_t signature_foo3[] = {
		0x21, 0x65, 0x5b, 0x5f, 0x1a, 0xa9, 0x65, 0x99,
		0x6b, 0x3f, 0x97, 0xb3, 0xc8, 0x49, 0xea, 0xfb,
		0xa9, 0x22, 0xa0, 0xa6, 0x29, 0x92, 0xf7, 0x3b,
		0x3d, 0x1b, 0x73, 0x10, 0x6a, 0x84, 0xad, 0x85,
		0xe9, 0xb8, 0x6a, 0x7b, 0x60, 0x05, 0xea, 0x86,
		0x83, 0x37, 0xff, 0x2d, 0x20, 0xa7, 0xf5, 0xfb,
		0xd4, 0xcd, 0x10, 0xb0, 0xbe, 0x49, 0xa6, 0x8d,
		0xa2, 0xb2, 0xe0, 0xdc, 0x0a, 0xd8, 0x96, 0x0f,
	};

	TEST_ERRCHK(ed25519_ctx_test, CCC_ENGINE_ANY, TE_ALG_ED25519CTX,
		    &akey3, signature_foo3, message_foo, sizeof_u32(message_foo),
		    ctx_foo, sizeof_u32(ctx_foo));

	LOG_INFO("ED25519CTX signature OK\n");

fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519CTX signature verification tests FAILED\n");
	}
	return ret;
}

status_t run_ed25519_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

#if CCC_WITH_PASS_EC_PUBKEY_IN_KEYSLOT && HAVE_WRITE_PKA1_EC_KEYSLOT_PUBKEY
	TEST_ERRCHK(TEST_ED25519_verify_test_sha_abc_pass_ks, CCC_ENGINE_ANY, TE_ALG_ED25519);
#endif

	TEST_ERRCHK(TEST_ED25519_verify_test1001, CCC_ENGINE_ANY, TE_ALG_ED25519);
#if HAVE_ED_PKEY
	TEST_ERRCHK(TEST_ED25519_verify_test1_derive, CCC_ENGINE_ANY, TE_ALG_ED25519);
#endif
	TEST_ERRCHK(TEST_ED25519_verify_test1_compressed, CCC_ENGINE_ANY, TE_ALG_ED25519);
	TEST_ERRCHK(TEST_ED25519_verify_test2, CCC_ENGINE_ANY, TE_ALG_ED25519);
	TEST_ERRCHK(TEST_ED25519_verify_test3, CCC_ENGINE_ANY, TE_ALG_ED25519);
	TEST_ERRCHK(TEST_ED25519_verify_test4, CCC_ENGINE_ANY, TE_ALG_ED25519);
	TEST_ERRCHK(TEST_ED25519_verify_test_sha_abc, CCC_ENGINE_ANY, TE_ALG_ED25519);

	/* Message is a PRE-HASH value (RFC-8032) */
	TEST_ERRCHK(TEST_ED25519_verify_test_PH, CCC_ENGINE_ANY, TE_ALG_ED25519PH);

	/* ED25519CTX with non-empty context */
	TEST_ERRCHK(TEST_ED25519_verify_test_CTX, CCC_ENGINE_ANY, TE_ALG_ED25519CTX);
fail:
	return ret;
}
#endif /* TEST_ED25519 */

#ifdef TEST_ED25519_SIGN
static status_t TEST_ED25519_sign_verify(crypto_context_t *c, te_crypto_algo_t algo, engine_id_t eid,
					 const uint8_t *msg,
					 uint32_t msg_len,
					 const uint8_t *correct_signature,
					 const uint8_t *ctx,
					 uint32_t ctx_len)
{
	status_t ret = NO_ERROR;
	te_crypto_args_t arg = { .ca_handle = 0U, };

	/* Little endian ED25519 signature
	 */
	uint8_t signature[CCC_ED25519_SIGNATURE_SIZE];

	/* Compressed pubkey for the private key below:
	 * .ed25519_compressed_point = {
	 *    0xd7, 0x5a, 0x98, 0x01, 0x82, 0xb1, 0x0a, 0xb7,
	 *    0xd5, 0x4b, 0xfe, 0xd3, 0xc9, 0x64, 0x07, 0x3a,
	 *    0x0e, 0xe1, 0x72, 0xf3, 0xda, 0xa6, 0x23, 0x25,
	 *    0xaf, 0x02, 0x1a, 0x68, 0xf7, 0x07, 0x51, 0x1a,
	 * },
	 * .point_flags = CCC_EC_POINT_FLAG_COMPRESSED_ED25519,
	 */

	/* Lwrve is selected with init parameters, the keys need to be valid for the
	 * selected lwrve.
	 */
	static te_args_key_data_t akey = {

		.k_keyslot = 3U,	// XXX PKA1 EC keyslots not usable for this

		/* Provide a private key => pubkey is generated internally
		 */
		.k_flags     = KEY_FLAG_PLAIN | KEY_FLAG_LITTLE_ENDIAN,
		.k_key_type  = KEY_TYPE_EC_PRIVATE,
		.k_ec_private = {
			.pubkey = {
				.point_flags = CCC_EC_POINT_FLAG_UNDEFINED,
			},

			/* Private key is a 32 byte random number
			 */
			.key = {
				0x9d, 0x61, 0xb1, 0x9d, 0xef, 0xfd, 0x5a, 0x60,
				0xba, 0x84, 0x4a, 0xf4, 0x92, 0xec, 0x2c, 0xc4,
				0x44, 0x49, 0xc5, 0x69, 0x7b, 0x32, 0x69, 0x19,
				0x70, 0x3b, 0xac, 0x03, 0x1c, 0xae, 0x7f, 0x60,
			},
			.key_length = 32U,
		},
	};

	LOG_ALWAYS("ED25519(xxx) signing && verify (pubkey callwlated)\n");

	/* Generate signature */

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_SIGN, algo);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_SIGN;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;		    /* Pass the engine selector hint in init generics */

	/* This algo does not use the context, but push it to the call just to
	 * see it has no effect. Verify does not push this below.
	 */
	if ((NULL != ctx) && (ctx_len > 0U)) {
		if (ctx_len > MAX_ECC_DOM_CONTEXT_SIZE) {
			CCC_ERROR_WITH_ECODE(ERR_BAD_LEN);
		}

		se_util_mem_move(&arg.ca_init.ec.dom_context.value[0],
				 ctx, ctx_len);
		arg.ca_init.ec.dom_context.length = ctx_len;
	}

	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size = msg_len;
	arg.ca_data.src	     = msg;
	arg.ca_data.dst_size = sizeof_u32(signature);
	arg.ca_data.dst      = signature;

	LOG_INFO("ED25519(xxx) sign[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, msg_len);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519 sign[0x%x] (COMBINED OPERATION) ret %d\n", algo, ret);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519(xxx) signature created OK\n");

	CRYPTO_CONTEXT_RESET(c);

	DUMP_HEX("Created ED25519(xxx) signature:", signature, arg.ca_data.dst_size);

	if (NULL != correct_signature) {
		VERIFY_ARRAY_VALUE(signature, correct_signature, sizeof_u32(signature));
	}

	/* Verify signature generated above */

	CRYPTO_CONTEXT_SETUP(c, TE_ALG_MODE_VERIFY, algo);

	/* Preset fields */
	arg.ca_alg_mode = TE_ALG_MODE_VERIFY;
	arg.ca_algo     = algo;
	arg.ca_opcode   = TE_OP_COMBINED_OPERATION;

	arg.ca_init.ec.flags    = INIT_FLAG_EC_NONE;
	arg.ca_init.ec.lwrve_id = TE_LWRVE_ED25519; /* Edwards twisted lwrve ED25519 */
	arg.ca_init.engine_hint = eid;

	/* Do not push the context to the call here on verify, ctx must not
	 * affect this result.
	 */
	LOG_INFO("Hint: use engine 0x%x (%s) for EDDSA lwrve %u\n", eid, eid_name(eid),
		 arg.ca_init.ec.lwrve_id);

	/* Pass the key params */
	arg.ca_set_key.kdata = &akey;

	arg.ca_data.src_size	       = msg_len;
	arg.ca_data.src		       = msg;
	arg.ca_data.src_signature_size = sizeof_u32(signature);
	arg.ca_data.src_signature      = signature;

	LOG_INFO("ED25519(xxx) verify[0x%x] (COMBINED OPERATION) message length %u bytes\n",
		 algo, msg_len);

	ret = CRYPTO_OPERATION(c, &arg);

	LOG_INFO("Operation used engine 0x%x (%s)\n",
		 arg.ca_init.engine_hint,
		 eid_name(arg.ca_init.engine_hint));

	LOG_INFO("ED25519[0x%x] (COMBINED OPERATION) ret %d\n", algo, ret);
	CCC_ERROR_CHECK(ret);

	LOG_INFO("ED25519 signature OK\n");
fail:
	if (NO_ERROR != ret) {
		LOG_INFO("ED25519 signature verification FAILED XXX\n");
	}
	CRYPTO_CONTEXT_RESET(c);
	return ret;
}

status_t run_ed25519_sign_verify_test_cases(crypto_context_t *crypto_ctx)
{
	status_t ret = NO_ERROR;

#if HAVE_ED25519_SIGN
	uint32_t inx = 0U;

	uint8_t null_signature[CCC_ED25519_SIGNATURE_SIZE] = {
		/* enc(R) */
		0xe5, 0x56, 0x43, 0x00, 0xc3, 0x60, 0xac, 0x72,
		0x90, 0x86, 0xe2, 0xcc, 0x80, 0x6e, 0x82, 0x8a,
		0x84, 0x87, 0x7f, 0x1e, 0xb8, 0xe5, 0xd9, 0x74,
		0xd8, 0x73, 0xe0, 0x65, 0x22, 0x49, 0x01, 0x55,
		/* enc(S) */
		0x5f, 0xb8, 0x82, 0x15, 0x90, 0xa3, 0x3b, 0xac,
		0xc6, 0x1e, 0x39, 0x70, 0x1c, 0xf9, 0xb4, 0x6b,
		0xd2, 0x5b, 0xf5, 0xf0, 0x59, 0x5b, 0xbe, 0x24,
		0x65, 0x51, 0x41, 0x43, 0x8e, 0x7a, 0x10, 0x0b,
	};

	TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519,
		    NULL, 0U,
		    null_signature, NULL, 0U);

	/* Pass 64 bytes of null sig as it would be SHA-512 digest
	 * ED25519PH must sign/verify
	 */
	TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519PH,
		    null_signature, 64U, /* Pass 64 bytes as message to sign */
		    NULL, NULL, 0U);

	TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519CTX,
		    NULL, 0U,
		    NULL, NULL, 0U);

	for (inx = 0U; inx < MAX_ECC_DOM_CONTEXT_SIZE; inx++) {
		/* dom2() context passed, but not used by this algorithm
		 */
		TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519,
			    null_signature, inx+16U,
			    NULL, null_signature, inx);
	}

	for (inx = 0U; inx < MAX_ECC_DOM_CONTEXT_SIZE; inx++) {
		/* Pass 64 bytes as message to sign, ED25519PH only signs 64 byte
		 * data chunks (it accepts SHA512 digest data only).
		 *
		 * dom2() context passed, but not used by this algorithm
		 */
		TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519PH,
			    null_signature, 64U,
			    NULL, null_signature, inx);
	}

	for (inx = 0U; inx < MAX_ECC_DOM_CONTEXT_SIZE; inx++) {
		TEST_ERRCHK(TEST_ED25519_sign_verify, CCC_ENGINE_ANY, TE_ALG_ED25519CTX,
			    null_signature, inx+16U,
			    NULL, null_signature, inx);
	}
#else
	TEST_EXPECT_RET(TEST_ED25519_sign_verify, ERR_NOT_SUPPORTED, CCC_ENGINE_ANY, TE_ALG_ED25519,
			NULL, 0U,
			NULL, NULL, 0U);
#endif /* HAVE_ED25519_SIGN */

fail:
	return ret;
}
#endif /* TEST_ED25519_SIGN */
#endif /* KERNEL_TEST_MODE */
