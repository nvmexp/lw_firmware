/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2020-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *
 * This code is for testing and libCCC usage purposes only!
 * Do not replicate blindly for production usecases. Consult with your local crypto expert!
 * 
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * */

/*
 * README:
 *
 * For GCM usage there are 2 major actions (encrypt & decrypt).
 * Each of these follows the generic workflow:
 * 1. Choose/Generate IV
 * 2. Initialize/Select Engine
 * 3. Handle Additional Data (AAD)
 * 4. Encrypt/Decrypt
 * 5. Repeat 3 & 4 for all packets in a given message (if as necessary)
 * 6. Generate Tag
 *      -  this is done by setting is_last = true, input/src = NULL, and aes_flags = AES_FLAGS_AE_FINALIZE_TAG
 *
 * AAD & encrypt/decrypt steps are interchangeable in order. These can also be
 * called multiple times to update the digest in the event that data to
 * process (encrypt/decrypt) comes in as some data stream.
 *
 * Once all of the data to encrypt/decrypt has been processed only then do you
 * generate the tag. For GCM attestation to pass the tag generated by
 * encryption must match the tag generated after decryption.
 *
 * each steps 3,4,6 will require separate calls to engine_aes_process_block_locked() 
 */


#include <lwriscv/gcc_attrs.h>
#include "debug.h"
#include "tegra_se.h"
#include "tegra_cdev.h"

#define GCM_KEY_BITS                        ((uint32_t)256)
#define GCM_KEY_BYTES                       ((uint32_t)(GCM_KEY_BITS >> 3))
#define PLAIN_TEXT_BYTES                    ((uint32_t)((SE_AES_BLOCK_LENGTH) << 1))
#define CTR_START_PROCESS_BIGENDIAN         ((uint32_t)0x01000000) // see comment in eng_aes_gcm_process_block_locked() for rationale
#define GCM_IV_SIZE_BYTES                   ((uint32_t)(12))
#define GCM_TAG_SIZE_BYTES                  ((uint32_t)(12))

#define GCM_HANDLE_AS_STREAM 0

/** @brief AES GCM Encryption API
 *
 * @param inputBuf: unencrypted data which should be encrypted
 * @param outputBuf: buffer to write encrypted ciphertext to
 * @param inputOutputBufLen: length of input/output buffers (these should be same length)
 * @param tagOutput: buffer to write GCM tag to
 * @param key: AES256 encryption key
 * @param iv: buffer containing random iv (96 bit)
 *
 * @note additional data is not used here
 *
 * @return NO_ERROR on success, error (from error_code.h) on failure
 */
static status_t gcm_encrypt(
    const uint8_t* inputBuf,
    uint8_t* outputBuf,
    uint32_t inputOutputBufLen,
    uint8_t* tagOutput,
    const uint8_t* key,
    const uint8_t* iv,
    const uint8_t* addData,
    uint32_t addLen);

/** @brief AES GCM Decryption API
 *
 * @param inputBuf: encrypted ciphertext data
 * @param outputBuf: buffer to write decrypted plaintext to
 * @param inputOutputBufLen: length of input/output buffers (these should be same length)
 * @param expectedTag: GCM tag necessary to decrypt
 * @param key: AES256 encryption key
 * @param iv: buffer containing random iv (96 bit)
 *
 * @note additional data is not used here
 *
 * @return NO_ERROR on success, error (from error_code.h) on failure
 */
static status_t gcm_decrypt(
    const uint8_t* inputBuf,
    uint8_t* outputBuf,
    uint32_t inputOutputBufLen,
    const uint8_t* expectedTag,
    const uint8_t* key,
    const uint8_t* iv,
    const uint8_t* addData,
    uint32_t addLen);

static void gcm_dumpAESMemory(
    struct se_engine_aes_context* econtext,
    struct se_data_params* input_params);

inline status_t gcm_processBlock(
    struct se_engine_aes_context* econtext,
    struct se_data_params* input_params,
    const uint8_t* srcBuf,
    uint8_t* dstBuf,
    uint32_t srcLen,
    uint32_t dstLen,
    const char* debugStr);

uint32_t verifyAesGcm(void)
{
    /*
        From https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/dolwments/mac/gcmtestvectors.zip

        [Keylen = 256]
        [IVlen = 96]
        [PTlen = 256]
        [AADlen = 128]
        [Taglen = 104]

        Count = 0
        Key = 48508a044214967c9dd9d96c31cb1b5bb9e9bd6b846acc9cf966fa77588be255
        IV = cdd7e89a53d165c9ca7d38cf
        CT = eea9af91339b6f8d0afb913e039a9942016f9bc81e766466f5edfb7e74aac294
        AAD = 2955f7e9f9f47e84679771693d06cb91
        Tag = 4a939d5ea73865063fcd38c2cd
        PT = ae653c27dd06e65cff5ae9699adb6e11b4822075e2e510a91a22996f9197a6d9
    */


    uint8_t Key[] = {0x48, 0x50, 0x8a, 0x04, 0x42, 0x14, 0x96, 0x7c, 0x9d, 0xd9, 0xd9, 0x6c, 0x31, 0xcb, 0x1b, 0x5b, 0xb9, 0xe9, 0xbd, 0x6b, 0x84, 0x6a, 0xcc, 0x9c, 0xf9, 0x66, 0xfa, 0x77, 0x58, 0x8b, 0xe2, 0x55};
    uint8_t IV[] = {0xcd, 0xd7, 0xe8, 0x9a, 0x53, 0xd1, 0x65, 0xc9, 0xca, 0x7d, 0x38, 0xcf};
    uint8_t CT[] = {0xee, 0xa9, 0xaf, 0x91, 0x33, 0x9b, 0x6f, 0x8d, 0x0a, 0xfb, 0x91, 0x3e, 0x03, 0x9a, 0x99, 0x42, 0x01, 0x6f, 0x9b, 0xc8, 0x1e, 0x76, 0x64, 0x66, 0xf5, 0xed, 0xfb, 0x7e, 0x74, 0xaa, 0xc2, 0x94};
    uint8_t AAD[] = {0x29, 0x55, 0xf7, 0xe9, 0xf9, 0xf4, 0x7e, 0x84, 0x67, 0x97, 0x71, 0x69, 0x3d, 0x06, 0xcb, 0x91};
    uint8_t Tag[] = {0x4a, 0x93, 0x9d, 0x5e, 0xa7, 0x38, 0x65, 0x06, 0x3f, 0xcd, 0x38, 0xc2, 0xcd};
    uint8_t PT[] = {0xae, 0x65, 0x3c, 0x27, 0xdd, 0x06, 0xe6, 0x5c, 0xff, 0x5a, 0xe9, 0x69, 0x9a, 0xdb, 0x6e, 0x11, 0xb4, 0x82, 0x20, 0x75, 0xe2, 0xe5, 0x10, 0xa9, 0x1a, 0x22, 0x99, 0x6f, 0x91, 0x97, 0xa6, 0xd9};

    uint8_t encryptedText[sizeof(PT)] = {0};
    uint8_t decryptedText[sizeof(PT)] = {0};
    uint8_t callwlatedTag[sizeof(Tag)] = {0};
    status_t res = NO_ERROR;

    TRACE_START("AES_GCM");
    res = gcm_encrypt(PT, encryptedText, sizeof(PT), callwlatedTag, Key, IV, AAD, sizeof(AAD));
    if (memCompare(encryptedText, CT, sizeof(CT)) || (res != NO_ERROR) || memCompare(callwlatedTag, Tag, sizeof(Tag)))
    {
        printf("Encryption Failed %d\n", res);
        DUMP_MEM("PT", PT, sizeof(PT));
        DUMP_MEM("expected_CT ", CT, sizeof(CT));
        DUMP_MEM("encrypted_CT", encryptedText, sizeof(encryptedText));
        DUMP_MEM("expected_Tag ", Tag, sizeof(Tag));
        DUMP_MEM("encrypted_Tag", callwlatedTag, sizeof(callwlatedTag));
        if(res == NO_ERROR)
        {
            // Throw error if gcm_encrypt/decrypt returned NO_ERROR, but either tag or CT doesn't match expected.
            res = ERR_GENERIC;
        }
    }
    else // Encryption succeeded
    {
        res = gcm_decrypt(encryptedText, decryptedText, sizeof(PT), callwlatedTag, Key, IV, AAD, sizeof(AAD));
        if (memCompare(PT, decryptedText, sizeof(PT)) || (res != NO_ERROR))
        {
            printf("Decryption Failed %d\n", res);
            DUMP_MEM("CT", CT, sizeof(CT));
            DUMP_MEM("expected_PT ", PT, sizeof(PT));
            DUMP_MEM("decrypted_PT", decryptedText, sizeof(decryptedText));
            if(res == NO_ERROR)
            {
                // Throw error if gcm_encrypt/decrypt returned NO_ERROR, but decrypted text doesn't match expected.
                // Tag match is checked within gcm_decrypt.
                res = ERR_GENERIC;
            }
        }
    }

    if(res == NO_ERROR)
    {
        printf("Encryption/Decryption Successful\n");
    }

    TRACE_END("%s = %d", "AES_GCM", res);
    return (uint32_t) res;
}

/** @brief AES GCM Encryption API
 *
 * @param inputBuf: unencrypted data which should be encrypted
 * @param outputBuf: buffer to write encrypted ciphertext to
 * @param inputOutputBufLen: length of input/output buffers (these should be same length)
 * @param tagOutput: buffer to write GCM tag to
 * @param key: AES256 encryption key
 * @param iv: buffer containing random iv (96 bit)
 *
 * @note additional data is not used here
 *
 * @return NO_ERROR on success, error (from error_code.h) on failure
 */
static status_t gcm_encrypt(
    const uint8_t* inputBuf,
    uint8_t* outputBuf,
    uint32_t inputOutputBufLen,
    uint8_t* tagOutput,
    const uint8_t* key,
    const uint8_t* iv,
    const uint8_t* addData,
    uint32_t addLen)
{
    engine_t *engine = NULL;
    struct se_engine_aes_context econtext = {0}; // se_engine_aes_context_t
    struct se_data_params input_params = {0};

#if(DEBUG_ENABLE)
    const char* s_gcmEncrypt = "AES_GCM encrypt";
    const char* s_gcmSelectEngine = "AES_GCM select engine";
#endif

    status_t res = ((inputBuf == NULL || outputBuf == NULL || inputOutputBufLen == 0 || tagOutput == NULL || key == NULL || iv == NULL)) ? ERR_ILWALID_ARGS : NO_ERROR;

    TRACE_START(s_gcmEncrypt);
    CCC_ERROR_CHECK(res);

    // Select GCM Engine
    TRACE_START(s_gcmSelectEngine);
    res = ccc_select_engine((const struct engine_s **)&engine, CCC_ENGINE_CLASS_AES, ENGINE_SE0_AES1);
    TRACE_END("%s = %d", s_gcmSelectEngine, res);
    CCC_ERROR_CHECK(res);

    // Prepare IV/CTR
        // These are both contained in econtext.gcm.counter field.
        // This 4 word array is big-endian: first 3 words are IV, last word is CTR
    uint32_t gcmCounterBigEndian[4] = {0};
    memcpy((void*) gcmCounterBigEndian, (void*) iv, GCM_IV_SIZE_BYTES);
    
    // Then set the counter to default start value (already reversed) -- do this anytime you're processing a new message.
    gcmCounterBigEndian[3] = CTR_START_PROCESS_BIGENDIAN;

    // Initialize Engine
    econtext.engine = engine;
    econtext.cmem = NULL;
    econtext.is_encrypt = true; // true since we're encrypting
    econtext.is_hash = false; // must be FALSE (engine_aes_process_arg_check:2964])
    econtext.is_first = true;
    econtext.se_ks.ks_keydata = key;
    econtext.se_ks.ks_bitsize = GCM_KEY_BITS; // IS_VALID_AES_KEYSIZE_BITS
    econtext.se_ks.ks_subkey_slot = 0; // < SE_AES_MAX_KEYSLOTS
    econtext.aes_flags = (AES_FLAGS_DYNAMIC_KEYSLOT | AES_FLAGS_CTR_MODE_BIG_ENDIAN | AES_FLAGS_HW_CONTEXT);
    econtext.algorithm = TE_ALG_AES_GCM;
    econtext.gcm.counter = gcmCounterBigEndian;
    econtext.gcm.tag = tagOutput;

    // Handle Additional Data
    if((addLen != 0) && (addData != NULL))
    {
        econtext.aes_flags |= AES_FLAGS_AE_AAD_DATA;
        res = gcm_processBlock(&econtext, &input_params, addData, NULL, addLen, 0, "AES_GCM additional data");
        if((res == NO_ERROR) && (econtext.gcm.aad_len != addLen))
        {
            res = ERR_GENERIC;
        }
        CCC_ERROR_CHECK(res);
    }

    // Encrypt
#if GCM_HANDLE_AS_STREAM
    uint32_t remaining = inputOutputBufLen;
    uint32_t ptSize = 0;
    for(uint32_t i = 0; i < remaining;)
    {
        ptSize = MIN(((uint32_t) SE_AES_BLOCK_LENGTH), (inputOutputBufLen - i));
        res = gcm_processBlock(&econtext, &input_params, inputBuf + i, outputBuf + i, ptSize, ptSize, "AES_GCM encrypt block");
        i += ptSize;
        CCC_ERROR_CHECK(res);

        // Update first/last flags
        // is_first will be (desirably) cleared inside engine_aes_process_block_locked. Setting is_first=false here is not necessary, but just to be obvious as to what is going on, we're explicitly clearing it here.
        econtext.is_first = false;
    }
#else
    res = gcm_processBlock(&econtext, &input_params, inputBuf, outputBuf, inputOutputBufLen, inputOutputBufLen, "AES_GCM encrypt block");
    CCC_ERROR_CHECK(res);
#endif

    // Enable the finalize tag and HW context flags
    // HW_CONTEXT gets cleared inside engine_aes_process_block_locked
    // AES_FLAGS_AE_FINALIZE_TAG is necessary to generate the tag
    econtext.aes_flags |= (AES_FLAGS_AE_FINALIZE_TAG);

    // Update first/last flags
    // is_first will be (desirably) cleared inside engine_aes_process_block_locked, but just to be obvious as to
    // what is going on we're explicitly clearing it here. This is not necessary.
    // is_last needs to be set in order to process the tag
    econtext.is_first = false;
    econtext.is_last = true;

    // Generate the tag
    // Modify the input params such that source is NULL w/ length equal to the number of bytes encrypted; the destination is the tag w/ GCM_TAG_SIZE_BYTES length.
    res = gcm_processBlock(&econtext, &input_params, NULL, tagOutput, inputOutputBufLen, GCM_TAG_SIZE_BYTES, "AES_GCM generate tag");
    CCC_ERROR_CHECK(res);
    
    // Print result
    input_params.src = inputBuf;
    input_params.dst = outputBuf;
    input_params.input_size = inputOutputBufLen;
    input_params.output_size = inputOutputBufLen;
    gcm_dumpAESMemory(&econtext, &input_params);

fail:
    TRACE_END("%s = %d.", s_gcmEncrypt, res);
    TRACE_NEWLINE();
    return res;
}

/** @brief AES GCM Decryption API
 *
 * @param inputBuf: encrypted ciphertext data
 * @param outputBuf: buffer to write decrypted plaintext to
 * @param inputOutputBufLen: length of input/output buffers (these should be same length)
 * @param expectedTag: GCM tag necessary to decrypt
 * @param key: AES256 encryption key
 * @param iv: buffer containing random iv (96 bit)
 *
 * @note additional data is not used here
 *
 * @return NO_ERROR on success, error (from error_code.h) on failure
 */
static status_t gcm_decrypt(
    const uint8_t* inputBuf,
    uint8_t* outputBuf,
    uint32_t inputOutputBufLen,
    const uint8_t* expectedTag,
    const uint8_t* key,
    const uint8_t* iv,
    const uint8_t* addData,
    uint32_t addLen)
{
#if(DEBUG_ENABLE)
    const char* s_gcmDecrypt = "AES_GCM decrypt";
    const char* s_gcmSelectEngine = "AES_GCM select engine";
#endif
 
    engine_t *engine = NULL;
    struct se_engine_aes_context econtext = {0}; // engine_aes_process_arg_check
    struct se_data_params input_params = {0};
    uint8_t callwlatedTag[GCM_TAG_SIZE_BYTES] = {0};
    status_t res = ((inputBuf == NULL || outputBuf == NULL || inputOutputBufLen == 0 || expectedTag == NULL || key == NULL || iv == NULL)) ? ERR_ILWALID_ARGS : NO_ERROR;

    TRACE_START(s_gcmDecrypt);
    CCC_ERROR_CHECK(res);

    // Select GCM Engine
    TRACE_START(s_gcmSelectEngine);
    res = ccc_select_engine((const struct engine_s **)&engine, CCC_ENGINE_CLASS_AES, ENGINE_SE0_AES1);
    TRACE_END("%s = %d", s_gcmSelectEngine, res);
    CCC_ERROR_CHECK(res);

    // Prepare IV/CTR
    // These are both contained in econtext.gcm.counter field.
    // This 4 word array is big-endian: first 3 words are IV, last word is CTR
    uint32_t gcmCounterBigEndian[4] = {0};
    memcpy((void*) gcmCounterBigEndian, (void*) iv, GCM_IV_SIZE_BYTES);
    
    // Then set the counter to default start value (already reversed) -- do this anytime you're processing a new message.
    gcmCounterBigEndian[3] = CTR_START_PROCESS_BIGENDIAN;

    // Initialize Engine
    econtext.engine = engine;
    econtext.is_first = true;
    econtext.is_last = false; // only used during encryption/tag generation
    econtext.cmem = NULL;
    econtext.is_encrypt = false; // false since we're decrypting
    econtext.is_hash = false; // must be FALSE (engine_aes_process_arg_check:2964])
    econtext.se_ks.ks_keydata = key;
    econtext.se_ks.ks_bitsize = GCM_KEY_BITS; // IS_VALID_AES_KEYSIZE_BITS
    econtext.se_ks.ks_subkey_slot = 0; // < SE_AES_MAX_KEYSLOTS

    econtext.aes_flags = (AES_FLAGS_DYNAMIC_KEYSLOT | AES_FLAGS_CTR_MODE_BIG_ENDIAN | AES_FLAGS_HW_CONTEXT);
    econtext.algorithm = TE_ALG_AES_GCM;
    econtext.gcm.counter = gcmCounterBigEndian;
    econtext.gcm.tag = callwlatedTag;

    // Handle Additional Data
    if((addLen != 0) && (addData != NULL))
    {
        econtext.aes_flags |= AES_FLAGS_AE_AAD_DATA;

        // Dst is NULL (0 len) when handling additional (unencrypted) data
        res = gcm_processBlock(&econtext, &input_params, addData, NULL, addLen, 0, "AES_GCM additional data");
        CCC_ERROR_CHECK(res);
    }

    // Decrypt
#if GCM_HANDLE_AS_STREAM
    uint32_t remaining = inputOutputBufLen;
    uint32_t ptSize = 0;
    for(uint32_t i = 0; i < remaining;)
    {
        ptSize = MIN( (uint32_t)SE_AES_BLOCK_LENGTH , (inputOutputBufLen - i));
        res = gcm_processBlock(&econtext, &input_params, inputBuf + i, outputBuf + i, ptSize, ptSize, "AES_GCM decrypt block");
        i += ptSize;
        CCC_ERROR_CHECK(res);
    }
#else
    res = gcm_processBlock(&econtext, &input_params, inputBuf, outputBuf, inputOutputBufLen, inputOutputBufLen, "AES_GCM decrypt block");
    CCC_ERROR_CHECK(res);
#endif

    // Finalize Tag and compare

    // Enable the finalize tag and HW context flags
    // HW_CONTEXT gets cleared inside engine_aes_process_block_locked
    // AES_FLAGS_AE_FINALIZE_TAG is necessary to generate the tag
    econtext.aes_flags |= (AES_FLAGS_AE_FINALIZE_TAG | AES_FLAGS_HW_CONTEXT);

    // Update first/last flags
    // is_first will be (desirably) cleared inside engine_aes_process_block_locked, but just to be obvious as to
    // what is going in we're explicitly clearing it here. This is not necessary.
    // is_last needs to be set in order to process the tag
    econtext.is_first = false;
    econtext.is_last = true;

    // Generate the tag
    // Modify the input params such that source is NULL and the destination is the tag.
    res = gcm_processBlock(&econtext, &input_params, NULL, callwlatedTag, inputOutputBufLen, GCM_TAG_SIZE_BYTES, "AES_GCM generate tag");
    CCC_ERROR_CHECK(res);

    // Print result
    input_params.src = inputBuf;
    input_params.dst = outputBuf;
    input_params.input_size = inputOutputBufLen;
    input_params.output_size = inputOutputBufLen;
    gcm_dumpAESMemory(&econtext, &input_params);

    // Validate
    if(memcmp(callwlatedTag, expectedTag, SE_AES_BLOCK_LENGTH) != 0)
    {
        printf("Tag Mismatch! Attestation/Validation Failed.\n");
        res = ERR_GENERIC;
    }
    else
    {
        printf("Tags Matched! Attestation/Validation Successful.\n");
    }

fail:
    TRACE_END("%s = %d.", s_gcmDecrypt, res);
    TRACE_NEWLINE();
    return res;
}

static void gcm_dumpAESMemory(struct se_engine_aes_context* econtext, struct se_data_params* input_params)
{
#if(DEBUG_ENABLE)
    DUMP_MEM("tag", econtext->gcm.tag, SE_AES_BLOCK_LENGTH);
    DUMP_MEM("src", input_params->src, input_params->input_size);
    DUMP_MEM("dst", input_params->dst, input_params->output_size);
#else
    (void) econtext;
    (void) input_params;
#endif
}

/** @brief AES GCM CCC Lite API
 *
 * @param econtext: engine context
 * @param input_params: pointer to struct which needs to reference the I/O buffers
 * @param srcBuf: Input buffer (NULL for tag generation)
 * @param dstBuf: Output buffer
 * @param srcLen: length of input buffer (0 for tag generation)
 * @param dstLen: length of output buffer
 * @param debugStr: string describing the process (e.g. encrypt/decrypt/tag)
 *
 * @note The IV is incremented just before the block is processed (unless econtext->is_first=true in which case the IV
 * increment is skipped). So when engine_aes_process_block_locked returns, the engine context contains the IV which was
 * just used to process the block.
 *
 * @return NO_ERROR on success, error (from error_code.h) on failure
 */
inline status_t gcm_processBlock(
    struct se_engine_aes_context* econtext,
    struct se_data_params* input_params,
    const uint8_t* srcBuf,
    uint8_t* dstBuf,
    uint32_t srcLen,
    uint32_t dstLen,
    GCC_ATTR_UNUSED const char* debugStr)
{

    input_params->src = srcBuf;
    input_params->dst = dstBuf;
    input_params->input_size = srcLen;
    input_params->output_size = dstLen;
    TRACE_START(debugStr);
    status_t res = engine_aes_process_block_locked(input_params, econtext);
    TRACE_END("%s = %d", debugStr, res);
    return res;
}
