/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#include "manifest_gh100.h"

const PKC_VERIFICATION_MANIFEST manifest = {
    // Decrytpted part of manifest
    .stage1RSA3KSigProd     = {0, },
    .stage1RSA3KSigDebug    = {0, },
    .magicNumberStage1      = 0x42,
    .bUseDevKey             = TRUE,
    .manifestEncParams      = {
        // MK TODO: check endiannes and if we care about that field on non-fsp
        .encryptionDerivationString = "",
        /*.iv                 = { 0x27, 0xd0, 0xef, 0x69, 0xc4, 0xbb, 0xca, 0x8a,
                                0x34, 0x37, 0xc8, 0xcb, 0x8c, 0xb8, 0xfc, 0x04 },*/
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8, 0x8c},
                                                
        .authTag            = {0, },
    },

    // Encrypted part of manifest (stage 1)
    .version               = 0x01,  // This has to be 1 on GA10x
    .ucodeId               = 0x04,  // See https://confluence.lwpu.com/display/GFS/Ucode+ID+Assignment
    .ucodeVersion          = 0x00,  // Post-QS signed
    .bRelaxedVersionCheck  = TRUE,  // Allow >= check for ucode version in BR revocation
    .engineIdMask          = ENGINE_TO_ENGINE_ID_MASK(PWR_PMU),    // Base 1
    // This field will be patched during build
    .itcmSizeIn256Bytes    = (IMEM_LIMIT) / 256,    // NA, incorrect value will not work on boot
    // This field will be patched during build
    .dtcmSizeIn256Bytes    = (DMEM_LIMIT) / 256,    // NA, incorrect value will not work on boot
    .fmcHashPadInfoBitMask = 0x00000000,            // LSB determines if PDI is pre-pended to the FMC before hashing
    .fmcEncParams          = {
        // NOT AUTOGENERATED! also must be !=0
        // MK TODO: check endiannes
        .encryptionDerivationString = "",
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8, 0x8c},
        .authTag            = {0, },
    },
    // Need a checklist that says this cannot be 0
    // This field will be patched by siggen
    .digest                = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // NA, patched by siggen when signing
                               0x00000000, 0x00000000, 0x00000000, 0x00000000,
                               0x00000000, 0x00000000, 0x00000000, 0x00000000 },
    .secretMask            = {
        .scpSecretMask     = 0x0,                       // SCP 'secret' instrlwtion is not allowed
        .scpSecretMaskLock = 0xFFFFFFFFFFFFFFFFULL,     // This mask is locked and cannot be changed
    },
    .debugAccessControl    = {
        // See https://confluence.lwpu.com/display/LW/LWWATCH+Debugging+and+Security+-+GA10X+POR for reviewed POR debugging capabilities
        .dbgctl =
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STOP,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RUN,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STEP,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_J,      _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_EMASK,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RREG,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WREG,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RDM,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WDM,    _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RSTAT,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_IBRKPT, _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RCSR,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WCSR,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RPC,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RFREG,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WFREG,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _START_IN_ICD,     _FALSE  ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _SINGLE_STEP_MODE, _DISABLE),
        .dbgctlLock = 0xFFFFFFFF,       // DBGCTL cannot be changed by any code running on the core
    },
    .bDICE = FALSE,
    .bKDF  = FALSE,                     // PMU Steady State does not use fuse keys
    .bCertCA = FALSE,
    .bAttester = FALSE,
    
    .mspm  = {
        .mplm  = (LW_RISCV_CSR_MSPM_MPLM_LEVEL2),   // PMU has level 2 only
        .msecm = 0x0                                // This allow only inselwre SCPDMATRANSFER, I think this is what we want but not sure (AI: Follow up with HW)
    },

    .kdfConstant = { 0 },   // PMU does not use KDF (for decrypt fuse key)

    .deviceMap.deviceMap = {
        DEVICEMAP(_MMODE,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_RISCV_CTL,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PIC,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_TIMER,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HOSTIF,         _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DMA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        // PMB must be unlocked so someone can write LOCKPMB (and then disable/lock it). Used since PMU has a open DMEM aperture
        DEVICEMAP(_PMB,            _ENABLE,  _ENABLE,  _UNLOCKED) |
        DEVICEMAP(_DIO,            _DISABLE, _DISABLE, _LOCKED  ),

        DEVICEMAP(_KEY,            _DISABLE, _DISABLE, _LOCKED  ) |     // PMU steady state has no key access
        DEVICEMAP(_DEBUG,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SHA,            _DISABLE, _DISABLE, _LOCKED  ) |     // PMU steady state does not use SHA engine
        DEVICEMAP(_KMEM,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_BROM,           _ENABLE,  _DISABLE, _LOCKED  ) |     // BROM enforced
        DEVICEMAP(_ROM_PATCH,      _DISABLE, _DISABLE, _LOCKED  ) |     // Doesnt exist in Peregrine?
        DEVICEMAP(_IOPMP,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_NOACCESS,       _DISABLE, _DISABLE, _LOCKED  ),      // Empty Group

        DEVICEMAP(_SCP,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FBIF,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FALCON_ONLY,    _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PRGN_CTL,       _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP0, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP1, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP2, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP3, _ENABLE,  _ENABLE,  _LOCKED  ),

        DEVICEMAP(_PLM,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HUB_DIO,        _DISABLE, _DISABLE, _LOCKED  ) |      // What is in this? Seems like an empty group
        DEVICEMAP(_RESET,          _ENABLE,  _ENABLE,  _LOCKED  ),
    },

    .corePmp = {
        .cfg = {
            [0] = // PMP entry 0..7 -> pmpcfg0
            PMP_ENTRY(_DENIED, _DENIED, _DENIED, _NAPOT, _UNLOCK, 0)        | // IMEM FMC, access block for S/U *MUST BE UNLOCKED*
            PMP_ENTRY(_DENIED, _DENIED, _DENIED, _NAPOT, _UNLOCK, 1)        | // DMEM FMC, access blocks for S/U *MUST BE UNLOCKED*
            PMP_ENTRY(_PERMITTED, _DENIED, _PERMITTED, _NAPOT, _LOCK, 2)    | // IMEM FMC, write block for ALL *MUST BE LOCKED*
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _NAPOT, _LOCK, 3) | // IMEM, R *W* X, we write via DMA, but bootloader does memcpy :(
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK, 4) | // DMEM, RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK, 5) | // LOCALIO, RW
            PMP_ENTRY_OFF(6)                                                | // TOR start for PRI (se next)
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _TOR,   _LOCK, 7),  // TOR - PRI - RW
            [1] = // PMP entry 8..15 -> pmpcfg2
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _TOR,   _LOCK, 0) | // TOR - FBGPA - RWX
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED, _TOR,   _LOCK, 1),  // TOR - GVA/SYSGPA - RWX (X for inst_in_sys)
            [2] = 0, // PMP entry 16..23 -> extpmp0
            [3] = 0, // PMP entry 24-31 -> extpmp2
        },
        .addr = {
            // PMPADDR
            IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1), // PMPADDR(0)
            IOPMPADDR_LO_DMEM(DMEM_LIMIT - 1), // PMPADDR(1)
            IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1), // PMPADDR(2)
            0x000000000004FFFF, // IMEM (why are we not using IMEM START/END? Should probably write NAPOT macros, if thats a thing)
            0x000000000006FFFF, // DMEM (Need to double check the start/end, can someone who know NAPOT do this without looking at Lily's code?)
            ((LW_RISCV_AMAP_INTIO_START >> 2) | ((LW_RISCV_AMAP_INTIO_SIZE - 1) >> 3)), // LOCALIO
            (LW_RISCV_AMAP_PRIV_START >> 2),   // PRI start
            (LW_RISCV_AMAP_PRIV_END   >> 2),   // PRI end
            (LW_RISCV_AMAP_FBGPA_END  >> 2),   // FBGPA end, do we not want to mark the address hole (between PRIV End and GPA start as all denined)?
            (LW_RISCV_AMAP_GVA_END    >> 2),   // End of GVA (think we should have separate GVA and SYSGPA entries?)
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0,      // 10-15
            // NEXTPMPADDR
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31
        },
    },

    // IO_PMP_MODE - NAPOT for all entries as that's the only mode we support
    .ioPmpMode = 0xffffffffffffffff,

    .ioPmp.entry = {
        // Order: cfg, usercfg, addrlo, addrhi
        [0] = { // IOPMPCFG(0) - block IMEM FMC access - All masters
            .cfg     = DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            .usercfg = 0x0,
            .addrLo  = IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1),
            .addrHi  = 0,
        },
        [1] = { // IOPMPCFG(1) - block DMEM FMC access - All masters
            .cfg     = DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            .usercfg = 0x0,
            .addrLo  = IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1),
            .addrHi  = 0,
        },
        [2] = { // IOPMPCFG(2) - block whole IMEM R/W - PMB
            .cfg = IOPMP_CFG_ALL_PMB(_DISABLE, _DISABLE, _LOCKED),
            .usercfg = 0x0,
            .addrLo = IOPMPADDR_LO_ALL_IMEM,
            .addrHi = 0,
        },
        [3] = { // IOPMPCFG(3) - permit PMB DMEM R - we can do it because FMC is locked already
            .cfg = IOPMP_CFG_ALL_PMB(_ENABLE, _DISABLE, _LOCKED),
            .usercfg = 0x0,
            .addrLo = IOPMPADDR_LO_ALL_DMEM,
            .addrHi = 0,
        },
        // rest is zero
    },

    .numberOfValidPairs      = 27,  // 27 registers

    .registerPair.entries    = {
        [0] = {
            .addr    = LW_PRGNLCL_FBIF_CTL2,
            .andMask = 0,
            .orMask  = DRF_DEF(_PRGNLCL, _FBIF_CTL2, _NACK_MODE, _NACK_AS_ACK),
        },
        // PLMs, see https://confluence.lwpu.com/pages/viewpage.action?pageId=481960351
        // PLMs that are fully disabled
        [1] = {
            .addr    = LW_PRGNLCL_FALCON_AMAP_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_AMAP       ),
        },
        [2] = {
            .addr    = LW_PRGNLCL_FALCON_BOOTVEC_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_BOOTVEC    ),
        },
        [3] = {
            .addr    = LW_PRGNLCL_FALCON_CPUCTL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_CPUCTL     ),
        },
        [4] = {
            .addr    = LW_PRGNLCL_FALCON_DBGCTL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_DBGCTL     ),
        },
        [5] = {
            .addr    = LW_PRGNLCL_FALCON_PMB_IMEM_PRIV_LEVEL_MASK(0), // This is indexed, but one element, ct_assert at the end
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_PMB_IMEM   ),
        },
        [6] = {
            .addr    = LW_PRGNLCL_FALCON_PRIVSTATE_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_PRIVSTATE  ),
        },
        [7] = {
            .addr    = LW_PRGNLCL_FALCON_SAFETY_CTRL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_SAFETY_CTRL),
        },
        [8] = {
            .addr    = LW_PRGNLCL_FALCON_SCTL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_SCTL       ),
        },
        [9] = {
            .addr    = LW_PRGNLCL_FALCON_TRACEBUF_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_TRACEBUF   ),
        },
        [10] = {
            .addr    = LW_PRGNLCL_RISCV_BOOTVEC_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(RISCV_BOOTVEC     ),
        },
        //
        // PLMs that are accessed by RISC-V but can be fully disabled, because
        // RISC-V bypassess PLM checks
        //
        [11] = {
            .addr    = LW_PRGNLCL_FALCON_DIODT_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_DIODT  ),
        },
        [12] = {
            .addr    = LW_PRGNLCL_FALCON_SHA_RAL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_SHA_RAL),
        },
        [13] = {
            .addr    = LW_PRGNLCL_FALCON_TMR_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_TMR    ),
        },
        [14] = {
            .addr    = LW_PRGNLCL_FALCON_WDTMR_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_WDTMR  ),
        },
        [15] = {
            .addr    = LW_PRGNLCL_RISCV_MSIP_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(RISCV_MSIP    ),
        },
        [16] = {
            .addr    = LW_PRGNLCL_RISCV_LWCONFIG_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_ALL_DISABLE_WITH_REPORT_ERROR(RISCV_LWCONFIG),
        },
        // Those have SELF L0 access because DMA does post level check
        [17] = {
            .addr    = LW_PRGNLCL_FALCON_IMEM_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_IMEM,       PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(PMU)),
        },
        [18] = {
            .addr    = LW_PRGNLCL_FALCON_DMEM_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_DMEM,       PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(PMU)),
        },
        // PLMs that are programmed to values
        [19] = {
            .addr    = LW_PRGNLCL_FBIF_REGIONCFG_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FBIF_REGIONCFG,   PLM_LEVEL3,     PLM_LEVEL3          ), // ACR needs it
        },
        [20] = {
            .addr    = LW_PRGNLCL_FALCON_DMA_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_DMA,       PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
        },
        [21] = {
            .addr    = LW_PRGNLCL_FALCON_EXE_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_EXE,       PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
        },
        [22] = {
            .addr    = LW_PRGNLCL_FALCON_IRQSCMASK_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_IRQSCMASK, PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
        },
        [23] = {
            .addr    = LW_PRGNLCL_FALCON_IRQTMR_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_IRQTMR,    PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
        },
        [24] = {
            .addr    = LW_PRGNLCL_FBIF_CTL2_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FBIF_CTL2,        PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
        },
        [25] = {
            .addr    = LW_PRGNLCL_RISCV_DBGCTL_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(RISCV_DBGCTL,     PLM_ALL_LEVELS, PLM_LEVEL3          ),
        },
        [26] = {
            .addr    = LW_PRGNLCL_RISCV_IRQ_PRIV_LEVEL_MASK,
            .andMask = 0,
            .orMask  = PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(RISCV_IRQ,        PLM_ALL_LEVELS, PLM_LEVEL3          ),
        },
    },
};

// We set PLM for single PMB PLM
ct_assert(LW_PRGNLCL_FALCON_PMB_IMEM_PRIV_LEVEL_MASK__SIZE_1 == 1);
