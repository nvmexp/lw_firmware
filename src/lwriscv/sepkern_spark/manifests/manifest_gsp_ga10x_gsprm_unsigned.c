/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#include "manifest_ga10x.h"

const PKC_VERIFICATION_MANIFEST manifest = {
    .version               = 0x01,
    .ucodeId               = 0x04,
    .ucodeVersion          = 0x01,
    .bRelaxedVersionCheck  = TRUE,
    .engineIdMask          = ENGINE_TO_ENGINE_ID_MASK(GSP),
    // This field will be patched during build
    .itcmSizeIn256Bytes    = (IMEM_LIMIT) / 256,
    // This field will be patched during build
    .dtcmSizeIn256Bytes    = (DMEM_LIMIT) / 256,
    .fmcHashPadInfoBitMask = 0x00000000,
    // NOT AUTOGENERATED! also must be !=0
    .CbcIv                 = { 0x27d0ef69, 0xc4bbca8a, 0x3437c8cb, 0x8cb8fc04 },
    // This field will be patched by siggen
    .digest                = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,
                               0x00000000, 0x00000000, 0x00000000, 0x00000000 },
    .secretMask            = {
        .scpSecretMask     = 0x0000000000000000ULL,
        .scpSecretMaskLock = 0xFFFFFFFFFFFFFFFFULL,
    },
    .debugAccessControl    = {
        .dbgctl =
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STOP,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RUN,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STEP,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_J,      _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_EMASK,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RREG,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WREG,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RDM,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WDM,    _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RSTAT,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_IBRKPT, _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RCSR,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WCSR,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RPC,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RFREG,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WFREG,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _START_IN_ICD,     _FALSE  ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _SINGLE_STEP_MODE, _DISABLE),
        .dbgctlLock = 0xFFFFFFFF,
    },
    .bDecFuseKeys = FALSE,
    .mspm         = {
        .mplm  = (LW_RISCV_CSR_MSPM_MPLM_LEVEL0),
        .msecm = 0x0
    },

    .kdfConstant = { 0 },

    .deviceMap.deviceMap = {
        DEVICEMAP(_MMODE,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_RISCV_CTL,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PIC,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_TIMER,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HOSTIF,         _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DMA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        // PMB must be unlocked so someone can write LOCKPMB (and then disable/lock it)
        DEVICEMAP(_PMB,            _ENABLE,  _ENABLE,  _UNLOCKED) |
        DEVICEMAP(_DIO,            _DISABLE, _DISABLE, _LOCKED  ),

        DEVICEMAP(_KEY,            _DISABLE, _DISABLE, _LOCKED  ) |
        DEVICEMAP(_DEBUG,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SHA,            _DISABLE, _DISABLE, _LOCKED  ) |
        DEVICEMAP(_KMEM,           _DISABLE, _DISABLE, _LOCKED  ) |
        DEVICEMAP(_BROM,           _ENABLE,  _DISABLE, _LOCKED  ) | // BROM enforced
        DEVICEMAP(_ROM_PATCH,      _DISABLE, _DISABLE, _LOCKED  ) |
        DEVICEMAP(_IOPMP,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_NOACCESS,       _DISABLE, _DISABLE, _LOCKED  ), // Empty Group

        DEVICEMAP(_SCP,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FBIF,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FALCON_ONLY,    _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PRGN_CTL,       _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP0, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP1, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP2, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP3, _ENABLE,  _ENABLE,  _LOCKED  ),

        DEVICEMAP(_PLM,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HUB_DIO,        _DISABLE, _DISABLE, _LOCKED  ),
    },

    .corePmp = {
        .pmpcfg = {
            // PMPCFG
            PMP_ENTRY_OFF, // TOR start for IMEM SK (see next)
            PMP_ENTRY(_DENIED, _DENIED, _DENIED, _TOR, _UNLOCK), // IMEM SK, access block for S/U *MUST BE UNLOCKED*
            PMP_ENTRY(_DENIED, _DENIED, _DENIED, _NAPOT, _UNLOCK), // DMEM FMC, access blocks for S/U *MUST BE UNLOCKED*
            PMP_ENTRY(_PERMITTED, _DENIED, _PERMITTED, _NAPOT, _LOCK), // IMEM FMC, write block for ALL *MUST BE LOCKED*
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _NAPOT, _LOCK), // IMEM, R *W* X, we write via DMA, but bootloader does memcpy :(
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK), // DMEM, RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK), // LOCALIO, RW
            PMP_ENTRY_OFF, // TOR start for PRI (see next)
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _TOR,   _LOCK), // TOR - PRI - RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _TOR,   _LOCK), // TOR - FBGPA - RWX
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _TOR,   _LOCK), // TOR - GVA/SYSGPA - RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK), // EMEM - RW
            0x0, 0x0, 0x0, 0x0, // 12-15
            // NEXTPMPCFG
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31, these slots are used by BR internally
        },
        .pmpaddr = {
            // PMPADDR
            (LW_RISCV_AMAP_IMEM_START >> 2),
            ((LW_RISCV_AMAP_IMEM_START + SK_IMEM_LIMIT) >> 2),
            IOPMPADDR_LO_DMEM(DMEM_LIMIT - 1),
            IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1),
            IOPMPADDR_LO_ALL_IMEM,
            IOPMPADDR_LO_ALL_DMEM,
            ((LW_RISCV_AMAP_INTIO_START >> 2) | ((LW_RISCV_AMAP_INTIO_SIZE - 1) >> 3)),
            (LW_RISCV_AMAP_PRIV_START >> 2),
            (LW_RISCV_AMAP_PRIV_END   >> 2),
            (LW_RISCV_AMAP_FBGPA_END  >> 2),
            (LW_RISCV_AMAP_GVA_END    >> 2),
            IOPMPADDR_LO_NAPOT(LW_RISCV_AMAP_EMEM_START, LW_RISCV_AMAP_EMEM_SIZE - 1),
            // NEXTPMPADDR
            0x0, 0x0, 0x0, 0x0, // 12-15
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31
        },
    },

    // IO_PMP_MODE - NAPOT for all entries as that's the only mode we support
    .ioPmpMode = 0xffffffffffffffff,

    .ioPmp = {
        .iopmpcfg = {
            // IOPMPCFG(0) - block IMEM FMC access - All masters
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            // IOPMPCFG(1) - block DMEM FMC access - All masters
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
            DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            // IOPMPCFG(2) - block whole IMEM R/W - PMB
            IOPMP_CFG_ALL_PMB(_DISABLE, _DISABLE, _LOCKED),
            // IOPMPCFG(3) - permit PMB DMEM R - we can do it because FMC is locked already
            IOPMP_CFG_ALL_PMB(_ENABLE, _DISABLE, _LOCKED),
            0x0, 0x0 , 0x0, 0x0, // 4-7
            0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0, 0x0, // 8-15
            0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0, 0x0,   // 24-31
        },
        .iopmpaddrlo = {
            IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1), // IOPMPADDR(0) - FMC IMEM
            IOPMPADDR_LO_DMEM(DMEM_LIMIT - 1), // IOPMPADDR(1) - FMC DMEM
            IOPMPADDR_LO_ALL_IMEM,  // IOPMPADDR(2) - Map whole IMEM aperture
            IOPMPADDR_LO_ALL_DMEM,  // IOPMPADDR(3) - Map whole DMEM aperture
            0x0, 0x0, 0x0, 0x0, // 4-7
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 8-15
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31
        },
        .iopmpaddrhi = { // Must be always 0 for IMEM and DMEM
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0-7
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 8-15
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31
        },
    },

    .numberOfValidPairs = 29,
    .registerPair       = {
        .addr    = {
            LW_PRGNLCL_FBIF_CTL2,
            // From https://lwpu-my.sharepoint.com/:x:/r/personal/jamesx_lwidia_com/_layouts/15/guestaccess.aspx?e=cy8ezJ&share=EaW73mnA-b1Jp0hH4agGUnQB6MB9I8XugtRv8BdV6eRoKw
            LW_PRGNLCL_FALCON_AMAP_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_BOOTVEC_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_CPUCTL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_DBGCTL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_DIODT_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_DIODTA_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_DMA_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_DMEM_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_EXE_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_IMEM_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_IRQSCMASK_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_MTHDCTX_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_PMB_IMEM_PRIV_LEVEL_MASK(0), // This is indexed, but one element, ct_assert at the end
            LW_PRGNLCL_FALCON_PRIVSTATE_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_SAFETY_CTRL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_SCTL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_SHA_RAL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_TMR_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_TRACEBUF_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FALCON_WDTMR_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FBIF_CTL2_PRIV_LEVEL_MASK,
            LW_PRGNLCL_FBIF_REGIONCFG_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_BOOTVEC_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_CPUCTL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_DBGCTL_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_IRQ_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_MSIP_PRIV_LEVEL_MASK,
            LW_PRGNLCL_RISCV_LWCONFIG_PRIV_LEVEL_MASK,
        },
        .andMask = {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0,
        },
        .orMask  = {
            DRF_DEF(_PRGNLCL, _FBIF_CTL2, _NACK_MODE, _NACK_AS_ACK),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_AMAP),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_BOOTVEC),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_CPUCTL),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_DBGCTL),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_DIODT),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_DIODTA),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_DMA, PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_DMEM, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FALCON_EXE, PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_IMEM, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_IRQSCMASK, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_MTHDCTX, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_PMB_IMEM),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_PRIVSTATE),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_SAFETY_CTRL),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_SCTL),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_SHA_RAL, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_TMR, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(FALCON_TRACEBUF),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FALCON_WDTMR, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(FBIF_CTL2, PLM_ALL_LEVELS, PLM_LEVEL2_AND_ABOVE),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(FBIF_REGIONCFG, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_ALL_DISABLE_WITH_REPORT_ERROR(RISCV_BOOTVEC),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(RISCV_CPUCTL, PLM_ALL_LEVELS, PLM_LEVEL3),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(RISCV_DBGCTL, PLM_ALL_LEVELS, PLM_LEVEL3),
            PLM_SET_ALL_SOURCES_WITH_REPORT_ERROR(RISCV_IRQ, PLM_ALL_LEVELS, PLM_ALL_LEVELS_DISABLED),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(RISCV_MSIP, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
            PLM_SET_SOURCE_WITH_REPORT_ERROR(RISCV_LWCONFIG, PLM_ALL_LEVELS, PLM_ALL_LEVELS, PLM_SOURCE_ID(GSP)),
        },
    },
};

// We set PLM for single PMB PLM
ct_assert(LW_PRGNLCL_FALCON_PMB_IMEM_PRIV_LEVEL_MASK__SIZE_1 == 1);
