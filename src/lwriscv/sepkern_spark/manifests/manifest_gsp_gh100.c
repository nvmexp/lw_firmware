/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#include "manifest_gh100.h"

const PKC_VERIFICATION_MANIFEST manifest = {
    // Decrytpted part of manifest
    .stage1RSA3KSigProd     = {0, },
    .stage1RSA3KSigDebug    = {0, },
    .magicNumberStage1      = 0x42,
    .bUseDevKey             = TRUE,
    .manifestEncParams      = {
        // MK TODO: check endiannes and if we care about that field on non-fsp
        .encryptionDerivationString = "",
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8,0x8c},
        .authTag            = {0, },
    },

    // Encrypted part of manifest (stage 1)
    .version               = 0x07,
    .ucodeId               = 0x04,
    .ucodeVersion          = 0x00,
    .bRelaxedVersionCheck  = TRUE,
    .engineIdMask          = ENGINE_TO_ENGINE_ID_MASK(GSP),
    // This field will be patched during build
    .itcmSizeIn256Bytes    = (IMEM_LIMIT) / 256,
    // This field will be patched during build
    .dtcmSizeIn256Bytes    = (DMEM_LIMIT) / 256,
    .fmcHashPadInfoBitMask = 0x00000000,
    .fmcEncParams          = {
        // NOT AUTOGENERATED! also must be !=0
        // MK TODO: check endiannes
        .encryptionDerivationString = "",
        .iv                 = {0x69, 0xef, 0xd0, 0x27, 0x8a, 0xca, 0xbb, 0xc4,
                               0xcb, 0xc8, 0x37, 0x34, 0x04, 0xfc, 0xb8,0x8c},

        .authTag            = {0, },
    },
    .digest                = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,
                               0x00000000, 0x00000000, 0x00000000, 0x00000000,
                               0x00000000, 0x00000000, 0x00000000, 0x00000000 },
    .secretMask            = {
        .scpSecretMask     = 0x0000000000000000ULL,
        .scpSecretMaskLock = 0xFFFFFFFFFFFFFFFFULL,
    },
    .debugAccessControl    = {
        // Enable debugging for now, let Separation Kernel disable it if needed.
        .dbgctl =
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STOP,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RUN,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_STEP,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_J,      _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_EMASK,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RREG,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WREG,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RDM,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WDM,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RSTAT,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_IBRKPT, _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RCSR,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WCSR,   _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RPC,    _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_RFREG,  _ENABLE ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _ICD_CMDWL_WFREG,  _ENABLE ) |

            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _START_IN_ICD,     _FALSE  ) |
            DRF_DEF(_PRGNLCL, _RISCV_DBGCTL, _SINGLE_STEP_MODE, _DISABLE),

        .dbgctlLock = 0x0,
    },
    .bDICE = FALSE,
    .bKDF  = FALSE,
    .bCertCA = FALSE,
    .bAttester = FALSE,
    .mspm  = {
        .mplm  = (LW_RISCV_CSR_MSPM_MPLM_LEVEL0),
        .msecm = 0x0
    },

    .kdfConstant = { 0 },

    .deviceMap.deviceMap = {
        DEVICEMAP(_MMODE,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_RISCV_CTL,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PIC,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_TIMER,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HOSTIF,         _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DMA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        // PMB must be unlocked so someone can write LOCKPMB (and then disable/lock it)
        DEVICEMAP(_PMB,            _ENABLE,  _ENABLE,  _UNLOCKED) |
        DEVICEMAP(_DIO,            _DISABLE, _DISABLE, _LOCKED  ),

        DEVICEMAP(_KEY,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_DEBUG,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SHA,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_KMEM,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_BROM,           _ENABLE,  _DISABLE, _LOCKED  ) | // BROM enforced
        DEVICEMAP(_ROM_PATCH,      _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_IOPMP,          _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_NOACCESS,       _DISABLE, _DISABLE, _LOCKED  ), // Empty Group

        DEVICEMAP(_SCP,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FBIF,           _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_FALCON_ONLY,    _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_PRGN_CTL,       _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP0, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP1, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP2, _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_SCRATCH_GROUP3, _ENABLE,  _ENABLE,  _LOCKED  ),

        DEVICEMAP(_PLM,            _ENABLE,  _ENABLE,  _LOCKED  ) |
        DEVICEMAP(_HUB_DIO,        _ENABLE,  _ENABLE,  _LOCKED  ) |  // Secure Bus - needed for HDCP
        DEVICEMAP(_RESET,          _ENABLE,  _ENABLE,  _LOCKED  ),
    },

    .corePmp = {
        .cfg = {
            [0] = // PMP entry 0..7 -> pmpcfg0
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _NAPOT, _LOCK, 0) | // IMEM - RWX
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK, 1) | // DMEM - RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK, 2) | // EMEM - RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _NAPOT, _LOCK, 3) | // LOCALIO - RW
            PMP_ENTRY_OFF(4)                                                | // TOR start for PRI
            PMP_ENTRY(_PERMITTED, _PERMITTED, _DENIED,    _TOR,   _LOCK, 5) | // TOR - PRI - RW
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _TOR,   _LOCK, 6) | // TOR - FBGPA - RWX
            PMP_ENTRY(_PERMITTED, _PERMITTED, _PERMITTED, _TOR,   _LOCK, 7),  // TOR - GVA/SYSGPA - RWX (inst-in-sys)
            [1] = 0, // PMP entry 8..15 -> pmpcfg2
            [2] = 0, // PMP entry 16..23 -> extpmp0
            [3] = 0, // PMP entry 24-31 -> extpmp2
        },
        .addr = {
            // PMPADDR
            0x000000000004FFFF, // IMEM
            0x000000000006FFFF, // DMEM
            0x000000000048FFFF, // EMEM
            ((LW_RISCV_AMAP_INTIO_START >> 2) | ((LW_RISCV_AMAP_INTIO_SIZE - 1) >> 3)), // LOCALIO
            (LW_RISCV_AMAP_EXTIO1_START >> 2), // PRI start
            (LW_RISCV_AMAP_EXTIO1_END   >> 2),   // PRI END, address hole
            (LW_RISCV_AMAP_EXTMEM1_END  >> 2),   // FBGPA END, address hole
            (LW_RISCV_AMAP_EXTMEM3_END  >> 2),  // End of GVA
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 8-15
            // MEXTPMPADDR
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 16-23
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 24-31
        },
    },

    // IO_PMP_MODE - NAPOT for all entries as that's the only mode we support
    .ioPmpMode = 0xffffffffffffffff,

    .ioPmp.entry = {
        // Order: cfg, usercfg, addrlo, addrhi
        [0] = { // IOPMPCFG(0) - block IMEM FMC access - All masters
            .cfg     = DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            .usercfg = 0x0,
            .addrLo  = IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1),
            .addrHi  = 0,
        },
        [1] = { // IOPMPCFG(1) - block DMEM FMC access - All masters
            .cfg     = DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _READ,   _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _WRITE,  _DISABLE) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _MASTER, _ALL_MASTERS_ENABLED) |
                       DRF_DEF(_PRGNLCL, _RISCV_IOPMP_CFG, _LOCK,   _LOCKED),
            .usercfg = 0x0,
            .addrLo  = IOPMPADDR_LO_IMEM(IMEM_LIMIT - 1),
            .addrHi  = 0,
        },
        [2] = { // IOPMPCFG(2) - block whole IMEM R/W - PMB
            .cfg = IOPMP_CFG_ALL_PMB(_DISABLE, _DISABLE, _LOCKED),
            .usercfg = 0x0,
            .addrLo = IOPMPADDR_LO_ALL_IMEM,
            .addrHi = 0,
        },
        [3] = { // IOPMPCFG(3) - permit PMB DMEM R - we can do it because FMC is locked already
            .cfg = IOPMP_CFG_ALL_PMB(_ENABLE, _DISABLE, _LOCKED),
            .usercfg = 0x0,
            .addrLo = IOPMPADDR_LO_ALL_DMEM,
            .addrHi = 0,
        },
        // rest is zero
    },

    .numberOfValidPairs = 0x0,
    .registerPair       = { },
};
