#
# Copyright 2016-2020 by LWPU Corporation.  All rights reserved.  All
# information contained herein is proprietary and confidential to LWPU
# Corporation.  Any use, reproduction, or disclosure without the written
# permission of LWPU Corporation is prohibited.
#

package UcodeAnalyze;

use strict;
use warnings 'all';

use Utils;                             # import rmconfig utility functions
use util::UtilsUproc;                  # for 'utilParseHalParamBlock'
use Rmconfig::CfgHash;
use chipGroups;                        # imports CHIPS from Chips.pm and chip functions
use analyze::Output;

use Carp;
use List::Util qw(first max sum);

# HACK to get access to $UPROC from major script (e.g. rtos-flcn-script.pl)
our $UPROC;
*UPROC  = \$main::UPROC;

my $EMIT = undef;                      # ref to GenFile to emit g_xxx from template

sub new {
    (@_ == 3 or @_ == 4) or croak "usage: UcodeAnalyze->new(TASKS-REF, PROFILES-REF[, UPROC-ARCH] )";
    my ($class, $tasksRef, $profilesRef, $arch) = @_;

    if (defined $arch) {
        $arch = uc $arch;
    }
    else {
        $arch = 'FALCON';
    }

    # extract "pmu-gp10x" to ("pmu", "gp10x")
    $tasksRef->{PROFILE_NAME} =~ /^(\w+)-(\w+)$/;
    my ($opmode, $buildName) = (lc $1, lc $2);

    my $self = {
        FUNCTIONS     => {},
        TASK_OVERHEAD => 0,
        PROFILES_REF  => $profilesRef,
        TASKS_REF     => $tasksRef,
        OPMODE        => $opmode,
        BUILD         => $buildName,
        LWROOT        => $tasksRef->{LW_ROOT},
        ARCH          => $arch,
    };

    bless $self, $class;

    $self->loadConfig('Analyze.pm');

    return $self;
}

# generate g_analyze.h
sub printAnalyzeHeader {
    (@_ == 2) or croak 'usage: obj->printAnalyzeHeader( OUTPUT-FILE )';

    my ($self, $outputFile) = @_;

    # TODO -- Code refactor required
    #         The parsing phase should be moved init() or new()
    $self->parseCycles();

    $EMIT = GenFile->new('C', $outputFile,
                         { update_only_if_changed => 1, } );  # PARAMS-HASH-REF

    croak "Error: Could not create output file '$outputFile' : $!"     if ! $EMIT;

    # Print start of include guard
    $EMIT->print(<<__CODE__);
//
// This file is automatically generated by 'rtos-flcn-script.pl' - DO NOT EDIT!
//
// Defines from Ucode Analyze (Analyze.pm)
//

#ifndef _G_ANALYZE_H_
#define _G_ANALYZE_H_

__CODE__

    # use the ordered list
    foreach my $funcName (@{$self->{CONF}{CYCLE_LIMITS_LIST}}) {
        my $limit = $self->{CONF}{CYCLE_LIMITS}{$funcName};
        my $comments = '';

        if (!defined $limit) {
            $limit = 1;
            $comments = ' /* undef */'
        }

        $EMIT->printf("#define %-60s %4d%s\n",
                      (uc $self->{OPMODE})."_FUNC_CYCLE_NUMS_$funcName",
                      $limit,
                      $comments);
    }

    # Print end of include guard
    $EMIT->printf("\n#endif //_G_ANALYZE_H_\n");

    $EMIT->closefile();
    $EMIT = undef;
}


sub init {
    (@_ == 2) or croak "usage: obj->init( FILENAME )";
    my ($self, $objdumpFile) = @_;

    $self->loadProfile();
    $self->loadObjdump($objdumpFile);
    $self->extractTaskInfo();
}

sub analyze {
    (@_ == 1) or croak "usage: obj->analyze()";
    my $self = shift;

    $self->addInterruptOverhead();

    $self->analyzeCycles();
    $self->analyzeCompactFuncs();

    # analyze start, ISRs, ESR, and every task
    my @allRoots = ($self->getRtosRoots(), keys %{$self->{TASKS}});
    foreach my $root (@allRoots) {
        $self->traverseGraph($root);
    }

    $self->analyzeUnreached();
}

sub validate {
    (@_ == 1 || @_ == 2) or croak "usage: obj->validate( [ VALIDATE-OVL ] )";
    my ($self, $validateOverlays) = @_;

    foreach my $fn ($self->getRtosRoots()) {
        my $stackErr = $self->validateStack($fn);
        loudError("stack", $stackErr) if $stackErr;
    }

    # sanity check to capture script error
    croak "validate() requires Profile Util module being initialized"        unless $UPROC->{PROFILE_UTIL};

    foreach my $task (keys %{$self->{TASKS}}) {
        my $stackErr = $self->validateStack($task);
        loudError("stack", $stackErr) if $stackErr;

        if ($validateOverlays) {
            my $ovlErr = $self->validateOverlays($task);
            loudError("overlay", $ovlErr) if $ovlErr;
        }
    }



    # check for unexpectedly unreached functions
    foreach my $name (@{$self->{UNREACHED}}) {
        my $nameTrimmed = trimFuncName($name);

        if (not contains($self->{CONF}{UNREACHED}, $nameTrimmed)) {
            loudError("unreached", "Function $nameTrimmed is never reached.");
        }
    }
}

sub output {
    (@_ == 2) or croak "usage: obj->output( OUTPUT-DIR )";
    my ($self, $outputDir) = @_;
    outputAnalysis($self, $outputDir);
}

### Non-public methods, don't call these from outside the module

sub loadConfig {
    (@_ == 2) or croak "usage: obj->loadConfig( FILENAME )";
    my ($self, $filename) = @_;
    $self->{CONF} = do $filename or croak "Error loading $filename: $@";
}

sub loadProfile {
    (@_ == 1) or croak "usage: obj->loadProfile( )";
    my ($self) = @_;

    # PMU & SEC2 use upper case but DPU doesn't
    my $build = $self->{OPMODE} eq "dpu" ? $self->{BUILD} : uc $self->{BUILD};

    my $profileRef = $self->{PROFILES_REF}->grpItemRef($build) || die "$build not in Profiles.pm\n";
    $self->{PROFILE} = $profileRef;
}

sub loadObjdump {
    (@_ == 2) or croak "usage: obj->loadObjdump( FILENAME )";
    my ($self, $filename) = @_;

    # assume nm file is in same directory & has same name
    my $nmFile = $filename;
    $nmFile =~ s/\.objdump$/.nm/;
    my $symbols = $self->loadSymbols($nmFile);

    my $functions = {};
    my $lwrrentOvl;

    my $prevFnDropThrough = undef;

    open(my $fh, "<", $filename) or croak "Error opening $filename: $!";
    while (my $line = <$fh>) {
        # ADDRESS <LABEL>:
        if ($line =~ /^([a-f\d]+) <(_?([\w\.]+))>:$/) {
            my $fn = {
                NAME => $self->{ARCH} eq 'RISCV' ? $2 : $3, # RISCV doesn't prepend _ to names in objdump
                FULL_NAME => $2,
                ADDR => $1,
                OVERLAY => $lwrrentOvl,
                CALLS => [],
                STACK => 0,
                FUNC_PTRS => 0,
                IS_PROTECTED => 0,
            };

            if ($self->{ARCH} eq 'RISCV' && $fn->{NAME} =~ /(__section_imem|__syscall_permitted)/) {
                next;
            }

            $self->parseFunction($fh, $fn, $symbols);
            $functions->{$fn->{NAME}} = $fn;

            if ($prevFnDropThrough) {
                push @{$prevFnDropThrough->{CALLS}}, $fn->{NAME};
                @{$prevFnDropThrough->{CALLS}} = unique(@{$prevFnDropThrough->{CALLS}});
                $prevFnDropThrough = undef;
            }

            if ($fn->{DROP_THROUGH}) {
                $prevFnDropThrough = $fn;
            }
        } elsif ($line =~ /^Disassembly of section \.(\w+):$/) {
            # remove "imem_" overlay prefix
            $lwrrentOvl = ($1 eq "text") ? "resident" : substr($1, 5);
        }
    }
    close($fh);

    $self->addFPMappings($functions);
    $self->{FUNCTIONS} = $functions;
}

sub loadSymbols {
    (@_ == 2) or croak "usage: obj->loadSymbols( FILENAME )";
    my ($self, $filename, ) = @_;
    open(my $fh, "<", $filename) or croak "Error opening $filename: $!";

    # create map from numerical address to function name
    my %symbols = ();
    my $sizeTls = 0;
    while (my $line = <$fh>) {
        if ($self->{ARCH} eq 'FALCON') {
            # OFFSET [SIZE] TYPE FUNCTION
            $line =~ /^([\da-f]{8}) (?:[\da-f]{8} )?[TtW] _?(\w+)$/ or next;
            next if $2 =~ /^imem_/;  # for SEC2
            $symbols{hex $1} = $2;
        } else { # RISCV
            $line =~ m/^([0-9a-fA-F]{8})([0-9a-fA-F]{8})( ([0-9a-fA-F]{8})([0-9a-fA-F]{8}))? (.) (.+)$/ or next;

            my ($valuehi, $valuelo, $sizehi, $sizelo, $type, $name) = ($1, $2, $4, $5, $6, $7);

            if ($name !~ /^__section/ && $sizelo) {
                $symbols{hex $valuelo} = $name;
            }

            if ($name eq 'kernelTls') {
                # Each task has a TLS placed on its stack. Use the kernel TLS for size reference.
                $sizeTls = $sizelo;
            }
        }
    }

    if ($self->{ARCH} eq 'RISCV') {
        if ($sizeTls == 0) {
            loudError("loadSymbol", "RISCV - Unable to infer TLS size from kernel TLS!");
        }

        $self->{TASK_OVERHEAD} += $sizeTls;
    }

    close($fh);
    return \%symbols;
}

sub parseFunction {
    my $self = shift;

    if ($self->{ARCH} eq 'FALCON') {
        $self->parseFunctionFalcon(@_);
    }
    elsif ($self->{ARCH} eq 'RISCV') {
        $self->parseFunctionRiscv(@_);
    }
    else {
        loudError("function", "Arch " . $self->{ARCH} . " invalid!");
    }
}

sub parseFunctionFalcon {
    (@_ == 4) or croak "usage: obj->parseFunctionFalcon(FILE, FUNCTION-REF, SYMBOLS-REF)";
    my ($self, $file, $fn, $symbols) = @_;

    my @calls = ();

    # set to 1 after encountering a return instruction
    my $returned = 0;

    # 4 bytes for return address saved by the caller
    my ($stack, $maxStack, $funcPtrs) = (4, 4, 0);

    # start is started automatically, so no saved return address
    if ($fn->{NAME} eq "start") {
        $stack = $maxStack = 0;
    }

    while (my $line = <$file>) {
        # functions are separated by an empty line
        last if $line eq "\n";

        # just skip lines that don't match
        $line =~ m/:\t(?:[a-f\d]{2} )+\s{3,}([\w -.]+);$/ or next;

        # get instruction mnemonic and arguments
        my ($ins, @args) = split " ", $1;

        if ($ins eq "call") {
            if ($args[0] =~ /0x([a-f\d]+)/) {
                # colwert hex -> address -> function name
                my $target = $symbols->{hex $1};
                if ($target) {
                    push @calls, $target;
                    if ($target eq "__stack_chk_fail") {
                        $fn->{IS_PROTECTED} = 1;
                    }
                } else {
                    loudError("function", "Couldn't resolve address 0x$1");
                }
            } else {
                # if argument isn't hex, it must be a register
                $funcPtrs++;
            }
        } elsif ($ins =~ /^reti?$/) {
            # only count one return per function
            if (not $returned) {
                $stack -= 4;
                $returned = 1;
            }
        } elsif ($ins eq "pushm") {
            $stack += 4 * (1 + int(substr($args[0], 1)));
        } elsif ($ins =~ /^popm[ab]?$/) {
            if ($args[1] eq "0x1") {
                # popm with this bit set acts as a return too
                if ($returned) {
                    next;
                }
                $stack -= 4;
                $returned = 1;
            }
            # "popm a6" is equivalent to pop a0, pop a1, ..., pop a6
            $stack -= 4 * (1 + int(substr($args[0], 1)));
            $stack -= hex($args[2]) if $args[2];
        } elsif ($ins eq "addsp") {
            # negative argument adds to stack usage
            if (substr($args[0], 0, 1) eq "-") {
                $stack += hex(substr($args[0], 1));
            } else {
                $stack -= hex($args[0]);
            }
        } elsif ($ins eq "push") {
            $stack += 4;
        } elsif ($ins eq "pop") {
            $stack -= 4;
        }

        $maxStack = max($stack, $maxStack);
    }

    # ignore multiple calls to the same function
    @calls = unique(@calls);

    $fn->{CALLS} = \@calls;
    $fn->{STACK} = $maxStack;
    $fn->{FUNC_PTRS} = $funcPtrs;
}

sub parseFunctionRiscv {
    (@_ == 4) or croak "usage: obj->parseFunctionFalcon(FILE, FUNCTION-REF, SYMBOLS-REF)";
    my ($self, $file, $fn, $symbols) = @_;

    my @calls = ();

    # set to 1 after encountering a return instruction
    my $returned = 0;

    # Calling doesn't automatically save anything onto the stack
    my ($stack, $maxStack, $funcPtrs) = (0, 0, 0);
    my ($ins, $argsStr);
    $ins = 'nop';

    if (($fn->{NAME} eq 'xPortStartScheduler') or
        ($fn->{NAME} eq 'partitionSwitch')) {
        # MMINTS-TODO: Fix it properly
        # HACK - treat scheduler start as having an indirect jump
        # to map prvTaskStart and vTaskExit as fp targets instead
        # of mapping them and all their callees as "unreached".
        # Do the same treatment for partition switch code that is in asm.
        $funcPtrs++;
    }

    while (my $line = <$file>) {
        # functions are separated by an empty line
        last if $line eq "\n";

        # just skip lines that don't match
        $line =~ m/:\t(?:[a-f\d]{2})+\s+([\w!-.]+\s[\w!-.]*)(\s<(.*?)>)?$/ or next;

        my $symbolUsed = undef;
        if ($3) {
            $symbolUsed = $3;
        }

        # get instruction mnemonic and arguments
        my @insParts = split /\s/, $1;

        if (@insParts != 1 && @insParts != 2) {
            loudError("function", "parse error: cannot process $line");
        }

        if ($insParts[0] eq 'nop') {
            # Skip early to avoid overriding $ins, since it should track
            # the last non-nop instruction
            next;
        }

        ($ins, $argsStr) = @insParts;
        $ins =~ s/^\s+|\s+$//g;

        my @args;

        if ($argsStr) {
            $argsStr =~ s/^\s+|\s+$//g;
            @args = split ",", $argsStr;
        }

        if ($ins eq "jalr" || $ins eq "jr") {
            if ($fn->{NAME} =~ /^__.*?sf\d$/) {
                # HACK - the RISCV soft float functions might use
                # jr for jump tables, and there's no way to prevent this, so just
                # handle it separately.
                next;
            }

            # Indirect jump
            $funcPtrs++;
        } elsif ($ins eq "jal" || $ins eq "j" || $ins =~ /^b/) {

            # colwert hex -> address -> function name
            my $target = $symbols->{hex $args[-1]};

            # In most cases the symbol GCC provides here should match the function name.
            # Exceptions: section start markers get in the way sometimes; also, on GA100-RISCV some of the
            # soft-float function symbols have entries with a duplicate addr/size in the .nm.
            # Otherwise, the only possible cause of this is two equivalent functions getting collapsed into one,
            # and a name mismatch resulting from both being present in the .nm. In this case the symbol from
            # the objdump takes precedence.
            if ($target && $target ne $symbolUsed && $symbolUsed !~ /__section_imem_.*?_start/ && $symbolUsed !~ /^__.*?sf\d$/) {
                $target = $symbolUsed;
            }

            if (!$target && $symbolUsed && $symbolUsed !~ /__section_imem_.*?_start/ && $symbolUsed !~ /\+0x/) {
                # hack to work around stuff like __PortEnterFromTask that doesn't have a size
                # in the .nm but looks like a function in the .objdump.
                $target = $symbolUsed;
            }

            if ($symbolUsed =~ /^__.*?sf\d$/) {
                # HACK to handle soft-float functions properly.
                $target = $symbolUsed;
            }

            if ($target) {
                if (!$symbolUsed) {
                    loudError("stack", "Expected symbol to check against, in $line");
                }

                # Exception: j used to jump to start of the current function
                # (assuming it does not put anything onto the stack) is treated
                # as a simple loop and not reflected in the calltree.
                if ($target eq $fn->{FULL_NAME} && $ins eq "j") {
                    if ($stack != 0) {
                        loudError("stack", "Unexpected self-relwrsion with j in @{[$fn->{FULL_NAME}]}");
                    }

                    next;
                }

                push @calls, $target;
                if ($target eq "__stack_chk_fail") {
                    $fn->{IS_PROTECTED} = 1;
                }
            } elsif ($ins eq "jal") {
                loudError("stack", "RISCV: jal to unresolved address 0x$1 in @{[$fn->{FULL_NAME}]}");
            }
        } elsif ($ins eq "addi" && @args == 3 && $args[0] eq 'sp') {
            if ($args[1] ne "sp") {
                loudError("stack", "Unexpected sp change, instruction $line");
            }

            $stack += -int($args[2]);
        }

        $maxStack = max($stack, $maxStack);
    }

    # ignore multiple calls to the same function
    @calls = unique(@calls);

    #
    # For asm "functions":
    # If the last instruction parsed (not counting nop-s) is not an unconditional branch
    # (excluding a jalr that assumes return to the calling location, which is not applicable
    # to jal that can be used to jump to noreturn functions),
    # we will drop through to the next function.
    #
    my $intrHandlers = $self->{CONF}{RTOS_PARAMS}{$self->{ARCH}}->{INTERRUPT_HANDLERS};
    if ((!exists $symbols->{hex $fn->{ADDR}} || contains($intrHandlers, $fn->{NAME})) &&
          $ins ne 'unimp' && $ins ne 'ret' && $ins ne 'j') {
        $fn->{DROP_THROUGH} = 1;
    }

    $fn->{CALLS} = \@calls;
    $fn->{STACK} = $maxStack;
    $fn->{FUNC_PTRS} = $funcPtrs;
}

sub addFPMappings {
    (@_ == 2) or croak "usage: obj->addFPMappings(FUNCTIONS-REF)";
    my ($self, $functions) = @_;

    my $fpMappings = $self->{CONF}{FP_MAPPINGS};
    my @haveFPs = grep { $functions->{$_}{FUNC_PTRS} } keys %$functions;
    foreach my $srcFn (@haveFPs) {
        my $fn = $functions->{$srcFn};
        $srcFn = trimFuncName($srcFn);

        if (not exists $fpMappings->{$srcFn}) {
            die "Error: Missing mapping for function pointer used inside $srcFn\n";
        }

        my %mapping = ();
        foreach my $prevFn (keys %{$fpMappings->{$srcFn}}) {
            # silently skip previous-in-path functions that don't exist
            next if not ($prevFn eq "ALL" or exists $functions->{$prevFn});

            # keep NULLs, filter out missing functions
            my @targets;
            foreach my $target (@{$fpMappings->{$srcFn}{$prevFn}}) {
                if ($target eq "NULL" or exists $functions->{$target}) {
                    push @targets, $target;
                    next;
                }
                if ($target =~ m/^(\w+)\*\*\*$/) {
                    my $funcPrefix = $1;
                    push @targets, grep { m/^$funcPrefix/ } keys %$functions;
                }
            }

            if (0 == @targets) {
                die "Error: empty FP mapping for $srcFn => $prevFn\n";
            }

            $mapping{$prevFn} = \@targets;
        }

        # error if no previous-in-path functions are valid
        if (0 == keys %mapping) {
            die "Error: empty FP mapping for $srcFn\n";
        }

        $fn->{FP_CALLS} = \%mapping;
    }
}

sub extractTaskInfo {
    (@_ == 1) or croak "usage: obj->extractTaskInfo()";
    my $self = shift;

    my $taskItems = $self->{TASKS_REF}{GROUP_ITEMS_H};

    while (my ($key, $taskDef) = each %$taskItems) {
        my $entryFn;
        if (exists $taskDef->{OSTASK_DEFINE}) {
            $entryFn = $taskDef->{OSTASK_DEFINE}{ENTRY_FN};
        } elsif (exists $taskDef->{OSWKRTHD_DEFINE}) {
            $entryFn = $taskDef->{OSWKRTHD_DEFINE}{ENTRY_FN};

            # turn SEC2's worker thread into regular task definition
            my $newTask = {
                OVERLAY_COMBINATION => $taskDef->{OVERLAY_COMBINATION},
                OSTASK_DEFINE => {
                    # copy existing fields
                    %{$taskDef->{OSWKRTHD_DEFINE}},

                    STACK_SIZE =>
                        (max map {$_->{STACK_SIZE}} @{$taskDef->{JOBS}}),

                    MAX_OVERLAYS_IMEM_LS =>
                        (max map {$_->{MAX_OVERLAYS_IMEM_LS}} @{$taskDef->{JOBS}}),
                },
            };

            $taskDef = $newTask;
        } else {
            croak "Unexpected item $key in Tasks.pm";
            next;
        }

        # skip tasks that aren't in this build
        next if not exists $self->{FUNCTIONS}{$entryFn};
        $self->{TASKS}{$entryFn} = $taskDef;
    }
}

sub addInterruptOverhead {
    (@_ == 1) or croak "usage: obj->addInterruptOverhead()";
    my $self = shift;
    my $intOverhead = $self->{CONF}{RTOS_PARAMS}{$self->{ARCH}}{INTERRUPT_OVERHEAD};

    #
    # Give every task entry point extra stack usage for interrupt overhead.
    #
    # Cycles use the same mechanism. Assume there can be no relwrsion to a task entry point.
    # MMINTS-TODO: enforce no relwrsion to task entry point allowed.
    # Enfore no compaction of task entry points.
    #
    foreach my $task (keys %{$self->{TASKS}}) {
        my $fn = $self->{FUNCTIONS}{$task};
        $fn->{ORIG_STACK} = $fn->{STACK};
        $fn->{STACK} += $intOverhead;
        $fn->{EXTRA_STACK} = "$intOverhead";
    }
}

sub compactTraverseSingleFunction {
    (@_ == 3) or croak "usage: obj->compactTraverseSingleFunction(NAME, PROCESS-AS-KERNEL-MODE)";
    my ($self, $name, $userModeOnly) = @_;

    my $info = $self->traverseGraph($name, 0, $userModeOnly);
    $info->{COMPACTED} = 1;

    if ($self->{ARCH} eq 'FALCON') {
        my $ovlRulesHash = $info->{OVL_RULES_HASH};
        my @ovlStrs = keys %$ovlRulesHash;
        if (@ovlStrs > 1 or ($ovlStrs[0] and $ovlRulesHash->{$ovlStrs[0]}{OVL_ARRAY} and
                                @{$ovlRulesHash->{$ovlStrs[0]}{OVL_ARRAY}} > 1)) {
            loudError("compact", "can't compact function $name, its ".
                                 "calltree includes multiple overlays");
        }
    }

    return $info->{CALLS_SKIPPED};
}

sub analyzeCompactFuncs {
    (@_ == 1) or croak "usage: obj->analyzeCompactFuncs()";
    my $self = shift;
    my $functions = $self->{FUNCTIONS};

    # don't try to compact functions that aren't present
    # MMINTS-TODO: handle RISCV static function name mangling here somehow
    my @toCompact = grep {exists $functions->{$_}} @{$self->{CONF}{COMPACT}};

    my %userModeOnlyMaxStacks;

    foreach my $name (@toCompact) {
        if ($self->{ARCH} eq 'RISCV') {
            # Compact with user-mode first to get the user-mode-only stack
            my $numSkipped = $self->compactTraverseSingleFunction($name, 1);
            $userModeOnlyMaxStacks{$name} = $self->{INFO}{$name}{MAX_STACK}{AMT};

            if ($numSkipped == 0) {
                # Don't re-traverse with kernel-mode if we didn't skip anything
                # when going user-mode-only.
                next;
            }
        }

        $self->compactTraverseSingleFunction($name, 0);
    }

    foreach my $name (@toCompact) {
        my $fn = $functions->{$name};

        # rename original function
        $functions->{$name . "-ORIGINAL"} = $fn;

        # insert compacted replacement
        $functions->{$name} = {
            NAME => $fn->{NAME} . "-COMPACTED",
            FULL_NAME => $fn->{FULL_NAME} . "-COMPACTED",
            ADDR => $fn->{ADDR},
            OVERLAY => $fn->{OVERLAY},
            #ENTRY_FN => $fn->{ENTRY_FN},

            CALLS => [],
            COMPACTED_ENTRY_CALLS => $fn->{CALLS},

            STACK => $self->{INFO}{$name}{MAX_STACK}{AMT},
            COMPACTED_ENTRY_STACK => $fn->{STACK},

            COMPACTED_USER_MODE_ONLY_STACK => $userModeOnlyMaxStacks{$name},

            FUNC_PTRS => 0,
            COMPACTED_ENTRY_FUNC_PTRS => $fn->{FUNC_PTRS},

            COMPACTED => 1,

            COMPACTED_PROTECTED_FUNCS => $self->{INFO}{$name}{PROTECTED_FUNCS},
        };

        if ($self->{ARCH} ne 'RISCV') {
            delete $functions->{$name}{COMPACTED_USER_MODE_ONLY_STACK};
        } elsif ($functions->{$name}{COMPACTED_USER_MODE_ONLY_STACK} > $functions->{$name}{STACK}) {
            loudError("compact", "Error compacting function $name: " .
                                 "computed user-mode-only stack is larger than the max stack!");
        }

        if (exists $fn->{ORIG_STACK}) {
            $functions->{$name}{COMPACTED_ENTRY_ORIG_STACK} = $fn->{ORIG_STACK};
        }

        if (exists $fn->{EXTRA_STACK}) {
            $functions->{$name}{COMPACTED_ENTRY_EXTRA_STACK} = $fn->{EXTRA_STACK};
        }

        if (exists $fn->{REACHED}) {
            $functions->{$name}{REACHED} = $fn->{REACHED};
        }

        if (exists $fn->{IS_PROTECTED}) {
            $functions->{$name}{IS_PROTECTED} = $fn->{IS_PROTECTED};
        }

        # Done copying, now update the original's name
        $fn->{NAME} = $fn->{NAME} . "-ORIGINAL";
    }

    foreach my $name (@toCompact) {
        #
        # Once all compact functions are processed, re-traverse
        # to properly include compacted functions in other compacted
        # functions' trees.
        #
        $functions->{$name}->{CALLS} = $functions->{$name}->{COMPACTED_ENTRY_CALLS};
        $functions->{$name}->{STACK} = $functions->{$name}->{COMPACTED_ENTRY_STACK};
        $functions->{$name}->{FUNC_PTRS} = $functions->{$name}->{COMPACTED_ENTRY_FUNC_PTRS};

        # We want to process as kernel-mode to get the full trees
        $self->compactTraverseSingleFunction($name, 0);

        #
        # Reset the current compacted function's calls back to empty
        # and stack back to max once done
        #
        $functions->{$name}->{CALLS} = [];
        $functions->{$name}->{STACK} = $self->{INFO}{$name}{MAX_STACK}{AMT};
        $functions->{$name}->{FUNC_PTRS} = 0;
    }
}

sub parseCycles {
    (@_ == 1) or croak "usage: obj->parseCycles()";

    my $self = shift;
    my $cycleLimitsRef = delete $self->{CONF}{CYCLE_LIMITS};

    $cycleLimitsRef = cfgHashOrderedRef($cycleLimitsRef, 'cycleLimits');

    $self->{CONF}{CYCLE_LIMITS_LIST} = delete $cycleLimitsRef->{_ORIG_IN_ORDER_KEYS};

    foreach my $funcName (keys %{$cycleLimitsRef}) {
        my $value = $cycleLimitsRef->{$funcName};

        if (ref($value) eq 'ARRAY') {
            $value = UtilsUproc::parseHalParamBlock("[UcodeAnalyze] \$cycleLimits::${funcName}", $value);

            # Perl colwerts undef to string when it appears as a hash key.  Colwert it back to undef
            $value = undef          if $value eq 'undef';

            $cycleLimitsRef->{$funcName} = $value;
        }
    }

    $self->{CONF}{CYCLE_LIMITS} = $cycleLimitsRef;
}

sub analyzeCycles {
    (@_ == 1) or croak "usage: obj->analyzeCycles()";
    my $self = shift;

    $self->parseCycles();

    my $functions = $self->{FUNCTIONS};
    my $cycleLimitsRef = $self->{CONF}{CYCLE_LIMITS};

    # stack usage of each distinct cycle
    $self->{CYCLE_STACKS} = {};

    # max stack usage of all cycles that begin at a each function
    $self->{CYCLE_ROOTS} = {};

    foreach my $funcName (keys %$cycleLimitsRef) {
        # skip functions that do not exist in objdump
        # MMINTS-TODO: get this working with RISCV static function name mangling
        next unless exists $functions->{$funcName};

        my $info = $self->traverseGraph($funcName, 1);

        foreach my $cycle (@{$info->{CYCLES}}) {
            # colwert back to list format
            my @cycleFuncs = split ' ', $cycle;

            # ignore other cycles that the calltree might contain
            next if $funcName ne $cycleFuncs[0];

            my $cycleStack = sum(map($functions->{$_}{STACK}, @cycleFuncs));

            $self->{CYCLE_ROOTS}{$funcName} = max(
                $self->{CYCLE_ROOTS}{$funcName} || 0,
                $cycleStack
            );

            $self->{CYCLE_STACKS}{$cycle} = $cycleStack;
        }

        # don't treat it like a task during output
        delete $self->{INFO}{$funcName};
    }

    foreach my $funcName (keys %$cycleLimitsRef) {
        my $limit = ($self->{CONF}{CYCLE_LIMITS}{$funcName} || 1) - 1;
        my $stack = $self->{CYCLE_ROOTS}{$funcName} || 0;

        my $fn = $functions->{$funcName};
        $fn->{ORIG_STACK} = $fn->{STACK};
        $fn->{STACK} += $stack * $limit;
        $fn->{EXTRA_STACK} = "$limit*$stack";
    }
}

# RISCV: Remove suffixes like .part.1 and -ORIGINAL from funcs
sub trimFuncName {
    (@_ == 1) or croak "usage: trimFuncName(FN-NAME)";
    my $fnName = shift;

    $fnName = ($fnName =~ /^(.*?)-ORIGINAL$/) ? $1 : $fnName;
    $fnName = ($fnName =~ /^(.*?)(\.(part|isra|constprop)\.\d+?)+$/) ? $1 : $fnName;

    return $fnName;
}

sub getRiscvTaskStackSize {
    (@_ == 2) or croak "usage: obj->getRiscvTaskStackSize(ENTRY-FN)";

    my ($self, $entryFn) = @_;

    my $declStack;

    my $stackSecName = $self->{TASKS}{$entryFn}{OSTASK_DEFINE}{OVERLAY_STACK};
    if (defined $stackSecName and $stackSecName =~ m/^OVL_INDEX_DMEM\((stack\w+)\)$/) {
        if (defined $self->{DATA_SECTION_INFO}) {
            #
            # On RISCV we have different stack sizes than on Falcon.
            # It no longer makes sense to source them from Tasks.pm, so
            # we get the stack sizes directly from RiscvSectionsData.pm
            #
            my $stackName = $1;
            my $sectionRef = $self->getRiscvSectionByCamelCaseName($stackName, 1);

            if ($sectionRef) {
                $declStack = $sectionRef->{HEAP_SIZE};
            } else {
                loudError("stack", "Cannot find RISCV section $stackName");
            }
        } else {
            loudError("stack", "DATA_SECTION_INFO not configured, ".
                                "cannot fetch RISCV task stack size!");
        }
    } else {
        loudError("stack", "Tasks.pm stack section/overlay definition ".
                            "for ($entryFn, $stackSecName) is invalid!");
    }

    return $declStack;
}

sub traverseGraph {
    (@_ == 2 or @_ == 3 or @_ == 4)
        or croak "usage: obj->traverseGraph(ENTRY-FN, [FIND-CYCLES, [PROCESS-AS-KERNEL-MODE]])";
    my ($self, $entryFn, $findCycles, $userModeOnly) = @_;
    my $functions = $self->{FUNCTIONS};
    if (not exists $functions->{$entryFn}) {
        # MMINTS-TODO: refactor crashes in this file to use our libraries properly (utilExitIfErrors etc)
        die "[UcodeAnalyze] error [traverseGraph]: can't find function $entryFn\n";
        exit 1;
    }

    my %ovlRulesHash;   # all overlay combinations in the graph
    my @callTree;       # [function name, depth, cumulative stack]
    my @overflows;      # [path as string, stack]
    my @cycles;         # [function list as string]
    my @path;           # current path in the tree

    my %maxStack = (
        AMT => 0,       # usage in bytes
        PATHS => []     # all paths (as strings) that used that amount
    );
    my $declStack;
    my @funcsProtected;
    my $protectedFlag = {};

    if (exists $self->{TASKS}{$entryFn}) {
        if ($self->{ARCH} eq 'FALCON') {
            # avoid autovivifying {OSTASK_DEFINE}
            $declStack = $self->{TASKS}{$entryFn}{OSTASK_DEFINE}{STACK_SIZE};

            # Check if OverlaysDmem.pm was parsed (Doesn't exist on DPU lwrrently)
            if(defined $self->{DMEM_OVL_INFO}) {
                my $stackName = $self->{TASKS}{$entryFn}{OSTASK_DEFINE}{OVERLAY_STACK};
                if(defined $stackName and $stackName =~ m/^OVL_INDEX_DMEM\((stack\w+)\)$/) {
                    # Extract stack name from OSTASK_DEFINE
                    $stackName =~ s/^OVL_INDEX_DMEM\((stack\w+)\)$/$1/;
                    my $dmemOvlStackSize = $self->{DMEM_OVL_INFO}->{STACKS}->{$stackName};
                    if(defined $dmemOvlStackSize) {
                        if($dmemOvlStackSize * 256 != $declStack) {
                            printf "[UcodeAnalyze] Error: Stack size %d blocks (%d bytes) declared in ".
                                    "OverlaysDmem.pm doesn't match value %d bytes in Tasks.pm for task %s\n",
                                    $dmemOvlStackSize, $dmemOvlStackSize*256, $declStack, $self->{TASKS}{$entryFn}{NAME};
                            exit 1;
                        }
                    }
                }
            }
        } else {
            $declStack = $self->getRiscvTaskStackSize($entryFn);
        }
    }

    # queue item: [function name, depth, cumulative stack usage]
    my @queue;
    push @queue, [$entryFn, 0, 0];

    # Number of functions skipped due to e.g. user-mode-only traversal (RISCV)
    my $numSkipped = 0;

    while (@queue > 0) {
        my ($name, $depth, $stack) = @{pop @queue};
        my $fn = $functions->{$name};
        my $isUserModePath = 0;

        if (!$fn) {
            loudError("traverse", "No function found for $name!");
        }

        splice @path, $depth;

        if ($self->{ARCH} eq 'RISCV') {
            $isUserModePath = ((exists $self->{TASKS}{$entryFn}) || $userModeOnly) &&
                (@path > 0 && $path[-1] !~ /^lwrtos/) && # lwrtos* functions are the only ones allowed to raise priv on PMU-RISCV
                !(first { $self->isFunctionKernelMode($_) } @path); # make sure there were no kernel-mode functions up the call-tree already!

            #
            # If the current function requires kernel mode and the current path is user-mode-only,
            # then we can skip under certain conditions.
            #
            if ($isUserModePath && $self->isFunctionKernelMode($name)) {
                #
                # Tasks might call shared code that could have "if-kernel" or "if-priv" branches
                # going into kernel code. We don't have branch analysis right now,
                # so we can't do error-checking, but just assume that it is OK.
                #
                $numSkipped++;
                next;
            }
        }

        # check if this function is protected by SSP
        if ($fn->{IS_PROTECTED}) {
            push @funcsProtected, $name;
        } elsif (exists $fn->{COMPACTED_PROTECTED_FUNCS}) {
            # Propagate num of protected functions up from compacted functions
            push @funcsProtected, @{$fn->{COMPACTED_PROTECTED_FUNCS}};
        }

        $fn->{REACHED} = 1;

        # handle cycles
        my $isOrigMatch = 0;
        if (contains(\@path, $name) || ($isOrigMatch = contains(\@path, "$name-ORIGINAL"))) {
            my $searchName = $isOrigMatch ? "$name-ORIGINAL" : $name;

            push @callTree, ["CYCLE", $depth, $searchName];

            my $cycleStart = first { $path[$_] eq $searchName } 0..$#path;
            my @cycleFuncs = @path[$cycleStart .. $#path];
            # Trim -ORIGINAL in the cycle strings to match the original cycle analysis
            # (which happens pre-compaction)
            @cycleFuncs = map { trimFuncName($_) } @cycleFuncs;
            push @cycles, "@cycleFuncs";

            if (not ($findCycles or exists $self->{CYCLE_ROOTS}{$cycleFuncs[0]})) {
                print ((join ", ", @cycleFuncs) . " -> $searchName");
                loudError("traverse", "Error: found cycle at $searchName with no limit set in Analyze.pm");
            }

            next;
        } elsif ($fn->{COMPACTED}) {
            #
            # Go through all the functions in the compacted tree. If any one of them has already
            # been encountered in the path, then use the un-compacted function.
            #
            foreach my $compactedTreeEntry (@{$self->{INFO}{$name}{CALL_TREE}}) {
                my $calledByCompacted = $compactedTreeEntry->[0];
                if (contains(\@path, $calledByCompacted) || contains(\@path, "$calledByCompacted-ORIGINAL")) {
                    $name .= '-ORIGINAL';
                    $fn = $functions->{$name};
                    last;
                }
            }
        }

        push @path, $name;

        if (($self->{ARCH} eq 'RISCV') && exists $fn->{COMPACTED_USER_MODE_ONLY_STACK} &&
            ($name ne $entryFn) && $isUserModePath) {
            # If we're in user-mode, use user-mode-only size versions for all compacted functions in the tree.
            # These are often smaller than the kernel-mode versions in practice.
            $stack += $fn->{COMPACTED_USER_MODE_ONLY_STACK};
        } else {
            $stack += $fn->{STACK};
        }

        # reverse so that DFS traverses in the right order
        my @calls = reverse @{$fn->{CALLS}};
        if ($fn->{FUNC_PTRS}) {
            push @calls, $self->resolveFuncPtrs($fn, \@path);
        }

        if (@calls == 0) {
            # all overlays on this path, excluding resident
            my @pathOvls = map { $functions->{$_}{OVERLAY} } @path;
            @pathOvls = sort(unique(grep { $_ ne "resident" } @pathOvls));

            # store overlays as string for easier duplicate removal
            my $ovlStr = join " ", @pathOvls;
            if ($ovlStr) {
                if (not defined $ovlRulesHash{$ovlStr})
                {
                    $ovlRulesHash{$ovlStr}{OVL_ARRAY} = \@pathOvls;
                    $ovlRulesHash{$ovlStr}{PATH} = [];
                }
                push @{$ovlRulesHash{$ovlStr}{PATH}}, join (" ", @path);
            }

            my @pathProcessed;

            foreach my $name (@path) {
                my $fn = $self->{FUNCTIONS}{$name};
                push @pathProcessed, $fn->{NAME};
            }

            # check for max stack usage
            if ($stack > $maxStack{AMT}) {
                %maxStack = ( AMT => $stack, PATHS => ["@pathProcessed"] );
            } elsif ($stack == $maxStack{AMT}) {
                push @{$maxStack{PATHS}}, "@pathProcessed";
            }

            # check for stack overflow
            if (defined $declStack) {
                if ($stack > $declStack) {
                    if (exists $self->{TASKS}{$entryFn}) {
                        # MMINTS-TODO: error out properly here
                        die "@pathProcessed $stack $declStack";
                    }

                    push @overflows, ["@pathProcessed", $stack];
                }
            }
        } else {
            push @queue, map([$_, $depth + 1, $stack], @calls);
        }

        push @callTree, [$name, $depth, $stack];
    }

    %ovlRulesHash = removeSubsetsHash(%ovlRulesHash);

    @cycles = unique(@cycles);
    @funcsProtected = unique(@funcsProtected);

    my $info = {
        CALL_TREE      => \@callTree,
        OVL_RULES_HASH => \%ovlRulesHash,
        OVERFLOWS      => \@overflows,
        CYCLES         => \@cycles,
        MAX_STACK      => \%maxStack,
        PROTECTED_FUNCS => \@funcsProtected,
        CALLS_SKIPPED  => $numSkipped,
    };

    $self->{INFO}{$entryFn} = $info;
    return $info;
}

sub resolveFuncPtrs {
    (@_ == 3) or croak "usage: obj->resolveFuncPtrs(FUNCTION-REF, PATH)";
    my ($self, $fn, $path) = @_;

    # ALL overrides anything else
    foreach my $loc (("ALL", reverse @$path)) {
        # MMINTS-TODO: it's messy that we have to call trimFuncName for everything
        # that needs to match up to the configs in Analyze.pm.
        # Need to find a way to unhack this eventually.
        my $locTrimmed = trimFuncName($loc);

        if (exists $fn->{FP_CALLS}{$locTrimmed}) {
            my @targets = @{$fn->{FP_CALLS}{$locTrimmed}};
            # filter out NULLs; returning an empty list is OK
            @targets = grep { $_ ne "NULL" } @targets;

            return @targets;
        }
    }

    die "No FP mappings for @{[$fn->{NAME}]} match path: @$path\n";
}

sub analyzeUnreached {
    (@_ == 1) or croak "usage: obj->analyzeUnreached()";
    my $self = shift;

    my @unreached;
    while (my ($name, $fn) = each %{$self->{FUNCTIONS}}) {
        next if $fn->{REACHED};
        next if $name =~ /HalIfacesSetup_/;
        # both of these are actually labels, not functions
        next if $name =~ /^(_restore_ctx|GC5_EXIT)$/;
        push @unreached, $name;
    }

    @unreached = sort @unreached;
    $self->{UNREACHED} = \@unreached;
}

sub validateStack {
    (@_ == 2) or croak "usage: obj->validateStack(TASK)";
    my ($self, $task) = @_;
    my $si = $self->getStackInfo($task);
    if ($si->{DIFF} < 0) {
        my $excess = abs $si->{DIFF};
        return "Possible stack overflow in $task:\n" .
               "Reserved $si->{DECL} bytes but using $si->{TOTAL_USED} " .
               "(overflow: $excess bytes)";
    } else {
        return;
    }
}

# Check that every overlay rule determined during calltree traversal is a subset
# of at least one of the rules declared in Tasks.pm. This brute-force algorithm
# is O(n^3) but apparently that's good enough.
sub validateOverlays {
    (@_ == 2) or croak "usage: obj->validateOverlays(TASK)";
    my ($self, $task) = @_;

    # RISCV has no overlays to check
    return if $self->{ARCH} eq 'RISCV';

    # skip SEC2 tasks that use on-demand IMEM OVL paging
    return if $self->{TASKS}{$task}{OSTASK_DEFINE}{TASK_IMEM_PAGING} eq "LW_TRUE";

    my $ProfileUtil = $UPROC->{PROFILE_UTIL};

    # get all rules for lwrrently enabled chips
    my @taskRules = map {
        $_->{OVERLAYS}
    } grep {
        $ProfileUtil->isTargetProfileInPatternList($_->{PROFILES}) || chipEnabledListFromFamilyList(@{$_->{CHIPS}})
    } values %{$self->{TASKS}{$task}{OVERLAY_COMBINATION}};

    foreach my $rule (@taskRules) {
        map {
            s/^\.imem_//;   # remove "imem_" prefix
            s/\?$//;        # remove trailing "?"
        } @$rule;
    }

    my @errs;
    my $errno = 0;
    foreach my $ovlStr (keys %{$self->{INFO}{$task}{OVL_RULES_HASH}}) {
        my $rule = $self->{INFO}{$task}{OVL_RULES_HASH}->{$ovlStr}{OVL_ARRAY};
        # needs to be subset of at least one declared rule
        my $ruleOK = scalar grep { isSubset($rule, $_) } @taskRules;
        if (not $ruleOK) {
            push @errs, $errno++ . ": [ " . join(", ", map("'.imem_$_'", @$rule)) . " ]";
            push @errs, "PATHS:";
            push @errs, map( "\t" . $_, @{$self->{INFO}{$task}{OVL_RULES_HASH}->{join(" ", @$rule)}{PATH}});
            push @errs, "\n";
        }
    }

    if (@errs > 0) {
        my $spew = "$task overlay failure:\n";
        $spew .= "TASK_RULES:\n";
        foreach my $taskRule (@taskRules)
        {
            $spew .= "\t[ " . join(", ", map("'.imem_$_'", @$taskRule)) . " ]\n";
        }
        $spew .= "\n\n";

        $spew .= join("\n", @errs);

        return $spew;
    } else {
        return;
    }
}

sub loudError {
    my ($type, $desc) = @_;
    printf "\n********!!!!!!!! %s ERROR !!!!!!!!********\n", uc $type;
    die $desc . "\n";
    exit 1;
}

sub getRiscvSectionByCamelCaseName {
    (@_ == 3) or croak "usage: obj->getSectionByCamelCaseName(SECTION-NAME, IS-DATA)";

    # Colwert from camel-case to tag name
    my ($self, $sectionName, $isData) = @_;
    $sectionName =~ s/([A-Z])/_$1/g;
    $sectionName = uc $sectionName;
    return $self->{$isData ? 'DATA_SECTION_INFO' : 'CODE_SECTION_INFO'}->grpItemRef($sectionName);
}

sub isFunctionKernelMode {
    (@_ == 2) or croak "usage: obj->getStackInfo(FN-NAME)";
    my ($self, $name) = @_;
    my $sectionName = $self->{FUNCTIONS}{$name}{OVERLAY};

    if ($sectionName eq 'identity') {
    # HACK: identity mapping is not in RiscvSectionsCode.pm, because it doesn't have to be
        return 1;
    }

    return $self->getRiscvSectionByCamelCaseName($sectionName, 0)->{PERMISSIONS} =~ /X/;
}

sub getStackInfo {
    (@_ == 2) or croak "usage: obj->getStackInfo(ENTRY-FN)";
    my ($self, $entryFn) = @_;

    if (not exists $self->{INFO}{$entryFn}) {
        die "[UcodeAnalyze] error [getStackInfo]: can't find function $entryFn\n";
        exit 1;
    }

    my %res;

    my $maxStack = $self->{INFO}{$entryFn}{MAX_STACK};
    $res{USED} = $maxStack->{AMT};
    $res{MAX_STACK_PATHS} = $maxStack->{PATHS};

    my $taskInfo = $self->{INFO}{$entryFn};
    $res{PROTECTED_FUNCS} = $taskInfo->{PROTECTED_FUNCS};

    my $rtosParams = $self->{CONF}{RTOS_PARAMS}{$self->{ARCH}};
    my $isTrapHandler = 0;
    if (contains($rtosParams->{INTERRUPT_HANDLERS}, $entryFn)) {
        $res{ADJUST} = -$rtosParams->{INTERRUPT_OVERHEAD};
        $isTrapHandler = 1;
    } else {
        $res{ADJUST} = 0;
    }

    if (exists $self->{TASKS}{$entryFn}) {
        $res{ADJUST} += $self->{TASK_OVERHEAD};
    }

    $res{TOTAL_USED}  = $res{USED} + $res{ADJUST};

    if ($self->{ARCH} eq 'FALCON') {
        # mystery bug.  Tasks fails when remain space is zero
        # AI: Nemko
        $res{TOTAL_USED} += 4;
    }

    if (exists $self->{TASKS}{$entryFn}) {
        if ($self->{ARCH} eq 'FALCON') {
            $res{DECL} = $self->{TASKS}{$entryFn}{OSTASK_DEFINE}{STACK_SIZE};
        } else { # RISCV
            $res{DECL} = $self->getRiscvTaskStackSize($entryFn);
        }
    } else {
        if ($isTrapHandler) {
            if ($self->{ARCH} eq 'FALCON') {
                if ($entryFn =~ /^IV*/) {
                    $res{DECL} = $self->{PROFILE}{ISR_STACK};
                } elsif ($entryFn =~ /^EV*/) {
                    $res{DECL} = $self->{PROFILE}{ESR_STACK};
                } else {
                    loudError("stack", "Can't match trap handler $entryFn to the Falcon ".
                                       "interrupt stack or exception stack");
                }
            } else { # RISCV
                # We can still have nested exceptions inside trap handler code, so halve the sys stack size
                $res{DECL} = $self->{PROFILE}{SYS_STACK} / 2;
            }
        } else {
            if ($self->{ARCH} eq 'RISCV' && $entryFn eq $rtosParams->{START}) {
                # On RISCV the pre-init code uses the system stack, same as trap handlers.
                $res{DECL} = $self->{PROFILE}{SYS_STACK};

                # HACK: add the trap handler's max stack to the pre-init stack
                if ($res{ADJUST} != 0) {
                    loudError("stack", "Initial adjust value for $entryFn should be 0!");
                }

                if (@{$rtosParams->{INTERRUPT_HANDLERS}} != 1) {
                    loudError("stack", "Too many interrupt handlers for RISCV! Expected 1 handler!");
                }

                my $resTrapHandler = $self->getStackInfo($rtosParams->{INTERRUPT_HANDLERS}[0]);
                $res{ADJUST} = $resTrapHandler->{TOTAL_USED};
                $res{TOTAL_USED} += $res{ADJUST};

                # MMINTS-TODO: add some string field to print to "identify" the ADJUST value
            }
        }
    }

    if ($res{DECL}) {
        $res{DIFF} = $res{DECL} - $res{TOTAL_USED};
    } else {
        $res{DECL} = $res{DIFF} = 0;
    }

    return \%res;
}

sub getRtosRoots {
    (@_ == 1) or croak "usage: obj->getRtosRoots()";
    my $self = shift;
    # helper returning all non-task entry points
    my $rtosParams = $self->{CONF}{RTOS_PARAMS}{$self->{ARCH}};
    return (
        @{$rtosParams->{INTERRUPT_HANDLERS}},
        $rtosParams->{START}
    );
}

# returns count of item in array
sub contains {
    my ($arr, $item) = @_;
    return scalar grep { $_ eq $item } @$arr;
}

# get unique elements, ordering preserved
sub unique {
    my %h = ();
    return grep { not $h{$_}++ } @_;
}

# returns true if $arr1 is a subset of $arr2
sub isSubset {
    my ($arr1, $arr2) = @_;
    my %hash;
    @hash{@$arr1} = ();
    delete @hash{@$arr2};
    return not keys %hash;
}

# Remove overlay subsets from OVL_RULES_HASH
sub removeSubsetsHash {
    my (%hash) = @_;
    my @sorted_keys = map { my @arr = ( $_, $hash{$_}{OVL_ARRAY} ); \@arr } keys %hash;
    @sorted_keys = sort { scalar @{$a->[1]} <=> scalar @{$b->[1]} } @sorted_keys;

    for (my $i = 0; $i < @sorted_keys; $i++) {
        # only check arrays after it, since ones before are <= in size
        for (my $j = $i + 1; $j < @sorted_keys; $j++) {
            if (isSubset($sorted_keys[$i]->[1], $sorted_keys[$j]->[1]))
            {
                push @{$hash{$sorted_keys[$j]->[0]}{PATH}}, @{$hash{$sorted_keys[$i]->[0]}{PATH}};
                delete $hash{$sorted_keys[$i]->[0]};
                last;
            }
        }
    }

    return %hash;
}

1;
