/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2013-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file: acr.c
 */

//
// Includes
//
#include "acr.h"
#include "dev_fb.h"
#include "dev_pwr_pri.h"
#include "dev_pwr_falcon_csb.h"
#include "dev_pwr_csb.h"

#include "falcon.h"

#include "acr_objacr.h"
#include "acr_objacrlib.h"

#include "config/g_acr_private.h"
#include "config/g_hal_register.h"

#include "sec2mutexreservation.h"

//
// Global Variables
//

/*! g_signature holds the signature of ACR HS ucode */
LwU32               g_signature[4]                          ATTR_OVLY(".data")              ATTR_ALIGNED(16);
/*! g_reserved is reserved data space in DMEM */
ACR_RESERVED_DMEM   g_reserved                              ATTR_OVLY(".dataEntry")         ATTR_ALIGNED(ACR_DESC_ALIGN);
/*! g_desc is ACR DMEM descriptor containing data passed by LWGPU-RM Master */
RM_FLCN_ACR_DESC    g_desc                                  ATTR_OVLY(".dataEntry")         ATTR_ALIGNED(ACR_DESC_ALIGN);
/*! acrHsScratchPad is global variable used to store random number generated by RNG */
LwU32               acrHsScratchPad[SCP_REG_SIZE_IN_DWORDS] ATTR_OVLY(".data")              ATTR_ALIGNED(SCP_ADDR_ALIGNMENT_IN_BYTES);

#define ACR_PC_TRIM(pc) ((pc) & 0x0FFFFFFFU)
#define ACR_TAG_TRIM(tag) ((tag) & 0x00FFFFFFU)

/*! MASK for getting block index in IMEM tag */
#define BLK_IDX_MASK_IN_IMTAG (0x0000FFFFU)
/*! Op-codes for two conselwtive nop instructions */
#define NOPNOP (0x04F804F8U)
//
// Static function prototypes
//

static void ensureReturnPCIsNotInHS(void) GCC_ATTRIB_ALWAYSINLINE();
static inline void ensureReturnPCIsInNS(void) GCC_ATTRIB_ALWAYSINLINE();
static inline void acrInitializeStackCanaryHS(void);

#ifdef IS_SSP_ENABLED

/*! __stack_chk_guard variable to store stack canary for SSP */
LwU32  __stack_chk_guard;

/*!
 * @brief Setup canary for SSP
 *        Initialzing canary to random generated number in NS section. This canary value is generated during ucode build.
 */

GCC_ATTRIB_NO_STACK_PROTECT() GCC_ATTRIB_NOINLINE()
static void canary_setup(void)
{
	__stack_chk_guard = RANDOM_CANARY_NS;
}

/*!
 * @brief Initialize stack canary to RANDOM value using RNG present in SCP.
 *        \note
 *        This is part of Stack Smashing Protection security feature. This is done for HS section.
 *     -# Initialize SCP's RNG.(Random Number Generator)
 *     -# GetRandomNumber from RNG once it is successfully initialized.
 *     -# Make sure that Random number generated is not all zero's or all 1's.
 *     -# Initialize stack canary with Random number received after step 3.
 *     -# Writes error code "ACR_ERROR_SCP_RNG_FAILED" to MAILBOX0 in case RNG fails to generate random number.
 *     -# Scrub acrHsScratchPad to avoid leaking the random number to adversary.
 *
 */
static inline void
acrInitializeStackCanaryHS(void)
{
  LwBool bFound = LW_FALSE;
  LwU32 i;

  acrInitScpRng_HAL();

  // Set the value of stack canary to a random value to ensure adversary cannot craft an attack by looking at the
  // assembly to determine the canary value.
  do
  {    
    if (acrGetRandNum_HAL(pAcr, acrHsScratchPad) == ACR_OK) {
       // Make sure value of random number is not all 0s or all 1s as these
       // might be values an adversary may think of trying
       for (i = 0; i < SCP_REG_SIZE_IN_DWORDS; i++)
       {
          if (acrHsScratchPad[i] != 0U && acrHsScratchPad[i] != 0xffffffffU)
          {
            __stack_chk_guard = (LwU32)(acrHsScratchPad[i]);
            bFound = LW_TRUE;
            break;
          }
       }
    }
    else {
       //Fatal error if 128 bit random number generation failed
       acrWriteStatusToFalconMailbox(ACR_ERROR_SCP_RNG_FAILED);
       falc_halt();
    }
  } while (!bFound);

  //Scrub the local variable as a good security practice
  for (i = 0; i < SCP_REG_SIZE_IN_DWORDS; i++)
  {
     acrHsScratchPad[i] = 0;
  }   
}
#endif

//Global Functions

/*!
 * @brief  ACR ucode Entry. First starts with Non-Secure(NS) code exelwtion.
 *        -# Enable DMEM apertures.
 *        -# Add Default error code i.e. "ACR_ERROR_BIN_STARTED_BUT_NOT_FINISHED"
 *        -# Load HS signatures.
 *        -# Programs SEC spr to indicate start/end of HS ucode loaded in IMEM to Falcon BROM.
 *        -# Calls into Heavy Secure(HS) function i.e. acrEntryFunction 
 *        -# Add two nop instructions. HS function to confirm these nops are present at return location and halt in case two nops are not present. This is to mitigate NS_Race_To_HS.
 *
 */
int main(int argc, char **Argv)
{
    LwU32 start       = (ACR_PC_TRIM((LwU32)acr_code_start));
    LwU32 end         = (ACR_PC_TRIM((LwU32)acr_code_end));

#ifdef IS_SSP_ENABLED
	// Setup canary for SSP
	canary_setup();
#endif

#ifdef DMEM_APERT_ENABLED
    //
    // Enable DMEM apertures.
    // Using blocking falcon write instruction directly here as wrapper function
    // falc_stxb_i_with_halt() will be in HS overlay and this is NS code.
    // WARNING: BELOW CODE SHOULDN'T BE COPIED INTO SECURE CODE AS IT IS NOT DOING ERROR CHECKS.
    //
    acr_falc_stxb_i( LW_CPWR_FALCON_DMEMAPERT, 0,
        DRF_NUM(_CPWR_FALCON, _DMEMAPERT, _ENABLE,   1) |
        DRF_NUM(_CPWR_FALCON, _DMEMAPERT, _TIME_UNIT,2) |
        DRF_NUM(_CPWR_FALCON, _DMEMAPERT, _TIME_OUT, 255));
#endif

    // Set DEFAULT error code
    acr_falc_stxb_i( LW_CPWR_FALCON_MAILBOX0, 0, (LwU32)ACR_ERROR_BIN_STARTED_BUT_NOT_FINISHED);

    // Load the signature first
    falc_scp_trap(2);
    falc_dmwrite(0, (((LwU32)6 << 16) | (LwU32)(g_signature)));
    falc_dmwait();

    //
    // All the required code is already loaded into IMEM
    // Just need to program the SEC spr and jump into code
    //
    CHECK_WRAP_AND_HALT(end < start);
    falc_wspr(SEC, SVEC_REG(start, (end - start), 0U, IS_HS_ENCRYPTED));

    // ACR entry point
    acrEntryFunction();
    // Don't remove below 2 nop instructions. HS ucode halts in case 2 nops are not present here. Refer - http://lwbugs/2672836
    falc_nop();
    falc_nop();

#ifndef ACR_SAFE_BUILD
    // Enable interrupts
    falc_ssetb_i(16);
    falc_ssetb_i(17);
    // Falcon core v > 4
    falc_ssetb_i(18);

    // Clear SVEC register
    falc_wspr(SEC, 0);

    // Halt anyway.. Bootloader is already ilwalidated above..
    falc_halt();
#endif

    return 0;
}

/*!
 * @brief Ensure Return PC does belong to NS section. This is a security feature. 
 *        IMEM tag is callwlated based on return PC value.\n
 *        IMEM Block(corresponding to tag) found is ensured to be valid, not secure, not pending, not missing and not multi hit. Issue falcon halt in
 *        case any of above condition is violated.\n
 *        8 bytes are read from returnPC location and ensured that it contains NOP instructions. Instructions in IMEM(NS/LS) part are read
 *        using falcon IMEMC/D registers.\n
 */
static void
ensureReturnPCIsInNS(void)
{
    LwU32 *returnPC = __builtin_return_address(0);
    LwU32 imtagVal;
    LwU32 tmp;
    LwU32 valid, pending, secure, missing, multihit;
    LwU32 phyBlkId, phyOffset, pcLo, aincr, imemc, dataL, dataH;
    
    falc_imtag(&imtagVal, (LwU32)returnPC);

    valid     = DRF_VAL(_FLCN, _IMTAG_BLK, _VALID, imtagVal);
    pending   = DRF_VAL(_FLCN, _IMTAG_BLK, _PENDING, imtagVal);
    secure    = DRF_VAL(_FLCN, _IMTAG_BLK, _SELWRE, imtagVal);
    multihit  = DRF_VAL(_FLCN, _IMTAG_BLK, _MULTI_HIT, imtagVal);
    missing   = DRF_VAL(_FLCN, _IMTAG_BLK, _MISS, imtagVal);

    if((valid == 0U) || (pending == 1U) || (secure == 1U) || (missing == 1U) || (multihit == 1U))
    {
        falc_halt();// issue falcon halt if returnPC block is invalid, pending, secure, mutlihit or missing. WARNING: Make sure you have mitigation for NS_Restart_From_HS implemented before issuing falc_halt
    }

    phyBlkId = (imtagVal & (LwU32)BLK_IDX_MASK_IN_IMTAG) << 8U; //Lower 8bit is 0
    phyOffset = (LwU32)returnPC & 0xflw; //word offset
    pcLo = (LwU32)returnPC & 0x3U;
    aincr = 0x2000000; //(1U << 25U) ccomplains for MISRA 12.2 violation. Basically this is to configure IMEM in auto read increment mode.
    // read IMEM via PMB
    imemc = phyBlkId | phyOffset | aincr;
    ACR_REG_WR32(CSB, LW_CPWR_FALCON_IMEMC(0U), imemc);
    dataL = ACR_REG_RD32(CSB, LW_CPWR_FALCON_IMEMD(0U));
    dataH = ACR_REG_RD32(CSB, LW_CPWR_FALCON_IMEMD(0U));
    // make sure the first 2 instructions are "nop"
    tmp = (dataL >> (pcLo << 3U)) | (dataH << ((4U - pcLo) << 3U));
    if (tmp != (LwU32)NOPNOP)
    {
        falc_halt(); // issue falcon halt in case return PC location doesn't contain 2 conselwtive NOP instructions. WARNING: Make sure you have mitigation for NS_Restart_From_HS implemented before issuing falc_halt
    }
}

/*!
 * @brief Ensures Return PC does not belong to HS section. This is a security feature. 
 *        IMEM tag is callwlated based on return PC value and it is ensured that tag found is not part of HS.\n
 *        Falcon is halted in case return PC belongs to HS section.
 */
static void
ensureReturnPCIsNotInHS(void)
{
    LwU32 *returnPC = __builtin_return_address(0);
    LwU32 imtagVal;

    falc_imtag(&imtagVal, (LwU32)returnPC);

    if (IMTAG_IS_SELWRE(imtagVal))
    {
        // Return PC is pointing to a secure block. NS/LS must be trying to mount a ROP attack. Take punitive action.This reference implementation simply halts.
        falc_halt();
    }
}

/*!
 * @brief Initialize HAL setup to Initialize HAL pointers.
 *        -# Call to "acrMitigateNsRestartFromHs" is a security feature that makes sure master cannot restart ACR in case it halts in HS mode.
 *        -# Call to "ensureReturnPCIsNotInHS" is a security feature that ensures that return PC is not in HS mode.
 *        -# Call to "ensureReturnPCIsInNS" is a security feature that ensures that return PC is in NS and contains two NOP instructions.
 *        -# Initialize stack canary for SSP feature.
 *        -# Perform build check for this binary.
 *        -# Perform FUSE revocation check.(Protection from rollback attacks.)
 *        -# Lock Falcon reset.
 *        -# Initiate acrInit exelwtion.
 *        -# Unlock Falcon reset after acrInit completes.
 *        -# ACR ucode completes all exelwtion before end of this function and calls falc_halt() to HALT the falcon in HS mode.
 */
GCC_ATTRIB_STACK_PROTECT()
void
acrEntryFunction(void)
{
    // Make sure different master cannot restart ACR in case it halts in HS mode
    acrMitigateNsRestartFromHs_HAL();

    ensureReturnPCIsNotInHS();

    ensureReturnPCIsInNS();

    ACR_STATUS status = ACR_OK;
    ACR_STATUS flcnLockStatus = ACR_OK;

#ifdef IS_CAPTURE_VCAST
    // Allowing DMEM read only for testing and collection of coverage results. VCAST dumps coverage results in DMEM.
    // IS_CAPTURE_VCAST should be enabled locally. It is only present for testing purposes. Please note this flag should never be enabled for
    // production profiles. This is a CYA bit. This bit has no effect in production mode. Writing 1 to this bit will disable lockdown for Inselwre code
    // if the unit is in debug mode.
    ACR_REG_WR32_STALL(CSB, LW_CPWR_PMU_SCP_CTL_DEBUG, DRF_DEF(_CPWR_PMU, _SCP_CTL_DEBUG, _LOCKDOWN_CYA, _ENABLE));
#endif

#ifdef IS_SSP_ENABLED
    // Save NS stack canary, this is required because we want to enable SSP for HS entry
    LwU32 nsCanary = __stack_chk_guard;
    // Reinitialize canary to random number generated by HS
    acrInitializeStackCanaryHS();
#endif

    // Verify if this binary should be allowed to run on particular chip
    if (ACR_OK != (status = acrCheckIfBuildIsSupported_HAL(pAcr)))
    {
        acrWriteStatusToFalconMailbox(status);
        falc_halt();
    }

    // Check if sw ucode version matches hw version
    if (ACR_OK != (status = acrCheckFuseRevocation_HAL(pAcr)))
    {
        acrWriteStatusToFalconMailbox(status);
        falc_halt();
    }

    // Lock falcon reset so that no one can reset ACR
    if (ACR_OK != (status = acrLockFalconReset_HAL(pAcr, LW_TRUE)))
    {
        goto done;
    }

    acrValidateBlocks();

    // Call the main function to handle ACR
#ifdef ACR_LOAD_PATH
    if (ACR_OK != (status = acrInit_HAL(pAcr)))
    {
        goto done;
    }
#endif

done:
    acrWriteStatusToFalconMailbox(status);
    flcnLockStatus = acrLockFalconReset_HAL(pAcr, LW_FALSE);
    // Unlock falcon reset to original mask value
    // HALT in HS mode if there is some error encountered during acrInit_HAL exelwtion.
    if ((status != ACR_OK) || (flcnLockStatus != ACR_OK))
    {
        // NOTE: Do not put any C code after this as GPRs are cleared
        acrCleanup();
        falc_halt();
    }
    // NOTE: Do not put any C code after this as GPRs are cleared
    acrCleanup();
// Two branches for FALCON HALT for safe and non-safe builds.

#ifdef ACR_SAFE_BUILD
// HALT in HS mode for SAFE PROFILE as there is no other firmware that needs to be exelwted on current falcon.
    falc_halt();
#else
// Halt here to ensure PMU LS mode is not compromised. This is essentially a jump to HALT opcodes written in non-HS part. This is done to clean up falcon
// pipeline of secure instructions, so as to de-assert Big Hammer lockdown successfully after ACR completion.
    acrForceHalt();
#endif

#ifdef IS_SSP_ENABLED
	// Restore NS canary
    __stack_chk_guard = nsCanary;
#endif
}

/*!
 * @brief This funtion will ilwalidate the bubbles (blocks not of ACR HS, caused if ACR blocks are not loaded contiguously in IMEM)
 */
void
acrValidateBlocks(void)
{
    LwU32 start        = (ACR_PC_TRIM((LwU32)acr_resident_code_start));
    LwU32 end          = (ACR_PC_TRIM((LwU32)acr_resident_code_end));

    LwU32 tmp          = 0;
    LwU32 imemBlks     = 0;
    LwU32 blockInfo    = 0;
    LwU32 lwrrAddr     = 0;

    //
    // Loop through all IMEM blocks and ilwalidate those that doesnt fall within
    // acr_resident_code_start and acr_resident_code_end
    //

    // Read the total number of IMEM blocks
#ifdef ACR_FALCON_PMU
    tmp = ACR_REG_RD32(CSB, LW_CPWR_FALCON_HWCFG);
    imemBlks = DRF_VAL(_CPWR_FALCON, _HWCFG, _IMEM_SIZE, tmp);
#else
    ct_assert(0);
#endif
    for (tmp = 0; tmp < imemBlks; tmp++)
    {
        falc_imblk(&blockInfo, tmp);

        if (!(IMBLK_IS_ILWALID(blockInfo)))
        {
            lwrrAddr = IMBLK_TAG_ADDR(blockInfo);

            // Ilwalidate the block if it is not a part of ACR binary
            if (lwrrAddr < start || lwrrAddr >= end)
            {
                falc_imilw(tmp); 
            }
        }
    }
}

