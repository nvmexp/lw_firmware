/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file:  booter_se_access_tu10x.c
 */
//
// Includes
//
#include "booter.h"

//
// DIO channel requests use bit 17 of address to indicate a read req
// defining here to avoid magic number since it is not in the manuals
//
// TODO for jamesx by GP107 FS: File bug for HW to add
// TODO for jamesx by GP107 FS: Rename to something that HW would use as the define
//
#define FALCON_DIO_D0_READ_BIT          0x10000

/*
 * Utility macro that may be used validate an index to ensure a valid common HW
 * mutex corresponds to that index.  A non-zero return value represents a
 * valid mutex; zero represents an invalid mutex.
 *
 * @param[in] groupId: Group index
 * @param[in] mutexId: Mutex index
 */
#define SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupId, mutexId)                     \
    (groupId < LW_SSE_SE_COMMON_MUTEX_MUTEX__SIZE_1 &&                          \
        mutexId < LW_SSE_SE_COMMON_MUTEX_MUTEX__SIZE_2)

/*!
 * @brief: Acquires SE common mutex
 *
 * @param[in] busTarget: Since this is common binary, bus target could be LWDEC or
 *                          SEC2
 * @param[in] groupId:  From GV100 onwards, mutexes are grouped into HS and LS.
 *                          Indicate groud ID of mutex.
 * @param[in] mutexId:  Mutex id of register.
 * @param[out] pToken:  HW generated token which is used to acquire mutex. This
 *                          toekn is used to release mutex.
 *
 * @return  BOOTER_ERROR_ILWALID_ARGUMENT:     Invalid mutex group or id
            BOOTER_ERROR_ILWALID_ARGUMENT      pToken is null
 *          BOOTER_ERROR_MUTEX_ACQUIRE_FAILED: Error while accessing bus or failed
 *                                          to acquire mutex
 *          BOOTER_OK: No Error scenario
 */
BOOTER_STATUS
booterAcquireSelwreMutex_TU10X
(
    LwU8  mutexId,
    LwU8 *pToken
)
{
    LwU32       genId;
    LwU32       mutexOwner;
    BOOTER_STATUS  status = BOOTER_OK;


    // Setup bus target based on which falcon we're running on.
#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
    BOOTER_SELWREBUS_TARGET busTarget = SEC2_SELWREBUS_TARGET_SE;
#elif defined(BOOTER_RELOAD)
    BOOTER_SELWREBUS_TARGET busTarget = LWDEC_SELWREBUS_TARGET_SE;
#else
    ct_assert(0);
#endif

    if (NULL == pToken)
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }

    // Colwert into groupId and actual mutexId
    LwU8 groupIndex = SELWRE_MUTEX_DERIVE_GROUPID(mutexId);
    LwU8 mutexIndex = SELWRE_MUTEX_DERIVE_MUTEXID(mutexId);

    // Check validity of group and mutex
    if (!SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupIndex, mutexIndex))
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }

    // Get HW generated token
    CHECK_STATUS_AND_RETURN_IF_NOT_OK(
        booterSelwreBusReadRegister_HAL(pBooter, busTarget, LW_SSE_SE_COMMON_MUTEX_ID(groupIndex),
            &genId));

    genId = DRF_VAL(_SSE, _SE_COMMON_MUTEX_ID, _VALUE, genId);

    if (genId == LW_SSE_SE_COMMON_MUTEX_ID_VALUE_NOT_AVAIL ||
        genId == LW_SSE_SE_COMMON_MUTEX_ID_VALUE_INIT)
    {
        return BOOTER_ERROR_MUTEX_ACQUIRE_FAILED;
    }

    genId = FLD_SET_DRF_NUM(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, genId, 0);

    do
    {
        // Write generated token to Mutex register
        status = booterSelwreBusWriteRegister_HAL(pBooter, busTarget,
            LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex),
            genId);

        if (status != BOOTER_OK)
        {
            goto fail_and_bail_mutex;
        }

        // Read back Mutex register
        if (BOOTER_OK != (status = booterSelwreBusReadRegister_HAL(pBooter, busTarget,
            LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &mutexOwner)))
        {
            goto fail_and_bail_mutex;
        }

    } while (DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, mutexOwner) != DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, genId));

    *pToken = genId;
    return BOOTER_OK;

fail_and_bail_mutex:
    *pToken = 0;
    // Release the genID generated by this function
    if (genId != LW_SSE_SE_COMMON_MUTEX_ID_VALUE_INIT &&
        genId != LW_SSE_SE_COMMON_MUTEX_ID_VALUE_NOT_AVAIL)
    {
        booterSelwreBusWriteRegister_HAL(pBooter, busTarget,
                LW_SSE_SE_COMMON_MUTEX_ID_RELEASE(groupIndex), genId);
    }

    return BOOTER_ERROR_MUTEX_ACQUIRE_FAILED;
}

/*!
 * @brief: Releases common mutex
 *
 * @param[in] mutexId:  Mutex id of register.
 * @param[oin] hwToken: HW generated token which is used to acquire mutex. This
 *                          toekn is used to release mutex.
 *
 * @return  BOOTER_ERROR_ILWALID_ARGUMENT:   Invalid mutex group or id
 *          BOOTER_OK: No Error scenario
 */

BOOTER_STATUS
booterReleaseSelwreMutex_TU10X
(
    LwU8  mutexId,
    LwU8  hwTokenFromCaller
)
{
    BOOTER_STATUS status  = BOOTER_OK;
    BOOTER_STATUS status2 = BOOTER_OK;
    LwU32 mutexOwnerInHw;

    // Setup bus target based on which falcon we're running on.
#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
    BOOTER_SELWREBUS_TARGET busTarget = SEC2_SELWREBUS_TARGET_SE;
#elif defined(BOOTER_RELOAD)
    BOOTER_SELWREBUS_TARGET busTarget = LWDEC_SELWREBUS_TARGET_SE;
#else
    ct_assert(0);
#endif

    // Colwert into groupId and actual mutexId
    LwU8 groupIndex = SELWRE_MUTEX_DERIVE_GROUPID(mutexId);
    LwU8 mutexIndex = SELWRE_MUTEX_DERIVE_MUTEXID(mutexId);

    // Check validity of group and mutex
    if (!SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupIndex, mutexIndex))
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }

    // Read back mutex register and confirm ownership against hwToken passed by caller
    CHECK_STATUS_AND_RETURN_IF_NOT_OK (booterSelwreBusReadRegister_HAL(pBooter, busTarget,
        LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &mutexOwnerInHw));

    // Mutex is owned by caller if the caller's hwToken matches with HW, otherwise not
    if (DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, mutexOwnerInHw) != hwTokenFromCaller)
    {
        return BOOTER_ERROR_MUTEX_OWNERSHIP_MATCH_FAILED;
    }

    // All ok, release the mutex as well as the hwToken.
    status = booterSelwreBusWriteRegister_HAL(pBooter, busTarget,
                 LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex),
                 DRF_NUM(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, LW_SSE_SE_COMMON_MUTEX_MUTEX_VALUE_INIT));

    hwTokenFromCaller = FLD_SET_DRF_NUM(_SSE, _SE_COMMON_MUTEX_ID_RELEASE, _VALUE, hwTokenFromCaller, 0);

    status2 = booterSelwreBusWriteRegister_HAL(pBooter, busTarget,
                 LW_SSE_SE_COMMON_MUTEX_ID_RELEASE(groupIndex), hwTokenFromCaller);


    return ((status == BOOTER_OK) ? status2 : status);
}

/*!
 * @brief Sends a read or write request to the Secure private
 * bus between LWDEC/SEC2 and SECHUB
 *
 * @param[in] busTarget     Which secure bus should the request be sent to
 * @param[in] bRead         Whether it is a read or a write request
 * @param[in] addr          Address
 * @param[in] valToWrite    If its a write request, the value is written
 *
 * @return
 */
BOOTER_STATUS
booterSelwreBusSendRequest_TU10X
(
    BOOTER_SELWREBUS_TARGET    busTarget,
    LwBool                  bRead,
    LwU32                   addr,
    LwU32                   valueToWrite
)
{
    LwU32 status;
    LwU32 dioReadyVal;
    LwU32 ctrlAddr;
    LwU32 d0Addr;
    LwU32 d1Addr;

    // TODO for jamesx by GP107 FS: Use proper read/write methods (acrlibFlcnRead/Write) instead of ldx/stx
    //        The current unclean solution is unfortunate because we are out of BSI ram
    //        and using acrlib adds ~700 bytes in ucode which is ~2100B in BSI
    // TODO for jamesx for Bug 1732094: Error check for secure bus writes

    // Setup defines based on bus target
#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
    if (busTarget == SEC2_SELWREBUS_TARGET_SE)
    {
        dioReadyVal =   DRF_DEF(_CSEC, _FALCON_DOC_CTRL, _EMPTY,       _INIT) |
                        DRF_DEF(_CSEC, _FALCON_DOC_CTRL, _WR_FINISHED, _INIT) |
                        DRF_DEF(_CSEC, _FALCON_DOC_CTRL, _RD_FINISHED, _INIT);

        ctrlAddr = LW_CSEC_FALCON_DOC_CTRL;
        d0Addr   = LW_CSEC_FALCON_DOC_D0;
        d1Addr   = LW_CSEC_FALCON_DOC_D1;
    }
    else
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }
#elif defined(BOOTER_RELOAD)
    if (busTarget == LWDEC_SELWREBUS_TARGET_SE)
    {
        dioReadyVal =   DRF_DEF(_CLWDEC, _FALCON_DOC_CTRL, _EMPTY,       _INIT) |
                        DRF_DEF(_CLWDEC, _FALCON_DOC_CTRL, _WR_FINISHED, _INIT) |
                        DRF_DEF(_CLWDEC, _FALCON_DOC_CTRL, _RD_FINISHED, _INIT);

        ctrlAddr = LW_CLWDEC_FALCON_DOC_CTRL;
        d0Addr   = LW_CLWDEC_FALCON_DOC_D0;
        d1Addr   = LW_CLWDEC_FALCON_DOC_D1;
    }
    else
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }
#else
    ct_assert(0);
#endif

    //
    // Send out the read/write request onto the DIO
    // 1. Wait for channel to become empty/ready
    do
    {
        status = BOOTER_REG_RD32(CSB, ctrlAddr) & dioReadyVal;
    }
    // TODO for jamesx for Bug 1732094: Timeout support
    while (status != dioReadyVal);

    // 2. If it is a write request the push value onto D1,
    //    otherwise set the read bit in the address
    if (bRead)
    {
        addr |= FALCON_DIO_D0_READ_BIT;
    }
    else
    {
        BOOTER_REG_WR32(CSB, d1Addr, valueToWrite);
    }

    // 3. Issue request
    BOOTER_REG_WR32(CSB, d0Addr, addr);

    return BOOTER_OK;
}

/*!
 * @brief Once a read request happens through booterSelwreBusSendRequest,
 *        this function reads the data back
 *
 * @param[in] busTarget     Which secure bus should the request be sent to
 *
 * @return value read from the secure bus
 */
BOOTER_STATUS
booterSelwreBusGetData_TU10X
(
    BOOTER_SELWREBUS_TARGET    busTarget,
    LwU32                   addr,
    LwU32                  *pVal
)
{
    LwU32 error;
    LwU32 data;
    LwU32 pop1Dword     = 0;
    LwU32 dicCtrlAddr;
    LwU32 docCtrlAddr;
    LwU32 d0Addr;
#ifndef DISABLE_SE_ACCESSES
    LwU32 index;
#endif

     if (NULL == pVal)
     {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
     }

#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
     // Setup defines based on bus target
    if (busTarget ==  SEC2_SELWREBUS_TARGET_SE)
    {
        dicCtrlAddr = LW_CSEC_FALCON_DIC_CTRL;
        docCtrlAddr = LW_CSEC_FALCON_DOC_CTRL;
        d0Addr      = LW_CSEC_FALCON_DIC_D0;
    }
    else
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }

    // Common stuff for access to both HUB and SE switch
    pop1Dword   = FLD_SET_DRF_NUM(_CSEC, _FALCON_DIO_DIC_CTRL, _POP, 0x1, pop1Dword);
#elif defined(BOOTER_RELOAD)
    if (busTarget ==  LWDEC_SELWREBUS_TARGET_SE)
    {
        dicCtrlAddr = LW_CLWDEC_FALCON_DIC_CTRL;
        docCtrlAddr = LW_CLWDEC_FALCON_DOC_CTRL;
        d0Addr      = LW_CLWDEC_FALCON_DIC_D0;
        pop1Dword   = FLD_SET_DRF_NUM(_CLWDEC, _FALCON_DIC_CTRL, _POP, 0x1, pop1Dword);
    }
    else
    {
        return BOOTER_ERROR_ILWALID_ARGUMENT;
    }
#else
    ct_assert(0);
#endif

    //
    // Read data from DIO
    // 1. Wait until data is available
    //
#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
    do
    {
        data = BOOTER_REG_RD32(CSB, dicCtrlAddr);
    }
    // TODO for jamesx for Bug 1732094: Timeout support
    while (FLD_TEST_DRF_NUM(_CSEC, _FALCON_DIO_DIC_CTRL, _COUNT, 0x0, data));
#elif defined(BOOTER_RELOAD)
    do
    {
        data = BOOTER_REG_RD32(CSB, dicCtrlAddr);
    }
    // TODO for jamesx for Bug 1732094: Timeout support
    while (FLD_TEST_DRF_NUM(_CLWDEC, _FALCON_DIC_CTRL, _COUNT, 0x0, data));
#endif


    // 2. Pop read data
    BOOTER_REG_WR32(CSB, dicCtrlAddr, pop1Dword);

    // 2.5 Check read error from the DOC control
    error = BOOTER_REG_RD32(CSB, docCtrlAddr);

    //Check if there is a read error or a protocol error
#if defined(BOOTER_LOAD) || defined(BOOTER_UNLOAD)
    if (FLD_TEST_DRF_NUM(_CSEC, _FALCON_DIO_DOC_CTRL, _RD_ERROR,       0x1, error) ||
        FLD_TEST_DRF_NUM(_CSEC, _FALCON_DIO_DOC_CTRL, _PROTOCOL_ERROR, 0x1, error))
    {
        return BOOTER_ERROR_SELWRE_BUS_REQUEST_FAILED;
    }
#elif defined(BOOTER_RELOAD)
    if (FLD_TEST_DRF_NUM(_CLWDEC, _FALCON_DOC_CTRL, _RD_ERROR,       0x1, error) ||
        FLD_TEST_DRF_NUM(_CLWDEC, _FALCON_DOC_CTRL, _PROTOCOL_ERROR, 0x1, error))
    {
        return BOOTER_ERROR_SELWRE_BUS_REQUEST_FAILED;
    }
#else
    ct_assert(0);
#endif


    // 3. Get the data itself
    *pVal = BOOTER_REG_RD32(CSB, d0Addr);

#ifndef DISABLE_SE_ACCESSES
    //
    // We have skipped PEH for SE registers in falc_ldxb_i_with_halt
    // So doing some PEH here, and allowing badfxxxx reads(valid) for TRNG registers
    // More details in Bug 200326572, and in comments of function falc_ldxb_i_with_halt
    //
    if (booterIgnoreSePkaBankRegForBadValueCheck_HAL(pBooter, addr))
    {
        return BOOTER_OK;
    }

    if ((*pVal & CSB_INTERFACE_MASK_VALUE) == CSB_INTERFACE_BAD_VALUE)
    {
        for (index = 0; index < LW_SSE_SE_TRNG_RAND__SIZE_1; index++)
        {
            if(addr == LW_SSE_SE_TRNG_RAND(index))
            {
                return BOOTER_OK;
            }
        }
        FAIL_BOOTER_WITH_ERROR(BOOTER_ERROR_PRI_FAILURE_FOR_SE_REG_ACCESS_OVER_SE_BUS);
    }
#endif

    return BOOTER_OK;
}

/*!
 * @brief Write a register using the secure bus
 *
 * @param[in] busTarget     Which secure bus should the request be sent to
 * @param[in] addr  Address
 * @param[in] val   If its a write request, the value is written
 *
 * @return    BOOTER_STATUS whether the write was successful or not
 */
BOOTER_STATUS
booterSelwreBusWriteRegister_TU10X
(
    BOOTER_SELWREBUS_TARGET busTarget,
    LwU32 addr,
    LwU32 val
)
{
    return booterSelwreBusSendRequest_HAL(pBooter, busTarget, LW_FALSE, addr, val);
}

/*!
 * @brief Read a register using the secure bus
 *
 * @param[in] busTarget     Which secure bus should the request be sent to
 * @param[in] addr   Address
 * @param[in] *pVal  Pointer for value to be read
 *
 * @return BOOTER_STATUS whether the read was successful or not
 */
BOOTER_STATUS
booterSelwreBusReadRegister_TU10X
(
    BOOTER_SELWREBUS_TARGET busTarget,
    LwU32 addr,
    LwU32 *pVal
)
{
    BOOTER_STATUS status = BOOTER_OK;

    status = booterSelwreBusSendRequest_HAL(pBooter, busTarget, LW_TRUE, addr, 0);

    if (status == BOOTER_OK)
    {
        booterSelwreBusGetData_HAL(pBooter, busTarget, addr, pVal);
        return BOOTER_OK;
    }

    return status;
}

