#!/usr/bin/perl -w
#
# _LWRM_COPYRIGHT_BEGIN_
#
# Copyright 2021 by LWPU Corporation.  All rights reserved.  All
# information contained herein is proprietary and confidential to LWPU
# Corporation.  Any use, reproduction, or disclosure without the written
# permission of LWPU Corporation is prohibited.
#
# _LWRM_COPYRIGHT_END_
#

#
# vcast_submit.pl
#   Script to submit auto-generated metadata.json and coverage report in HTML format to
#   a set location in perforce for further processing
#

use strict;
use warnings "all";

use Elw;
use File::Copy;
use Getopt::Long;
use JSON;

#
# Global variables
#
my $opt_verbose = 0;    # Set to print verbose info
my $p4Path;             # Path to P4 
my $p4Root;             # Path to P4 Root
my $trackerJson;        # Path to reportTracker.json
my $metadataJson;       # Path to metadata.json (Auto-generated during vcast build)
my $reportHtml;         # Path to vectorcast result HTML file
my $clNumber;           # CL number created for submission
my $status = 1;         # Track status
my $metadataCopyToPath; # Metadata path to copy to
my $reportCopyToPath;   # Report path to copy to

# Path where storage is expected to be
my $storagePath = "/sw/apps/gpu/drivers/resman/pmu/pmu-dashboard/vcastreports";

#
# Helper Functioins
#
sub verbose { print(@_, "\n") if ( $opt_verbose ); }

#
# Functions
#

# usage
sub usage
{
    print <<__USAGE__;

Usage:

   perl vcast_submit.pl [ options ]

Options:

    --help                                      This message

    --verbose                                   Enable verbose messages while running script

__USAGE__

    exit 0;
}

# Function to exec a command passed to it
sub runCmd
{
    verbose("Cmd: $_[0]\n");
    my @data = `$_[0] 2>&1`;
    if ($? != 0)
    {
        die "Error running cmd: ($_[0]) Error msg: $! Error code: $?\n";
    }
    verbose("Output: @data\n");
    return @data;
}

# Function to run a command and test its output for matching keywords
sub runCmdAndTest
{
    my @data = runCmd(@_);
    if (!$data[0] || $data[0] !~ /.* - opened for*/)
    {
        print "Error running p4 cmd $_[0]: $data[0]\n";
        $status = 0;
        return 0;
    }
    return 1;
}

# setup for pre-processing
sub setup
{
    $p4Path = "p4";

    $p4Root = $ELW{P4ROOT};
    
    if (!$p4Root)
    {
        die "Error: P4ROOT not set. Please set environment variable to use this script\n";
    }

    # Update storagePath with p4Root
    $storagePath = $p4Root.$storagePath;

    $trackerJson = "$storagePath/reportTracker.json";

    unless (-e $trackerJson)
    {
        die "Error: Please sync folder //sw/gpu/drivers/resman/pmu/pmu-dashboard/vcastreports\n";
    }

    $metadataJson = "../prod_app/vcast_elw/metadata.json";

    unless (-e $metadataJson)
    {
        die "Error: Cannot find metadata.json at $metadataJson\n";
    }

    $reportHtml = "../prod_app/vcast_elw/vcast_elw_aggregate_coverage_report.html";

    unless (-e $reportHtml)
    {
        die "Error: Cannot find vcast_elw_aggregate_coverage_report.html at $reportHtml\n";
    }

}

# Parse command line arguments
sub parseArgs
{
    my $result;
    my $help;

    $result = GetOptions(
        "help"                      => \$help,              # --help
        "verbose|v"                 => \$opt_verbose,       # --verbose -v
        );

    usage()             if $help;
}

sub vcastSubmit
{
    # Read tracker data
    my $trackerJsonData;
    my $driverBranch;
    my $pmuProfile;
    my $reportCount = 0;

    open(FHIN, '<', $trackerJson) or die "unable to open input file $trackerJson\n";
    {
        local $/ = undef;
        $trackerJsonData = <FHIN>; 
    }
    close(FHIN);

    verbose("Tracker data:\n$trackerJsonData");

    my $trackerData = JSON->new->decode($trackerJsonData);

    # Read metadata
    my $metadataJsonData;
    open(FHIN, '<', $metadataJson) or die "unable to open input file $metadataJson\n";
    {
        local $/ = undef;
        $metadataJsonData = <FHIN>; 
    }
    close(FHIN);

    my $metadataData = JSON->new->decode($metadataJsonData);

    # Check if all fields are filled in metadata
    foreach my $key (keys %$metadataData)
    {
        verbose("$key = $metadataData->{$key}\n");
        if(!$metadataData->{$key})
        {
            die "Missing data for $key. Please fill in manually if not autogenerated\n";
        }
        if ($key eq "driverBranch")
        {
            $driverBranch = $metadataData->{$key};
        }
        elsif ($key eq "pmuProfile")
        {
            $pmuProfile = $metadataData->{$key};
        }
    }

    # Find correct entry and update tracker count
    foreach my $data (@{$trackerData})
    {
        if ($data->{'driverBranch'} eq $driverBranch &&
            $data->{'pmuProfile'} eq $pmuProfile)
        {
            $data->{'reportCount'}++;
            $reportCount = $data->{'reportCount'};
            last;
        }
    }

    # If no record was found, reportCount will be 0. Create new record
    if ($reportCount == 0)
    {
        $reportCount++;
        push (@$trackerData,
            {
                driverBranch => "$driverBranch",
                pmuProfile => "$pmuProfile",
                reportCount => $reportCount,
                lastProcessed => 0
            }
        );

        #Create new directories to store the reports
        unless (mkdir "$storagePath/$driverBranch")
        {
            die "Creation of dirs $storagePath/$driverBranch failed: $! ($?)";
        }
        unless (mkdir "$storagePath/$driverBranch/$pmuProfile")
        {
            die "Creation of dirs $storagePath/$driverBranch/$pmuProfile failed: $! ($?)";
        }
    }

    # Copy result and metadata file to the required path
    print "Copying data...\n";
    $metadataCopyToPath = "$storagePath/$driverBranch/$pmuProfile/metadata$reportCount.json";
    $reportCopyToPath ="$storagePath/$driverBranch/$pmuProfile/report$reportCount.html";
    if (-e $metadataCopyToPath)
    {
        die "Error: File $metadataCopyToPath already exists !";
    }
    if (-e $reportCopyToPath)
    {
        die "Error: File $reportCopyToPath already exists !";
    }
    copy($metadataJson, $metadataCopyToPath)
        or die "Copy of $metadataJson failed: $! ($?)";
    copy($reportHtml, $reportCopyToPath)
        or die "Copy of $metadataJson failed: $! ($?)";

     # Update tracker
     print "Updating tracker...\n";
     my @p4Data = runCmd("p4 --field \"Description=VCAST coverage data. Report $reportCount to $driverBranch/$pmuProfile. Auto-submitting via script\" --field \"Files=\" change -o | p4 change -i");

     if ($p4Data[0] =~ /Change (\d+) created/)
     {
        $clNumber = $1;
     }
     else
     {
         die "CL creation failed (@p4Data)";
     }

     verbose("CL number = $clNumber");

     return if (!runCmdAndTest("p4 edit -c $clNumber $trackerJson"));
     open(FHOUT, '>', $trackerJson) or die "unable to open output file $trackerJson\n";
     binmode(FHOUT);
     print FHOUT JSON->new->pretty->encode(\@$trackerData);
     close(FHOUT);

     return if (!runCmdAndTest("p4 add -c $clNumber $metadataCopyToPath"));
     return if (!runCmdAndTest("p4 add -c $clNumber $reportCopyToPath"));

     @p4Data = runCmd("p4 submit -c $clNumber");
     if ($p4Data[$#p4Data] !~ /submitted/)
     {
         print "Error submitting change: $p4Data[$#p4Data]\n";
         print "\nP4 command return data:\n@p4Data\n";
         $status = 0;
         return;
     }

     print "Successfully submitted as report $reportCount to $storagePath/$driverBranch/$pmuProfile!\n";
}

sub cleanup
{
    print "Cleaning up...\n";
    runCmd("p4 revert -c $clNumber //...");
    runCmd("p4 change -d $clNumber");
    unlink($reportCopyToPath) or die "Can't delete $reportCopyToPath";
    unlink($metadataCopyToPath) or die "Can't delete $metadataCopyToPath";
}

#
# Start exelwtion here!
#

my $start_time = time();
parseArgs();

setup();
vcastSubmit();
if (!$status)
{
    cleanup();
}

my $end_time = time();
my $run_time = $end_time - $start_time;
print "\lwCAST submit script runtime = $run_time secs\n";
