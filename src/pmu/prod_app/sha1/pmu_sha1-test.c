/*
 * Copyright (c) 2019, LWPU CORPORATION. All rights reserved.
 *
 * LWPU CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from LWPU CORPORATION is strictly prohibited.
 */

#include "test-macros.h"
#include "pmu_sha1.h"

// Utility copy function
static LwU32 _copyFunc(LwU8 *pBuff, LwU32 index, LwU32 size, void *pInfo)
{
    memcpy(pBuff, (LwU8*) pInfo + index, size);
    return size;
}   

// SHA1 operates on blocks of 64 bytes, so try edge cases
// Initialize with some data
static LwU8 data1[32] = {
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61 
}; 

static LwU8 data2[64] = {  
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef
};

static LwU8 data3[65] = {
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0x42
};

static LwU8 data4[128] = {
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61 
};

// Hash gold values
static const LwU8 hash1[LW_PMU_SHA1_DIGEST_SIZE] = {
    0x68, 0xf8, 0x4a, 0x59, 0xa3, 0xca, 0x2d, 0x0e, 
    0x5c, 0xb1, 0x64, 0x6f, 0xbb, 0x16, 0x4d, 0xa4, 
    0x09, 0xb5, 0xd8, 0xf2
};
static const LwU8 hash2[LW_PMU_SHA1_DIGEST_SIZE] = {
    0x2b, 0x91, 0x60, 0x41, 0x7a, 0xed, 0x21, 0x57, 
    0x77, 0x67, 0x2b, 0xe9, 0xfa, 0x9c, 0x1f, 0x51, 
    0x01, 0x33, 0xd0, 0x05
};
static const LwU8 hash3[LW_PMU_SHA1_DIGEST_SIZE] = {
    0x2d, 0x7a, 0x8b, 0xfe, 0xa6, 0x93, 0xb6, 0xd3, 
    0x38, 0xf1, 0xfe, 0x24, 0xfb, 0x30, 0xc8, 0xa4,
    0x06, 0xc4, 0x53, 0xda
};
static const LwU8 hash4[LW_PMU_SHA1_DIGEST_SIZE] = {
    0x7c, 0x7c, 0x1a, 0xd3, 0x6e, 0x54, 0xa9, 0xc4, 
    0xe5, 0x4d, 0x0c, 0xee, 0x16, 0x4d, 0xfe, 0x1f,
    0x37, 0x68, 0x0c, 0x6f
};

/* TODO: switch this suite over to fully using LibUT APIs */
UT_SUITE_DEFINE(PMU_SHA1,
                UT_SUITE_SET_COMPONENT("TODO")
                UT_SUITE_SET_DESCRIPTION("TODO")
                UT_SUITE_SET_OWNER("TODO"))

UT_CASE_DEFINE(PMU_SHA1, ValidityTest,
  UT_CASE_SET_DESCRIPTION("TODO") 
  UT_CASE_SET_TYPE(REQUIREMENTS)
  UT_CASE_LINK_REQS("TODO")
  UT_CASE_LINK_SPECS("TODO"))

UT_CASE_RUN(PMU_SHA1, ValidityTest)
{
    LwU8 hash[LW_PMU_SHA1_DIGEST_SIZE] = {0}; // Output storage buffer
 
    pmuSha1(hash, data1, sizeof(data1), _copyFunc);
    UT_ASSERT_EQUAL_INT(memcmp(hash, hash1, sizeof(hash)), 0);
 
    pmuSha1(hash, data2, sizeof(data2), _copyFunc);
    UT_ASSERT_EQUAL_INT(memcmp(hash, hash2, sizeof(hash)), 0);
 
    pmuSha1(hash, data3, sizeof(data3), _copyFunc);
    UT_ASSERT_EQUAL_INT(memcmp(hash, hash3, sizeof(hash)), 0);
 
    pmuSha1(hash, data4, sizeof(data4), _copyFunc);
    UT_ASSERT_EQUAL_INT(memcmp(hash, hash4, sizeof(hash)), 0);
}
