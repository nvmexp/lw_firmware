/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2017-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file clk_vf_point_35_volt.c
 *
 * @brief Module managing all state related to the CLK_VF_POINT_VOLT structure.
 * This structure defines a point on the VF lwrve for which voltage is the
 * independent variable (i.e. fixed for this VF point) and frequency is the
 * dependent variable (i.e. varies with process, temperature, etc.).
 *
 * The CLK_VF_POINT_VOLT class supplies the voltage value from the CLK_VF_POINT
 * super-class (@ref CLK_VF_POINT::voltageuV) to the specified VFE Equation
 * (@ref CLK_PROG_3X_PRIMARY::pVfEntries[railIdx]->vfeIdx) and stores the resulting
 * frequency in the CLK_VF_POINT super-class (@ref CLK_VF_POINT::freqMHz).
 *
 * The CLK_VF_POINT_VOLT class is intended to be used to describe frequency
 * regions which are generated by the NAFLL, whose ADC/LUT has fixed voltage
 * steps.  The CLK_PROG entry for this region will generate a CLK_VF_POINT_VOLT
 * object for each voltage in the ADC/LUT.
 */

/* ------------------------ Includes --------------------------------------- */
#include "pmu_objclk.h"
#include "perf/3x/vfe.h"
#include "volt/objvolt.h"

/* ------------------------ Global Variables ------------------------------- */
/* ------------------------ Static Function Prototypes --------------------- */
/* ------------------------ Macros ----------------------------------------- */
/* ------------------------ Public Functions ------------------------------- */
/*!
 * CLK_VF_POINT_35_VOLT class constructor.
 *
 * @copydoc BoardObjGrpIfaceModel10ObjSet
 */
FLCN_STATUS
clkVfPointGrpIfaceModel10ObjSet_35_VOLT
(
    BOARDOBJGRP_IFACE_MODEL_10        *pModel10,
    BOARDOBJ          **ppBoardObj,
    LwLength            size,
    RM_PMU_BOARDOBJ    *pBoardObjDesc
)
{
    RM_PMU_CLK_CLK_VF_POINT_35_VOLT_BOARDOBJ_SET *pSet =
        (RM_PMU_CLK_CLK_VF_POINT_35_VOLT_BOARDOBJ_SET *)pBoardObjDesc;
    CLK_VF_POINT_35_VOLT   *pVfPoint35Volt;
    FLCN_STATUS             status;


    // Call into CLK_VF_POINT_35 super-constructor
    status = clkVfPointGrpIfaceModel10ObjSet_35(pModel10, ppBoardObj, size, pBoardObjDesc);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPointGrpIfaceModel10ObjSet_35_VOLT_exit;
    }

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Volt, *ppBoardObj, CLK, CLK_VF_POINT, 35_VOLT,
                                  &status, clkVfPointGrpIfaceModel10ObjSet_35_VOLT_exit);

    // Copy the CLK_VF_POINT_35_VOLT-specific data.
    pVfPoint35Volt->sourceVoltageuV = pSet->sourceVoltageuV;
    pVfPoint35Volt->freqDelta       = pSet->freqDelta;

clkVfPointGrpIfaceModel10ObjSet_35_VOLT_exit:
    return status;
}

/*!
 * @copydoc ClkVfPointLoad
 */
FLCN_STATUS
clkVfPointLoad_35_VOLT_IMPL
(
    CLK_VF_POINT            *pVfPoint,
    CLK_PROG_3X_PRIMARY      *pProg3XPrimary,
    CLK_DOMAIN_3X_PRIMARY    *pDomain3XPrimary,
    LwU8                     voltRailIdx,
    LwU8                     lwrveIdx
)
{
    CLK_VF_POINT_35_VOLT   *pVfPoint35Volt;
    VOLT_RAIL              *pVoltRail;
    FLCN_STATUS             status         = FLCN_ERR_NOT_SUPPORTED;
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Volt, &pVfPoint->super, CLK, CLK_VF_POINT, 35_VOLT,
                                  &status, clkVfPointLoad_35_VOLT_exit);
    pBaseVFTuple = clkVfPoint35BaseVFTupleGet(&pVfPoint35Volt->super);

    // Sanity check.
    if (pBaseVFTuple == NULL)
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        goto clkVfPointLoad_35_VOLT_exit;
    }

    pBaseVFTuple->voltageuV = pVfPoint35Volt->sourceVoltageuV;

    pVoltRail = VOLT_RAIL_GET(voltRailIdx);
    if (pVoltRail != NULL)
    {
        status = voltRailRoundVoltage(pVoltRail,            // pRail
                    (LwS32*)&pBaseVFTuple->voltageuV,       // pVoltageuV
                    LW_TRUE,                                // bRoundUp
                    LW_TRUE);                               // bBound
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPointLoad_35_VOLT_exit;
        }
    }

clkVfPointLoad_35_VOLT_exit:
    return status;
}

/*!
 * @copydoc ClkVfPointVoltageuVGet
 */
FLCN_STATUS
clkVfPointVoltageuVGet_35_VOLT_IMPL
(
    CLK_VF_POINT  *pVfPoint,
    LwU8           voltageType,
    LwU32         *pVoltageuV
)
{
    CLK_VF_POINT_35_VOLT *pVfPoint35Volt;
    FLCN_STATUS           status         = FLCN_OK;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Volt, &pVfPoint->super, CLK, CLK_VF_POINT, 35_VOLT,
                                  &status, clkVfPointVoltageuVGet_35_VOLT_IMPL_exit);

    // Call super class implementation.
    status = clkVfPointVoltageuVGet_35(pVfPoint, voltageType, pVoltageuV);
    if (status == FLCN_OK)
    {
        return status;
    }

    if (LW2080_CTRL_CLK_VOLTAGE_TYPE_SOURCE == voltageType)
    {
        // Return the source voltage if requested.
        *pVoltageuV = pVfPoint35Volt->sourceVoltageuV;
        status = FLCN_OK;
    }
    else
    {
        // All other voltage types are un-supported.  Return error.
        PMU_BREAKPOINT();
        status = FLCN_ERR_NOT_SUPPORTED;
    }

clkVfPointVoltageuVGet_35_VOLT_IMPL_exit:
    return status;
}

/* ------------------------- Private Functions ------------------------------ */
