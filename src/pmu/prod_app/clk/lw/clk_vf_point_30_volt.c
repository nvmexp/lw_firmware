/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2015-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file clk_vf_point_30_volt.c
 *
 * @brief Module managing all state related to the CLK_VF_POINT_VOLT structure.
 * This structure defines a point on the VF lwrve for which voltage is the
 * independent variable (i.e. fixed for this VF point) and frequency is the
 * dependent variable (i.e. varies with process, temperature, etc.).
 *
 * The CLK_VF_POINT_VOLT class supplies the voltage value from the CLK_VF_POINT
 * super-class (@ref CLK_VF_POINT::voltageuV) to the specified VFE Equation
 * (@ref CLK_PROG_3X_PRIMARY::pVfEntries[railIdx]->vfeIdx) and stores the resulting
 * frequency in the CLK_VF_POINT super-class (@ref CLK_VF_POINT::freqMHz).
 *
 * The CLK_VF_POINT_VOLT class is intended to be used to describe frequency
 * regions which are generated by the NAFLL, whose ADC/LUT has fixed voltage
 * steps.  The CLK_PROG entry for this region will generate a CLK_VF_POINT_VOLT
 * object for each voltage in the ADC/LUT.
 */

/* ------------------------ Includes --------------------------------------- */
#include "pmu_objclk.h"
#include "perf/3x/vfe.h"
#include "volt/objvolt.h"

/* ------------------------ Static Function Prototypes ---------------------- */
static BoardObjVirtualTableDynamicCast (s_vfeVarDynamicCast_30_VOLT)
    GCC_ATTRIB_SECTION("imem_perf", "s_vfeVarDynamicCast_30_VOLT")
    GCC_ATTRIB_USED();

/* ------------------------ Global Variables ------------------------------- */
/*!
 * Virtual table for CLK_VF_POINT_30_VOLT object interfaces.
 */
BOARDOBJ_VIRTUAL_TABLE ClkVfPoint30VoltVirtualTable =
{
    BOARDOBJ_VIRTUAL_TABLE_ASSIGN_DYNAMIC_CAST(s_vfeVarDynamicCast_30_VOLT)
};

/* ------------------------ Static Function Prototypes --------------------- */
/* ------------------------ Macros ----------------------------------------- */
/* ------------------------ Public Functions ------------------------------- */
/*!
 * CLK_VF_POINT_30_VOLT class constructor.
 *
 * @copydoc BoardObjGrpIfaceModel10ObjSet
 */
FLCN_STATUS
clkVfPointGrpIfaceModel10ObjSet_30_VOLT
(
    BOARDOBJGRP_IFACE_MODEL_10        *pModel10,
    BOARDOBJ          **ppBoardObj,
    LwLength            size,
    RM_PMU_BOARDOBJ    *pBoardObjSet
)
{
    RM_PMU_CLK_CLK_VF_POINT_30_VOLT_BOARDOBJ_SET *pSet =
        (RM_PMU_CLK_CLK_VF_POINT_30_VOLT_BOARDOBJ_SET *)pBoardObjSet;
    CLK_VF_POINT_30_VOLT   *pVfPoint30Volt;
    FLCN_STATUS             status;


    // Call into CLK_VF_POINT_30 super-constructor
    status = clkVfPointGrpIfaceModel10ObjSet_SUPER(pModel10, ppBoardObj, size, pBoardObjSet);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPointGrpIfaceModel10ObjSet_30_VOLT_exit;
    }

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint30Volt, *ppBoardObj, CLK, CLK_VF_POINT, 30_VOLT,
                                  &status, clkVfPointGrpIfaceModel10ObjSet_30_VOLT_exit);

    // Copy the CLK_VF_POINT_30_VOLT-specific data.
    pVfPoint30Volt->sourceVoltageuV = pSet->sourceVoltageuV;
    pVfPoint30Volt->freqDelta       = pSet->freqDelta;

clkVfPointGrpIfaceModel10ObjSet_30_VOLT_exit:
    return status;
}

/*!
 * _VOLT implemenation.
 *
 * @copydoc ClkVfPoint30Cache
 */
FLCN_STATUS
clkVfPoint30Cache_VOLT
(
    CLK_VF_POINT_30            *pVfPoint30,
    CLK_DOMAIN_30_PRIMARY       *pDomain30Primary,
    CLK_PROG_30_PRIMARY         *pProg30Primary,
    LwU8                        voltRailIdx,
    LW2080_CTRL_CLK_VF_PAIR    *pVfPairLast,
    LW2080_CTRL_CLK_VF_PAIR    *pBaseVFPairLast,
    LW2080_CTRL_CLK_VF_PAIR    *pBaseVFPairLwrr
)
{
    CLK_VF_POINT_30_VOLT       *pVfPoint30Volt;
    VOLT_RAIL                  *pVoltRail;
    RM_PMU_PERF_VFE_VAR_VALUE   vfeVarVal;
    RM_PMU_PERF_VFE_EQU_RESULT  result;
    LwU32                       voltageuV;
    LwU16                       freqMHz;
    FLCN_STATUS                 status;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint30Volt, &pVfPoint30->super.super,
                                  CLK, CLK_VF_POINT, 30_VOLT, &status,
                                  clkVfPoint30Cache_VOLT_exit);

    // 1. Round source voltage to the voltage rail's steps.
    voltageuV = pVfPoint30Volt->sourceVoltageuV;

    pVoltRail = VOLT_RAIL_GET(voltRailIdx);
    if (pVoltRail != NULL)
    {
        status = voltRailRoundVoltage(pVoltRail,
                    (LwS32*)&voltageuV, LW_TRUE, LW_TRUE);
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPoint30Cache_VOLT_exit;
        }
    }

    clkVfPoint30VoltageuVSet(pVfPoint30, voltageuV);
    LW2080_CTRL_CLK_VF_PAIR_VOLTAGE_UV_SET(pBaseVFPairLwrr, voltageuV);

    // 2. Compute the frequency for the voltage.
    vfeVarVal.voltage.varType  = LW2080_CTRL_PERF_VFE_VAR_TYPE_SINGLE_VOLTAGE;
    vfeVarVal.voltage.varValue = pVfPoint30Volt->sourceVoltageuV;
    status = vfeEquEvaluate(
        clkProg3XPrimaryVfeIdxGet(&pProg30Primary->primary, voltRailIdx),
        &vfeVarVal,
        1,
        LW2080_CTRL_PERF_VFE_EQU_OUTPUT_TYPE_FREQ_MHZ,
        &result);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint30Cache_VOLT_exit;
    }
    freqMHz = (LwU16)result.freqMHz;

    // 3. VF lwrve smoothening code
    if ((clkProg3XPrimaryIsVFSmoothingRequired(&pProg30Primary->primary, voltageuV)) &&
        (LW2080_CTRL_CLK_PROG_1X_SOURCE_NAFLL == (pProg30Primary)->super.super.source))
    {
        LwU16 expectedMaxFreqMHz;

        expectedMaxFreqMHz =
            LW2080_CTRL_CLK_VF_PAIR_FREQ_MHZ_GET(pBaseVFPairLast) +
                clkProg3XPrimaryMaxFreqStepSizeMHzGet(&pProg30Primary->primary);

        freqMHz = LW_MIN(freqMHz, expectedMaxFreqMHz);
    }

    // 4. Round frequency to closest step supported by frequency generator.
    status = clkProg3XFreqMHzQuantize(
                &pProg30Primary->super.super,            // pProg3X
                (CLK_DOMAIN_3X_PROG *)pDomain30Primary,   // pDomain3XProg
                &freqMHz,                               // pFreqMHz
                LW_TRUE);                               // bFloor
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint30Cache_VOLT_exit;
    }
    LW2080_CTRL_CLK_VF_PAIR_FREQ_MHZ_SET(pBaseVFPairLwrr, freqMHz);

    // 5. Adjust by the frequency delta.
    freqMHz = clkFreqDeltaAdjust(freqMHz, &pVfPoint30Volt->freqDelta);

    //
    // 6. If modified, round frequency to closest step supported by
    //    frequency generator.
    //
    if (freqMHz != LW2080_CTRL_CLK_VF_PAIR_FREQ_MHZ_GET(pBaseVFPairLwrr))
    {
        status = clkProg3XFreqMHzQuantize(
                    &pProg30Primary->super.super,            // pProg3X
                    (CLK_DOMAIN_3X_PROG *)pDomain30Primary,   // pDomain3XProg
                    &freqMHz,                               // pFreqMHz
                    LW_TRUE);                               // bFloor
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPoint30Cache_VOLT_exit;
        }
    }
    clkVfPoint30FreqMHzSet(pVfPoint30, freqMHz);

clkVfPoint30Cache_VOLT_exit:
    return status;
}

/*!
 * @copydoc ClkVfPointVoltageuVGet
 */
FLCN_STATUS
clkVfPointVoltageuVGet_30_VOLT
(
    CLK_VF_POINT  *pVfPoint,
    LwU8           voltageType,
    LwU32         *pVoltageuV
)
{
    CLK_VF_POINT_30_VOLT *pVfPoint30Volt;
    FLCN_STATUS           status         = FLCN_OK;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint30Volt, &pVfPoint->super,
                                  CLK, CLK_VF_POINT, 30_VOLT, &status,
                                  clkVfPointVoltageuVGet_30_VOLT_exit);

    // Call super class implementation.
    status = clkVfPointVoltageuVGet_30(pVfPoint, voltageType, pVoltageuV);
    if (status == FLCN_OK)
    {
        return status;
    }

    if (LW2080_CTRL_CLK_VOLTAGE_TYPE_SOURCE == voltageType)
    {
        // Return the source voltage if requested.
        *pVoltageuV = pVfPoint30Volt->sourceVoltageuV;
        status = FLCN_OK;
    }
    else
    {
        // All other voltage types are un-supported.  Return error.
        PMU_BREAKPOINT();
        status = FLCN_ERR_NOT_SUPPORTED;
    }

clkVfPointVoltageuVGet_30_VOLT_exit:
    return status;
}


/* ------------------------- Private Functions ------------------------------ */
/*!
 * @brief   CLK_VF_POINT_30_VOLT implementation of
 *          @ref BoardObjVirtualTableDynamicCast()
 *
 * @copydoc BoardObjVirtualTableDynamicCast()
 */
static void *
s_vfeVarDynamicCast_30_VOLT
(
    BOARDOBJ   *pBoardObj,
    LwU8        requestedType
)
{
    void                 *pObject     = NULL;
    CLK_VF_POINT_30_VOLT *pVfPt30Volt = (CLK_VF_POINT_30_VOLT *)pBoardObj;

    if (BOARDOBJ_GET_TYPE(pBoardObj) !=
        LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 30_VOLT))
    {
        PMU_BREAKPOINT();
        goto s_vfeVarDynamicCast_30_VOLT_exit;
    }

    switch (requestedType)
    {
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, BASE):
        {
            CLK_VF_POINT *pVfPt = &pVfPt30Volt->super.super;
            pObject = (void *)pVfPt;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 30):
        {
            CLK_VF_POINT_30 *pVfPt30 = &pVfPt30Volt->super;
            pObject = (void *)pVfPt30;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 30_VOLT):
        {
            pObject = (void *)pVfPt30Volt;
            break;
        }
        default:
        {
            PMU_BREAKPOINT();
            break;
        }
    }

s_vfeVarDynamicCast_30_VOLT_exit:
    return pObject;
}
