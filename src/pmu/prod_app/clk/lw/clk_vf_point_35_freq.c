/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2017-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file clk_vf_point_35_freq.c
 *
 * @brief Module managing all state related to the CLK_VF_POINT_FREQ structure.
 * This structure defines a point on the VF lwrve for which frequency is the
 * independent variable (i.e. fixed for this VF point) and voltage is the
 * dependent variable (i.e. varies with process, temperature, etc.).
 *
 * The CLK_VF_POINT_FREQ class supplies the frequency value from the CLK_VF_POINT
 * super-class (@ref CLK_VF_POINT::freqMHz) to the specified VFE Equation
 * (@ref CLK_PROG_3X_PRIMARY::pVfEntries[railIdx]->vfeIdx) and stores the resulting
 * voltage in the CLK_VF_POINT super-class (@ref CLK_VF_POINT::voltageuV).
 *
 * The CLK_VF_POINT_FREQ class is intended to be used to describe frequency
 * regions which are generated by the fixed-frequency generators (PLL,
 * OneSource) which generate a given frequency for which a minimum required
 * voltage must be determined.
 */

/* ------------------------ Includes --------------------------------------- */
#include "pmu_objclk.h"
#include "perf/3x/vfe.h"
#include "volt/objvolt.h"

ct_assert(CLK_CLK_VF_POINT_35_FREQ_FREQ_TUPLE_MAX_SIZE <=
    LW2080_CTRL_CLK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE);

/* ------------------------ Static Function Prototypes ---------------------- */
static BoardObjVirtualTableDynamicCast (s_vfeVarDynamicCast_35_FREQ)
    GCC_ATTRIB_SECTION("imem_perf", "s_vfeVarDynamicCast_35_FREQ")
    GCC_ATTRIB_USED();

/* ------------------------ Global Variables ------------------------------- */
/*!
 * Virtual table for CLK_VF_POINT_35_FREQ object interfaces.
 */
BOARDOBJ_VIRTUAL_TABLE ClkVfPoint35FreqVirtualTable =
{
    BOARDOBJ_VIRTUAL_TABLE_ASSIGN_DYNAMIC_CAST(s_vfeVarDynamicCast_35_FREQ)
};

/* ------------------------ Static Function Prototypes --------------------- */
/* ------------------------ Macros ----------------------------------------- */
/* ------------------------ Public Functions ------------------------------- */
/*!
 * CLK_VF_POINT_35_FREQ class constructor.
 *
 * @copydoc BoardObjGrpIfaceModel10ObjSet
 */
FLCN_STATUS
clkVfPointGrpIfaceModel10ObjSet_35_FREQ
(
    BOARDOBJGRP_IFACE_MODEL_10        *pModel10,
    BOARDOBJ          **ppBoardObj,
    LwLength            size,
    RM_PMU_BOARDOBJ    *pBoardObjDesc
)
{
    RM_PMU_CLK_CLK_VF_POINT_35_FREQ_BOARDOBJ_SET *pSet =
        (RM_PMU_CLK_CLK_VF_POINT_35_FREQ_BOARDOBJ_SET *)pBoardObjDesc;
    CLK_VF_POINT_35_FREQ   *pVfPoint35Freq;
    LwU8                    clkPos;
    FLCN_STATUS             status;

    // Call into CLK_VF_POINT_35 super-constructor
    status = clkVfPointGrpIfaceModel10ObjSet_35(pModel10, ppBoardObj, size, pBoardObjDesc);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPointGrpIfaceModel10ObjSet_35_FREQ_exit;
    }

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Freq, *ppBoardObj, CLK, CLK_VF_POINT, 35_FREQ,
                                  &status, clkVfPointGrpIfaceModel10ObjSet_35_FREQ_exit);

    // Copy the CLK_VF_POINT_35_FREQ-specific data.
    for (clkPos = 0; clkPos < (Clk.progs.secondaryEntryCount + 1U); clkPos++)
    {
        // Update the base frequency tuple.
        pVfPoint35Freq->baseVFTuple.freqTuple[clkPos].freqMHz =
            pSet->freqMHz;
    }

    pVfPoint35Freq->voltDeltauV = pSet->voltDeltauV;

clkVfPointGrpIfaceModel10ObjSet_35_FREQ_exit:
    return status;
}

/*!
 * @copydoc BoardObjIfaceModel10GetStatus
 */
FLCN_STATUS
clkVfPointIfaceModel10GetStatus_35_FREQ
(
    BOARDOBJ_IFACE_MODEL_10              *pModel10,
    RM_PMU_BOARDOBJ       *pPayload
)
{
    BOARDOBJ *pBoardObj = boardObjIfaceModel10BoardObjGet(pModel10);
    RM_PMU_CLK_CLK_VF_POINT_35_FREQ_BOARDOBJ_GET_STATUS *pVfPoint35FreqStatus =
        (RM_PMU_CLK_CLK_VF_POINT_35_FREQ_BOARDOBJ_GET_STATUS *)pPayload;
    CLK_VF_POINT_35_FREQ   *pVfPoint35Freq;
    LwU8                    idx;
    FLCN_STATUS             status          = FLCN_OK;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Freq, pBoardObj,
                                  CLK, CLK_VF_POINT, 35_FREQ, &status,
                                  clkVfPointIfaceModel10GetStatus_35_FREQ_exit);

    status = clkVfPointIfaceModel10GetStatus_35(pModel10, pPayload);
    if (status != FLCN_OK)
    {
        goto clkVfPointIfaceModel10GetStatus_35_FREQ_exit;
    }

    // Copy-out the _35 specific params.
    pVfPoint35FreqStatus->baseVFTuple = pVfPoint35Freq->baseVFTuple;

    // Init the output struct.
    memset(pVfPoint35FreqStatus->offsetedVFTuple, 0,
        (sizeof(LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE) * LW2080_CTRL_CLK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE));

    for (idx = 0; idx < CLK_CLK_VF_POINT_35_FREQ_FREQ_TUPLE_MAX_SIZE; idx++)
    {
        pVfPoint35FreqStatus->offsetedVFTuple[idx] =
            pVfPoint35Freq->offsetedVFTuple[idx];
    }

clkVfPointIfaceModel10GetStatus_35_FREQ_exit:
    return status;
}

/*!
 * @copydoc ClkVfPointLoad
 */
FLCN_STATUS
clkVfPointLoad_35_FREQ
(
    CLK_VF_POINT            *pVfPoint,
    CLK_PROG_3X_PRIMARY      *pProg3XPrimary,
    CLK_DOMAIN_3X_PRIMARY    *pDomain3XPrimary,
    LwU8                     voltRailIdx,
    LwU8                     lwrveIdx
)
{
    CLK_DOMAIN_35_PRIMARY    *pDomain35Primary =
        (CLK_DOMAIN_35_PRIMARY *)INTERFACE_TO_BOARDOBJ_CAST(pDomain3XPrimary);
    CLK_DOMAIN             *pDomain;
    CLK_VF_POINT_35        *pVfPoint35;
    LwBoardObjIdx           clkIdx;
    FLCN_STATUS             status      = FLCN_OK;
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35, &pVfPoint->super,
                                  CLK, CLK_VF_POINT, 35, &status,
                                  clkVfPointLoad_35_FREQ_exit);
    pBaseVFTuple = clkVfPoint35BaseVFTupleGet(pVfPoint35);

    // Sanity check.
    if (pBaseVFTuple == NULL)
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        goto clkVfPointLoad_35_FREQ_exit;
    }

    //
    // Sanity check all position mapping.
    // Update the base frequency value of secondary clock domains
    //
    BOARDOBJGRP_ITERATOR_BEGIN(CLK_DOMAIN, pDomain, clkIdx,
        &pDomain35Primary->primarySecondaryDomainsGrpMask.super)
    {
        CLK_DOMAIN_35_PROG *pDomain35Prog = CLK_DOMAIN_35_PROG_GET(clkIdx);
        LwU8                clkPos;

        if (pDomain35Prog == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto clkVfPointLoad_35_FREQ_exit;
        }

        clkPos = clkDomain35ProgGetClkDomainPosByIdx(pDomain35Prog, lwrveIdx);

        // Validate the position.
        if ((clkPos == LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID) ||
            (clkPos >= CLK_CLK_VF_POINT_35_FREQ_FREQ_TUPLE_MAX_SIZE))
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_ARGUMENT;
            goto clkVfPointLoad_35_FREQ_exit;
        }

        // Translate Primary -> Secondary.
        if (BOARDOBJ_GET_TYPE(pDomain) !=
            LW2080_CTRL_CLK_CLK_DOMAIN_TYPE_35_PRIMARY)
        {
            status = clkProg3XPrimaryFreqTranslatePrimaryToSecondary(
                        pProg3XPrimary,                                      // pProg3XPrimary
                        pDomain3XPrimary,                                    // pDomain3XPrimary
                        BOARDOBJ_GRP_IDX_TO_8BIT(clkIdx),                   // clkDomIdx
                        &pBaseVFTuple->freqTuple[clkPos].freqMHz,           // pFreqMHz
                        LW_FALSE,                                           // bOCAjdAndQuantize
                        LW_TRUE);                                           // bQuantize
            if (status != FLCN_OK)
            {
                PMU_BREAKPOINT();
                goto clkVfPointLoad_35_FREQ_exit;
            }
        }
    }
    BOARDOBJGRP_ITERATOR_END;

clkVfPointLoad_35_FREQ_exit:
    return status;
}

/*!
 * _FREQ implemenation.
 *
 * @copydoc ClkVfPoint35Cache
 */
FLCN_STATUS
clkVfPoint35Cache_FREQ
(
    CLK_VF_POINT_35            *pVfPoint35,
    CLK_VF_POINT_35            *pVfPoint35Last,
    CLK_DOMAIN_35_PRIMARY       *pDomain35Primary,
    CLK_PROG_35_PRIMARY         *pProg35Primary,
    LwU8                        voltRailIdx,
    LwU8                        lwrveIdx,
    LwBool                      bVFEEvalRequired
)
{
    LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE *pOffsetedVFTuple =
        clkVfPoint35OffsetedVFTupleGet(pVfPoint35);
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple =
        clkVfPoint35BaseVFTupleGet(pVfPoint35);
    CLK_VF_POINT_35_FREQ       *pVfPoint35Freq;
    CLK_DOMAIN                 *pDomain;
    VOLT_RAIL                  *pVoltRail;
    RM_PMU_PERF_VFE_VAR_VALUE   vfeVarVal;
    RM_PMU_PERF_VFE_EQU_RESULT  result;
    LwU32                       voltageuV;
    LwBoardObjIdx               clkIdx;
    FLCN_STATUS                 status    = FLCN_OK;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint35Freq, &pVfPoint35->super.super,
                                  CLK, CLK_VF_POINT, 35_FREQ, &status,
                                  clkVfPoint35Cache_FREQ_exit);

    // Sanity check.
    if ((pBaseVFTuple == NULL) ||
        (pOffsetedVFTuple == NULL))
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        goto clkVfPoint35Cache_FREQ_exit;
    }
    voltageuV = pBaseVFTuple->voltageuV;

    // Evaluate the VFE on client's request
    if (bVFEEvalRequired)
    {
        CLK_DOMAIN_35_PROG *pDomain35Prog = &pDomain35Primary->super;
        LwU8                clkPos;

        if (pDomain35Prog == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto clkVfPoint35Cache_FREQ_exit;
        }

        clkPos = clkDomain35ProgGetClkDomainPosByIdx(pDomain35Prog, lwrveIdx);

        // Validate the position.
        if (clkPos == LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_ARGUMENT;
            goto clkVfPoint35Cache_FREQ_exit;
        }

        // 1. Compute voltage for the frequency.
        vfeVarVal.frequency.varType      = LW2080_CTRL_PERF_VFE_VAR_TYPE_SINGLE_FREQUENCY;
        vfeVarVal.frequency.varValue     = pBaseVFTuple->freqTuple[clkPos].freqMHz;
        vfeVarVal.frequency.clkDomainIdx = LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID;

        status = vfeEquEvaluate(
            clkProg35PrimaryVfeIdxGet(pProg35Primary,
                voltRailIdx,
                lwrveIdx),                                  // vfeEquIdx
            &vfeVarVal,                                     // pValues
            1,                                              // valCount
            LW2080_CTRL_PERF_VFE_EQU_OUTPUT_TYPE_VOLT_UV,   // outputType
            &result);                                       // pResult
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPoint35Cache_FREQ_exit;
        }
        voltageuV = result.voltuV;

        // 2. Round voltage to closest step supported by voltage rail.
        pVoltRail = VOLT_RAIL_GET(voltRailIdx);
        if (pVoltRail == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto clkVfPoint35Cache_FREQ_exit;
        }
        status = voltRailRoundVoltage(pVoltRail,            // pRail
                                      (LwS32*)&voltageuV,   // pVoltageuV
                                      LW_TRUE,              // bRoundUp
                                      LW_TRUE);             // bBound
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPoint35Cache_FREQ_exit;
        }

        // 3. Update the base voltage value.
        pBaseVFTuple->voltageuV = voltageuV;
    }

    // 4. Adjust by the VF point's voltage delta.
    if ((PMUCFG_FEATURE_ENABLED(PMU_CLK_CLK_DOMAIN_OVOC_SUPPORTED)) &&
        (pVfPoint35Freq->voltDeltauV != 0))
    {
        voltageuV = clkVoltDeltaAdjust(voltageuV, pVfPoint35Freq->voltDeltauV);

        // 3. Round voltage to closest step supported by voltage rail.
        pVoltRail = VOLT_RAIL_GET(voltRailIdx);
        if (pVoltRail == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto clkVfPoint35Cache_FREQ_exit;
        }
        status = voltRailRoundVoltage(pVoltRail,            // pRail
                                      (LwS32*)&voltageuV,   // pVoltageuV
                                      LW_TRUE,              // bRoundUp
                                      LW_TRUE);             // bBound
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto clkVfPoint35Cache_FREQ_exit;
        }
    }

    // Update the offseted VF tuple
    BOARDOBJGRP_ITERATOR_BEGIN(CLK_DOMAIN, pDomain, clkIdx,
        &pDomain35Primary->primarySecondaryDomainsGrpMask.super)
    {
        CLK_DOMAIN_35_PROG *pDomain35Prog = CLK_DOMAIN_35_PROG_GET(clkIdx);
        LwU8                clkPos;

        if (pDomain35Prog == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto clkVfPoint35Cache_FREQ_exit;
        }

        clkPos = clkDomain35ProgGetClkDomainPosByIdx(pDomain35Prog, lwrveIdx);

        // Validate the position.
        if (clkPos == LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_ARGUMENT;
            goto clkVfPoint35Cache_FREQ_exit;
        }

        // Use the above callwlated VF point voltage value.
        pOffsetedVFTuple[clkPos].voltageuV = voltageuV;

        // Use the base VF point frequency value.
        pOffsetedVFTuple[clkPos].freqMHz   =
            pBaseVFTuple->freqTuple[clkPos].freqMHz;
    }
    BOARDOBJGRP_ITERATOR_END;

clkVfPoint35Cache_FREQ_exit:
    return status;
}

/*!
 * @copydoc ClkVfPoint35Smoothing
 */
FLCN_STATUS
clkVfPoint35Smoothing_FREQ
(
    CLK_VF_POINT_35            *pVfPoint35,
    CLK_VF_POINT_35            *pVfPoint35Last,
    CLK_DOMAIN_35_PRIMARY       *pDomain35Primary,
    CLK_PROG_35_PRIMARY         *pProg35Primary,
    LwU8                        lwrveIdx
)
{
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple =
        clkVfPoint35BaseVFTupleGet(pVfPoint35);

    // Sanity check.
    if (pBaseVFTuple == NULL)
    {
        return FLCN_ERR_ILWALID_ARGUMENT;
    }

    // VF lwrve smoothing is only supported on voltage based VF point.
    if ((clkProg3XPrimaryIsVFSmoothingRequired(&pProg35Primary->primary,
            pBaseVFTuple->voltageuV)) &&
        (LW2080_CTRL_CLK_PROG_1X_SOURCE_NAFLL == (pProg35Primary)->super.super.source))
    {
        PMU_BREAKPOINT();
        return FLCN_ERR_NOT_SUPPORTED;
    }

    return FLCN_OK;
}

/* ------------------------- Private Functions ------------------------------ */
/*!
 * @brief   CLK_VF_POINT_35_FREQ implementation of
 *          @ref BoardObjVirtualTableDynamicCast()
 *
 * @copydoc BoardObjVirtualTableDynamicCast()
 */
static void *
s_vfeVarDynamicCast_35_FREQ
(
    BOARDOBJ   *pBoardObj,
    LwU8        requestedType
)
{
    void                 *pObject     = NULL;
    CLK_VF_POINT_35_FREQ *pVfPt35Freq = (CLK_VF_POINT_35_FREQ *)pBoardObj;

    if (BOARDOBJ_GET_TYPE(pBoardObj) !=
        LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 35_FREQ))
    {
        PMU_BREAKPOINT();
        goto s_vfeVarDynamicCast_35_FREQ_exit;
    }

    switch (requestedType)
    {
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, BASE):
        {
            CLK_VF_POINT *pVfPt = &pVfPt35Freq->super.super;
            pObject = (void *)pVfPt;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 35):
        {
            CLK_VF_POINT_35 *pVfPt35 = &pVfPt35Freq->super;
            pObject = (void *)pVfPt35;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 35_FREQ):
        {
            pObject = (void *)pVfPt35Freq;
            break;
        }
        default:
        {
            PMU_BREAKPOINT();
            break;
        }
    }

s_vfeVarDynamicCast_35_FREQ_exit:
    return pObject;
}
