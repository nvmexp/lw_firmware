/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file clk_vf_point_40_freq.c
 *
 * @brief Module managing all state related to the CLK_VF_POINT_FREQ structure.
 * This structure defines a point on the VF lwrve for which frequency is the
 * independent variable (i.e. fixed for this VF point) and voltage is the
 * dependent variable (i.e. varies with process, temperature, etc.).
 *
 * The CLK_VF_POINT_FREQ class is intended to be used to describe frequency
 * regions which are generated by the fixed-frequency generators (PLL,
 * OneSource) which generate a given frequency for which a minimum required
 * voltage must be determined.
 */

/* ------------------------ Includes --------------------------------------- */
#include "pmu_objclk.h"
#include "perf/3x/vfe.h"
#include "volt/objvolt.h"
#if (PMU_PROFILE_GA10X_RISCV)
#include <lwriscv/print.h>
#endif 

ct_assert(CLK_CLK_VF_POINT_40_FREQ_FREQ_TUPLE_MAX_SIZE <=
    LW2080_CTRL_CLK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE);

/* ------------------------ Static Function Prototypes ---------------------- */
static BoardObjVirtualTableDynamicCast (s_vfeVarDynamicCast_40_FREQ)
    GCC_ATTRIB_SECTION("imem_perf", "s_vfeVarDynamicCast_40_FREQ")
    GCC_ATTRIB_USED();
static FLCN_STATUS
s_clkVfPoint40OffsetedVFCache_FREQ_HELPER
(
    CLK_VF_POINT_40                             *pVfPoint40,
    CLK_VF_POINT_40                             *pVfPoint40Last,
    CLK_DOMAIN_40_PROG                          *pDomain40Prog,
    CLK_VF_REL                                  *pVfRel,
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE  *pBaseVFTuple,
    LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE       *pOffsetedVFTuple
) GCC_ATTRIB_SECTION("imem_perfVfIlwalidation", "s_clkVfPoint40OffsetedVFCache_FREQ_HELPER");
static FLCN_STATUS
s_clkVfPoint40OffsetVFCache_FREQ_HELPER
(
    CLK_VF_POINT_40                     *pVfPoint40,
    CLK_VF_POINT_40                     *pVfPoint40Last,
    CLK_DOMAIN_40_PROG                  *pDomain40Prog,
    CLK_VF_REL                          *pVfRel,
    LW2080_CTRL_CLK_OFFSET_VF_TUPLE     *pOffsetVFTuple
) GCC_ATTRIB_SECTION("imem_perfVfIlwalidation", "s_clkVfPoint40OffsetVFCache_FREQ_HELPER");

/* ------------------------ Global Variables ------------------------------- */
/*!
 * Virtual table for CLK_VF_POINT_40_FREQ object interfaces.
 */
BOARDOBJ_VIRTUAL_TABLE ClkVfPoint40FreqVirtualTable =
{
    BOARDOBJ_VIRTUAL_TABLE_ASSIGN_DYNAMIC_CAST(s_vfeVarDynamicCast_40_FREQ)
};

/* ------------------------ Global Variables ------------------------------- */
/* ------------------------ Static Function Prototypes --------------------- */
/* ------------------------ Macros ----------------------------------------- */
/* ------------------------ Public Functions ------------------------------- */
/*!
 * CLK_VF_POINT_40_FREQ class constructor.
 *
 * @copydoc BoardObjGrpIfaceModel10ObjSet
 */
FLCN_STATUS
clkVfPointGrpIfaceModel10ObjSet_40_FREQ
(
    BOARDOBJGRP_IFACE_MODEL_10        *pModel10,
    BOARDOBJ          **ppBoardObj,
    LwLength            size,
    RM_PMU_BOARDOBJ    *pBoardObjDesc
)
{
    RM_PMU_CLK_CLK_VF_POINT_40_FREQ_BOARDOBJ_SET *pSet =
        (RM_PMU_CLK_CLK_VF_POINT_40_FREQ_BOARDOBJ_SET *)pBoardObjDesc;
    CLK_VF_POINT_40_FREQ   *pVfPoint40Freq;
    LwU8                    clkPos;
    FLCN_STATUS             status;

    // Call into CLK_VF_POINT_40 super-constructor
    status = clkVfPointGrpIfaceModel10ObjSet_40(pModel10, ppBoardObj, size, pBoardObjDesc);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPointGrpIfaceModel10ObjSet_40_FREQ_exit;
    }

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint40Freq, *ppBoardObj, CLK, CLK_VF_POINT, 40_FREQ,
                                  &status, clkVfPointGrpIfaceModel10ObjSet_40_FREQ_exit);

    // Copy the CLK_VF_POINT_40_FREQ-specific data.

    //
    // Update the base frequency of primary and all its secondaries with
    // primary's frequency value.
    //
    for (clkPos = 0U; clkPos < (Clk.vfRels.secondaryEntryCount + 1U); clkPos++)
    {
        // Update the base frequency tuple.
        pVfPoint40Freq->baseVFTuple.freqTuple[clkPos].freqMHz =
            pSet->freqMHz;
    }

    pVfPoint40Freq->voltDeltauV = pSet->voltDeltauV;

clkVfPointGrpIfaceModel10ObjSet_40_FREQ_exit:
    return status;
}

/*!
 * @copydoc BoardObjIfaceModel10GetStatus
 */
FLCN_STATUS
clkVfPointIfaceModel10GetStatus_40_FREQ
(
    BOARDOBJ_IFACE_MODEL_10              *pModel10,
    RM_PMU_BOARDOBJ       *pPayload
)
{
    BOARDOBJ *pBoardObj = boardObjIfaceModel10BoardObjGet(pModel10);
    RM_PMU_CLK_CLK_VF_POINT_40_FREQ_BOARDOBJ_GET_STATUS *pVfPoint40FreqStatus =
        (RM_PMU_CLK_CLK_VF_POINT_40_FREQ_BOARDOBJ_GET_STATUS *)pPayload;
    CLK_VF_POINT_40_FREQ   *pVfPoint40Freq;
    LwU8                    idx;
    FLCN_STATUS             status          = FLCN_OK;

    BOARDOBJ_DYNAMIC_CAST_OR_GOTO(pVfPoint40Freq, pBoardObj, CLK, CLK_VF_POINT, 40_FREQ,
                                  &status, clkVfPointIfaceModel10GetStatus_40_FREQ_exit);

    status = clkVfPointIfaceModel10GetStatus_40(pModel10, pPayload);
    if (status != FLCN_OK)
    {
        goto clkVfPointIfaceModel10GetStatus_40_FREQ_exit;
    }

    // Copy-out the _40 specific params.
    pVfPoint40FreqStatus->baseVFTuple = pVfPoint40Freq->baseVFTuple;

    // Init the output struct.
    memset(pVfPoint40FreqStatus->offsetedVFTuple, 0U,
        (sizeof(LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE) *
            LW2080_CTRL_CLK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE));

    // Init the output struct.
    memset(pVfPoint40FreqStatus->offsetVFTuple, 0U,
        (sizeof(LW2080_CTRL_CLK_OFFSET_VF_TUPLE) *
            LW2080_CTRL_CLK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE));

    for (idx = 0U; idx < CLK_CLK_VF_POINT_40_FREQ_FREQ_TUPLE_MAX_SIZE; idx++)
    {
        pVfPoint40FreqStatus->offsetedVFTuple[idx] =
            pVfPoint40Freq->offsetedVFTuple[idx];

        pVfPoint40FreqStatus->offsetVFTuple[idx] =
            pVfPoint40Freq->offsetVFTuple[idx];
    }

clkVfPointIfaceModel10GetStatus_40_FREQ_exit:
    return status;
}

/*!
 * @copydoc ClkVfPointClientVoltDeltaSet
 */
FLCN_STATUS
clkVfPointClientVoltDeltaSet_40_FREQ
(
    CLK_VF_POINT    *pVfPoint,
    LwS32            voltDelta
)
{
    CLK_VF_POINT_40_FREQ *pVfPoint40Freq = (CLK_VF_POINT_40_FREQ *)pVfPoint;

    pVfPoint40Freq->clientVoltDeltauV = voltDelta;

    return FLCN_OK;
}

/*!
 * @copydoc ClkVfPoint40Load
 */
FLCN_STATUS
clkVfPoint40Load_FREQ
(
    CLK_VF_POINT_40        *pVfPoint40,
    CLK_DOMAIN_40_PROG     *pDomain40Prog,
    CLK_VF_REL             *pVfRel,
    LwU8                    lwrveIdx
)
{
    CLK_DOMAIN   *pDomain;
    LwBoardObjIdx clkIdx;
    FLCN_STATUS   status = FLCN_ERR_ILWALID_STATE;

    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple     =
        clkVfPoint40BaseVFTupleGet(pVfPoint40);

    if (PMUCFG_FEATURE_ENABLED(PMU_CLK_CLK_VF_POINT_BASE_VF_CACHE))
    {
        // Update the cache
        LwU16 vfIdx = BOARDOBJ_GET_GRP_IDX(&pVfPoint40->super.super);
        (void)vfIdx;

        clkVfPointsBaseVfCacheFreqSet(lwrveIdx, 0U, vfIdx, CLK_VF_PRIMARY_POS,
            pBaseVFTuple->freqTuple[CLK_VF_PRIMARY_POS].freqMHz);
    }

    // Sanity check all position mapping.
    BOARDOBJGRP_ITERATOR_BEGIN(CLK_DOMAIN, pDomain, clkIdx,
        clkDomain40ProgGetPrimarySecondaryDomainsMask(pDomain40Prog, pVfRel->railIdx))
    {
        CLK_DOMAIN_40_PROG *pDomain40ProgLocal = (CLK_DOMAIN_40_PROG *)pDomain;
        LwU8                clkPos             =
            clkDomain40ProgGetClkDomainPosByIdx(pDomain40ProgLocal, pVfRel->railIdx);

        // Init state to FLCN_OK.
        status = FLCN_OK;

        // Validate the position.
        if ((clkPos == LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID) ||
            (clkPos >= CLK_CLK_VF_POINT_40_FREQ_FREQ_TUPLE_MAX_SIZE))
        {
            status = FLCN_ERR_ILWALID_STATE;
            PMU_BREAKPOINT();
            goto clkVfPoint40Load_FREQ_exit;
        }

        if (BOARDOBJ_GET_GRP_IDX(&pDomain40Prog->super.super.super.super) != clkIdx)
        {
            //
            // Translate base frequency of all secondaries using
            // Primary -> Secondary relationships.
            //
            status = clkVfRelFreqTranslatePrimaryToSecondary(pVfRel,     // pVfRel
                        BOARDOBJ_GRP_IDX_TO_8BIT(clkIdx),           // secondaryIdx
                        &pBaseVFTuple->freqTuple[clkPos].freqMHz,   // pFreqMHz
                        LW_TRUE);                                   // bQuantize
            if (status != FLCN_OK)
            {
                PMU_BREAKPOINT();
                goto clkVfPoint40Load_FREQ_exit;
            }
        }

    }
    BOARDOBJGRP_ITERATOR_END;

clkVfPoint40Load_FREQ_exit:
    return status;
}

/*!
 * _FREQ implementation.
 *
 * @copydoc ClkVfPoint40Cache
 */
FLCN_STATUS
clkVfPoint40Cache_FREQ
(
    CLK_VF_POINT_40            *pVfPoint40,
    CLK_VF_POINT_40            *pVfPoint40Last,
    CLK_DOMAIN_40_PROG         *pDomain40Prog,
    CLK_VF_REL                 *pVfRel,
    LwU8                        lwrveIdx,
    LwBool                      bVFEEvalRequired
)
{
    LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE      *pOffsetedVFTuple =
        clkVfPoint40OffsetedVFTupleGet(pVfPoint40);
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple     =
        clkVfPoint40BaseVFTupleGet(pVfPoint40);
    VOLT_RAIL                  *pVoltRail;
    RM_PMU_PERF_VFE_VAR_VALUE   vfeVarVal;
    RM_PMU_PERF_VFE_EQU_RESULT  result;
    FLCN_STATUS                 status    = FLCN_OK;

    // Sanity check.
    if ((pBaseVFTuple     == NULL) ||
        (pOffsetedVFTuple == NULL))
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        PMU_BREAKPOINT();
        goto clkVfPoint40Cache_FREQ_exit;
    }

    // Evaluate the VFE on client's request
    if (bVFEEvalRequired)
    {
        LwU16 vfIdx = BOARDOBJ_GET_GRP_IDX(&pVfPoint40->super.super);
        (void)vfIdx;

        if (clkVfPointsVfCacheIsValidGet(lwrveIdx, 0U))
        {
            pBaseVFTuple->voltageuV =
                clkVfPointsBaseVfCacheVoltGet(lwrveIdx, 0U, vfIdx, CLK_VF_PRIMARY_POS);

            if (pBaseVFTuple->voltageuV == 0U)
            {
                status = FLCN_ERR_ILWALID_STATE;
                PMU_BREAKPOINT();
                goto clkVfPoint40Cache_FREQ_exit;
            }
        }
        else
        {
            LwU32 voltageuV;

            // Compute voltage for the frequency.
            vfeVarVal.frequency.varType      = LW2080_CTRL_PERF_VFE_VAR_TYPE_SINGLE_FREQUENCY;
            vfeVarVal.frequency.varValue     = pBaseVFTuple->freqTuple[CLK_VF_PRIMARY_POS].freqMHz;
            vfeVarVal.frequency.clkDomainIdx = LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID;

            status = vfeEquEvaluate(
                clkVfRelVfeIdxGet(pVfRel, lwrveIdx),           // vfeEquIdx
                &vfeVarVal,                                     // pValues
                1,                                              // valCount
                LW2080_CTRL_PERF_VFE_EQU_OUTPUT_TYPE_VOLT_UV,   // outputType
                &result);                                       // pResult
            if (status != FLCN_OK)
            {
                PMU_BREAKPOINT();
                goto clkVfPoint40Cache_FREQ_exit;
            }
            voltageuV = result.voltuV;

            // Round voltage to closest step supported by voltage rail.
            pVoltRail = VOLT_RAIL_GET(clkVfRelVoltRailIdxGet(pVfRel));
            if (pVoltRail == NULL)
            {
                PMU_BREAKPOINT();
                status = FLCN_ERR_ILWALID_INDEX;
                goto clkVfPoint40Cache_FREQ_exit;
            }
            status = voltRailRoundVoltage(pVoltRail,            // pRail
                                          (LwS32*)&voltageuV,   // pVoltageuV
                                          LW_TRUE,              // bRoundUp
                                          LW_TRUE);             // bBound
            if (status != FLCN_OK)
            {
                PMU_BREAKPOINT();
                goto clkVfPoint40Cache_FREQ_exit;
            }

            // Update the base voltage value.
            pBaseVFTuple->voltageuV = voltageuV;
        }
    }

    // Adjust by the VF point frequency delta.
    status = s_clkVfPoint40OffsetedVFCache_FREQ_HELPER(
                pVfPoint40,
                pVfPoint40Last,
                pDomain40Prog,
                pVfRel,
                pBaseVFTuple,
                pOffsetedVFTuple);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint40Cache_FREQ_exit;
    }

clkVfPoint40Cache_FREQ_exit:
    return status;
}

static FLCN_STATUS
s_clkVfPoint40OffsetedVFCache_FREQ_HELPER
(
    CLK_VF_POINT_40                             *pVfPoint40,
    CLK_VF_POINT_40                             *pVfPoint40Last,
    CLK_DOMAIN_40_PROG                          *pDomain40Prog,
    CLK_VF_REL                                  *pVfRel,
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE  *pBaseVFTuple,
    LW2080_CTRL_CLK_CLK_VF_POINT_VF_TUPLE       *pOffsetedVFTuple
)
{
    CLK_VF_POINT_40_FREQ       *pVfPoint40Freq = (CLK_VF_POINT_40_FREQ *)pVfPoint40;
    VOLT_RAIL                  *pVoltRail;
    FLCN_STATUS                 status    = FLCN_OK;

    // Sanity check.
    if ((pBaseVFTuple     == NULL) ||
        (pOffsetedVFTuple == NULL))
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        PMU_BREAKPOINT();
        goto s_clkVfPoint40OffsetedVFCache_FREQ_HELPER_exit;
    }

    // Adjust by the VF point's voltage delta.
    if ((PMUCFG_FEATURE_ENABLED(PMU_CLK_CLK_DOMAIN_OVOC_SUPPORTED)) &&
        (clkDomain40ProgIsOVEnabled(pDomain40Prog))                 &&
        (clkVfRelOVOCEnabled(pVfRel))                               &&
        (pVfPoint40Freq->voltDeltauV != 0U))
    {
        // Set offseted frequency equal to base frequency.
        pOffsetedVFTuple[CLK_VF_PRIMARY_POS].freqMHz =
            pBaseVFTuple->freqTuple[CLK_VF_PRIMARY_POS].freqMHz;

        // Adjust offseted voltage with volt delta.
        pOffsetedVFTuple[CLK_VF_PRIMARY_POS].voltageuV =
            clkVoltDeltaAdjust(pBaseVFTuple->voltageuV, pVfPoint40Freq->voltDeltauV);

        // Round voltage to closest step supported by voltage rail.
        pVoltRail = VOLT_RAIL_GET(clkVfRelVoltRailIdxGet(pVfRel));
        if (pVoltRail == NULL)
        {
            PMU_BREAKPOINT();
            status = FLCN_ERR_ILWALID_INDEX;
            goto s_clkVfPoint40OffsetedVFCache_FREQ_HELPER_exit;
        }
        status = voltRailRoundVoltage(pVoltRail,                                // pRail
                    (LwS32*)&pOffsetedVFTuple[CLK_VF_PRIMARY_POS].voltageuV,     // pVoltageuV
                    LW_TRUE,                                                    // bRoundUp
                    LW_TRUE);                                                   // bBound
        if (status != FLCN_OK)
        {
            PMU_BREAKPOINT();
            goto s_clkVfPoint40OffsetedVFCache_FREQ_HELPER_exit;
        }
    }
    else
    {
        // Set offseted tuple equal to base tuple.
        pOffsetedVFTuple[CLK_VF_PRIMARY_POS].voltageuV =
            pBaseVFTuple->voltageuV;
        pOffsetedVFTuple[CLK_VF_PRIMARY_POS].freqMHz =
            pBaseVFTuple->freqTuple[CLK_VF_PRIMARY_POS].freqMHz;
    }

s_clkVfPoint40OffsetedVFCache_FREQ_HELPER_exit:
    return status;
}

/*!
 * _FREQ implementation.
 *
 * @copydoc ClkVfPoint40OffsetVFCache
 */
FLCN_STATUS
clkVfPoint40OffsetVFCache_FREQ
(
    CLK_VF_POINT_40            *pVfPoint40,
    CLK_VF_POINT_40            *pVfPoint40Last,
    CLK_DOMAIN_40_PROG         *pDomain40Prog,
    CLK_VF_REL                 *pVfRel
)
{
    LW2080_CTRL_CLK_OFFSET_VF_TUPLE     *pOffsetVFTuple =
        clkVfPoint40OffsetVFTupleGet(pVfPoint40);

    FLCN_STATUS                 status    = FLCN_OK;

    // Sanity check.
    if (pOffsetVFTuple == NULL)
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        PMU_BREAKPOINT();
        goto clkVfPoint40OffsetVFCache_FREQ_exit;
    }

    // Adjust by the VF point frequency delta.
    status = s_clkVfPoint40OffsetVFCache_FREQ_HELPER(
                pVfPoint40,
                pVfPoint40Last,
                pDomain40Prog,
                pVfRel,
                pOffsetVFTuple);
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint40OffsetVFCache_FREQ_exit;
    }

clkVfPoint40OffsetVFCache_FREQ_exit:
    return status;
}

static FLCN_STATUS
s_clkVfPoint40OffsetVFCache_FREQ_HELPER
(
    CLK_VF_POINT_40                     *pVfPoint40,
    CLK_VF_POINT_40                     *pVfPoint40Last,
    CLK_DOMAIN_40_PROG                  *pDomain40Prog,
    CLK_VF_REL                          *pVfRel,
    LW2080_CTRL_CLK_OFFSET_VF_TUPLE     *pOffsetVFTuple
)
{
    CLK_VF_POINT_40_FREQ       *pVfPoint40Freq = (CLK_VF_POINT_40_FREQ *)pVfPoint40;
    FLCN_STATUS                 status    = FLCN_OK;

    // Sanity check.
    if (pOffsetVFTuple == NULL)
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        PMU_BREAKPOINT();
        goto s_clkVfPoint40OffsetVFCache_FREQ_HELPER_exit;
    }

    // Adjust by the VF point's voltage delta.
    if ((PMUCFG_FEATURE_ENABLED(PMU_CLK_CLK_DOMAIN_OVOC_SUPPORTED)) &&
        (clkDomain40ProgIsOVEnabled(pDomain40Prog))                 &&
        (clkVfRelOVOCEnabled(pVfRel))                               &&
        (pVfPoint40Freq->voltDeltauV != 0U))
    {
        pOffsetVFTuple[CLK_VF_PRIMARY_POS].voltageuV = pVfPoint40Freq->voltDeltauV;
        pOffsetVFTuple[CLK_VF_PRIMARY_POS].freqMHz   = 0;
    }
    else
    {
        // Set offseted tuple equal to zero.
        pOffsetVFTuple[CLK_VF_PRIMARY_POS].voltageuV = 0;
        pOffsetVFTuple[CLK_VF_PRIMARY_POS].freqMHz   = 0;
    }

s_clkVfPoint40OffsetVFCache_FREQ_HELPER_exit:
    return status;
}

/*!
 * _FREQ implementation.
 *
 * @copydoc ClkVfPoint40BaseVFCache
 */
FLCN_STATUS
clkVfPoint40BaseVFCache_FREQ
(
    CLK_VF_POINT_40            *pVfPoint40,
    CLK_VF_POINT_40            *pVfPoint40Last,
    CLK_DOMAIN_40_PROG         *pDomain40Prog,
    CLK_VF_REL                 *pVfRel,
    LwU8                        lwrveIdx,
    LwU8                        cacheIdx
)
{
    LW2080_CTRL_CLK_CLK_VF_POINT_BASE_VF_TUPLE *pBaseVFTuple     =
        clkVfPointsBaseVfCacheBaseVFTupleGet(lwrveIdx, cacheIdx,
            BOARDOBJ_GET_GRP_IDX(&pVfPoint40->super.super));
    VOLT_RAIL                  *pVoltRail;
    RM_PMU_PERF_VFE_VAR_VALUE   vfeVarVal[2];
    RM_PMU_PERF_VFE_EQU_RESULT  result;
    LwU32                       voltageuV;
    FLCN_STATUS                 status    = FLCN_OK;

    // Sanity check.
    if (pBaseVFTuple == NULL)
    {
        status = FLCN_ERR_ILWALID_ARGUMENT;
        PMU_BREAKPOINT();
        goto clkVfPoint40BaseVFCache_FREQ_exit;
    }

    // Compute voltage for the frequency at specified temperature.
    vfeVarVal[0].frequency.varType      = LW2080_CTRL_PERF_VFE_VAR_TYPE_SINGLE_FREQUENCY;
    vfeVarVal[0].frequency.varValue     = pBaseVFTuple->freqTuple[CLK_VF_PRIMARY_POS].freqMHz;
    vfeVarVal[0].frequency.clkDomainIdx = LW2080_CTRL_CLK_CLK_DOMAIN_INDEX_ILWALID;

    vfeVarVal[1].temperature.varType    = LW2080_CTRL_PERF_VFE_VAR_TYPE_SINGLE_SENSED_TEMP;
    vfeVarVal[1].temperature.varValue   = RM_PMU_CELSIUS_TO_LW_TEMP(cacheIdx * 5);

    status = vfeEquEvaluate(
        clkVfRelVfeIdxGet(pVfRel, lwrveIdx),            // vfeEquIdx
        vfeVarVal,                                      // pValues
        2U,                                             // valCount
        LW2080_CTRL_PERF_VFE_EQU_OUTPUT_TYPE_VOLT_UV,   // outputType
        &result);                                       // pResult
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint40BaseVFCache_FREQ_exit;
    }
    voltageuV = result.voltuV;

    if (voltageuV == 0U)
    {
        status = FLCN_ERR_ILWALID_STATE;
        PMU_BREAKPOINT();
        goto clkVfPoint40BaseVFCache_FREQ_exit;
    }

    // Round voltage to closest step supported by voltage rail.
    pVoltRail = VOLT_RAIL_GET(clkVfRelVoltRailIdxGet(pVfRel));
    if (pVoltRail == NULL)
    {
        PMU_BREAKPOINT();
        status = FLCN_ERR_ILWALID_INDEX;
        goto clkVfPoint40BaseVFCache_FREQ_exit;
    }
    status = voltRailRoundVoltage(pVoltRail,            // pRail
                                  (LwS32*)&voltageuV,   // pVoltageuV
                                  LW_TRUE,              // bRoundUp
                                  LW_TRUE);             // bBound
    if (status != FLCN_OK)
    {
        PMU_BREAKPOINT();
        goto clkVfPoint40BaseVFCache_FREQ_exit;
    }

    // Update the base voltage value.
    pBaseVFTuple->voltageuV = voltageuV;

clkVfPoint40BaseVFCache_FREQ_exit:
    return status;
}

/* ------------------------- Private Functions ------------------------------ */
/*!
 * @brief   CLK_VF_POINT_40_FREQ implementation of
 *          @ref BoardObjVirtualTableDynamicCast()
 *
 * @copydoc BoardObjVirtualTableDynamicCast()
 */
static void *
s_vfeVarDynamicCast_40_FREQ
(
    BOARDOBJ   *pBoardObj,
    LwU8        requestedType
)
{
    void                 *pObject     = NULL;
    CLK_VF_POINT_40_FREQ *pVfPt40Freq = (CLK_VF_POINT_40_FREQ *)pBoardObj;

    if (BOARDOBJ_GET_TYPE(pBoardObj) !=
        LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 40_FREQ))
    {
        PMU_BREAKPOINT();
        goto s_vfeVarDynamicCast_40_FREQ_exit;
    }

    switch (requestedType)
    {
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, BASE):
        {
            CLK_VF_POINT *pVfPt = &pVfPt40Freq->super.super;
            pObject = (void *)pVfPt;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 40):
        {
            CLK_VF_POINT_40 *pVfPt40 = &pVfPt40Freq->super;
            pObject = (void *)pVfPt40;
            break;
        }
        case LW2080_CTRL_BOARDOBJ_TYPE(CLK, CLK_VF_POINT, 40_FREQ):
        {
            pObject = (void *)pVfPt40Freq;
            break;
        }
        default:
        {
            PMU_BREAKPOINT();
            break;
        }
    }

s_vfeVarDynamicCast_40_FREQ_exit:
    return pObject;
}
