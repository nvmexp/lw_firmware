/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file   hdcp22wired_verify_certificate.c
 * @brief  Hdcp22 wrapper Functions for security
 */

/* ------------------------ System includes --------------------------------- */
/* ------------------------ OpenRTOS includes ------------------------------- */
/* ------------------------ Application includes ---------------------------- */
#include "hdcp22wired_cmn.h"
#include "csb.h"
#include "common_hslib.h"
#include "seapi.h"

/* ------------------------ Types definitions ------------------------------- */
/* ------------------------ External definitions ---------------------------- */
#ifdef GSPLITE_RTOS
static void _hdcp22wiredValidateCertrxSrmEntry(void)
    GCC_ATTRIB_USED()
    GCC_ATTRIB_SECTION("imem_hdcp22ValidateCertrxSrm", "start");
#endif
FLCN_STATUS hdcp22wiredVerifyRxCertificateHandler(SELWRE_ACTION_ARG *pArg)
    GCC_ATTRIB_SECTION("imem_hdcp22ValidateCertrxSrm", "hdcp22wiredVerifyRxCertificateHandler");

/* ------------------------ Static variables -------------------------------- */
// Arrays used for testing, defines for certificates, reference pEkpub values, etc
LwU8 rsaTprefix[] =
{
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00,  0x04, 0x20,
};

const LwU32    gDcpExponent = 0x03;

#ifdef HDCP22_DEBUG_MODE
const LwU8     gDcpKpub[HDCP22_SIZE_KPUB_DCP]  GCC_ATTRIB_ALIGN(sizeof(LwU32)) = {
    0xa2, 0xc7, 0x55, 0x57, 0x54, 0xcb, 0xaa, 0xa7, 0x7a, 0x27, 0x92, 0xc3, 0x1a, 0x6d, 0xc2, 0x31,
    0xcf, 0x12, 0xc2, 0x24, 0xbf, 0x89, 0x72, 0x46, 0xa4, 0x8d, 0x20, 0x83, 0xb2, 0xdd, 0x04, 0xda,
    0x7e, 0x01, 0xa9, 0x19, 0xef, 0x7e, 0x8c, 0x47, 0x54, 0xc8, 0x59, 0x72, 0x5c, 0x89, 0x60, 0x62,
    0x9f, 0x39, 0xd0, 0xe4, 0x80, 0xca, 0xa8, 0xd4, 0x1e, 0x91, 0xe3, 0x0e, 0x2c, 0x77, 0x55, 0x6d,
    0x58, 0xa8, 0x9e, 0x3e, 0xf2, 0xda, 0x78, 0x3e, 0xba, 0xd1, 0x05, 0x37, 0x07, 0xf2, 0x88, 0x74,
    0x0c, 0xbc, 0xfb, 0x68, 0xa4, 0x7a, 0x27, 0xad, 0x63, 0xa5, 0x1f, 0x67, 0xf1, 0x45, 0x85, 0x16,
    0x49, 0x8a, 0xe6, 0x34, 0x1c, 0x6e, 0x80, 0xf5, 0xff, 0x13, 0x72, 0x85, 0x5d, 0xc1, 0xde, 0x5f,
    0x01, 0x86, 0x55, 0x86, 0x71, 0xe8, 0x10, 0x33, 0x14, 0x70, 0x2a, 0x5f, 0x15, 0x7b, 0x5c, 0x65,
    0x3c, 0x46, 0x3a, 0x17, 0x79, 0xed, 0x54, 0x6a, 0xa6, 0xc9, 0xdf, 0xeb, 0x2a, 0x81, 0x2a, 0x80,
    0x2a, 0x46, 0xa2, 0x06, 0xdb, 0xfd, 0xd5, 0xf3, 0xcf, 0x74, 0xbb, 0x66, 0x56, 0x48, 0xd7, 0x7c,
    0x6a, 0x03, 0x14, 0x1e, 0x55, 0x56, 0xe4, 0xb6, 0xfa, 0x38, 0x2b, 0x5d, 0xfb, 0x87, 0x9f, 0x9e,
    0x78, 0x21, 0x87, 0xc0, 0x0c, 0x63, 0x3e, 0x8d, 0x0f, 0xe2, 0xa7, 0x19, 0x10, 0x9b, 0x15, 0xe1,
    0x11, 0x87, 0x49, 0x33, 0x49, 0xb8, 0x66, 0x32, 0x28, 0x7c, 0x87, 0xf5, 0xd2, 0x2e, 0xc5, 0xf3,
    0x66, 0x2f, 0x79, 0xef, 0x40, 0x5a, 0xd4, 0x14, 0x85, 0x74, 0x5f, 0x06, 0x43, 0x50, 0xcd, 0xde,
    0x84, 0xe7, 0x3c, 0x7d, 0x8e, 0x8a, 0x49, 0xcc, 0x5a, 0xcf, 0x73, 0xa1, 0x8a, 0x13, 0xff, 0x37,
    0x13, 0x3d, 0xad, 0x57, 0xd8, 0x51, 0x22, 0xd6, 0x32, 0x1f, 0xc0, 0x68, 0x4c, 0xa0, 0x5b, 0xdd,
    0x5f, 0x78, 0xc8, 0x9f, 0x2d, 0x3a, 0xa2, 0xb8, 0x1e, 0x4a, 0xe4, 0x08, 0x55, 0x64, 0x05, 0xe6,
    0x94, 0xfb, 0xeb, 0x03, 0x6a, 0x0a, 0xbe, 0x83, 0x18, 0x94, 0xd4, 0xb6, 0xc3, 0xf2, 0x58, 0x9c,
    0x7a, 0x24, 0xdd, 0xd1, 0x3a, 0xb7, 0x3a, 0xb0, 0xbb, 0xe5, 0xd1, 0x28, 0xab, 0xad, 0x24, 0x54,
    0x72, 0x0e, 0x76, 0xd2, 0x89, 0x32, 0xea, 0x46, 0xd3, 0x78, 0xd0, 0xa9, 0x67, 0x78, 0xc1, 0x2d,
    0x18, 0xb0, 0x33, 0xde, 0xdb, 0x27, 0xcc, 0xb0, 0x7c, 0xc9, 0xa4, 0xbd, 0xdf, 0x2b, 0x64, 0x10,
    0x32, 0x44, 0x06, 0x81, 0x21, 0xb3, 0xba, 0xcf, 0x33, 0x85, 0x49, 0x1e, 0x86, 0x4c, 0xbd, 0xf2,
    0x3d, 0x34, 0xef, 0xd6, 0x23, 0x7a, 0x9f, 0x2c, 0xda, 0x84, 0xf0, 0x83, 0x83, 0x71, 0x7d, 0xda,
    0x6e, 0x44, 0x96, 0xcd, 0x1d, 0x05, 0xde, 0x30, 0xf6, 0x1e, 0x2f, 0x9c, 0x99, 0x9c, 0x60, 0x07
};
#else
const LwU8     gDcpKpub[HDCP22_SIZE_KPUB_DCP]  GCC_ATTRIB_ALIGN(sizeof(LwU32)) = {
    0xB0, 0xE9, 0xAA, 0x45, 0xF1, 0x29, 0xBA, 0x0A, 0x1C, 0xBE, 0x17, 0x57, 0x28, 0xEB, 0x2B, 0x4E,
    0x8F, 0xD0, 0xC0, 0x6A, 0xAD, 0x79, 0x98, 0x0F, 0x8D, 0x43, 0x8D, 0x47, 0x04, 0xB8, 0x2B, 0xF4,
    0x15, 0x21, 0x56, 0x19, 0x01, 0x40, 0x01, 0x3B, 0xD0, 0x91, 0x90, 0x62, 0x9E, 0x89, 0xC2, 0x27,
    0x8E, 0xCF, 0xB6, 0xDB, 0xCE, 0x3F, 0x72, 0x10, 0x50, 0x93, 0x8C, 0x23, 0x29, 0x83, 0x7B, 0x80,
    0x64, 0xA7, 0x59, 0xE8, 0x61, 0x67, 0x4C, 0xBC, 0xD8, 0x58, 0xB8, 0xF1, 0xD4, 0xF8, 0x2C, 0x37,
    0x98, 0x16, 0x26, 0x0E, 0x4E, 0xF9, 0x4E, 0xEE, 0x24, 0xDE, 0xCC, 0xD1, 0x4B, 0x4B, 0xC5, 0x06,
    0x7A, 0xFB, 0x49, 0x65, 0xE6, 0xC0, 0x00, 0x83, 0x48, 0x1E, 0x8E, 0x42, 0x2A, 0x53, 0xA0, 0xF5,
    0x37, 0x29, 0x2B, 0x5A, 0xF9, 0x73, 0xC5, 0x9A, 0xA1, 0xB5, 0xB5, 0x74, 0x7C, 0x06, 0xDC, 0x7B,
    0x7C, 0xDC, 0x6C, 0x6E, 0x82, 0x6B, 0x49, 0x88, 0xD4, 0x1B, 0x25, 0xE0, 0xEE, 0xD1, 0x79, 0xBD,
    0x39, 0x85, 0xFA, 0x4F, 0x25, 0xEC, 0x70, 0x19, 0x23, 0xC1, 0xB9, 0xA6, 0xD9, 0x7E, 0x3E, 0xDA,
    0x48, 0xA9, 0x58, 0xE3, 0x18, 0x14, 0x1E, 0x9F, 0x30, 0x7F, 0x4C, 0xA8, 0xAE, 0x53, 0x22, 0x66,
    0x2B, 0xBE, 0x24, 0xCB, 0x47, 0x66, 0xFC, 0x83, 0xCF, 0x5C, 0x2D, 0x1E, 0x3A, 0xAB, 0xAB, 0x06,
    0xBE, 0x05, 0xAA, 0x1A, 0x9B, 0x2D, 0xB7, 0xA6, 0x54, 0xF3, 0x63, 0x2B, 0x97, 0xBF, 0x93, 0xBE,
    0xC1, 0xAF, 0x21, 0x39, 0x49, 0x0C, 0xE9, 0x31, 0x90, 0xCC, 0xC2, 0xBB, 0x3C, 0x02, 0xC4, 0xE2,
    0xBD, 0xBD, 0x2F, 0x84, 0x63, 0x9B, 0xD2, 0xDD, 0x78, 0x3E, 0x90, 0xC6, 0xC5, 0xAC, 0x16, 0x77,
    0x2E, 0x69, 0x6C, 0x77, 0xFD, 0xED, 0x8A, 0x4D, 0x6A, 0x8C, 0xA3, 0xA9, 0x25, 0x6C, 0x21, 0xFD,
    0xB2, 0x94, 0x0C, 0x84, 0xAA, 0x07, 0x29, 0x26, 0x46, 0xF7, 0x9B, 0x3A, 0x19, 0x87, 0xE0, 0x9F,
    0xEB, 0x30, 0xA8, 0xF5, 0x64, 0xEB, 0x07, 0xF1, 0xE9, 0xDB, 0xF9, 0xAF, 0x2C, 0x8B, 0x69, 0x7E,
    0x2E, 0x67, 0x39, 0x3F, 0xF3, 0xA6, 0xE5, 0xCD, 0xDA, 0x24, 0x9B, 0xA2, 0x78, 0x72, 0xF0, 0xA2,
    0x27, 0xC3, 0xE0, 0x25, 0xB4, 0xA1, 0x04, 0x6A, 0x59, 0x80, 0x27, 0xB5, 0xDA, 0xB4, 0xB4, 0x53,
    0x97, 0x3B, 0x28, 0x99, 0xAC, 0xF4, 0x96, 0x27, 0x0F, 0x7F, 0x30, 0x0C, 0x4A, 0xAF, 0xCB, 0x9E,
    0xD8, 0x71, 0x28, 0x24, 0x3E, 0xBC, 0x35, 0x15, 0xBE, 0x13, 0xEB, 0xAF, 0x43, 0x01, 0xBD, 0x61,
    0x24, 0x54, 0x34, 0x9F, 0x73, 0x3E, 0xB5, 0x10, 0x9F, 0xC9, 0xFC, 0x80, 0xE8, 0x4D, 0xE3, 0x32,
    0x96, 0x8F, 0x88, 0x10, 0x23, 0x25, 0xF3, 0xD3, 0x3E, 0x6E, 0x6D, 0xBB, 0xDC, 0x29, 0x66, 0xEB
};
#endif // HDCP22_DEBUG_MODE

/* ------------------------ Static Functions -------------------------------- */
#ifdef GSPLITE_RTOS
/*!
 * @brief Entry function of HS lib overlay.
 */
static void
_hdcp22wiredValidateCertrxSrmEntry(void)
{
    // Validate that caller is HS, otherwise halt
    VALIDATE_THAT_CALLER_IS_HS();

    return;
}
#endif

/*
 * @brief      This function verifies the RSA signature using PKCS1-v1_5 standard
 *
 * @param[in]   pData       Pointer to input data.
 * @param[in]   dataLength  Input data length.
 * @param[in]   pSignature  Pointer to signature data.
 *
 * returns FLCN_OK          If Cerficate signature is valid
 *                          else if Cerficate signature invalid.
 */
FLCN_STATUS
hdcp22RsaVerifyDcpSignature
(
    LwU8   *pData,
    LwU32   dataLength,
    LwU8   *pSignature
)
{
    FLCN_STATUS status = FLCN_OK;
    LwS32       PS_size;
    LwU32       exponent;
    LwU32       EM[HDCP22_SIZE_RX_MODULUS_ROOT_8/sizeof(LwU32)];
    LwU8       *pEM = (LwU8 *)EM;
    LwU32       output[HDCP22_SIZE_RX_MODULUS_ROOT_8/sizeof(LwU32)];
    LwU8       *pCalHash;

    exponent = gDcpExponent;
    HDCP22WIRED_SEC_ACTION_MEMSET(EM, 0,  sizeof(EM));
    HDCP22WIRED_SEC_ACTION_MEMSET(output, 0, sizeof(output));

    //
    // RSA signature verification - raise signature to the power of exponent
    // and compare with EM note that all numbers are big-endian encoded under
    // PKCS1-v1_5.
    //
#ifdef HDCP22_USE_HW_RSA
    if (HDCP22WIRED_SEC_ACTION_HW_RSA_MODULAR_EXP(HDCP22_SIZE_RX_MODULUS_ROOT_8,
                                                  (LwU32 *)gDcpKpub,
                                                  &exponent,
                                                  (LwU32*)pSignature,
                                                  output) != FLCN_OK)
    {
        status = FLCN_ERR_HDCP22_RSA_HW;
    }
#else
    HDCP22WIRED_SEC_ACTION_SWAP_ENDIANNESS(output,
                                           pSignature,
                                           HDCP22_SIZE_RX_MODULUS_ROOT_8);

    hdcpAttachAndLoadOverlay(HDCP_BIGINT);
    status = hdcp22SwRsaModularExp(HDCP22_SIZE_RX_MODULUS_ROOT_8,
                                   gDcpKpub,
                                   &exponent,
                                   output,
                                   output);
    hdcpDetachOverlay(HDCP_BIGINT);
#endif

    if (status != FLCN_OK)
    {
        goto label_return;
    }

    HDCP22WIRED_SEC_ACTION_SWAP_ENDIANNESS(output,
                                           output,
                                           HDCP22_SIZE_RX_MODULUS_ROOT_8);

    //
    // Prepare encoded message EM: see RFC 3447 section 9.2: EMSA-PKCS1-v1_5
    // EM = 0x00 || 0x01 || PS || 0x00 || T.
    //
    PS_size = HDCP22_SIZE_RX_MODULUS_ROOT_8 - 3 - sizeof(rsaTprefix) -
              HDCP22_SHA256_HASH_BLOCK;

    pEM[0] = 0x00;
    pEM[1] = 0x01;
    HDCP22WIRED_SEC_ACTION_MEMSET(&pEM[2], 0xff, PS_size);
    pEM[2 + PS_size] = 0x00;
    HDCP22WIRED_SEC_ACTION_MEMCPY(&pEM[3 + PS_size], rsaTprefix, sizeof(rsaTprefix));

    // Callwated SHA Hash.
    pCalHash = &pEM[3 + PS_size + sizeof(rsaTprefix)];
    HDCP22WIRED_SEC_ACTION_MEMSET(pCalHash, 0, HDCP22_SHA256_HASH_BLOCK);
    hdcpAttachAndLoadOverlay(HDCP22WIRED_LIB_SHA);
    status = HDCP22WIRED_SEC_ACTION_SHA256((LwU8 *)pCalHash, (LwU8 *)pData, dataLength);
    hdcpDetachOverlay(HDCP22WIRED_LIB_SHA);

    if ((status != FLCN_OK) ||
        HDCP22WIRED_SEC_ACTION_MEMCMP(output, pEM, HDCP22_SIZE_RX_MODULUS_ROOT_8))
    {
        status = FLCN_ERR_HDCP22_CERT_RX;
    }
    else
    {
        status = FLCN_OK;
    }

label_return:
    return status;
}

/* ------------------------ Public Functions -------------------------------- */
#ifndef HDCP22_USE_HW_RSA
/*
 * @brief This function does RSA modular exponential using Montgomery Exponential.
 * @param[in]   keySize     Key Size for RSA operation
 * @param[in]   modulus     The modulus for modular exponentiation
 * @param[in]   exponent    The exponent for modular exponentiation
 * @param[in]   base        The base for modular exponentiation
 * @param[out]  output      The ouput buffer to save result.
 * @returns     FLCN_STATUS FLCN_OK on successfull exelwtion
 *                          Appropriate error status on failure.
 */
FLCN_STATUS
hdcp22SwRsaModularExp
(
    const LwU32     keySize,
    const LwU8     *pModulus,
    const LwU32    *pExponent,
    LwU32          *pBase,
    LwU32          *pOutput
)
{
    BigIntModulus   modular;

    if (keySize > HDCP22_SIZE_RX_MODULUS_ROOT_8)
    {
        return FLCN_ERR_ILLEGAL_OPERATION;
    }

    HDCP22WIRED_SEC_ACTION_MEMSET(&modular, 0, sizeof(modular));
    HDCP22WIRED_SEC_ACTION_BIGINT_MODULUS_INIT(&modular, pModulus, keySize);
    HDCP22WIRED_SEC_ACTION_BIGINT_POWER_MOD(pOutput, pBase, pExponent, &modular, 1);

    return FLCN_OK;
}
#endif // !HDCP22_USE_HW_RSA

/*!
 * @brief Function to verify certificate.
 * @param[in]  pArg         Pointer to secure action argument.
 *
 * @return     FLCN_STATUS  FLCN_OK when succeed else error.
 */
FLCN_STATUS
hdcp22wiredVerifyRxCertificateHandler
(
    SELWRE_ACTION_ARG *pArg
)
{
    PSELWRE_ACTION_VERIFY_CERTIFICATE_ARG pActionArg  = &pArg->action.secActiolwerifyCertificate;
    SELWRE_ACTION_TYPE      prevState   = SELWRE_ACTION_ILWALID;
    HDCP22_CERTIFICATE     *pRecvCert   = &pActionArg->rxCert;
    FLCN_STATUS             status      = FLCN_OK;

    // Check if the previous state.
    CHECK_STATUS(hdcp22wiredReadFromSelwreMemory_HAL(&Hdcp22wired,
                                                     HDCP22_SECRET_PREV_STATE,
                                                     (LwU8 *)&prevState));
    if(prevState != SELWRE_ACTION_START_SESSION)
    {
        status = FLCN_ERR_HS_HDCP22_WRONG_SEQUENCE;
        goto label_return;
    }

    hdcpAttachAndLoadOverlay(HDCP22WIRED_RSA_SIGNATURE);
    status = hdcp22RsaVerifyDcpSignature((LwU8*)pRecvCert,
                                         sizeof(*pRecvCert) - sizeof(pRecvCert->signature),
                                         pRecvCert->signature);
    hdcpDetachOverlay(HDCP22WIRED_RSA_SIGNATURE);

    if (status != FLCN_OK)
    {
        goto label_return;
    }

    // Save Rx ID for SRM revocation.
    CHECK_STATUS(hdcp22wiredWriteToSelwreMemory_HAL(&Hdcp22wired,
                                                    HDCP22_SECRET_RX_ID,
                                                    (LwU8 *)pRecvCert->id,
                                                    LW_FALSE));

    // TODO: Save pKpubRx's hash to selwreMemory and check hash at eKmKdGen.

    // Update Previous state.
    prevState = SELWRE_ACTION_VERIFY_CERTIFICATE;
    CHECK_STATUS(hdcp22wiredWriteToSelwreMemory_HAL(&Hdcp22wired,
                                                    HDCP22_SECRET_PREV_STATE,
                                                    (LwU8 *)&prevState,
                                                    LW_FALSE));

label_return:

    return status;
}
