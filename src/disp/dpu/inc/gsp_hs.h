/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2016-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#ifndef GSP_HS_H
#define GSP_HS_H


/*!
 * @file gsp_hs.h
 * This file holds the inline definitions of functions used for revocation
 * support for HS overlays
 */

/* ------------------------- System includes -------------------------------- */
#include "dpusw.h"
/* ------------------------- Application includes --------------------------- */
#include "gsp_bar0_hs.h"
#include "gsp_csb.h"
#include "dev_falcon_v4_addendum.h"
#include "scp_internals.h"
#include "lwosselwreovly.h"
#ifdef IS_SSP_ENABLED
#include "seapi.h"
#ifdef LIB_CCC_PRESENT
#include "lib_hdcp22wired.h"
#endif
#endif
/* ------------------------- Types definitions ------------------------------ */
/* ------------------------- External definitions --------------------------- */
/* ------------------------- Static variables ------------------------------- */
/* ------------------------- Defines ---------------------------------------- */
/*!
 * Utility macro to disable big hammer lockdown prior to jumping out of
 * heavy secure mode
 */
#define DISABLE_BIG_HAMMER_LOCKDOWN() REG_WR32_STALL(CSB, LW_CGSP_SCP_CTL_CFG,  \
                DRF_DEF(_CGSP, _SCP_CTL_CFG, _LOCKDOWN_SCP, _ENABLE) |          \
                DRF_DEF(_CGSP, _SCP_CTL_CFG, _LOCKDOWN, _DISABLE))


#define VALIDATE_RETURN_PC_AND_HALT_IF_HS()  do {                       \
        if(_dpuEnsureReturnPCIsNotInHS() != FLCN_OK)                    \
        {                                                               \
            REG_WR32(CSB, LW_CGSP_FALCON_MAILBOX0,                      \
                     FLCN_ERR_HS_CHK_RETURN_PC_AT_HS_ENTRY_IS_OF_HS);   \
            falc_halt();                                                \
        }                                                               \
        }                                                               \
        while (LW_FALSE)

#define CLEAR_SCP_REGISTER_HS(scpReg)          \
    do                                         \
    {                                          \
        falc_scp_secret(0, scpReg);            \
        falc_scp_xor(scpReg, scpReg);          \
    } while (LW_FALSE)

/* ------------------------- Function Prototypes ---------------------------- */
static inline FLCN_STATUS _dpuCheckPmbPLM_GV10X(void)
    GCC_ATTRIB_ALWAYSINLINE();

static inline FLCN_STATUS _dpuIsLsOrHsModeSet_GV10X(LwBool *pBLsModeSet, LwBool *pBHsModeSet)
    GCC_ATTRIB_ALWAYSINLINE();

static inline FLCN_STATUS _dpuEnsureReturnPCIsNotInHS(void)
    GCC_ATTRIB_ALWAYSINLINE();

static inline void _clearSCPregisters(void)
    GCC_ATTRIB_ALWAYSINLINE();

static inline FLCN_STATUS _enterHS(void)
    GCC_ATTRIB_ALWAYSINLINE();

static inline void _exitHS(void)
    GCC_ATTRIB_ALWAYSINLINE();   

#ifdef IS_SSP_ENABLED
static FLCN_STATUS _dpuSelwreactionUpdateStackCanaryHS(void)
    GCC_ATTRIB_NO_STACK_PROTECT()
    GCC_ATTRIB_SECTION("imem_selwreActionHs", "_dpuSelwreactionUpdateStackCanaryHS")
    GCC_ATTRIB_USED();
static void _dpuSelwreactionRestoreStackCanaryHS(void)
    GCC_ATTRIB_NO_STACK_PROTECT()
    GCC_ATTRIB_SECTION("imem_selwreActionHs", "_dpuSelwreactionRestoreStackCanaryHS")
    GCC_ATTRIB_USED();
#endif

/* ------------------------- Static Variables ------------------------------- */
#ifdef IS_SSP_ENABLED
static void *gPCanaryFromLSCaller = 0;
#endif

/* ------------------------- Private Functions ------------------------------ */
#ifdef IS_SSP_ENABLED
/*
 *   @brief UpdateStack canary to true random number generated by SE after entering in HS.
 *
 *   return FLCN_STATUS  FLCN_OK in case of successful exelwtion
 */
static FLCN_STATUS
_dpuSelwreactionUpdateStackCanaryHS(void)
{
    LwU32 randNum = 0;
    FLCN_STATUS status = FLCN_OK;

    // Save canary previously set in LS code to restore before exiting from HS code.
    gPCanaryFromLSCaller = __stack_chk_guard;

#ifdef LIB_CCC_PRESENT
    // TODO: Call LibCCC wrapper once implemented in LibCCC. Tracking Bug: 200762634
    if (FLCN_OK != hdcp22LibCccGetRandomNumberHs(&randNum, 1))
    {
        return FLCN_ERR_HS_GEN_RANDOM;
    }
#else
    // Generate random number from SE trng and assign it to canary
    if (SE_OK != seTrueRandomGetNumberHs(&randNum, 1))
    {
        status = FLCN_ERR_HS_GEN_RANDOM;
    }
#endif

    // UpdateStack canary value
    _dpuSetStackCanary((void *)randNum);
    return status;
}

/*
 *   @brief Restore canary before returning to LS code.
 *
 *   return FLCN_STATUS  FLCN_OK in case of succesful exelwtion
 */
static void
_dpuSelwreactionRestoreStackCanaryHS(void)
{
    // Restore canary value
    _dpuSetStackCanary(gPCanaryFromLSCaller);
}
#endif

/*!
 * @brief  Ensure that the PLM of IMEM and DMEM meet the security requirement
 *
 * @return FLCN_OK  if the PLM already meets the requirement
 *         FLCN_ERR_INSUFFICIENT_PMB_PLM_PROTECTION  otherwise
 */
static inline FLCN_STATUS
_dpuCheckPmbPLM_GV10X(void)
{
    FLCN_STATUS flcnStatus = FLCN_OK;
    LwU32       dmemPrivLevel = 0xFF;
    LwU32       imemPrivLevel = 0xFF;

    CHECK_FLCN_STATUS(CSB_REG_RD32_HS_ERRCHK(LW_CGSP_FALCON_DMEM_PRIV_LEVEL_MASK, &dmemPrivLevel));

    CHECK_FLCN_STATUS(CSB_REG_RD32_HS_ERRCHK(LW_CGSP_FALCON_IMEM_PRIV_LEVEL_MASK, &imemPrivLevel));

    //
    // Disabling level1 DMEM/IMEM access HS check, as ACR lib which boots GSP is running in LEVEL 2,
    // It Can not disable access of level1 clinets. Once ACR runs in HS mode, we need to enable this checks.
    //

    if (FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _READ_PROTECTION_LEVEL0, _ENABLE, dmemPrivLevel) ||
        // FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _READ_PROTECTION_LEVEL1, _ENABLE, dmemPrivLevel) ||
        FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _READ_PROTECTION_LEVEL2, _ENABLE, dmemPrivLevel))
    {
        flcnStatus = FLCN_ERR_INSUFFICIENT_PMB_PLM_PROTECTION;
        goto ErrorExit;
    }

    if (FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL0, _ENABLE, dmemPrivLevel) ||
        // FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL1, _ENABLE, dmemPrivLevel) ||
        FLD_TEST_DRF(_CGSP, _FALCON_DMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL2, _ENABLE, dmemPrivLevel))
    {
        flcnStatus = FLCN_ERR_INSUFFICIENT_PMB_PLM_PROTECTION;
        goto ErrorExit;
    }

    if (FLD_TEST_DRF(_CGSP, _FALCON_IMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL0, _ENABLE, imemPrivLevel) ||
        // FLD_TEST_DRF(_CGSP, _FALCON_IMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL1, _ENABLE, imemPrivLevel) ||
        FLD_TEST_DRF(_CGSP, _FALCON_IMEM_PRIV_LEVEL_MASK, _WRITE_PROTECTION_LEVEL2, _ENABLE, imemPrivLevel))
    {
        flcnStatus = FLCN_ERR_INSUFFICIENT_PMB_PLM_PROTECTION;
        goto ErrorExit;
    }

ErrorExit:
    return flcnStatus;
}

/*!
 * @brief  Check if SCTL_LSMODE or SCTL_HSMODE is set
 *
 * @param[in]  pBLsModeSet   Pointer saving if SCTL_LSMODE is set
 * @param[in]  pBHsModeSet   Pointer saving if SCTL_HSMODE is set
 */
static inline FLCN_STATUS
_dpuIsLsOrHsModeSet_GV10X
(
    LwBool *pBLsModeSet,
    LwBool *pBHsModeSet
)
{
    FLCN_STATUS flcnStatus = FLCN_OK;
    LwU32 data32 = 0;

    CHECK_FLCN_STATUS(CSB_REG_RD32_HS_ERRCHK(LW_CGSP_FALCON_SCTL, &data32));

    if (pBLsModeSet != NULL)
    {
        *pBLsModeSet = FLD_TEST_DRF(_CGSP, _FALCON_SCTL, _LSMODE, _TRUE, data32);
    }

    if (pBHsModeSet != NULL)
    {
        *pBHsModeSet = FLD_TEST_DRF(_CGSP, _FALCON_SCTL, _HSMODE, _TRUE, data32);
    }

ErrorExit:
    return flcnStatus;
}

/*!
 * @brief  Check if return PC is in HS or not.
 *         This function must be called as first statement in HS entry functions.
 *         This is to prevent ROP attacks where LS/NS code calling HSEntry can modify return PC
 *         so that it points to another HS overlay rather than pointing to caller.
 *
 * @return FLCN_OK  if return PC is not in HS
 *         FLCN_ERR_HS_CHK_RETURN_PC_AT_HS_ENTRY_IS_OF_HS if return PC is in HS
 */
static inline FLCN_STATUS
_dpuEnsureReturnPCIsNotInHS(void)
{
    LwU32 *returnPC = __builtin_return_address(0);
    LwU32 imtagVal;

    falc_imtag(&imtagVal, (LwU32)returnPC);

    if (FLD_TEST_DRF(_PFALCON, _FALCON_IMTAG_BLK, _SELWRE, _YES, imtagVal))
    {
        // Return PC is pointing to a secure block. NS/LS must be trying to mount a ROP attack. Take punitive action.
        return FLCN_ERR_HS_CHK_RETURN_PC_AT_HS_ENTRY_IS_OF_HS;
    }

    return FLCN_OK;
}

/*!
 * @brief clear all the SCP registers
 */
static inline void 
_clearSCPregisters(void)
{
    // Clear SCP registers
    CLEAR_SCP_REGISTER_HS(SCP_R0);
    CLEAR_SCP_REGISTER_HS(SCP_R1);
    CLEAR_SCP_REGISTER_HS(SCP_R2);
    CLEAR_SCP_REGISTER_HS(SCP_R3);
    CLEAR_SCP_REGISTER_HS(SCP_R4);
    CLEAR_SCP_REGISTER_HS(SCP_R5);
    CLEAR_SCP_REGISTER_HS(SCP_R6);
    CLEAR_SCP_REGISTER_HS(SCP_R7);
}

/*!
 * @brief Enter HS Sequence 
 * Helper function to call all the HS Common PreChecks
 *
 * @return FLCN_OK  If all HS common pre check passes 
 *                  Appropriate error status on failure.
 */
static inline FLCN_STATUS 
_enterHS(void)
{

    FLCN_STATUS flcnStatus = FLCN_ERROR;

    //**************NO CALL TO NON-INLINED FUNCTIONS BEFORE THIS POINT ************** 
#ifdef IS_SSP_ENABLED
    // Set canary to random number generated by SE engine
    CHECK_FLCN_STATUS(_dpuSelwreactionUpdateStackCanaryHS());    
#endif

    //
    // We are using ga10x, ad10x Non BFHS profile for running on DFPGA VDVS Setup.
    // HS Entry Checks does not pass in it. Hence Skipping HS PreCheck for 
    // HDCP Sanity to pass on presilicon debug setup
    // 
#if !(DPU_PROFILE_ga10x || DPU_PROFILE_ad10x)
    // Make sure all the HS Common Pre Checks are passing 
    CHECK_FLCN_STATUS(dpuHsPreCheckCommon_HAL(&Dpu.hal)); 
#endif

    // Check return PC to make sure that it is not in HS
    VALIDATE_RETURN_PC_AND_HALT_IF_HS();

ErrorExit:
    return flcnStatus;   
}

/*!
 * @brief Exit HS Sequence.
 * HS exit checks and sequence is captured in 
 * https://confluence.lwpu.com/display/GFS/HS+Entry+and+Exit+Security+Checks
 */
static inline void 
_exitHS(void)
{
    //
    // Re-configure the RNG CTRL registers (before exiting HS) to ensure RNG can 
    // still work at LS
    if (dpuForceStartScpRNGHs_HAL() != FLCN_OK)
    {
        REG_WR32(CSB, LW_CGSP_FALCON_MAILBOX0, FLCN_ERR_HS_RNG_CONFIG_ERROR);
        DPU_HALT();
    }

    // Change Reset Protection from Level 3 to Level2 as we are returning to LS
    if (dpuUpdateResetPrivLevelMaskHS_HAL(&Dpu.hal, LW_FALSE) != FLCN_OK)
    {
        REG_WR32(CSB, LW_CGSP_FALCON_MAILBOX0, FLCN_ERR_HS_UPDATE_RESET_PLM_ERROR);
        DPU_HALT();
    }

#ifdef IS_SSP_ENABLED
    // Restore canary to LS canary value before exiting HS code.
    _dpuSelwreactionRestoreStackCanaryHS();
#endif

    //
    // We have restored to LS canary at this point 
    // We should not call to non-inline function after this point. 
    //

    // clear SCP registers
    _clearSCPregisters();

    //
    // Disable big hammer lockdown before returning
    // to light secure mode. This should be the last operation in HS
    // 
    DISABLE_BIG_HAMMER_LOCKDOWN();
}
#endif // _GSP_HS_H_
