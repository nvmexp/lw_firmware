/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2020-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file:  acr_se_access_gh100.c
 */
//
// Includes
//
#include "acr.h"
#include "acrdrfmacros.h"
#include "acr_objacr.h"

#include "mmu/mmucmn.h"
#include "dev_top.h"
#include "dev_master.h"
#include "dev_fb.h"
#include "dev_fuse.h"
#include "sec2mutexreservation.h"
#include "dev_se_seb.h"
#include "dev_se_seb_addendum.h"
#include "config/g_acr_private.h"


/*
 * Utility macro that may be used validate an index to ensure a valid common HW
 * mutex corresponds to that index.  A non-zero return value represents a
 * valid mutex; zero represents an invalid mutex.
 *
 * @param[in] groupId: Group index
 * @param[in] mutexId: Mutex index
 */
#define SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupId, mutexId)                     \
    (groupId < LW_SSE_SE_COMMON_MUTEX_MUTEX__SIZE_1 &&                          \
        mutexId < LW_SSE_SE_COMMON_MUTEX_MUTEX__SIZE_2)

/*!
 * @brief: Acquires SE common mutex
 *
 * @param[in] busTarget: Since this is common binary, bus target could be PMU or
 *                          SEC2
 * @param[in] groupId:  From GV100 onwards, mutexes are grouped into HS and LS.
 *                          Indicate groud ID of mutex.
 * @param[in] mutexId:  Mutex id of register.
 * @param[out] pToken:  HW generated token which is used to acquire mutex. This
 *                          toekn is used to release mutex.
 *
 * @return  ACR_ERROR_ILWALID_ARGUMENT:     Invalid mutex group or id
            ACR_ERROR_ILWALID_ARGUMENT      pToken is null
 *          ACR_ERROR_MUTEX_ACQUIRE_FAILED: Error while accessing bus or failed
 *                                          to acquire mutex
 *          ACR_OK: No Error scenario
 */
ACR_STATUS
acrAcquireSelwreMutex_GH100
(
    LwU8  mutexId,
    LwU8 *pToken
)
{
    LwU32       genId      = 0;
    LwU32       mutexOwner = 0;
    ACR_STATUS  status     = ACR_OK;
    DIO_PORT    dioPort;
    dioPort.dioType        = DIO_TYPE_SE;
    dioPort.portIdx        = 0;

#ifdef ACR_FMODEL_BUILD
    {
        return ACR_OK;
    }
#endif // ACR_FMODEL_BUILD

    if (NULL == pToken)
    {
        return ACR_ERROR_ILWALID_ARGUMENT;
    }

    // Colwert into groupId and actual mutexId
    LwU8 groupIndex = SELWRE_MUTEX_DERIVE_GROUPID(mutexId);
    LwU8 mutexIndex = SELWRE_MUTEX_DERIVE_MUTEXID(mutexId);

    // Check validity of group and mutex
    if (!SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupIndex, mutexIndex))
    {
        return ACR_ERROR_ILWALID_ARGUMENT;
    }

    // Get HW generated token
    CHECK_LIBLWRISCV_STATUS_AND_RETURN_IF_NOT_OK(
        dioReadWrite(dioPort, DIO_OPERATION_RD, (LwU32)LW_SSE_SE_COMMON_MUTEX_ID(groupIndex), &genId), ACR_ERROR_LIBLWRISCV_DIO_ERROR);

    genId = DRF_VAL(_SSE, _SE_COMMON_MUTEX_ID, _VALUE, genId);

    if (genId == LW_SSE_SE_COMMON_MUTEX_ID_VALUE_NOT_AVAIL ||
        genId == LW_SSE_SE_COMMON_MUTEX_ID_VALUE_INIT)
    {
        return ACR_ERROR_MUTEX_ACQUIRE_FAILED;
    }

    genId = FLD_SET_DRF_NUM(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, genId, 0);

    do
    {
        // Write generated token to Mutex register
        CHECK_LIBLWRISCV_STATUS_OK_OR_GOTO_CLEANUP(dioReadWrite(dioPort, DIO_OPERATION_WR,
                     (LwU32)LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &genId), ACR_ERROR_MUTEX_ACQUIRE_FAILED);

        // Read back Mutex register
        CHECK_LIBLWRISCV_STATUS_OK_OR_GOTO_CLEANUP(dioReadWrite(dioPort, DIO_OPERATION_RD,
            (LwU32)LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &mutexOwner), ACR_ERROR_MUTEX_ACQUIRE_FAILED);


    } while (DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, mutexOwner) != DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, genId));

    *pToken = (LwU8)genId;
    return status;

Cleanup:
    *pToken = 0;
    // Release the genID generated by this function
    if (genId != LW_SSE_SE_COMMON_MUTEX_ID_VALUE_INIT &&
        genId != LW_SSE_SE_COMMON_MUTEX_ID_VALUE_NOT_AVAIL)
    {
        CHECK_LIBLWRISCV_STATUS_AND_RETURN_IF_NOT_OK(dioReadWrite(dioPort, DIO_OPERATION_WR,
                (LwU32)LW_SSE_SE_COMMON_MUTEX_ID_RELEASE(groupIndex), &genId), ACR_ERROR_SHA_MUTEX_RELEASE_FAILED);
    }

    return ACR_ERROR_MUTEX_ACQUIRE_FAILED;
}

/*!
 * @brief: Releases common mutex
 *
 * @param[in] mutexId:  Mutex id of register.
 * @param[oin] hwToken: HW generated token which is used to acquire mutex. This
 *                          toekn is used to release mutex.
 *
 * @return  ACR_ERROR_ILWALID_ARGUMENT:   Invalid mutex group or id
 *          ACR_OK: No Error scenario
 */

ACR_STATUS
acrReleaseSelwreMutex_GH100
(
    LwU8  mutexId,
    LwU8  hwTokenFromCaller
)
{
    ACR_STATUS  status         = ACR_OK;
    LWRV_STATUS lwrvStatus     = LWRV_OK;
    LwU32       mutexOwnerInHw = 0;
    LwU32 val;
    DIO_PORT    dioPort;
    dioPort.dioType            = DIO_TYPE_SE;
    dioPort.portIdx            = 0;

#ifdef ACR_FMODEL_BUILD
    {
        return ACR_OK;
    }
#endif // ACR_FMODEL_BUILD

    // Colwert into groupId and actual mutexId
    LwU8 groupIndex = SELWRE_MUTEX_DERIVE_GROUPID(mutexId);
    LwU8 mutexIndex = SELWRE_MUTEX_DERIVE_MUTEXID(mutexId);

    // Check validity of group and mutex
    if (!SELWRE_MUTEX_GROUP_INDEX_IS_VALID(groupIndex, mutexIndex))
    {
        return ACR_ERROR_ILWALID_ARGUMENT;
    }

    // Read back mutex register and confirm ownership against hwToken passed by caller
    CHECK_LIBLWRISCV_STATUS_AND_RETURN_IF_NOT_OK(dioReadWrite(dioPort, DIO_OPERATION_RD,
        (LwU32)LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &mutexOwnerInHw), ACR_ERROR_LIBLWRISCV_DIO_ERROR);

    // Mutex is owned by caller if the caller's hwToken matches with HW, otherwise not
    if (DRF_VAL(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, mutexOwnerInHw) != hwTokenFromCaller)
    {
        return ACR_ERROR_MUTEX_OWNERSHIP_MATCH_FAILED;
    }

    val = DRF_NUM(_SSE, _SE_COMMON_MUTEX_MUTEX, _VALUE, LW_SSE_SE_COMMON_MUTEX_MUTEX_VALUE_INIT);

    // All ok, release the mutex as well as the hwToken.
    CHECK_LIBLWRISCV_STATUS_OK_OR_GOTO_CLEANUP(dioReadWrite(dioPort, DIO_OPERATION_WR,
                 (LwU32)LW_SSE_SE_COMMON_MUTEX_MUTEX(groupIndex, mutexIndex), &val), ACR_ERROR_LIBLWRISCV_DIO_ERROR);

Cleanup:
    hwTokenFromCaller = FLD_SET_DRF_NUM(_SSE, _SE_COMMON_MUTEX_ID_RELEASE, _VALUE, hwTokenFromCaller, 0);

    val = hwTokenFromCaller;

    lwrvStatus = dioReadWrite(dioPort, DIO_OPERATION_WR, (LwU32)LW_SSE_SE_COMMON_MUTEX_ID_RELEASE(groupIndex), &val);

    if (status == ACR_OK)
    {
        CHECK_LIBLWRISCV_STATUS_AND_RETURN_IF_NOT_OK(lwrvStatus, ACR_ERROR_LIBLWRISCV_DIO_ERROR);
    }
    
    return status;
}
