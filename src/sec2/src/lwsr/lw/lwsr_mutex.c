/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2015-2019 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/*!
 * @file   lwsr_mutex.c
 *
 * Before an LWSR device can expose the locked registers of the LWSR interface,
 * the LWSR Mutex must have been successfully acquired by the client accessing
 * the SRC device at its interface.  The registers marked as Locked on the spec
 * shall not be accessible until the Mutex is acquired by source device client.
 * (Please refer to spec "LWSR Controller Mutex - Rev1.0" for more details.)
 *
 * (Note that here the "Mutex" refers to the mutex inside the LWSR device, not
 * the HW mutex in SEC2)
 *
 * A Mutex key will be generated by certain cryptogrphaic operation and be sent
 * back to the LWSR device to acquire the Mutex.  Here in this file we are
 * helping process the Mutex key computation and will return the Mutex key to
 * the client.  There are two cryptographic options can be used for Mutex key
 * computation.  We use HMAC-SHA1 for most of the LWSR devices.  But for some
 * rare devices, we use Fiestel-Cipher.  Client will indicate which algorithm to
 * be applied to the incoming keys.
 */

/* ------------------------- System Includes -------------------------------- */
#include "sec2sw.h"
#include "lwosselwreovly.h"

/* ------------------------- Application Includes --------------------------- */
#include "sec2_chnmgmt.h"

#include "class/cl95a1.h"
#include "lwsr/lwsr_mthds.h"
#include "sha1.h"
#include "sha256.h"

/* ------------------------- Macros and Defines ----------------------------- */
/*!
 * Colwenience macro to set the memdesc for DMA reads/writes
 */
#define LWSR_SET_MEMDESC(pMemDesc, addr32)                                     \
do                                                                             \
{                                                                              \
    (pMemDesc)->params = FLD_SET_DRF_NUM(_RM_FLCN_MEM_DESC, _PARAMS, _DMA_IDX, \
                                         RM_SEC2_DMAIDX_VIRT, 0);              \
    (pMemDesc)->address.lo = (addr32) << 8;                                    \
    (pMemDesc)->address.hi = (addr32) >> 24;                                   \
} while (LW_FALSE)

/* ------------------------- Global Variables ------------------------------- */
/* ------------------------- Static Variables ------------------------------- */
/*!
 * A 256-byte aligned scratch buffer for any operations which needs to be 256
 * aligned.
 */
static LwU8 _lwsrScratchBuf[64]
    GCC_ATTRIB_ALIGN(256);

/* ------------------------- Prototypes ------------------------------------- */
static FLCN_STATUS _lwsrDecryptAndValidateKey(LwU8 *pKeyBuf)
    GCC_ATTRIB_SECTION("imem_lwsr", "_lwsrDecryptAndValidateKey");

static void        _lwsrFeistelCipherGen(LwU8 result[SHA1_DIGEST_LENGTH], LwU8 message[LWSR_MSG_KEY_SIZE], LwU32 nMessageBytes, LwU8 key[LWSR_PLAIN_PRIV_KEY_SIZE], LwU32 nKeyBytes)
    GCC_ATTRIB_SECTION("imem_lwsr", "_lwsrFeistelCipherGen");

static LwU8        _lwsrLFSR(LwU8 pre)
    GCC_ATTRIB_SECTION("imem_lwsr", "_lwsrLFSR");

static void        _lwsrOneRoundOfFiestelCipher(LwU8 *pL, LwU8 *pR, LwU8 *pK)
    GCC_ATTRIB_SECTION("imem_lwsr", "_lwsrOneRoundOfFiestelCipher");


/* ------------------------- Public Functions ------------------------------- */
/*!
 * Get the message key and private key from FB, then write back the computed
 * mutex key to the FB after the cryptographic computation.
 *
 * @return FLCN_OK if the computation finishes successfully.  Or bubble up the
 *         errors returned from the callees.
 */
FLCN_STATUS
lwsrMutexKeyComputation(void)
{
    FLCN_STATUS      retVal                         = FLCN_OK;
    LwU32            algorithm;
    LwU32            keysBase;
    LwU8             msg[LWSR_MSG_KEY_SIZE]         = {0};
    LwU8             encKey[LWSR_ENC_PRIV_KEY_SIZE] = {0};
    RM_FLCN_MEM_DESC memdesc;
    LwU8             i;

    algorithm = LWSR_GET_METHOD_PARAM_OFFSET(
        LWSR_GET_SEC2_METHOD_ID(LWSR_METHOD_ID(MUTEX_ACQUIRE)));
    keysBase = LWSR_GET_METHOD_PARAM_OFFSET(
        LWSR_GET_SEC2_METHOD_ID(LWSR_METHOD_ID(MUTEX_ACQUIRE_KEYBUF)));

    memset(_lwsrScratchBuf, 0, sizeof(_lwsrScratchBuf));

    // DMA the message key from FB to DMEM buffer
    LWSR_SET_MEMDESC(&memdesc, keysBase);
    if ((retVal = dmaRead(_lwsrScratchBuf, &memdesc, LWSR_MSG_KEY_OFFS,
            LWSR_MSG_KEY_SIZE)) != FLCN_OK)
    {
        goto lwsrMutexAcquire_dmaError;
    }

    memcpy(msg, _lwsrScratchBuf, LWSR_MSG_KEY_SIZE);

    // DMA the encrypted vendor key from FB to DMEM buffer
    if ((retVal = dmaRead(_lwsrScratchBuf, &memdesc,
            LWSR_ENC_PRIV_KEY_OFFS, LWSR_ENC_PRIV_KEY_SIZE)) != FLCN_OK)
    {
        goto lwsrMutexAcquire_dmaError;
    }

    // Don't do the decryption if the hash values are all 0xFF
    for (i = LWSR_PLAIN_PRIV_KEY_SIZE; i < LWSR_ENC_PRIV_KEY_SIZE; i++)
    {
        if (_lwsrScratchBuf[i] != 0xFF)
        {
            break;
        }
    }

    OSTASK_ATTACH_AND_LOAD_IMEM_OVERLAY(OVL_INDEX_IMEM(libSha));

    if (i < LWSR_ENC_PRIV_KEY_SIZE)
    {
        //
        // Don't use local buffer to do the decryption since it may not be
        // 16 byte-aligned and will fail the DMA in _lwsrDecryptAndValidateKey
        //
        retVal = _lwsrDecryptAndValidateKey(_lwsrScratchBuf);
    }

    if (retVal == FLCN_OK)
    {
        memcpy(encKey, _lwsrScratchBuf, LWSR_PLAIN_PRIV_KEY_SIZE);

        if (algorithm == LW95A1_LWSR_MUTEX_ACQUIRE_ALGORITHM_HMACSHA1)
        {
            hmacSha1(_lwsrScratchBuf, (void*)msg, LWSR_MSG_KEY_SIZE,
                     (void*)encKey, LWSR_PLAIN_PRIV_KEY_SIZE);
        }
        else if (algorithm == LW95A1_LWSR_MUTEX_ACQUIRE_ALGORITHM_FEISTELCIPHER)
        {
            _lwsrFeistelCipherGen(_lwsrScratchBuf, msg, LWSR_MSG_KEY_SIZE,
                                  encKey, LWSR_PLAIN_PRIV_KEY_SIZE);
        }
        else
        {
            retVal = FLCN_ERR_NOT_SUPPORTED;
        }
    }

    if (retVal != FLCN_OK)
    {
        //
        // Don't return error since it may cause timeout in the client, instead,
        // just return mutex key as all 0xFF indicating an error.
        //
        memset((_lwsrScratchBuf + LWSR_MUTEX_KEY_OFFS), 0xFF,
               SHA1_DIGEST_LENGTH);
        retVal = FLCN_OK;
    }

    if ((retVal = dmaWrite(_lwsrScratchBuf, &memdesc, LWSR_MUTEX_KEY_OFFS,
            SHA1_DIGEST_LENGTH)) != FLCN_OK)
    {
        goto lwsrMutexAcquire_dmaError;
    }

lwsrMutexAcquire_dmaError:
    if (retVal == FLCN_ERR_DMA_NACK)
    {
        retVal = FLCN_ERR_ILLEGAL_OPERATION;
    }

    OSTASK_DETACH_IMEM_OVERLAY(OVL_INDEX_IMEM(libSha));
    return retVal;
}

/* ------------------------- Private Functions ------------------------------ */
/*!
 * Decrypt the key using falcon HW secret and validate it.
 * pKeyBuf will be atleast 16B aligned
 *
 * @param[in]  pKeyBuf   Pointer to the key buffer to be decrypted and validated
 *
 * @return FLCN_OK if the key is decrypted and validated successfully.
 *         FLCN_ERR_ILWALID_ARGUMENT if the key is not successfully validated.
 */
static FLCN_STATUS
_lwsrDecryptAndValidateKey
(
    LwU8 *pKeyBuf
)
{
    FLCN_STATUS status;
    LwU32       index = 0;
    LwU8        sha2Hash[SHA256_HASH_BLOCK];

    // Enter HS mode so we can use SCP
    OSTASK_ATTACH_AND_LOAD_IMEM_OVERLAY_HS(OVL_INDEX_IMEM(lwsrcrypt));

    // Setup entry into HS mode
    OS_HS_MODE_SETUP_IN_TASK(OVL_INDEX_IMEM(lwsrcrypt), NULL, 0);

    status = lwsrCryptEntry(pKeyBuf);

    // Cleanup after returning from HS mode
    OS_HS_MODE_CLEANUP_IN_TASK(NULL, 0);

    OSTASK_DETACH_IMEM_OVERLAY_HS(OVL_INDEX_IMEM(lwsrcrypt));

    if (status != FLCN_OK)
    {
        return status;
    }

    // Callwlate the hash
    sha256(sha2Hash, pKeyBuf, LWSR_PLAIN_PRIV_KEY_SIZE);

    index = 0;
    // Compare the hash
    while (index < SHA256_HASH_BLOCK)
    {
        if (sha2Hash[index] != pKeyBuf[LWSR_PLAIN_PRIV_KEY_SIZE + index])
        {
            return FLCN_ERR_ILWALID_ARGUMENT;
        }
        ++index;
    }

    return FLCN_OK;
}

/*!
 * @brief Mutex WAR algorithm for Himax HX8880-B.
 *
 *    The phases are:
 *    M[1]  & M[0]   with K[0] ~K[2]  = > M[1.3]  & M[0.3]
 *    M[2]  & M[0.3] with K[3] ~K[5]  = > M[2.3]  & M[0.6]
 *    M[3]  & M[1.3] with K[6] ~K[8]  = > M[3.3]  & M[1.6]
 *    M[4]  & M[2.3] with K[9] ~K[11] = > M[4.3]  & M[2.6]
 *    M[5]  & M[3.3] with K[12]~K[14] = > M[5.3]  & M[3.6]
 *    M[6]  & M[0.6] with K[15]~K[1]  = > M[6.3]  & M[0.9]
 *    M[7]  & M[1.6] with K[2] ~K[4]  = > M[7.3]  & M[1.9]
 *    M[8]  & M[2.6] with K[5] ~K[7]  = > M[8.3]  & M[2.9]
 *    M[9]  & M[3.6] with K[8] ~K[10] = > M[9.3]  & M[3.9]
 *    M[10] & M[0.9] with K[11]~K[13] = > M[10.3] & M[0.12]
 *    M[11] & M[1.9] with K[14]~K[0]  = > M[11.3] & M[1.12]
 *
 *    The end result : M[3.9], M[2.9], M[1.12], M[0.12]
 *
 * @param[in/out]  result          result value
 * @param[in]      message         the message key
 * @param[in]      nMessageBytes   bytes of the message
 * @param[in]      key             the vendor key
 * @param[in]      nKeyBytes       bytes of the key
 */
static void
_lwsrFeistelCipherGen
(
    LwU8  result[SHA1_DIGEST_LENGTH],
    LwU8  message[LWSR_MSG_KEY_SIZE],
    LwU32 nMessageBytes,
    LwU8  key[LWSR_PLAIN_PRIV_KEY_SIZE],
    LwU32 nKeyBytes
)
{
    LwU8  L;
    LwU8  R;
    LwU32 R_counter = 0;
    LwU32 K_counter = 0;
    LwU32 i;
    LwU32 round;

    result[0] = message[0];

    for (i = 1; i < nMessageBytes; i++)
    {
        L = message[i];
        R = result[R_counter];

        // Take 3 rounds to scramble the data
        for (round = 0; round < 3; round++)
        {
            _lwsrOneRoundOfFiestelCipher(&L, &R, &key[K_counter]);

            if (K_counter < (nKeyBytes - 1))
            {
                K_counter++;
            }
            else
            {
                K_counter = 0;
            }
        }

        // exchange L, R to save
        result[R_counter] = L;
        if (i < 4)
        {
            result[i] = R;
        }

        if (i >= 2)
        {
            R_counter++;
        }
        if (R_counter >= 4)
        {
            R_counter = 0;
        }
    }
}

/*!
 * @brief Linear Feedback Shift Register.
 *
 * @param[in]  pre   input
 *
 * @return  The computed LFSR.
 */
static LwU8
_lwsrLFSR
(
    LwU8 pre
)
{
    LwU8 lfsr = pre;
    LwU8 bit;

    // only do one step to generate key stream.
    /* taps: 8 6 5 4; feedback polynomial: x^8 + x^6 + x^5 + x^4 + 1 */
    bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1;
    lfsr = (lfsr >> 1) | (bit << 7);
    return lfsr;
}

/*!
 * @brief one round of Fiestel Cipher.
 *
 * @param[in]  *pL   Fiestel Cipher lift part
 * @param[in]  *pR   Fiestel Cipher right part
 * @param[in]  *pK   Fiestel Cipher key part
 */
static void
_lwsrOneRoundOfFiestelCipher
(
    LwU8 *pL,
    LwU8 *pR,
    LwU8 *pK
)
{
    LwU8 f;
    LwU8 tmp;

    f = _lwsrLFSR(*pK) ^ *pR;
    *pL = *pL ^ f;

    // exchange L and R
    tmp = *pL;
    *pL = *pR;
    *pR = tmp;
}

