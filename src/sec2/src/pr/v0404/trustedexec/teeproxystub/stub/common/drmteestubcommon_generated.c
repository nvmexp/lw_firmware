/**@@@+++@@@@******************************************************************
**
** Microsoft (r) PlayReady (r)
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/* This code was autogenerated by proxy_stubcommon.py. Please do not hand edit this file! */

#include <drmresults.h>
#include <drmtee.h>
#include <drmteebase.h>
#include <oemtee.h>
#include <oembyteorder.h>
#include <drmxbbuilder.h>
#include <drmxbparser.h>
#include <drmteecache.h>
#include <drmteestub.h>
#include <drmmathsafe.h>

#include <drmteeproxystubcommon.h>
#include <drmteestubcommon_generated.h>
#include <drmteestubcommon.h>

ENTER_PK_NAMESPACE_CODE;

#define DRM_TEE_STUB_MAXIMUM_SERIALIZED_MESSAGE_LENGTH 0x0FFFFFFF

#ifdef SINGLE_METHOD_ID_REPLAY
extern DRM_BYTE g_fInitialized;
extern DRM_TEE_CACHE_ENTRY g_rgoCache[OEM_TEE_CACHE_MAX_ENTRIES];
#endif

#if DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE
DRM_DWORD g_dwLwrrentTeeFunctionID = ( DRM_DWORD )DRM_METHOD_ID_DRM_TEE_Count + 1; /* Invalid function ID start value */
#endif /* DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE */

PREFAST_PUSH_DISABLE_EXPLAINED(__WARNING_UNINITIALIZED_MEMORY_6001, "Prefast Noise: Warning about rgParameters not being initialized before usage. However it is actually initialized by OEM_TEE_ZERO_MEMORY")
/*
** Synopsis:
**
** This method is the entrypoint for secure world PRITEE methods.  The OEM implementation
** of the normal/secure world transport will call this method with the serialized data passed
** into the OEM_TEE_PROXY_MethodIlwoke method.  This method will deserialize the message
** envelope, validate its contents, call the corresponding DRM_TEE_* method, and will package
** the response message in the f_pcbResponseMessage parameter.
**
** Arguments:
**
** f_cbRequestMessage:          (in)     The serialized method request from the normal world proxy.
** f_pbRequestMessage:          (in)     The size (in bytes) of the method request (f_cbRequestMessage).
** f_pcbResponseMessage:        (in/out) As an in parameter, this item holds the size (in bytes)
**                                       of the the response message buffer (f_pbResponseMessage).
**                                       As an out parameter, it is set to the size of the response
**                                       message copied to the response buffer (f_pbResponseMessage).
** f_pbResponseMessage:         (in/out) The response message buffer.
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_STUB_HandleMethodRequest(
    __in                                                                                          DRM_DWORD           f_cbRequestMessage,
    __in_bcount( f_cbRequestMessage )                                                       const DRM_BYTE           *f_pbRequestMessage,
    __inout_opt                                                                                   DRM_DWORD          *f_pcbResponseMessage,
    _Out_writes_bytes_opt_( *f_pcbResponseMessage )                                               DRM_BYTE           *f_pbResponseMessage )
{
    DRM_RESULT                               dr                     = DRM_SUCCESS;
    DRM_RESULT                               drTmp                  = DRM_SUCCESS;
    DRM_BYTE                                *pbStack                = NULL;
    DRM_DWORD                                cbStack                = DRM_TEE_PROXY_MESSAGE_OVERHEAD_MIN;
    DRM_DWORD                                cbMaxStack             = f_cbRequestMessage;
    XB_DRM_TEE_PROXY_METHOD_REQ             *pReq                   = NULL;
    DRM_DWORD                                cbReq                  = 0;
    DRM_STACK_ALLOCATOR_CONTEXT              stack;                 /* Initialized by DRM_STK_Init */
    DRM_TEE_CONTEXT                         *pTeeCtx                = NULL;
    DRM_DWORD                                dwVersionFound         = 0;
    XB_DRM_TEE_PROXY_METHOD_REQ             *pResp                  = NULL;
    DRM_RESULT                               drTEEResult            = DRM_SUCCESS;
    DRM_TEE_PROXY_PARAMETERS                *rgParameters           = NULL;

#if DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE
    /*
    ** The DRM_METHOD_ID_DRM_TEE_Count value is used to indicate allcations made prior to the PRITEE function ID being known.
    ** Any allocations made with this ID will be added to the PRITEE function's heap allocation size once the ID is known.
    */
    g_dwLwrrentTeeFunctionID = ( DRM_DWORD )DRM_METHOD_ID_DRM_TEE_Count;
#endif /* DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE */

    ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, sizeof( *rgParameters ) * MAX_DRM_TEE_PROXY_PARAMETER_COUNT, ( DRM_VOID ** )&rgParameters ) );  /* Zero-initialized by DRM_TEE_STUB_InitParameters */
    ChkDR( DRM_TEE_STUB_InitParameters( rgParameters ) );

    ChkArg( f_pbRequestMessage != NULL );
    ChkArg( f_cbRequestMessage  > 0    );
    ChkArg( f_cbRequestMessage <= DRM_TEE_STUB_MAXIMUM_SERIALIZED_MESSAGE_LENGTH );

    /* The maximum size of the stack can not be larger than the size of the message + minumum overhead */
    ChkDR( DRM_DWordAddSame( &cbMaxStack, DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD ) );

    ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, sizeof( *pReq ), ( DRM_VOID ** )&pReq ) );
    ChkVOID( OEM_TEE_ZERO_MEMORY( pReq, sizeof( *pReq ) ) );

    do
    {
        ChkVOID( DRM_TEE_IMPL_BASE_MemFree( NULL, ( DRM_VOID ** )&pbStack ) );
        ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, cbStack, ( DRM_VOID ** )&pbStack ) );
        ChkDR( DRM_STK_Init( &stack, pbStack, cbStack, TRUE ) );

        dr = DRM_XB_UnpackBinary(
            f_pbRequestMessage,
            f_cbRequestMessage,
            &stack,
            s_XB_DRM_TEE_PROXY_METHOD_REQ_FormatDescription,
            DRM_NO_OF(s_XB_DRM_TEE_PROXY_METHOD_REQ_FormatDescription),
            &dwVersionFound,
            &cbReq,
            pReq );

        if( DRM_FAILED( dr ) )
        {
            if( dr == DRM_E_OUTOFMEMORY )
            {
                cbStack <<= 1;
                if( cbStack > cbMaxStack )
                {
                    ChkDR( DRM_E_OUTOFMEMORY );
                }
            }

            /* needs to zero out as pReq is inout */
            ChkVOID( OEM_TEE_ZERO_MEMORY( pReq, sizeof( *pReq ) ) );
        }

    } while( dr == DRM_E_OUTOFMEMORY );

    if( DRM_FAILED( dr ) )
    {
        /*
        ** If serialization failed see if we tried to deserialize a structured serialization
        ** message.  If so, then return DRM_E_NOTIMPL rather than the XBinary error code.
        */
        if( f_cbRequestMessage >= sizeof(DRM_DWORD) )
        {
            static const DRM_BYTE rgbMarker[4] PR_ATTR_DATA_OVLY(_rgbMarker) = { ( DRM_BYTE )'P', ( DRM_BYTE )'R', ( DRM_BYTE )'X', ( DRM_BYTE )'Y' };

            if( *( const DRM_DWORD * )f_pbRequestMessage == *( const DRM_DWORD * )rgbMarker )
            {
                ChkDR( DRM_E_NOTIMPL );
            }
        }

        ChkDR( dr );
    }

    ChkBOOL( dwVersionFound == DRM_TEE_PROXY_LWRRENT_VERSION, DRM_E_XB_ILWALID_OBJECT );
    ChkBOOL( pReq->fValid && pReq->MethodInfo.fValid, DRM_E_XB_ILWALID_OBJECT );

#if DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE
    g_dwLwrrentTeeFunctionID = pReq->MethodInfo.dwMethodID;
#endif /* DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE */

    /* If we are not using the stack, we should free it to lower the peak heap usage for memory constrained devices. */
    if( stack.nStackTop == 0 )
    {
        ChkVOID( DRM_TEE_IMPL_BASE_MemFree( NULL, ( DRM_VOID ** )&pbStack ) );
        cbStack = 0;
        ChkVOID( OEM_SELWRE_ZERO_MEMORY( &stack, sizeof(stack) ) );
    }

    if( DRM_TEE_STUB_DOES_METHOD_USE_TEECTX( *pReq ) )
    {
#ifdef SINGLE_METHOD_ID_REPLAY
        /*
        ** LWE (nkuo) - when doing single methodID replay on falconsim, since global data can't
        ** be kept accross methodIDs, thus all the cached context ID will gone after AllocTeeCtx
        ** is done, so here we need to override the input ID to the cache to pretend the cache
        ** has been initialized and then the test can continue.
        */

        /* Never use jump macros while holding the critical section. */
        ChkDR(OEM_TEE_BASE_CRITSEC_Enter());
        g_fInitialized = 1;
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 0) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x30);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 1) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x31);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 2) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x32);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 3) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x33);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 4) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x34);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 5) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x35);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 6) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x36);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 7) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x37);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 8) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x38);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 9) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x39);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 10) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3a);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 11) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3b);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 12) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3c);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 13) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3d);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 14) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3e);
        *(((DRM_BYTE*)&g_rgoCache[0].idSession) + 15) = *(((DRM_BYTE*)f_pbRequestMessage) + 0x3f);
        ChkDR(OEM_TEE_BASE_CRITSEC_Leave());

        _InitializeTKeys();
#endif
        ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, sizeof(*pTeeCtx), ( DRM_VOID ** )&pTeeCtx ) );
        ChkVOID( OEM_TEE_ZERO_MEMORY( pTeeCtx, sizeof(*pTeeCtx) ) );

        ChkDR( DRM_TEE_STUB_XB_TEECtxFromXBTEECtx( &pReq->MethodContext, pTeeCtx ) );

        ChkDR( DRM_TEE_IMPL_CACHE_ReferenceContext( pTeeCtx ) );
    }

    ChkDR( DRM_TEE_STUB_ReadParameters( pTeeCtx, pReq, rgParameters ) );

    switch( pReq->MethodInfo.dwMethodID )
    {
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_AES128CBC_DecryptContentMultiple ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[8].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[8].uParameterValue.blobValue ) );
            ChkArg( rgParameters[9].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[9].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_AES128CBC_DecryptContentMultiple(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_QWORDLIST  *)&rgParameters[3].uParameterValue.qwlValue,
               (const DRM_TEE_QWORDLIST  *)&rgParameters[4].uParameterValue.qwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[5].uParameterValue.dwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[6].uParameterValue.dwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[7].uParameterValue.dwlValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[8].uParameterValue.blobValue,
               &rgParameters[9].uParameterValue.blobValue );

            rgParameters[9].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[9].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_AES128CTR_DecryptContent ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[6].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_AES128CTR_DecryptContent(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[3].uParameterValue.dwlValue,
               rgParameters[4].uParameterValue.qwValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[5].uParameterValue.blobValue,
               &rgParameters[6].uParameterValue.blobValue );

            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[6].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_AES128CTR_DecryptAudioContentMultiple ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[6].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_AES128CTR_DecryptAudioContentMultiple(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_QWORDLIST  *)&rgParameters[3].uParameterValue.qwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[4].uParameterValue.dwlValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[5].uParameterValue.blobValue,
               &rgParameters[6].uParameterValue.blobValue );

            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[6].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_AES128CTR_DecryptContentMultiple ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_QWORDLIST );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[8].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[8].uParameterValue.blobValue ) );
            ChkArg( rgParameters[9].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[9].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_AES128CTR_DecryptContentMultiple(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_QWORDLIST  *)&rgParameters[3].uParameterValue.qwlValue,
               (const DRM_TEE_QWORDLIST  *)&rgParameters[4].uParameterValue.qwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[5].uParameterValue.dwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[6].uParameterValue.dwlValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[7].uParameterValue.dwlValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[8].uParameterValue.blobValue,
               &rgParameters[9].uParameterValue.blobValue );

            rgParameters[9].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[9].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_SignDataWithSelwreStoreKey ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_BASE_SignDataWithSelwreStoreKey(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_CheckDeviceKeys ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_BASE_CheckDeviceKeys(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue );

            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_AllocTEEContext ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[2].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_BASE_AllocTEEContext(
                &pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               &rgParameters[2].uParameterValue.blobValue );

            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_FreeTEEContext ):
            ChkVOID( DRM_TEE_BASE_FreeTEEContext( &pTeeCtx ) );

            /* pTeeCtx is released in the call to _DRM_TEE_STUB_BASE_FreeTEEContext() */
            pTeeCtx = NULL;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_GetDebugInformation ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[2].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_BASE_GetDebugInformation(
                pTeeCtx,
               &rgParameters[1].uParameterValue.dwValue,
               &rgParameters[2].uParameterValue.blobValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[1].fIsOutputParameter = TRUE;
            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_GenerateNonce ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );

            drTEEResult = DRM_TEE_BASE_GenerateNonce(
                pTeeCtx,
               &rgParameters[1].uParameterValue.blobValue,
               &rgParameters[2].uParameterValue.idValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[1].fIsOutputParameter = TRUE;
            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_GetSystemTime ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );

            drTEEResult = DRM_TEE_BASE_GetSystemTime(
                pTeeCtx,
               &rgParameters[1].uParameterValue.qwValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD;
            rgParameters[1].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_GetFeatureInformation ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[2].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_BASE_GetFeatureInformation(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               &rgParameters[2].uParameterValue.blobValue );

            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_DECRYPT_PrepareToDecrypt ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[7].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_DECRYPT_PrepareToDecrypt(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[4].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[5].uParameterValue.blobValue,
               &rgParameters[6].uParameterValue.dwValue,
               &rgParameters[7].uParameterValue.blobValue );

            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[6].fIsOutputParameter = TRUE;
            rgParameters[7].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[7].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_DECRYPT_PreparePolicyInfo ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_DECRYPT_PreparePolicyInfo(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               rgParameters[2].uParameterValue.dwValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_DECRYPT_CreateOEMBlobFromCDKB ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_DECRYPT_CreateOEMBlobFromCDKB(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_DOM_PackageKeys ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[6].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_DOM_PackageKeys(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               rgParameters[2].uParameterValue.dwValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[4].uParameterValue.blobValue,
               &rgParameters[5].uParameterValue.dwlValue,
               &rgParameters[6].uParameterValue.blobValue );

            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST;
            rgParameters[5].fIsOutputParameter = TRUE;
            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[6].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_H264_PreProcessEncryptedData ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[7].uParameterValue.blobValue ) );
            ChkArg( rgParameters[8].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[8].uParameterValue.blobValue ) );
            ChkArg( rgParameters[9].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[9].uParameterValue.blobValue ) );
            ChkArg( rgParameters[10].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[10].uParameterValue.blobValue ) );
            ChkArg( rgParameters[11].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[11].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_H264_PreProcessEncryptedData(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.qwValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[4].uParameterValue.dwlValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[5].uParameterValue.blobValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[6].uParameterValue.dwlValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[7].uParameterValue.blobValue,
               &rgParameters[8].uParameterValue.blobValue,
               &rgParameters[9].uParameterValue.blobValue,
               &rgParameters[10].uParameterValue.blobValue,
               &rgParameters[11].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD;
            rgParameters[3].fIsOutputParameter = TRUE;
            rgParameters[8].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[8].fIsOutputParameter = TRUE;
            rgParameters[9].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[9].fIsOutputParameter = TRUE;
            rgParameters[10].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[10].fIsOutputParameter = TRUE;
            rgParameters[11].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[11].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_LICGEN_CompleteLicense ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[6].uParameterValue.blobValue ) );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[7].uParameterValue.blobValue ) );
            ChkArg( rgParameters[8].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[8].uParameterValue.blobValue ) );
            ChkArg( rgParameters[9].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[9].uParameterValue.blobValue ) );
            ChkArg( rgParameters[10].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[10].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_LICGEN_CompleteLicense(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (DRM_TEE_LICGEN_OP)rgParameters[2].uParameterValue.dwValue,
               rgParameters[3].uParameterValue.dwValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[4].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[5].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[6].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[7].uParameterValue.blobValue,
               &rgParameters[8].uParameterValue.blobValue,
               &rgParameters[9].uParameterValue.blobValue,
               &rgParameters[10].uParameterValue.blobValue );

            rgParameters[8].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[8].fIsOutputParameter = TRUE;
            rgParameters[9].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[9].fIsOutputParameter = TRUE;
            rgParameters[10].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[10].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_LICGEN_AES128CTR_EncryptContent ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_DWORDLIST );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_LICGEN_AES128CTR_EncryptContent(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_DWORDLIST  *)&rgParameters[3].uParameterValue.dwlValue,
               &rgParameters[4].uParameterValue.qwValue,
               &rgParameters[5].uParameterValue.blobValue );

            rgParameters[4].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_QWORD;
            rgParameters[4].fIsOutputParameter = TRUE;
            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_LICPREP_PackageKey ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_LICPREP_PackageKey(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[4].uParameterValue.blobValue,
               &rgParameters[5].uParameterValue.blobValue );

            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_LPROV_GenerateDeviceKeys ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[6].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_LPROV_GenerateDeviceKeys(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               (const DRM_ID  *)&rgParameters[4].uParameterValue.idValue,
               &rgParameters[5].uParameterValue.blobValue,
               &rgParameters[6].uParameterValue.blobValue );

            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[6].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SIGN_SignHash ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_SIGN_SignHash(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_RPROV_GenerateBootstrapChallenge ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_RPROV_GenerateBootstrapChallenge(
                pTeeCtx,
               &rgParameters[1].uParameterValue.blobValue,
               &rgParameters[2].uParameterValue.dwValue,
               &rgParameters[3].uParameterValue.dwValue,
               &rgParameters[4].uParameterValue.dwValue,
               &rgParameters[5].uParameterValue.blobValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[1].fIsOutputParameter = TRUE;
            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[2].fIsOutputParameter = TRUE;
            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[3].fIsOutputParameter = TRUE;
            rgParameters[4].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[4].fIsOutputParameter = TRUE;
            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_RPROV_ProcessBootstrapResponse ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_RPROV_ProcessBootstrapResponse(
                pTeeCtx,
               &rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[1].fIsOutputParameter = TRUE;
            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_RPROV_GenerateProvisioningRequest ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_RPROV_GenerateProvisioningRequest(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_ID  *)&rgParameters[2].uParameterValue.idValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_RPROV_ProcessProvisioningResponse ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_RPROV_ProcessProvisioningResponse(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               &rgParameters[4].uParameterValue.blobValue,
               &rgParameters[5].uParameterValue.blobValue );

            rgParameters[4].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[4].fIsOutputParameter = TRUE;
            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SAMPLEPROT_PrepareSampleProtectionKey ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[4].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_SAMPLEPROT_PrepareSampleProtectionKey(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue,
               &rgParameters[4].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            rgParameters[4].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[4].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SELWRESTOP_GetGenerationID ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );

            drTEEResult = DRM_TEE_SELWRESTOP_GetGenerationID(
                pTeeCtx,
               (const DRM_ID  *)&rgParameters[1].uParameterValue.idValue,
               &rgParameters[2].uParameterValue.dwValue );

            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_DWORD;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
#endif
#if defined (SEC_COMPILE)
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_REVOCATION_IngestRevocationInfo ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[3].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_REVOCATION_IngestRevocationInfo(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               &rgParameters[3].uParameterValue.blobValue );

            rgParameters[3].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[3].fIsOutputParameter = TRUE;
            break;
#endif
#ifdef NONE
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SELWRETIME_GenerateChallengeData ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[1].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_SELWRETIME_GenerateChallengeData(
                pTeeCtx,
               &rgParameters[1].uParameterValue.blobValue );

            rgParameters[1].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[1].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SELWRETIME_ProcessResponseData ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobConsistent( &rgParameters[4].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_SELWRETIME_ProcessResponseData(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[4].uParameterValue.blobValue );

            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SELWRESTOP2_GetSigningKeyBlob ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[2].uParameterValue.blobValue ) );

            drTEEResult = DRM_TEE_SELWRESTOP2_GetSigningKeyBlob(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               &rgParameters[2].uParameterValue.blobValue );

            rgParameters[2].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[2].fIsOutputParameter = TRUE;
            break;
        case DRM_TEE_PROXY_METHOD_ID( DRM_TEE_SELWRESTOP2_SignChallenge ):
            ChkArg( rgParameters[1].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[1].uParameterValue.blobValue ) );
            ChkArg( rgParameters[2].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[2].uParameterValue.blobValue ) );
            ChkArg( rgParameters[3].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB && IsBlobAssigned( &rgParameters[3].uParameterValue.blobValue ) );
            ChkArg( rgParameters[4].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[4].uParameterValue.blobValue ) );
            ChkArg( rgParameters[5].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID && IsBlobEmpty( &rgParameters[5].uParameterValue.blobValue ) );
            ChkArg( rgParameters[6].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );
            ChkArg( rgParameters[7].eParameterType == DRM_TEE_PROXY_PARAMETER_TYPE__ILWALID );

            drTEEResult = DRM_TEE_SELWRESTOP2_SignChallenge(
                pTeeCtx,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[1].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[2].uParameterValue.blobValue,
               (const DRM_TEE_BYTE_BLOB  *)&rgParameters[3].uParameterValue.blobValue,
               &rgParameters[4].uParameterValue.blobValue,
               &rgParameters[5].uParameterValue.blobValue,
               &rgParameters[6].uParameterValue.idValue,
               &rgParameters[7].uParameterValue.idValue );

            rgParameters[4].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[4].fIsOutputParameter = TRUE;
            rgParameters[5].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_TEE_BYTE_BLOB;
            rgParameters[5].fIsOutputParameter = TRUE;
            rgParameters[6].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID;
            rgParameters[6].fIsOutputParameter = TRUE;
            rgParameters[7].eParameterType     = DRM_TEE_PROXY_PARAMETER_TYPE__DRM_ID;
            rgParameters[7].fIsOutputParameter = TRUE;
            break;

        default:
            drTEEResult = DRM_E_NOTIMPL;
            break;
#endif
    }

    if( pReq->MethodInfo.dwMethodID != DRM_TEE_PROXY_METHOD_ID( DRM_TEE_BASE_FreeTEEContext ) )
    {
        DRM_RESULT dr2       = DRM_SUCCESS;
        DRM_DWORD  cbRespMsg = 0;

        ChkArg( f_pcbResponseMessage != NULL );
        ChkArg( f_pbResponseMessage  != NULL );

        ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, sizeof( *pResp ), ( DRM_VOID ** )&pResp ) );
        ChkVOID( OEM_TEE_ZERO_MEMORY( pResp, sizeof( *pResp ) ) );

        /* Response XB stack cannot be larger than the output buffer + overhead. */
        cbRespMsg = *f_pcbResponseMessage;
        ChkDR( DRM_DWordAdd( *f_pcbResponseMessage, DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD, &cbMaxStack ) );

        do
        {
            if( dr2 == DRM_E_OUTOFMEMORY || cbStack < DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD )
            {
                cbStack = cbStack < DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD ? DRM_TEE_PROXY_MESSAGE_RESPONSE_OVERHEAD : cbStack << 1;
                ChkBOOL( cbStack <= cbMaxStack, DRM_E_OUTOFMEMORY );
                ChkVOID( DRM_TEE_IMPL_BASE_MemFree( NULL, ( DRM_VOID ** )&pbStack ) );
                ChkDR( DRM_TEE_IMPL_BASE_MemAlloc( NULL, cbStack, ( DRM_VOID ** )&pbStack ) );
                ChkDR( DRM_STK_Init( &stack, pbStack, cbStack, TRUE ) );

                if( DRM_FAILED( dr2 ) )
                {
                    ChkVOID( OEM_SELWRE_ZERO_MEMORY( pResp, sizeof( *pResp ) ) );
                    ChkVOID( OEM_SELWRE_ZERO_MEMORY( f_pbResponseMessage, cbRespMsg ) );
                    *f_pcbResponseMessage = cbRespMsg;
                }
            }

            dr2 = DRM_TEE_STUB_GenerateOutput(
                pTeeCtx,
                rgParameters,
                drTEEResult,
                cbStack,
                pbStack,
                pReq,
                pResp,
                f_pcbResponseMessage,
                f_pbResponseMessage );

        } while( dr2 == DRM_E_OUTOFMEMORY );
        ChkDR( dr2 );
    }

ErrorExit:
    if( rgParameters != NULL )
    {
        //
        // LWE (kwilson) - Can't use ChkDR within ErrorExit. Cache the return value in drTmp and check value
        // of dr, before overwriting to be sure we are not overwriting a previous failure with success.
        //
        drTmp = DRM_TEE_STUB_FreeParameters(pTeeCtx, rgParameters);
        if (dr == DRM_SUCCESS)
        {
            dr = drTmp;
        }
        ChkVOID(DRM_TEE_IMPL_BASE_MemFree(pTeeCtx, (DRM_VOID **)&rgParameters));
    }

    if( pResp != NULL )
    {
        if( pResp->MethodContext.xbbaContext.pbDataBuffer != NULL )
        {
            ChkVOID( DRM_TEE_IMPL_BASE_MemFree( pTeeCtx, ( DRM_VOID ** )&pResp->MethodContext.xbbaContext.pbDataBuffer ) );
        }
        ChkVOID( DRM_TEE_IMPL_BASE_MemFree( pTeeCtx, ( DRM_VOID ** )&pResp ) );
    }

    ChkVOID( DRM_TEE_IMPL_BASE_MemFree( pTeeCtx, ( DRM_VOID ** )&pbStack ) );
    ChkVOID( DRM_TEE_IMPL_BASE_MemFree( pTeeCtx, ( DRM_VOID ** )&pReq ) );

    if( pTeeCtx != NULL )
    {
        /*
        ** Allocated during DRM_TEE_STUB_XB_TEECtxFromXBTEECtx OR during
        ** OEM_TEE_BASE_AllocTEEContext.  Either way, we don't need this memory any more because:
        ** 1. we got an error during this API call (and we need to avoid leaking this memory)
        ** OR 2. it's no longer required (DRM_TEE_BASE_FreeTEEContext case)
        ** OR 3. we've deserialized it back for the caller (non-DRM_TEE_BASE_FreeTEEContext cases).
        ** We MUST pass NULL for the first param because we're destroying any data in the OEM_TEE_CONTEXT.
        */
        ChkVOID( OEM_TEE_BASE_SelwreMemFree( NULL, (DRM_VOID**)&pTeeCtx->oContext.pbUnprotectedOEMData ) );

        /*
        ** In AllocTEEContext case, this was allocated during DRM_TEE_BASE_AllocTEEContext.
        ** For other cases, this was allocated inside this function.
        ** Either way, we need to free it to avoid leaking memory.
        ** We MUST pass NULL for the first param because we just destroyed any data in the OEM_TEE_CONTEXT.
        */
        ChkVOID( OEM_TEE_BASE_SelwreMemFree( NULL, (DRM_VOID**)&pTeeCtx ) );
    }

#if DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE
    g_dwLwrrentTeeFunctionID = ( DRM_DWORD )DRM_METHOD_ID_DRM_TEE_Count + 1; /* Invalid function ID value */
#endif /* DRM_PC_TEST_CAPTURE_TEE_HEAP_USAGE */

    return dr;
}
PREFAST_POP /* __WARNING_UNINITIALIZED_MEMORY_6001 */



EXIT_PK_NAMESPACE_CODE;

