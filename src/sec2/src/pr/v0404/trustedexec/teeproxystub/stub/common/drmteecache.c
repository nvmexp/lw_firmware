/**@@@+++@@@@******************************************************************
**
** Microsoft (r) PlayReady (r)
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <oemtee.h>
#include <oemteetypes.h>
#include <drmtee.h>
#include <drmhashcache.h>
#include <drmteecache.h>
#include <drmresults.h>
#include <drmteeselwrestop2internal.h>
#include <drmlastinclude.h>

ENTER_PK_NAMESPACE_CODE;
#if defined (SEC_COMPILE)

#define DRM_TEE_CACHED_VERIFIED_HASHES_COUNT     20
static DRM_CACHED_VERIFIED_HASH g_rgoCachedVerifiedHashBuffer[DRM_TEE_CACHED_VERIFIED_HASHES_COUNT] PR_ATTR_DATA_OVLY(_g_rgoCachedVerifiedHashBuffer) = { { 0 } };
static DRM_HASHCACHE_CONTEXT    g_oCachedVerifiedHashContext                                        PR_ATTR_DATA_OVLY(_g_oCachedVerifiedHashContext) GCC_ATTRIB_ALIGN(4) = { { 0 } };


// LWE (nkuo) - following variables need to be referenced in OEM_TEE_InitSharedDataStruct() so can't be declared as static
DRM_TEE_CACHE_ENTRY g_rgoCache[OEM_TEE_CACHE_MAX_ENTRIES] PR_SHARED_ATTR_DATA_OVLY(_g_rgoCache)     GCC_ATTRIB_ALIGN(64);

DRM_BYTE            g_iHead                               PR_SHARED_ATTR_DATA_OVLY(_g_iHead)        GCC_ATTRIB_ALIGN(4) = DRM_TEE_CACHE_HEAD_ENTRY;
DRM_BYTE            g_iTail                               PR_SHARED_ATTR_DATA_OVLY(_g_iTail)        GCC_ATTRIB_ALIGN(4) = DRM_TEE_CACHE_TAIL_ENTRY;
DRM_BYTE            g_iFree                               PR_SHARED_ATTR_DATA_OVLY(_g_iFree)        GCC_ATTRIB_ALIGN(4) = 0;
DRM_BYTE            g_cCache                              PR_SHARED_ATTR_DATA_OVLY(_g_cCache)       GCC_ATTRIB_ALIGN(4) = 0;
DRM_BYTE            g_fInitialized                        PR_SHARED_ATTR_DATA_OVLY(_g_fInitialized) GCC_ATTRIB_ALIGN(4) = TEE_CACHE_UNINITIALIZED;

/*
** These hashes are generated by Oem_Broker_ECDSA_P256_Verify.
*/
static DRM_GLOBAL_CONST DRM_BYTE s_rgbPreVerifiedHashes[][ OEM_SHA256_DIGEST_SIZE_IN_BYTES ]PR_ATTR_DATA_OVLY(_s_rgbPreVerifiedHashes) = {

    /*
    ** BCert dump output of pre-verified certificate that generates the following hash:
    **
    ** <PlayReady_Cert_Chain>
    **     <Format>v.1</Format>
    **     <Length>760</Length>
    **     <Number_of_Certs>1</Number_of_Certs>
    **
    **     <Certificate_1>
    **         <Version>1</Version>
    **         <Total_Length>760</Total_Length>
    **         <Signed_Length>616</Signed_Length>
    **         <Basic_Data>
    **             <Cert_Type>CRL Signer</Cert_Type>
    **             <Selwrity_Level>0</Selwrity_Level>
    **             <Expiration>Not set</Expiration>
    **             <Flags>0x0</Flags>
    **             <Certificate_Id>ftf+MVbZ6u80p0WbbgV/5g==</Certificate_Id>
    **             <Digest>lfhJiigDX1b2E4tPILkZNWI3Fak83vs6+hRWWI6gdMI=</Digest>
    **             <Client_Id>AAAAAAAAAAAAAAAAAAAAAA==</Client_Id>
    **             <Features>
    ** Empty
    **             </Features>
    **         </Basic_Data>
    **         <Key_Data>
    **             <KEY_0>
    **                 <Key_Type>0x1</Key_Type>
    **                 <Length>512 bit</Length>
    **                 <Key_Value>PzwJQbPiRcTwVTLxAECqSP0qyEQjaC2/Rf4qZf9O/zpgxCpxOGGjp7yJs+e5pPSqoouozuaJuo33sBtqecfckw==</Key_Value>
    **                 <Key_Usage>Sign CRL,</Key_Usage>
    **             </KEY_0>
    **         </Key_Data>
    **         <Manufacturer>
    **             <Manufacturer>Microsoft</Manufacturer>
    **             <Model_Name>PlayReady/SilverLight CRL Signer</Model_Name>
    **             <Model_Number>1.0.0.1</Model_Number>
    **         </Manufacturer>
    **         <Signature>
    **             <Signature_Type>0x1</Signature_Type>
    **             <Issuer_Key_Length>512</Issuer_Key_Length>
    **             <Issuer_Key_Value>t9g4RqwdfzOfBL5Ztu5HF38lNzehHjw9Palzo8p/d1+uR7VrJRZD6WWRRAf6Z12YMi/qirzgcJLHHDfMWu6ZAQ==</Issuer_Key_Value>
    **         </Signature>
    **
    **
    **     </Certificate_1>
    **
    ** </PlayReady_Cert_Chain>
    */
    {
        0x58, 0xcc, 0x81, 0x76, 0xf3, 0xe3, 0x4e, 0x72, 0xa7, 0x99, 0xc0, 0x06, 0x2a, 0xd4, 0x9b, 0xe0,
        0xe9, 0x56, 0xc1, 0x2a, 0xf3, 0x80, 0x56, 0x2f, 0x81, 0xb7, 0xc8, 0x2f, 0xb0, 0x97, 0x02, 0x0a,
    },

    /*
    ** BCert dump output of pre-verified certificate that generates the following hash:
    **
    ** <PlayReady_Cert_Chain>
    **     <Format>v.1</Format>
    **     <Length>764</Length>
    **     <Number_of_Certs>1</Number_of_Certs>
    **
    **     <Certificate_1>
    **         <Version>1</Version>
    **         <Total_Length>764</Total_Length>
    **         <Signed_Length>620</Signed_Length>
    **         <Basic_Data>
    **             <Cert_Type>Issuer</Cert_Type>
    **             <Selwrity_Level>0</Selwrity_Level>
    **             <Expiration>Not set</Expiration>
    **             <Flags>0x0</Flags>
    **             <Certificate_Id>DPJyKR7YVvSTfSDoct33ag==</Certificate_Id>
    **             <Digest>HyCsT4MXBFBLWK1jSSjlKQjKf/c2McyydNxKwu/1QaA=</Digest>
    **             <Client_Id>AAAAAAAAAAAAAAAAAAAAAA==</Client_Id>
    **             <Features>
    ** Empty
    **             </Features>
    **         </Basic_Data>
    **         <Key_Data>
    **             <KEY_0>
    **                 <Key_Type>0x1</Key_Type>
    **                 <Length>512 bit</Length>
    **                 <Key_Value>t9g4RqwdfzOfBL5Ztu5HF38lNzehHjw9Palzo8p/d1+uR7VrJRZD6WWRRAf6Z12YMi/qirzgcJLHHDfMWu6ZAQ==</Key_Value>
    **                 <Key_Usage>Sign,Issuer-Crl,</Key_Usage>
    **             </KEY_0>
    **         </Key_Data>
    **         <Manufacturer>
    **             <Manufacturer>Microsoft</Manufacturer>
    **             <Model_Name>PlayReady/SilverLight CRL Signer Root CA</Model_Name>
    **             <Model_Number>1.0.0.1</Model_Number>
    **         </Manufacturer>
    **         <Signature>
    **             <Signature_Type>0x1</Signature_Type>
    **             <Issuer_Key_Length>512</Issuer_Key_Length>
    **             <Issuer_Key_Value>hk1hz/IlbkIsVos8KAAc+z4VJ2WFhLoFIbebGCjZNt4dgmqPw+bn+nqQ1copRvH2Si77n13P/n5DTrRCk/rFqw==</Issuer_Key_Value>
    **         </Signature>
    **
    **
    **     </Certificate_1>
    **
    ** </PlayReady_Cert_Chain>
    */
    {
        0x7a, 0x3b, 0xa8, 0x06, 0xb5, 0xe2, 0x5d, 0xed, 0xfa, 0x5c, 0x7f, 0x89, 0x8c, 0xa5, 0x1f, 0xf8,
        0xa3, 0x3a, 0xf3, 0xf4, 0x7c, 0x53, 0xbd, 0xa0, 0x8e, 0xa0, 0x50, 0x02, 0x67, 0x4b, 0x3d, 0xd4,
    },

    /*
    ** BCert dump output of pre-verified certificate that generates the following hash:
    **
    **     <Certificate_1>
    **         <Version>1</Version>
    **         <Total_Length>432</Total_Length>
    **         <Signed_Length>288</Signed_Length>
    **         <Basic_Data>
    **             <Cert_Type>Application</Cert_Type>
    **             <Selwrity_Level>2000</Selwrity_Level>
    **             <Expiration>Not set</Expiration>
    **             <Flags>0x0</Flags>
    **             <Certificate_Id>A1AnhxOZHblG3Wq1JKL5Gg==</Certificate_Id>
    **             <Digest>ECqYeH3ZDs964wLFHXbWOF/i0DVKtI0N8XkDSSiXySI=</Digest>
    **             <Client_Id>AAAAAAAAAAAAAAAAAAAAAA==</Client_Id>
    **             <Features>
    ** Empty
    **             </Features>
    **         </Basic_Data>
    **         <Key_Data>
    **             <KEY_0>
    **                 <Key_Type>0x1</Key_Type>
    **                 <Length>512 bit</Length>
    **                 <Key_Value>WcP9ZMyhQ+fPOd/OFar6sVn1HMa9eqWEJnrS3RR2KZ3n8c9bP5ENgQA7+vO1nmuCFz2guDYhHkpfH1sZinnhMQ==</Key_Value>
    **                 <Key_Usage>EncryptKey-SampleProtectionAES128CTR,</Key_Usage>
    **             </KEY_0>
    **         </Key_Data>
    **         <Manufacturer>
    **             <Manufacturer>Microsoft</Manufacturer>
    **             <Model_Name>PlayReady Sample Protection cert</Model_Name>
    **             <Model_Number>70007</Model_Number>
    **         </Manufacturer>
    **         <Signature>
    **             <Signature_Type>0x1</Signature_Type>
    **             <Issuer_Key_Length>512</Issuer_Key_Length>
    **             <Issuer_Key_Value>ZovrucqmB6yNPqyYLhMoLMv/Mzh//EmrXfK4pDJBMUshOoJ422yGhvvyVKIJvlP02gIYuI1gGEcM+tjjmQmz8A==</Issuer_Key_Value>
    **         </Signature>
    **
    **
    **     </Certificate_1>
    */
    {
        0x42, 0x6E, 0x5A, 0xE6, 0xB9, 0x63, 0x44, 0xC6, 0x2A, 0x5C, 0x55, 0xD3, 0x1C, 0xCC, 0xF7, 0x5D,
        0x4D, 0x23, 0xFC, 0x91, 0xFC, 0xEC, 0x4D, 0x59, 0x4E, 0xA3, 0x54, 0xC5, 0x65, 0x40, 0x11, 0xD4,
    },

    /*
    ** BCert dump output of pre-verified certificate that generates the following hash:
    **
    **     <Certificate_2>
    **         <Version>1</Version>
    **         <Total_Length>764</Total_Length>
    **         <Signed_Length>620</Signed_Length>
    **         <Basic_Data>
    **             <Cert_Type>Issuer</Cert_Type>
    **             <Selwrity_Level>2000</Selwrity_Level>
    **             <Expiration>Not set</Expiration>
    **             <Flags>0x0</Flags>
    **             <Certificate_Id>50E2rQ/P3lYdO5BCC1q9SQ==</Certificate_Id>
    **             <Digest>xBwA/zZ2joQljKpV3GZUtfJMYpU4xXfFoSSOiuiXL/g=</Digest>
    **             <Client_Id>AAAAAAAAAAAAAAAAAAAAAA==</Client_Id>
    **             <Features>
    ** Empty
    **             </Features>
    **         </Basic_Data>
    **         <Key_Data>
    **             <KEY_0>
    **                 <Key_Type>0x1</Key_Type>
    **                 <Length>512 bit</Length>
    **                 <Key_Value>ZovrucqmB6yNPqyYLhMoLMv/Mzh//EmrXfK4pDJBMUshOoJ422yGhvvyVKIJvlP02gIYuI1gGEcM+tjjmQmz8A==</Key_Value>
    **                 <Key_Usage>Sign,Issuer-Application,</Key_Usage>
    **             </KEY_0>
    **         </Key_Data>
    **         <Manufacturer>
    **             <Manufacturer>Microsoft</Manufacturer>
    **             <Model_Name>PlayReady SL2000 Application Root CA</Model_Name>
    **             <Model_Number>1.0.0.1</Model_Number>
    **         </Manufacturer>
    **         <Signature>
    **             <Signature_Type>0x1</Signature_Type>
    **             <Issuer_Key_Length>512</Issuer_Key_Length>
    **             <Issuer_Key_Value>hk1hz/IlbkIsVos8KAAc+z4VJ2WFhLoFIbebGCjZNt4dgmqPw+bn+nqQ1copRvH2Si77n13P/n5DTrRCk/rFqw==</Issuer_Key_Value>
    **         </Signature>
    **
    **
    **     </Certificate_2>
    */
    {
        0xA1, 0x03, 0x47, 0xB8, 0x2B, 0x98, 0x3A, 0x6E, 0x90, 0x06, 0xE2, 0xCF, 0x8F, 0x67, 0xF1, 0x9C,
        0xCB, 0x7F, 0xE7, 0x87, 0x0E, 0x8D, 0x77, 0xA4, 0xE3, 0xF0, 0xEE, 0x5D, 0xC1, 0x4B, 0xF7, 0x09,
    },
};
#endif

#if DRM_DBG
#define ASSERTCACHE() _AssertCache()
#else /* DRM_DBG */
#define ASSERTCACHE()
#endif /* DRM_DBG */

#if DRM_DBG

static DRM_NO_INLINE DRM_VOID DRM_CALL _AssertCache( DRM_VOID );
static DRM_NO_INLINE DRM_VOID DRM_CALL _AssertCache( DRM_VOID )
{
    DRM_BYTE iEntry                             = 0;
    DRM_BYTE cFree                              = 0;
    DRM_BOOL fHead                              = FALSE;
    DRM_BOOL fTail                              = FALSE;
    DRM_BOOL rgfPrev[OEM_TEE_CACHE_MAX_ENTRIES] = {0};
    DRM_BOOL rgfNext[OEM_TEE_CACHE_MAX_ENTRIES] = {0};

    DRMASSERT( g_iHead < OEM_TEE_CACHE_MAX_ENTRIES || g_iHead == DRM_TEE_CACHE_HEAD_ENTRY );
    DRMASSERT( g_iTail < OEM_TEE_CACHE_MAX_ENTRIES || g_iTail == DRM_TEE_CACHE_TAIL_ENTRY );
    DRMASSERT( g_iFree < OEM_TEE_CACHE_MAX_ENTRIES || g_iFree == DRM_TEE_CACHE_FREE_ENTRY );
    DRMASSERT( g_cCache <= OEM_TEE_CACHE_MAX_ENTRIES );
    DRMASSERT( g_fInitialized == TEE_CACHE_INITIALIZED );

    if( g_iHead < OEM_TEE_CACHE_MAX_ENTRIES )
    {
        DRMASSERT( g_rgoCache[g_iHead].iPrev == DRM_TEE_CACHE_HEAD_ENTRY );
    }

    if( g_iTail < OEM_TEE_CACHE_MAX_ENTRIES )
    {
        DRMASSERT( g_rgoCache[g_iTail].iNext == DRM_TEE_CACHE_TAIL_ENTRY );
    }

    /* Make sure we don't have any duplicate entries */
    for( iEntry = 0; iEntry < OEM_TEE_CACHE_MAX_ENTRIES; iEntry++ )
    {
        if( g_rgoCache[iEntry].iPrev == DRM_TEE_CACHE_HEAD_ENTRY )
        {
            DRMASSERT( !fHead );
            fHead = TRUE;
        }
        else if( g_rgoCache[iEntry].iPrev == DRM_TEE_CACHE_FREE_ENTRY )
        {
            DRMASSERT( cFree < 2 );
            cFree++;
        }
        else
        {
            DRMASSERT( !rgfPrev[g_rgoCache[iEntry].iPrev] );
            rgfPrev[g_rgoCache[iEntry].iPrev] = TRUE;
        }

        if( g_rgoCache[iEntry].iNext == DRM_TEE_CACHE_TAIL_ENTRY )
        {
            DRMASSERT( !fTail );
            fTail = TRUE;
        }
        else if( g_rgoCache[iEntry].iNext == DRM_TEE_CACHE_FREE_ENTRY )
        {
            DRMASSERT( cFree < 2 );
            cFree++;
        }
        else
        {
            DRMASSERT( !rgfNext[g_rgoCache[iEntry].iNext] );
            rgfNext[g_rgoCache[iEntry].iNext] = TRUE;
        }
    }
}

#endif /* DRM_DBG */

#if defined(SEC_COMPILE)
static DRM_FRE_INLINE DRM_VOID DRM_CALL _RemoveEntry(
    __in                  DRM_BYTE                     f_iEntry );
static DRM_FRE_INLINE DRM_VOID DRM_CALL _RemoveEntry(
    __in                  DRM_BYTE                     f_iEntry )
{
    DRMASSERT( f_iEntry < OEM_TEE_CACHE_MAX_ENTRIES );

    if( g_cCache == 1 )
    {
        /* Remove the only entry */
        g_iHead = DRM_TEE_CACHE_HEAD_ENTRY;
        g_iTail = DRM_TEE_CACHE_TAIL_ENTRY;
    }
    else
    {
        if( g_rgoCache[f_iEntry].iPrev == DRM_TEE_CACHE_HEAD_ENTRY )
        {
            /* Set the cache head index */
            g_iHead = g_rgoCache[f_iEntry].iNext;
        }
        else
        {
            /* Fix the next index for the previous entry */
            g_rgoCache[g_rgoCache[f_iEntry].iPrev].iNext = g_rgoCache[f_iEntry].iNext;
        }

        if( g_rgoCache[f_iEntry].iNext == DRM_TEE_CACHE_TAIL_ENTRY )
        {
            /* Set the cache tail index */
            g_iTail = g_rgoCache[f_iEntry].iPrev;
        }
        else
        {
            /* Fix the prev index for the next entry */
            g_rgoCache[g_rgoCache[f_iEntry].iNext].iPrev = g_rgoCache[f_iEntry].iPrev;
        }

        /* Point the old entry to itself until we know where it goes */
        g_rgoCache[f_iEntry].iPrev = f_iEntry;
        g_rgoCache[f_iEntry].iNext = f_iEntry;
    }

    /* Track how many entries are in the cache */
    g_cCache--;     /* Can't underflow: static function and callers ensure its state */

    ASSERTCACHE();
}

static DRM_FRE_INLINE DRM_VOID DRM_CALL _FreeEntry(
    __in                  DRM_BYTE                     f_iEntry );
static DRM_FRE_INLINE DRM_VOID DRM_CALL _FreeEntry(
    __in                  DRM_BYTE                     f_iEntry )
{
    DRMASSERT( f_iEntry < OEM_TEE_CACHE_MAX_ENTRIES );

    /* Fix the prev index for the new free entry */
    g_rgoCache[f_iEntry].iPrev = DRM_TEE_CACHE_FREE_ENTRY;

    /* Fix the next index for the new free entry */
    g_rgoCache[f_iEntry].iNext = g_iFree;

    /* Fix the prev index for the old free entry */
    if( g_iFree != DRM_TEE_CACHE_FREE_ENTRY )
    {
        g_rgoCache[g_iFree].iPrev = f_iEntry;
    }

    /* Save the new free entry index */
    g_iFree = f_iEntry;

    ASSERTCACHE();
}

static DRM_FRE_INLINE DRM_VOID DRM_CALL _GetEntry(
    __out                 DRM_BYTE                    *f_piEntry );
static DRM_FRE_INLINE DRM_VOID DRM_CALL _GetEntry(
    __out                 DRM_BYTE                    *f_piEntry )
{
    DRM_BYTE iEntry = 0;

    DRMASSERT( f_piEntry != NULL );

    /* Check if we have to evict the least recently used entry */
    if( g_cCache >= OEM_TEE_CACHE_MAX_ENTRIES )
    {
        iEntry = g_iTail;

        ChkVOID( _RemoveEntry( iEntry ) );
        ChkVOID( _FreeEntry( iEntry ) );
    }

    /* Get the free entry index */
    *f_piEntry = g_iFree;

    if( g_cCache + 1 >= OEM_TEE_CACHE_MAX_ENTRIES )
    {
        /* We have no more free entries */
        g_iFree = DRM_TEE_CACHE_FREE_ENTRY;
    }
    else
    {
        /* Point the old free entry to itself until we know where it goes */
        g_rgoCache[g_iFree].iPrev = g_iFree;

        /* Update the free entry index */
        g_iFree = g_rgoCache[g_iFree].iNext;

        /* Fix the prev index for the new free entry */
        g_rgoCache[g_iFree].iPrev = DRM_TEE_CACHE_FREE_ENTRY;
    }

    ASSERTCACHE();
}

static DRM_FRE_INLINE DRM_VOID DRM_CALL _AddEntry(
    __in                  DRM_BYTE                     f_iEntry );
static DRM_FRE_INLINE DRM_VOID DRM_CALL _AddEntry(
    __in                  DRM_BYTE                     f_iEntry )
{
    DRMASSERT( f_iEntry < OEM_TEE_CACHE_MAX_ENTRIES );

    if( g_iHead == DRM_TEE_CACHE_HEAD_ENTRY )
    {
        /* Set the tail marker if this is the only entry */
        g_rgoCache[f_iEntry].iNext = DRM_TEE_CACHE_TAIL_ENTRY;
    }
    else
    {
        /* Add the new entry to the head of the cache */
        g_rgoCache[g_iHead].iPrev = f_iEntry;

        /* Fix the next index for the new entry */
        g_rgoCache[f_iEntry].iNext = g_iHead;
    }

    /* Set the head marker for the new entry */
    g_rgoCache[f_iEntry].iPrev = DRM_TEE_CACHE_HEAD_ENTRY;

    /* Save the new head entry index */
    g_iHead = f_iEntry;

    /* Save the new tail entry index if empty */
    if( g_iTail == DRM_TEE_CACHE_TAIL_ENTRY )
    {
        g_iTail = g_iHead;
    }

    /* Track how many entries are in the cache */
    g_cCache++;

    ASSERTCACHE();
}

static DRM_FRE_INLINE DRM_RESULT DRM_CALL _FindEntry(
    __in            const DRM_TEE_CONTEXT              *f_pContext,
    __out                 DRM_BYTE                     *f_piEntry );
static DRM_FRE_INLINE DRM_RESULT DRM_CALL _FindEntry(
    __in            const DRM_TEE_CONTEXT              *f_pContext,
    __out                 DRM_BYTE                     *f_piEntry )
{
    /*
    ** Intentionally do NOT declare DRM_RESULT dr here.
    ** Using macros which might call tracing code is unsafe here because
    ** this function is called while holding the global TEE critical section.
    */
    DRMASSERT( f_pContext != NULL );
    DRMASSERT( f_piEntry != NULL );

    /* Find entry in cache */
    for( *f_piEntry = g_iHead; *f_piEntry != DRM_TEE_CACHE_TAIL_ENTRY; *f_piEntry = g_rgoCache[ *f_piEntry ].iNext )
    {
        if( OEM_SELWRE_ARE_EQUAL( &f_pContext->idSession, &g_rgoCache[ *f_piEntry ].idSession, sizeof( g_rgoCache[ *f_piEntry ].idSession ) ) )
        {
            break;
        }
    }

    ASSERTCACHE();

    if( *f_piEntry == DRM_TEE_CACHE_TAIL_ENTRY )
    {
        return DRM_E_TEE_ILWALID_HWDRM_STATE;
    }
    return DRM_SUCCESS;
}

/*
** Synopsis:
**
** This function initializes the cache used to maintain the set of valid
** DRM_TEE_CONTEXT sessions.
**
** Operations Performed:
**
**  1. Build the initial cache layout.
**  2. Set the initial cache parameter values.
**
** Arguments:
**  None
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_Initialize( DRM_VOID )
{
    DRM_RESULT drRet   = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave = DRM_SUCCESS;
    DRM_BYTE   iEntry  = 0;

    DRMCASSERT( OEM_TEE_CACHE_MAX_ENTRIES <= ( DRM_MAX_UNSIGNED_TYPE( DRM_BYTE ) - 3 /* head, tail and free entries */ ) )

    {
        /* Never use jump macros while holding the critical section. */
        if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
        {
            if( g_fInitialized == TEE_CACHE_UNINITIALIZED )
            {
                ChkVOID( OEM_TEE_ZERO_MEMORY( g_rgoCache, sizeof( g_rgoCache ) ) );

                for( iEntry = 0; iEntry < OEM_TEE_CACHE_MAX_ENTRIES; iEntry++ )
                {
                    g_rgoCache[ iEntry ].iPrev = iEntry > 0 ? (DRM_BYTE)( iEntry - 1 ) : DRM_TEE_CACHE_FREE_ENTRY;
                    g_rgoCache[ iEntry ].iNext = iEntry < (DRM_BYTE)( OEM_TEE_CACHE_MAX_ENTRIES - 1 ) ? (DRM_BYTE)( iEntry + 1 ) : DRM_TEE_CACHE_FREE_ENTRY;
                }

                if( DRM_SUCCEEDED( drRet = DRM_HASHCACHE_Initialize(
                    DRM_NO_OF( s_rgbPreVerifiedHashes ),
                    (const OEM_SHA256_DIGEST *)s_rgbPreVerifiedHashes,
                    DRM_NO_OF( g_rgoCachedVerifiedHashBuffer ),
                    g_rgoCachedVerifiedHashBuffer,
                    &g_oCachedVerifiedHashContext ) ) )
                {
                    ChkVOID( DRM_TEE_IMPL_SELWRESTOP2_InitializeNotThreadSafe() );
                    g_fInitialized = TEE_CACHE_INITIALIZED;
                }
            }

            drLeave = OEM_TEE_BASE_CRITSEC_Leave();
        }
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}

/*
** Synopsis:
**
** This function adds a DRM_TEE_CONTEXT session to the cache of valid
** sessions.
**
** Operations Performed:
**
**  1. Find an empty cache slot.
**  2. Evict the least recently used session if necessary.
**  3. Add session to the empty cache slot.
**
** Arguments:
**
** f_pContext:          (in) The TEE context returned from
**                           DRM_TEE_BASE_AllocTEEContext.
*/
static DRM_GLOBAL_CONST DRM_ID s_idZero PR_ATTR_DATA_OVLY(_s_idZero) = DRM_ID_EMPTY;
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_AddContext(
    __in            const DRM_TEE_CONTEXT              *f_pContext )
{
    DRM_RESULT drRet    = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave  = DRM_SUCCESS;
    DRM_BYTE   iEntry   = 0;

    DRMASSERT( f_pContext != NULL );

    {
        /* Never use jump macros while holding the critical section. */
        if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
        {
            if( g_fInitialized != TEE_CACHE_INITIALIZED
             || OEM_SELWRE_ARE_EQUAL( &f_pContext->idSession, &s_idZero, sizeof( s_idZero ) ) )
            {
                drRet = DRM_E_TEE_ILWALID_HWDRM_STATE;
            }
            else
            {
                ChkVOID( _GetEntry( &iEntry ) );
                ChkVOID( _AddEntry( iEntry ) );

                /* Save the session ID to the new entry */
                g_rgoCache[ iEntry ].idSession = f_pContext->idSession;
            }

            drLeave = OEM_TEE_BASE_CRITSEC_Leave();
        }
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}

/*
** Synopsis:
**
** This function updates a DRM_TEE_CONTEXT session to be the most
** recently used session in the cache of valid sessions.
**
** Operations Performed:
**
**  1. Find the session to reference.
**  2. Remove the session from the middle of the cache.
**  3. Add the session to the head of the cache.
**
** Arguments:
**
** f_pContext:            (in) The TEE context returned from
**                             DRM_TEE_BASE_AllocTEEContext.
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_ReferenceContext(
    __in            const DRM_TEE_CONTEXT              *f_pContext )
{
    DRM_RESULT drRet    = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave  = DRM_SUCCESS;
    DRM_BYTE   iEntry   = 0;

    DRMASSERT( f_pContext != NULL );

    {
        /* Never use jump macros while holding the critical section. */
        if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
        {
            if( g_fInitialized != TEE_CACHE_INITIALIZED )
            {
                drRet = DRM_E_TEE_ILWALID_HWDRM_STATE;
            }
            else
            {
                drRet = _FindEntry( f_pContext, &iEntry );
                if( DRM_SUCCEEDED( drRet ) )
                {
                    ChkVOID( _RemoveEntry( iEntry ) );
                    ChkVOID( _AddEntry( iEntry ) );
                }
            }

            drLeave = OEM_TEE_BASE_CRITSEC_Leave();
        }
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}
#endif

#ifdef NONE
/*
** Synopsis:
**
** This function removes a DRM_TEE_CONTEXT session from the cache of
** valid sessions.
**
** Operations Performed:
**
**  1. Find the session to remove.
**  2. Remove the session from the cache.
**
** Arguments:
**
** f_pContext:          (in) The TEE context returned from
**                           DRM_TEE_BASE_AllocTEEContext.
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_RemoveContext(
    __in            const DRM_TEE_CONTEXT              *f_pContext )
{
    DRM_RESULT drRet    = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave  = DRM_SUCCESS;
    DRM_BYTE   iEntry   = 0;

    DRMASSERT( f_pContext != NULL );

    {
        /* Never use jump macros while holding the critical section. */
        if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
        {
            if( g_fInitialized != TEE_CACHE_INITIALIZED )
            {
                drRet = DRM_E_TEE_ILWALID_HWDRM_STATE;
            }
            else
            {
                drRet = _FindEntry( f_pContext, &iEntry );
                if( DRM_SUCCEEDED( drRet ) )
                {
                    ChkVOID( _RemoveEntry( iEntry ) );
                    ChkVOID( _FreeEntry( iEntry ) );
                }
            }

            drLeave = OEM_TEE_BASE_CRITSEC_Leave();
        }
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}
#endif

#if defined (SEC_COMPILE)
/*
** Synopsis:
**
** This function checks whether the given hash of data
** which has already been ECDSA signature-verified is contained within
** the cache.
** If so, it returns TRUE.
** If so, and the caller requests associated certificate data
** (which implies that the hash was a certificate), return that data.
**
** Operations Performed:
**
**  1. Search the cache for the given hash.
**  2. If found, read its public key and security level from the cache
**     (if available) into the output parameters and (regardless) return TRUE.
**  3. Otherwise, return FALSE.
**
** Arguments:
**
** f_pHash:                         (in) The hash.
** f_pCertificatePubkey:           (out) The (found) certificate's public key.
** f_pdwCertificateSelwrityLevel:  (out) The (found) certificate's security level.
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_CheckHash(
    __in            const OEM_SHA256_DIGEST            *f_pHash,
    __out                 DRM_BOOL                     *f_pfHashFound )
{
    DRM_RESULT drRet   = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave = DRM_SUCCESS;
    DRM_BOOL   fFound  = FALSE;

    DRMASSERT( f_pHash != NULL );
    DRMASSERT( f_pfHashFound != NULL );

    *f_pfHashFound = FALSE;

    /* Never use jump macros while holding the critical section. */
    if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
    {
        fFound = DRM_HASHCACHE_CheckHash( &g_oCachedVerifiedHashContext, f_pHash );

        if( DRM_SUCCEEDED( drLeave = OEM_TEE_BASE_CRITSEC_Leave() ) )
        {
            *f_pfHashFound = fFound;
        }
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}


/*
** Synopsis:
**
** This function adds the given hash of data
** which has already been ECDSA signature-verified to
** the cache.
**
** Operations Performed:
**
**  1. Add the hash to the cache.  If provided, add
**     its public key and security level.
**
** Arguments:
**
** f_pHash:                        (in) The hash.
** f_pCertificatePubkey:           (in) The certificate's public key.
** f_dwCertificateSelwrityLevel:   (in) The certificate's security level.
*/
DRM_NO_INLINE DRM_API DRM_RESULT DRM_CALL DRM_TEE_IMPL_CACHE_AddHash(
    __in            const OEM_SHA256_DIGEST            *f_pHash )
{
    DRM_RESULT drRet   = DRM_SUCCESS;  /* Do not use dr to ensure no jump macros are used. */
    DRM_RESULT drLeave = DRM_SUCCESS;

    DRMASSERT( f_pHash != NULL );

    /* Never use jump macros while holding the critical section. */
    if( DRM_SUCCEEDED( drRet = OEM_TEE_BASE_CRITSEC_Enter() ) )
    {
        ChkVOID( DRM_HASHCACHE_AddHash( &g_oCachedVerifiedHashContext, f_pHash ) );

        drLeave = OEM_TEE_BASE_CRITSEC_Leave();
    }

    return DRM_FAILED( drRet ) ? drRet : drLeave;
}
#endif

#ifdef NONE
/*
** Synopsis:
**
** This function clears the caches for verified hashes and
** for a verified RevInfo plus runtime CRL.
**
** Operations Performed:
**
**  1. Clear both caches.
*/
DRM_NO_INLINE DRM_API_VOID DRM_VOID DRM_CALL DRM_TEE_IMPL_CACHE_Clear( DRM_VOID )
{
    ChkVOID( DRM_HASHCACHE_Clear( &g_oCachedVerifiedHashContext ) );
}
#endif
EXIT_PK_NAMESPACE_CODE;

